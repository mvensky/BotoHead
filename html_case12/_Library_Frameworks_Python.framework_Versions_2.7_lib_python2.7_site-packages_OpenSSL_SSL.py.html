source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/OpenSSL/SSL.py</b><br>


file stats: <b>869 lines, 248 executed: 28.5% covered</b>
<pre>
<font color="green">   1. import socket</font>
<font color="green">   2. from sys import platform</font>
<font color="green">   3. from functools import wraps, partial</font>
<font color="green">   4. from itertools import count, chain</font>
<font color="green">   5. from weakref import WeakValueDictionary</font>
<font color="green">   6. from errno import errorcode</font>
<font color="black">   7. </font>
<font color="green">   8. from six import binary_type as _binary_type</font>
<font color="green">   9. from six import integer_types as integer_types</font>
<font color="green">  10. from six import int2byte, indexbytes</font>
<font color="black">  11. </font>
<font color="green">  12. from OpenSSL._util import (</font>
<font color="black">  13.     UNSPECIFIED as _UNSPECIFIED,</font>
<font color="black">  14.     exception_from_error_queue as _exception_from_error_queue,</font>
<font color="black">  15.     ffi as _ffi,</font>
<font color="black">  16.     lib as _lib,</font>
<font color="black">  17.     make_assert as _make_assert,</font>
<font color="black">  18.     native as _native,</font>
<font color="black">  19.     path_string as _path_string,</font>
<font color="black">  20.     text_to_bytes_and_warn as _text_to_bytes_and_warn,</font>
<font color="black">  21. )</font>
<font color="black">  22. </font>
<font color="green">  23. from OpenSSL.crypto import (</font>
<font color="black">  24.     FILETYPE_PEM, _PassphraseHelper, PKey, X509Name, X509, X509Store)</font>
<font color="black">  25. </font>
<font color="green">  26. try:</font>
<font color="green">  27.     _memoryview = memoryview</font>
<font color="red">  28. except NameError:</font>
<font color="red">  29.     class _memoryview(object):</font>
<font color="red">  30.         pass</font>
<font color="black">  31. </font>
<font color="green">  32. try:</font>
<font color="green">  33.     _buffer = buffer</font>
<font color="red">  34. except NameError:</font>
<font color="red">  35.     class _buffer(object):</font>
<font color="red">  36.         pass</font>
<font color="black">  37. </font>
<font color="green">  38. OPENSSL_VERSION_NUMBER = _lib.OPENSSL_VERSION_NUMBER</font>
<font color="green">  39. SSLEAY_VERSION = _lib.SSLEAY_VERSION</font>
<font color="green">  40. SSLEAY_CFLAGS = _lib.SSLEAY_CFLAGS</font>
<font color="green">  41. SSLEAY_PLATFORM = _lib.SSLEAY_PLATFORM</font>
<font color="green">  42. SSLEAY_DIR = _lib.SSLEAY_DIR</font>
<font color="green">  43. SSLEAY_BUILT_ON = _lib.SSLEAY_BUILT_ON</font>
<font color="black">  44. </font>
<font color="green">  45. SENT_SHUTDOWN = _lib.SSL_SENT_SHUTDOWN</font>
<font color="green">  46. RECEIVED_SHUTDOWN = _lib.SSL_RECEIVED_SHUTDOWN</font>
<font color="black">  47. </font>
<font color="green">  48. SSLv2_METHOD = 1</font>
<font color="green">  49. SSLv3_METHOD = 2</font>
<font color="green">  50. SSLv23_METHOD = 3</font>
<font color="green">  51. TLSv1_METHOD = 4</font>
<font color="green">  52. TLSv1_1_METHOD = 5</font>
<font color="green">  53. TLSv1_2_METHOD = 6</font>
<font color="black">  54. </font>
<font color="green">  55. OP_NO_SSLv2 = _lib.SSL_OP_NO_SSLv2</font>
<font color="green">  56. OP_NO_SSLv3 = _lib.SSL_OP_NO_SSLv3</font>
<font color="green">  57. OP_NO_TLSv1 = _lib.SSL_OP_NO_TLSv1</font>
<font color="black">  58. </font>
<font color="green">  59. OP_NO_TLSv1_1 = getattr(_lib, &quot;SSL_OP_NO_TLSv1_1&quot;, 0)</font>
<font color="green">  60. OP_NO_TLSv1_2 = getattr(_lib, &quot;SSL_OP_NO_TLSv1_2&quot;, 0)</font>
<font color="black">  61. </font>
<font color="green">  62. MODE_RELEASE_BUFFERS = _lib.SSL_MODE_RELEASE_BUFFERS</font>
<font color="black">  63. </font>
<font color="green">  64. OP_SINGLE_DH_USE = _lib.SSL_OP_SINGLE_DH_USE</font>
<font color="green">  65. OP_SINGLE_ECDH_USE = _lib.SSL_OP_SINGLE_ECDH_USE</font>
<font color="green">  66. OP_EPHEMERAL_RSA = _lib.SSL_OP_EPHEMERAL_RSA</font>
<font color="green">  67. OP_MICROSOFT_SESS_ID_BUG = _lib.SSL_OP_MICROSOFT_SESS_ID_BUG</font>
<font color="green">  68. OP_NETSCAPE_CHALLENGE_BUG = _lib.SSL_OP_NETSCAPE_CHALLENGE_BUG</font>
<font color="black">  69. OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = (</font>
<font color="green">  70.     _lib.SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG</font>
<font color="black">  71. )</font>
<font color="green">  72. OP_SSLREF2_REUSE_CERT_TYPE_BUG = _lib.SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG</font>
<font color="green">  73. OP_MICROSOFT_BIG_SSLV3_BUFFER = _lib.SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER</font>
<font color="green">  74. OP_MSIE_SSLV2_RSA_PADDING = _lib.SSL_OP_MSIE_SSLV2_RSA_PADDING</font>
<font color="green">  75. OP_SSLEAY_080_CLIENT_DH_BUG = _lib.SSL_OP_SSLEAY_080_CLIENT_DH_BUG</font>
<font color="green">  76. OP_TLS_D5_BUG = _lib.SSL_OP_TLS_D5_BUG</font>
<font color="green">  77. OP_TLS_BLOCK_PADDING_BUG = _lib.SSL_OP_TLS_BLOCK_PADDING_BUG</font>
<font color="green">  78. OP_DONT_INSERT_EMPTY_FRAGMENTS = _lib.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS</font>
<font color="green">  79. OP_CIPHER_SERVER_PREFERENCE = _lib.SSL_OP_CIPHER_SERVER_PREFERENCE</font>
<font color="green">  80. OP_TLS_ROLLBACK_BUG = _lib.SSL_OP_TLS_ROLLBACK_BUG</font>
<font color="green">  81. OP_PKCS1_CHECK_1 = _lib.SSL_OP_PKCS1_CHECK_1</font>
<font color="green">  82. OP_PKCS1_CHECK_2 = _lib.SSL_OP_PKCS1_CHECK_2</font>
<font color="green">  83. OP_NETSCAPE_CA_DN_BUG = _lib.SSL_OP_NETSCAPE_CA_DN_BUG</font>
<font color="black">  84. OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = (</font>
<font color="green">  85.     _lib.SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG</font>
<font color="black">  86. )</font>
<font color="green">  87. OP_NO_COMPRESSION = _lib.SSL_OP_NO_COMPRESSION</font>
<font color="black">  88. </font>
<font color="green">  89. OP_NO_QUERY_MTU = _lib.SSL_OP_NO_QUERY_MTU</font>
<font color="green">  90. OP_COOKIE_EXCHANGE = _lib.SSL_OP_COOKIE_EXCHANGE</font>
<font color="green">  91. OP_NO_TICKET = _lib.SSL_OP_NO_TICKET</font>
<font color="black">  92. </font>
<font color="green">  93. OP_ALL = _lib.SSL_OP_ALL</font>
<font color="black">  94. </font>
<font color="green">  95. VERIFY_PEER = _lib.SSL_VERIFY_PEER</font>
<font color="green">  96. VERIFY_FAIL_IF_NO_PEER_CERT = _lib.SSL_VERIFY_FAIL_IF_NO_PEER_CERT</font>
<font color="green">  97. VERIFY_CLIENT_ONCE = _lib.SSL_VERIFY_CLIENT_ONCE</font>
<font color="green">  98. VERIFY_NONE = _lib.SSL_VERIFY_NONE</font>
<font color="black">  99. </font>
<font color="green"> 100. SESS_CACHE_OFF = _lib.SSL_SESS_CACHE_OFF</font>
<font color="green"> 101. SESS_CACHE_CLIENT = _lib.SSL_SESS_CACHE_CLIENT</font>
<font color="green"> 102. SESS_CACHE_SERVER = _lib.SSL_SESS_CACHE_SERVER</font>
<font color="green"> 103. SESS_CACHE_BOTH = _lib.SSL_SESS_CACHE_BOTH</font>
<font color="green"> 104. SESS_CACHE_NO_AUTO_CLEAR = _lib.SSL_SESS_CACHE_NO_AUTO_CLEAR</font>
<font color="green"> 105. SESS_CACHE_NO_INTERNAL_LOOKUP = _lib.SSL_SESS_CACHE_NO_INTERNAL_LOOKUP</font>
<font color="green"> 106. SESS_CACHE_NO_INTERNAL_STORE = _lib.SSL_SESS_CACHE_NO_INTERNAL_STORE</font>
<font color="green"> 107. SESS_CACHE_NO_INTERNAL = _lib.SSL_SESS_CACHE_NO_INTERNAL</font>
<font color="black"> 108. </font>
<font color="green"> 109. SSL_ST_CONNECT = _lib.SSL_ST_CONNECT</font>
<font color="green"> 110. SSL_ST_ACCEPT = _lib.SSL_ST_ACCEPT</font>
<font color="green"> 111. SSL_ST_MASK = _lib.SSL_ST_MASK</font>
<font color="green"> 112. if _lib.Cryptography_HAS_SSL_ST:</font>
<font color="red"> 113.     SSL_ST_INIT = _lib.SSL_ST_INIT</font>
<font color="red"> 114.     SSL_ST_BEFORE = _lib.SSL_ST_BEFORE</font>
<font color="red"> 115.     SSL_ST_OK = _lib.SSL_ST_OK</font>
<font color="red"> 116.     SSL_ST_RENEGOTIATE = _lib.SSL_ST_RENEGOTIATE</font>
<font color="black"> 117. </font>
<font color="green"> 118. SSL_CB_LOOP = _lib.SSL_CB_LOOP</font>
<font color="green"> 119. SSL_CB_EXIT = _lib.SSL_CB_EXIT</font>
<font color="green"> 120. SSL_CB_READ = _lib.SSL_CB_READ</font>
<font color="green"> 121. SSL_CB_WRITE = _lib.SSL_CB_WRITE</font>
<font color="green"> 122. SSL_CB_ALERT = _lib.SSL_CB_ALERT</font>
<font color="green"> 123. SSL_CB_READ_ALERT = _lib.SSL_CB_READ_ALERT</font>
<font color="green"> 124. SSL_CB_WRITE_ALERT = _lib.SSL_CB_WRITE_ALERT</font>
<font color="green"> 125. SSL_CB_ACCEPT_LOOP = _lib.SSL_CB_ACCEPT_LOOP</font>
<font color="green"> 126. SSL_CB_ACCEPT_EXIT = _lib.SSL_CB_ACCEPT_EXIT</font>
<font color="green"> 127. SSL_CB_CONNECT_LOOP = _lib.SSL_CB_CONNECT_LOOP</font>
<font color="green"> 128. SSL_CB_CONNECT_EXIT = _lib.SSL_CB_CONNECT_EXIT</font>
<font color="green"> 129. SSL_CB_HANDSHAKE_START = _lib.SSL_CB_HANDSHAKE_START</font>
<font color="green"> 130. SSL_CB_HANDSHAKE_DONE = _lib.SSL_CB_HANDSHAKE_DONE</font>
<font color="black"> 131. </font>
<font color="black"> 132. </font>
<font color="green"> 133. class Error(Exception):</font>
<font color="black"> 134.     &quot;&quot;&quot;</font>
<font color="black"> 135.     An error occurred in an `OpenSSL.SSL` API.</font>
<font color="green"> 136.     &quot;&quot;&quot;</font>
<font color="black"> 137. </font>
<font color="black"> 138. </font>
<font color="green"> 139. _raise_current_error = partial(_exception_from_error_queue, Error)</font>
<font color="green"> 140. _openssl_assert = _make_assert(Error)</font>
<font color="black"> 141. </font>
<font color="black"> 142. </font>
<font color="green"> 143. class WantReadError(Error):</font>
<font color="green"> 144.     pass</font>
<font color="black"> 145. </font>
<font color="black"> 146. </font>
<font color="green"> 147. class WantWriteError(Error):</font>
<font color="green"> 148.     pass</font>
<font color="black"> 149. </font>
<font color="black"> 150. </font>
<font color="green"> 151. class WantX509LookupError(Error):</font>
<font color="green"> 152.     pass</font>
<font color="black"> 153. </font>
<font color="black"> 154. </font>
<font color="green"> 155. class ZeroReturnError(Error):</font>
<font color="green"> 156.     pass</font>
<font color="black"> 157. </font>
<font color="black"> 158. </font>
<font color="green"> 159. class SysCallError(Error):</font>
<font color="green"> 160.     pass</font>
<font color="black"> 161. </font>
<font color="black"> 162. </font>
<font color="green"> 163. class _CallbackExceptionHelper(object):</font>
<font color="black"> 164.     &quot;&quot;&quot;</font>
<font color="black"> 165.     A base class for wrapper classes that allow for intelligent exception</font>
<font color="black"> 166.     handling in OpenSSL callbacks.</font>
<font color="black"> 167. </font>
<font color="black"> 168.     :ivar list _problems: Any exceptions that occurred while executing in a</font>
<font color="black"> 169.         context where they could not be raised in the normal way.  Typically</font>
<font color="black"> 170.         this is because OpenSSL has called into some Python code and requires a</font>
<font color="black"> 171.         return value.  The exceptions are saved to be raised later when it is</font>
<font color="black"> 172.         possible to do so.</font>
<font color="green"> 173.     &quot;&quot;&quot;</font>
<font color="black"> 174. </font>
<font color="green"> 175.     def __init__(self):</font>
<font color="red"> 176.         self._problems = []</font>
<font color="black"> 177. </font>
<font color="green"> 178.     def raise_if_problem(self):</font>
<font color="black"> 179.         &quot;&quot;&quot;</font>
<font color="black"> 180.         Raise an exception from the OpenSSL error queue or that was previously</font>
<font color="black"> 181.         captured whe running a callback.</font>
<font color="black"> 182.         &quot;&quot;&quot;</font>
<font color="red"> 183.         if self._problems:</font>
<font color="red"> 184.             try:</font>
<font color="red"> 185.                 _raise_current_error()</font>
<font color="red"> 186.             except Error:</font>
<font color="red"> 187.                 pass</font>
<font color="red"> 188.             raise self._problems.pop(0)</font>
<font color="black"> 189. </font>
<font color="black"> 190. </font>
<font color="green"> 191. class _VerifyHelper(_CallbackExceptionHelper):</font>
<font color="black"> 192.     &quot;&quot;&quot;</font>
<font color="black"> 193.     Wrap a callback such that it can be used as a certificate verification</font>
<font color="black"> 194.     callback.</font>
<font color="green"> 195.     &quot;&quot;&quot;</font>
<font color="black"> 196. </font>
<font color="green"> 197.     def __init__(self, callback):</font>
<font color="red"> 198.         _CallbackExceptionHelper.__init__(self)</font>
<font color="black"> 199. </font>
<font color="red"> 200.         @wraps(callback)</font>
<font color="black"> 201.         def wrapper(ok, store_ctx):</font>
<font color="red"> 202.             cert = X509.__new__(X509)</font>
<font color="red"> 203.             cert._x509 = _lib.X509_STORE_CTX_get_current_cert(store_ctx)</font>
<font color="red"> 204.             error_number = _lib.X509_STORE_CTX_get_error(store_ctx)</font>
<font color="red"> 205.             error_depth = _lib.X509_STORE_CTX_get_error_depth(store_ctx)</font>
<font color="black"> 206. </font>
<font color="red"> 207.             index = _lib.SSL_get_ex_data_X509_STORE_CTX_idx()</font>
<font color="red"> 208.             ssl = _lib.X509_STORE_CTX_get_ex_data(store_ctx, index)</font>
<font color="red"> 209.             connection = Connection._reverse_mapping[ssl]</font>
<font color="black"> 210. </font>
<font color="red"> 211.             try:</font>
<font color="red"> 212.                 result = callback(</font>
<font color="red"> 213.                     connection, cert, error_number, error_depth, ok</font>
<font color="black"> 214.                 )</font>
<font color="red"> 215.             except Exception as e:</font>
<font color="red"> 216.                 self._problems.append(e)</font>
<font color="red"> 217.                 return 0</font>
<font color="black"> 218.             else:</font>
<font color="red"> 219.                 if result:</font>
<font color="red"> 220.                     _lib.X509_STORE_CTX_set_error(store_ctx, _lib.X509_V_OK)</font>
<font color="red"> 221.                     return 1</font>
<font color="black"> 222.                 else:</font>
<font color="red"> 223.                     return 0</font>
<font color="black"> 224. </font>
<font color="red"> 225.         self.callback = _ffi.callback(</font>
<font color="red"> 226.             &quot;int (*)(int, X509_STORE_CTX *)&quot;, wrapper)</font>
<font color="black"> 227. </font>
<font color="black"> 228. </font>
<font color="green"> 229. class _NpnAdvertiseHelper(_CallbackExceptionHelper):</font>
<font color="black"> 230.     &quot;&quot;&quot;</font>
<font color="black"> 231.     Wrap a callback such that it can be used as an NPN advertisement callback.</font>
<font color="green"> 232.     &quot;&quot;&quot;</font>
<font color="black"> 233. </font>
<font color="green"> 234.     def __init__(self, callback):</font>
<font color="red"> 235.         _CallbackExceptionHelper.__init__(self)</font>
<font color="black"> 236. </font>
<font color="red"> 237.         @wraps(callback)</font>
<font color="black"> 238.         def wrapper(ssl, out, outlen, arg):</font>
<font color="red"> 239.             try:</font>
<font color="red"> 240.                 conn = Connection._reverse_mapping[ssl]</font>
<font color="red"> 241.                 protos = callback(conn)</font>
<font color="black"> 242. </font>
<font color="black"> 243.                 # Join the protocols into a Python bytestring, length-prefixing</font>
<font color="black"> 244.                 # each element.</font>
<font color="red"> 245.                 protostr = b''.join(</font>
<font color="red"> 246.                     chain.from_iterable((int2byte(len(p)), p) for p in protos)</font>
<font color="black"> 247.                 )</font>
<font color="black"> 248. </font>
<font color="black"> 249.                 # Save our callback arguments on the connection object. This is</font>
<font color="black"> 250.                 # done to make sure that they don't get freed before OpenSSL</font>
<font color="black"> 251.                 # uses them. Then, return them appropriately in the output</font>
<font color="black"> 252.                 # parameters.</font>
<font color="black"> 253.                 conn._npn_advertise_callback_args = [</font>
<font color="red"> 254.                     _ffi.new(&quot;unsigned int *&quot;, len(protostr)),</font>
<font color="red"> 255.                     _ffi.new(&quot;unsigned char[]&quot;, protostr),</font>
<font color="black"> 256.                 ]</font>
<font color="red"> 257.                 outlen[0] = conn._npn_advertise_callback_args[0][0]</font>
<font color="red"> 258.                 out[0] = conn._npn_advertise_callback_args[1]</font>
<font color="red"> 259.                 return 0</font>
<font color="red"> 260.             except Exception as e:</font>
<font color="red"> 261.                 self._problems.append(e)</font>
<font color="red"> 262.                 return 2  # SSL_TLSEXT_ERR_ALERT_FATAL</font>
<font color="black"> 263. </font>
<font color="red"> 264.         self.callback = _ffi.callback(</font>
<font color="red"> 265.             &quot;int (*)(SSL *, const unsigned char **, unsigned int *, void *)&quot;,</font>
<font color="red"> 266.             wrapper</font>
<font color="black"> 267.         )</font>
<font color="black"> 268. </font>
<font color="black"> 269. </font>
<font color="green"> 270. class _NpnSelectHelper(_CallbackExceptionHelper):</font>
<font color="black"> 271.     &quot;&quot;&quot;</font>
<font color="black"> 272.     Wrap a callback such that it can be used as an NPN selection callback.</font>
<font color="green"> 273.     &quot;&quot;&quot;</font>
<font color="black"> 274. </font>
<font color="green"> 275.     def __init__(self, callback):</font>
<font color="red"> 276.         _CallbackExceptionHelper.__init__(self)</font>
<font color="black"> 277. </font>
<font color="red"> 278.         @wraps(callback)</font>
<font color="black"> 279.         def wrapper(ssl, out, outlen, in_, inlen, arg):</font>
<font color="red"> 280.             try:</font>
<font color="red"> 281.                 conn = Connection._reverse_mapping[ssl]</font>
<font color="black"> 282. </font>
<font color="black"> 283.                 # The string passed to us is actually made up of multiple</font>
<font color="black"> 284.                 # length-prefixed bytestrings. We need to split that into a</font>
<font color="black"> 285.                 # list.</font>
<font color="red"> 286.                 instr = _ffi.buffer(in_, inlen)[:]</font>
<font color="red"> 287.                 protolist = []</font>
<font color="red"> 288.                 while instr:</font>
<font color="red"> 289.                     l = indexbytes(instr, 0)</font>
<font color="red"> 290.                     proto = instr[1:l + 1]</font>
<font color="red"> 291.                     protolist.append(proto)</font>
<font color="red"> 292.                     instr = instr[l + 1:]</font>
<font color="black"> 293. </font>
<font color="black"> 294.                 # Call the callback</font>
<font color="red"> 295.                 outstr = callback(conn, protolist)</font>
<font color="black"> 296. </font>
<font color="black"> 297.                 # Save our callback arguments on the connection object. This is</font>
<font color="black"> 298.                 # done to make sure that they don't get freed before OpenSSL</font>
<font color="black"> 299.                 # uses them. Then, return them appropriately in the output</font>
<font color="black"> 300.                 # parameters.</font>
<font color="black"> 301.                 conn._npn_select_callback_args = [</font>
<font color="red"> 302.                     _ffi.new(&quot;unsigned char *&quot;, len(outstr)),</font>
<font color="red"> 303.                     _ffi.new(&quot;unsigned char[]&quot;, outstr),</font>
<font color="black"> 304.                 ]</font>
<font color="red"> 305.                 outlen[0] = conn._npn_select_callback_args[0][0]</font>
<font color="red"> 306.                 out[0] = conn._npn_select_callback_args[1]</font>
<font color="red"> 307.                 return 0</font>
<font color="red"> 308.             except Exception as e:</font>
<font color="red"> 309.                 self._problems.append(e)</font>
<font color="red"> 310.                 return 2  # SSL_TLSEXT_ERR_ALERT_FATAL</font>
<font color="black"> 311. </font>
<font color="red"> 312.         self.callback = _ffi.callback(</font>
<font color="red"> 313.             (&quot;int (*)(SSL *, unsigned char **, unsigned char *, &quot;</font>
<font color="black"> 314.                 &quot;const unsigned char *, unsigned int, void *)&quot;),</font>
<font color="red"> 315.             wrapper</font>
<font color="black"> 316.         )</font>
<font color="black"> 317. </font>
<font color="black"> 318. </font>
<font color="green"> 319. class _ALPNSelectHelper(_CallbackExceptionHelper):</font>
<font color="black"> 320.     &quot;&quot;&quot;</font>
<font color="black"> 321.     Wrap a callback such that it can be used as an ALPN selection callback.</font>
<font color="green"> 322.     &quot;&quot;&quot;</font>
<font color="black"> 323. </font>
<font color="green"> 324.     def __init__(self, callback):</font>
<font color="red"> 325.         _CallbackExceptionHelper.__init__(self)</font>
<font color="black"> 326. </font>
<font color="red"> 327.         @wraps(callback)</font>
<font color="black"> 328.         def wrapper(ssl, out, outlen, in_, inlen, arg):</font>
<font color="red"> 329.             try:</font>
<font color="red"> 330.                 conn = Connection._reverse_mapping[ssl]</font>
<font color="black"> 331. </font>
<font color="black"> 332.                 # The string passed to us is made up of multiple</font>
<font color="black"> 333.                 # length-prefixed bytestrings. We need to split that into a</font>
<font color="black"> 334.                 # list.</font>
<font color="red"> 335.                 instr = _ffi.buffer(in_, inlen)[:]</font>
<font color="red"> 336.                 protolist = []</font>
<font color="red"> 337.                 while instr:</font>
<font color="red"> 338.                     encoded_len = indexbytes(instr, 0)</font>
<font color="red"> 339.                     proto = instr[1:encoded_len + 1]</font>
<font color="red"> 340.                     protolist.append(proto)</font>
<font color="red"> 341.                     instr = instr[encoded_len + 1:]</font>
<font color="black"> 342. </font>
<font color="black"> 343.                 # Call the callback</font>
<font color="red"> 344.                 outstr = callback(conn, protolist)</font>
<font color="black"> 345. </font>
<font color="red"> 346.                 if not isinstance(outstr, _binary_type):</font>
<font color="red"> 347.                     raise TypeError(&quot;ALPN callback must return a bytestring.&quot;)</font>
<font color="black"> 348. </font>
<font color="black"> 349.                 # Save our callback arguments on the connection object to make</font>
<font color="black"> 350.                 # sure that they don't get freed before OpenSSL can use them.</font>
<font color="black"> 351.                 # Then, return them in the appropriate output parameters.</font>
<font color="black"> 352.                 conn._alpn_select_callback_args = [</font>
<font color="red"> 353.                     _ffi.new(&quot;unsigned char *&quot;, len(outstr)),</font>
<font color="red"> 354.                     _ffi.new(&quot;unsigned char[]&quot;, outstr),</font>
<font color="black"> 355.                 ]</font>
<font color="red"> 356.                 outlen[0] = conn._alpn_select_callback_args[0][0]</font>
<font color="red"> 357.                 out[0] = conn._alpn_select_callback_args[1]</font>
<font color="red"> 358.                 return 0</font>
<font color="red"> 359.             except Exception as e:</font>
<font color="red"> 360.                 self._problems.append(e)</font>
<font color="red"> 361.                 return 2  # SSL_TLSEXT_ERR_ALERT_FATAL</font>
<font color="black"> 362. </font>
<font color="red"> 363.         self.callback = _ffi.callback(</font>
<font color="red"> 364.             (&quot;int (*)(SSL *, unsigned char **, unsigned char *, &quot;</font>
<font color="black"> 365.                 &quot;const unsigned char *, unsigned int, void *)&quot;),</font>
<font color="red"> 366.             wrapper</font>
<font color="black"> 367.         )</font>
<font color="black"> 368. </font>
<font color="black"> 369. </font>
<font color="green"> 370. def _asFileDescriptor(obj):</font>
<font color="red"> 371.     fd = None</font>
<font color="red"> 372.     if not isinstance(obj, integer_types):</font>
<font color="red"> 373.         meth = getattr(obj, &quot;fileno&quot;, None)</font>
<font color="red"> 374.         if meth is not None:</font>
<font color="red"> 375.             obj = meth()</font>
<font color="black"> 376. </font>
<font color="red"> 377.     if isinstance(obj, integer_types):</font>
<font color="red"> 378.         fd = obj</font>
<font color="black"> 379. </font>
<font color="red"> 380.     if not isinstance(fd, integer_types):</font>
<font color="red"> 381.         raise TypeError(&quot;argument must be an int, or have a fileno() method.&quot;)</font>
<font color="red"> 382.     elif fd &lt; 0:</font>
<font color="red"> 383.         raise ValueError(</font>
<font color="red"> 384.             &quot;file descriptor cannot be a negative integer (%i)&quot; % (fd,))</font>
<font color="black"> 385. </font>
<font color="red"> 386.     return fd</font>
<font color="black"> 387. </font>
<font color="black"> 388. </font>
<font color="green"> 389. def SSLeay_version(type):</font>
<font color="black"> 390.     &quot;&quot;&quot;</font>
<font color="black"> 391.     Return a string describing the version of OpenSSL in use.</font>
<font color="black"> 392. </font>
<font color="black"> 393.     :param type: One of the SSLEAY_ constants defined in this module.</font>
<font color="black"> 394.     &quot;&quot;&quot;</font>
<font color="red"> 395.     return _ffi.string(_lib.SSLeay_version(type))</font>
<font color="black"> 396. </font>
<font color="black"> 397. </font>
<font color="green"> 398. def _make_requires(flag, error):</font>
<font color="black"> 399.     &quot;&quot;&quot;</font>
<font color="black"> 400.     Builds a decorator that ensures that functions that rely on OpenSSL</font>
<font color="black"> 401.     functions that are not present in this build raise NotImplementedError,</font>
<font color="black"> 402.     rather than AttributeError coming out of cryptography.</font>
<font color="black"> 403. </font>
<font color="black"> 404.     :param flag: A cryptography flag that guards the functions, e.g.</font>
<font color="black"> 405.         ``Cryptography_HAS_NEXTPROTONEG``.</font>
<font color="black"> 406.     :param error: The string to be used in the exception if the flag is false.</font>
<font color="black"> 407.     &quot;&quot;&quot;</font>
<font color="green"> 408.     def _requires_decorator(func):</font>
<font color="green"> 409.         if not flag:</font>
<font color="red"> 410.             @wraps(func)</font>
<font color="black"> 411.             def explode(*args, **kwargs):</font>
<font color="red"> 412.                 raise NotImplementedError(error)</font>
<font color="red"> 413.             return explode</font>
<font color="black"> 414.         else:</font>
<font color="green"> 415.             return func</font>
<font color="black"> 416. </font>
<font color="green"> 417.     return _requires_decorator</font>
<font color="black"> 418. </font>
<font color="black"> 419. </font>
<font color="green"> 420. _requires_npn = _make_requires(</font>
<font color="green"> 421.     _lib.Cryptography_HAS_NEXTPROTONEG, &quot;NPN not available&quot;</font>
<font color="black"> 422. )</font>
<font color="black"> 423. </font>
<font color="black"> 424. </font>
<font color="green"> 425. _requires_alpn = _make_requires(</font>
<font color="green"> 426.     _lib.Cryptography_HAS_ALPN, &quot;ALPN not available&quot;</font>
<font color="black"> 427. )</font>
<font color="black"> 428. </font>
<font color="black"> 429. </font>
<font color="green"> 430. _requires_sni = _make_requires(</font>
<font color="green"> 431.     _lib.Cryptography_HAS_TLSEXT_HOSTNAME, &quot;SNI not available&quot;</font>
<font color="black"> 432. )</font>
<font color="black"> 433. </font>
<font color="black"> 434. </font>
<font color="green"> 435. class Session(object):</font>
<font color="green"> 436.     pass</font>
<font color="black"> 437. </font>
<font color="black"> 438. </font>
<font color="green"> 439. class Context(object):</font>
<font color="black"> 440.     &quot;&quot;&quot;</font>
<font color="black"> 441.     :class:`OpenSSL.SSL.Context` instances define the parameters for setting</font>
<font color="black"> 442.     up new SSL connections.</font>
<font color="green"> 443.     &quot;&quot;&quot;</font>
<font color="green"> 444.     _methods = {</font>
<font color="green"> 445.         SSLv2_METHOD: &quot;SSLv2_method&quot;,</font>
<font color="green"> 446.         SSLv3_METHOD: &quot;SSLv3_method&quot;,</font>
<font color="green"> 447.         SSLv23_METHOD: &quot;SSLv23_method&quot;,</font>
<font color="green"> 448.         TLSv1_METHOD: &quot;TLSv1_method&quot;,</font>
<font color="green"> 449.         TLSv1_1_METHOD: &quot;TLSv1_1_method&quot;,</font>
<font color="green"> 450.         TLSv1_2_METHOD: &quot;TLSv1_2_method&quot;,</font>
<font color="black"> 451.     }</font>
<font color="green"> 452.     _methods = dict(</font>
<font color="green"> 453.         (identifier, getattr(_lib, name))</font>
<font color="green"> 454.         for (identifier, name) in _methods.items()</font>
<font color="green"> 455.         if getattr(_lib, name, None) is not None)</font>
<font color="black"> 456. </font>
<font color="green"> 457.     def __init__(self, method):</font>
<font color="black"> 458.         &quot;&quot;&quot;</font>
<font color="black"> 459.         :param method: One of SSLv2_METHOD, SSLv3_METHOD, SSLv23_METHOD, or</font>
<font color="black"> 460.             TLSv1_METHOD.</font>
<font color="black"> 461.         &quot;&quot;&quot;</font>
<font color="red"> 462.         if not isinstance(method, integer_types):</font>
<font color="red"> 463.             raise TypeError(&quot;method must be an integer&quot;)</font>
<font color="black"> 464. </font>
<font color="red"> 465.         try:</font>
<font color="red"> 466.             method_func = self._methods[method]</font>
<font color="red"> 467.         except KeyError:</font>
<font color="red"> 468.             raise ValueError(&quot;No such protocol&quot;)</font>
<font color="black"> 469. </font>
<font color="red"> 470.         method_obj = method_func()</font>
<font color="red"> 471.         _openssl_assert(method_obj != _ffi.NULL)</font>
<font color="black"> 472. </font>
<font color="red"> 473.         context = _lib.SSL_CTX_new(method_obj)</font>
<font color="red"> 474.         _openssl_assert(context != _ffi.NULL)</font>
<font color="red"> 475.         context = _ffi.gc(context, _lib.SSL_CTX_free)</font>
<font color="black"> 476. </font>
<font color="red"> 477.         self._context = context</font>
<font color="red"> 478.         self._passphrase_helper = None</font>
<font color="red"> 479.         self._passphrase_callback = None</font>
<font color="red"> 480.         self._passphrase_userdata = None</font>
<font color="red"> 481.         self._verify_helper = None</font>
<font color="red"> 482.         self._verify_callback = None</font>
<font color="red"> 483.         self._info_callback = None</font>
<font color="red"> 484.         self._tlsext_servername_callback = None</font>
<font color="red"> 485.         self._app_data = None</font>
<font color="red"> 486.         self._npn_advertise_helper = None</font>
<font color="red"> 487.         self._npn_advertise_callback = None</font>
<font color="red"> 488.         self._npn_select_helper = None</font>
<font color="red"> 489.         self._npn_select_callback = None</font>
<font color="red"> 490.         self._alpn_select_helper = None</font>
<font color="red"> 491.         self._alpn_select_callback = None</font>
<font color="black"> 492. </font>
<font color="black"> 493.         # SSL_CTX_set_app_data(self-&gt;ctx, self);</font>
<font color="black"> 494.         # SSL_CTX_set_mode(self-&gt;ctx, SSL_MODE_ENABLE_PARTIAL_WRITE |</font>
<font color="black"> 495.         #                             SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER |</font>
<font color="black"> 496.         #                             SSL_MODE_AUTO_RETRY);</font>
<font color="red"> 497.         self.set_mode(_lib.SSL_MODE_ENABLE_PARTIAL_WRITE)</font>
<font color="black"> 498. </font>
<font color="green"> 499.     def load_verify_locations(self, cafile, capath=None):</font>
<font color="black"> 500.         &quot;&quot;&quot;</font>
<font color="black"> 501.         Let SSL know where we can find trusted certificates for the certificate</font>
<font color="black"> 502.         chain</font>
<font color="black"> 503. </font>
<font color="black"> 504.         :param cafile: In which file we can find the certificates (``bytes`` or</font>
<font color="black"> 505.             ``unicode``).</font>
<font color="black"> 506.         :param capath: In which directory we can find the certificates</font>
<font color="black"> 507.             (``bytes`` or ``unicode``).</font>
<font color="black"> 508. </font>
<font color="black"> 509.         :return: None</font>
<font color="black"> 510.         &quot;&quot;&quot;</font>
<font color="red"> 511.         if cafile is None:</font>
<font color="red"> 512.             cafile = _ffi.NULL</font>
<font color="black"> 513.         else:</font>
<font color="red"> 514.             cafile = _path_string(cafile)</font>
<font color="black"> 515. </font>
<font color="red"> 516.         if capath is None:</font>
<font color="red"> 517.             capath = _ffi.NULL</font>
<font color="black"> 518.         else:</font>
<font color="red"> 519.             capath = _path_string(capath)</font>
<font color="black"> 520. </font>
<font color="red"> 521.         load_result = _lib.SSL_CTX_load_verify_locations(</font>
<font color="red"> 522.             self._context, cafile, capath</font>
<font color="black"> 523.         )</font>
<font color="red"> 524.         if not load_result:</font>
<font color="red"> 525.             _raise_current_error()</font>
<font color="black"> 526. </font>
<font color="green"> 527.     def _wrap_callback(self, callback):</font>
<font color="red"> 528.         @wraps(callback)</font>
<font color="black"> 529.         def wrapper(size, verify, userdata):</font>
<font color="red"> 530.             return callback(size, verify, self._passphrase_userdata)</font>
<font color="red"> 531.         return _PassphraseHelper(</font>
<font color="red"> 532.             FILETYPE_PEM, wrapper, more_args=True, truncate=True)</font>
<font color="black"> 533. </font>
<font color="green"> 534.     def set_passwd_cb(self, callback, userdata=None):</font>
<font color="black"> 535.         &quot;&quot;&quot;</font>
<font color="black"> 536.         Set the passphrase callback</font>
<font color="black"> 537. </font>
<font color="black"> 538.         :param callback: The Python callback to use</font>
<font color="black"> 539.         :param userdata: (optional) A Python object which will be given as</font>
<font color="black"> 540.                          argument to the callback</font>
<font color="black"> 541.         :return: None</font>
<font color="black"> 542.         &quot;&quot;&quot;</font>
<font color="red"> 543.         if not callable(callback):</font>
<font color="red"> 544.             raise TypeError(&quot;callback must be callable&quot;)</font>
<font color="black"> 545. </font>
<font color="red"> 546.         self._passphrase_helper = self._wrap_callback(callback)</font>
<font color="red"> 547.         self._passphrase_callback = self._passphrase_helper.callback</font>
<font color="red"> 548.         _lib.SSL_CTX_set_default_passwd_cb(</font>
<font color="red"> 549.             self._context, self._passphrase_callback)</font>
<font color="red"> 550.         self._passphrase_userdata = userdata</font>
<font color="black"> 551. </font>
<font color="green"> 552.     def set_default_verify_paths(self):</font>
<font color="black"> 553.         &quot;&quot;&quot;</font>
<font color="black"> 554.         Use the platform-specific CA certificate locations</font>
<font color="black"> 555. </font>
<font color="black"> 556.         :return: None</font>
<font color="black"> 557.         &quot;&quot;&quot;</font>
<font color="red"> 558.         set_result = _lib.SSL_CTX_set_default_verify_paths(self._context)</font>
<font color="red"> 559.         _openssl_assert(set_result == 1)</font>
<font color="black"> 560. </font>
<font color="green"> 561.     def use_certificate_chain_file(self, certfile):</font>
<font color="black"> 562.         &quot;&quot;&quot;</font>
<font color="black"> 563.         Load a certificate chain from a file</font>
<font color="black"> 564. </font>
<font color="black"> 565.         :param certfile: The name of the certificate chain file (``bytes`` or</font>
<font color="black"> 566.             ``unicode``).</font>
<font color="black"> 567. </font>
<font color="black"> 568.         :return: None</font>
<font color="black"> 569.         &quot;&quot;&quot;</font>
<font color="red"> 570.         certfile = _path_string(certfile)</font>
<font color="black"> 571. </font>
<font color="red"> 572.         result = _lib.SSL_CTX_use_certificate_chain_file(</font>
<font color="red"> 573.             self._context, certfile</font>
<font color="black"> 574.         )</font>
<font color="red"> 575.         if not result:</font>
<font color="red"> 576.             _raise_current_error()</font>
<font color="black"> 577. </font>
<font color="green"> 578.     def use_certificate_file(self, certfile, filetype=FILETYPE_PEM):</font>
<font color="black"> 579.         &quot;&quot;&quot;</font>
<font color="black"> 580.         Load a certificate from a file</font>
<font color="black"> 581. </font>
<font color="black"> 582.         :param certfile: The name of the certificate file (``bytes`` or</font>
<font color="black"> 583.             ``unicode``).</font>
<font color="black"> 584.         :param filetype: (optional) The encoding of the file, default is PEM</font>
<font color="black"> 585. </font>
<font color="black"> 586.         :return: None</font>
<font color="black"> 587.         &quot;&quot;&quot;</font>
<font color="red"> 588.         certfile = _path_string(certfile)</font>
<font color="red"> 589.         if not isinstance(filetype, integer_types):</font>
<font color="red"> 590.             raise TypeError(&quot;filetype must be an integer&quot;)</font>
<font color="black"> 591. </font>
<font color="red"> 592.         use_result = _lib.SSL_CTX_use_certificate_file(</font>
<font color="red"> 593.             self._context, certfile, filetype</font>
<font color="black"> 594.         )</font>
<font color="red"> 595.         if not use_result:</font>
<font color="red"> 596.             _raise_current_error()</font>
<font color="black"> 597. </font>
<font color="green"> 598.     def use_certificate(self, cert):</font>
<font color="black"> 599.         &quot;&quot;&quot;</font>
<font color="black"> 600.         Load a certificate from a X509 object</font>
<font color="black"> 601. </font>
<font color="black"> 602.         :param cert: The X509 object</font>
<font color="black"> 603.         :return: None</font>
<font color="black"> 604.         &quot;&quot;&quot;</font>
<font color="red"> 605.         if not isinstance(cert, X509):</font>
<font color="red"> 606.             raise TypeError(&quot;cert must be an X509 instance&quot;)</font>
<font color="black"> 607. </font>
<font color="red"> 608.         use_result = _lib.SSL_CTX_use_certificate(self._context, cert._x509)</font>
<font color="red"> 609.         if not use_result:</font>
<font color="red"> 610.             _raise_current_error()</font>
<font color="black"> 611. </font>
<font color="green"> 612.     def add_extra_chain_cert(self, certobj):</font>
<font color="black"> 613.         &quot;&quot;&quot;</font>
<font color="black"> 614.         Add certificate to chain</font>
<font color="black"> 615. </font>
<font color="black"> 616.         :param certobj: The X509 certificate object to add to the chain</font>
<font color="black"> 617.         :return: None</font>
<font color="black"> 618.         &quot;&quot;&quot;</font>
<font color="red"> 619.         if not isinstance(certobj, X509):</font>
<font color="red"> 620.             raise TypeError(&quot;certobj must be an X509 instance&quot;)</font>
<font color="black"> 621. </font>
<font color="red"> 622.         copy = _lib.X509_dup(certobj._x509)</font>
<font color="red"> 623.         add_result = _lib.SSL_CTX_add_extra_chain_cert(self._context, copy)</font>
<font color="red"> 624.         if not add_result:</font>
<font color="black"> 625.             # TODO: This is untested.</font>
<font color="red"> 626.             _lib.X509_free(copy)</font>
<font color="red"> 627.             _raise_current_error()</font>
<font color="black"> 628. </font>
<font color="green"> 629.     def _raise_passphrase_exception(self):</font>
<font color="red"> 630.         if self._passphrase_helper is None:</font>
<font color="red"> 631.             _raise_current_error()</font>
<font color="red"> 632.         exception = self._passphrase_helper.raise_if_problem(Error)</font>
<font color="red"> 633.         if exception is not None:</font>
<font color="red"> 634.             raise exception</font>
<font color="black"> 635. </font>
<font color="green"> 636.     def use_privatekey_file(self, keyfile, filetype=_UNSPECIFIED):</font>
<font color="black"> 637.         &quot;&quot;&quot;</font>
<font color="black"> 638.         Load a private key from a file</font>
<font color="black"> 639. </font>
<font color="black"> 640.         :param keyfile: The name of the key file (``bytes`` or ``unicode``)</font>
<font color="black"> 641.         :param filetype: (optional) The encoding of the file, default is PEM</font>
<font color="black"> 642. </font>
<font color="black"> 643.         :return: None</font>
<font color="black"> 644.         &quot;&quot;&quot;</font>
<font color="red"> 645.         keyfile = _path_string(keyfile)</font>
<font color="black"> 646. </font>
<font color="red"> 647.         if filetype is _UNSPECIFIED:</font>
<font color="red"> 648.             filetype = FILETYPE_PEM</font>
<font color="red"> 649.         elif not isinstance(filetype, integer_types):</font>
<font color="red"> 650.             raise TypeError(&quot;filetype must be an integer&quot;)</font>
<font color="black"> 651. </font>
<font color="red"> 652.         use_result = _lib.SSL_CTX_use_PrivateKey_file(</font>
<font color="red"> 653.             self._context, keyfile, filetype)</font>
<font color="red"> 654.         if not use_result:</font>
<font color="red"> 655.             self._raise_passphrase_exception()</font>
<font color="black"> 656. </font>
<font color="green"> 657.     def use_privatekey(self, pkey):</font>
<font color="black"> 658.         &quot;&quot;&quot;</font>
<font color="black"> 659.         Load a private key from a PKey object</font>
<font color="black"> 660. </font>
<font color="black"> 661.         :param pkey: The PKey object</font>
<font color="black"> 662.         :return: None</font>
<font color="black"> 663.         &quot;&quot;&quot;</font>
<font color="red"> 664.         if not isinstance(pkey, PKey):</font>
<font color="red"> 665.             raise TypeError(&quot;pkey must be a PKey instance&quot;)</font>
<font color="black"> 666. </font>
<font color="red"> 667.         use_result = _lib.SSL_CTX_use_PrivateKey(self._context, pkey._pkey)</font>
<font color="red"> 668.         if not use_result:</font>
<font color="red"> 669.             self._raise_passphrase_exception()</font>
<font color="black"> 670. </font>
<font color="green"> 671.     def check_privatekey(self):</font>
<font color="black"> 672.         &quot;&quot;&quot;</font>
<font color="black"> 673.         Check that the private key and certificate match up</font>
<font color="black"> 674. </font>
<font color="black"> 675.         :return: None (raises an exception if something's wrong)</font>
<font color="black"> 676.         &quot;&quot;&quot;</font>
<font color="red"> 677.         if not _lib.SSL_CTX_check_private_key(self._context):</font>
<font color="red"> 678.             _raise_current_error()</font>
<font color="black"> 679. </font>
<font color="green"> 680.     def load_client_ca(self, cafile):</font>
<font color="black"> 681.         &quot;&quot;&quot;</font>
<font color="black"> 682.         Load the trusted certificates that will be sent to the client.  Does</font>
<font color="black"> 683.         not actually imply any of the certificates are trusted; that must be</font>
<font color="black"> 684.         configured separately.</font>
<font color="black"> 685. </font>
<font color="black"> 686.         :param bytes cafile: The path to a certificates file in PEM format.</font>
<font color="black"> 687.         :return: None</font>
<font color="black"> 688.         &quot;&quot;&quot;</font>
<font color="red"> 689.         ca_list = _lib.SSL_load_client_CA_file(</font>
<font color="red"> 690.             _text_to_bytes_and_warn(&quot;cafile&quot;, cafile)</font>
<font color="black"> 691.         )</font>
<font color="red"> 692.         _openssl_assert(ca_list != _ffi.NULL)</font>
<font color="black"> 693.         # SSL_CTX_set_client_CA_list doesn't return anything.</font>
<font color="red"> 694.         _lib.SSL_CTX_set_client_CA_list(self._context, ca_list)</font>
<font color="black"> 695. </font>
<font color="green"> 696.     def set_session_id(self, buf):</font>
<font color="black"> 697.         &quot;&quot;&quot;</font>
<font color="black"> 698.         Set the session id to *buf* within which a session can be reused for</font>
<font color="black"> 699.         this Context object.  This is needed when doing session resumption,</font>
<font color="black"> 700.         because there is no way for a stored session to know which Context</font>
<font color="black"> 701.         object it is associated with.</font>
<font color="black"> 702. </font>
<font color="black"> 703.         :param bytes buf: The session id.</font>
<font color="black"> 704. </font>
<font color="black"> 705.         :returns: None</font>
<font color="black"> 706.         &quot;&quot;&quot;</font>
<font color="red"> 707.         buf = _text_to_bytes_and_warn(&quot;buf&quot;, buf)</font>
<font color="red"> 708.         _openssl_assert(</font>
<font color="red"> 709.             _lib.SSL_CTX_set_session_id_context(</font>
<font color="red"> 710.                 self._context,</font>
<font color="red"> 711.                 buf,</font>
<font color="red"> 712.                 len(buf),</font>
<font color="red"> 713.             ) == 1</font>
<font color="black"> 714.         )</font>
<font color="black"> 715. </font>
<font color="green"> 716.     def set_session_cache_mode(self, mode):</font>
<font color="black"> 717.         &quot;&quot;&quot;</font>
<font color="black"> 718.         Enable/disable session caching and specify the mode used.</font>
<font color="black"> 719. </font>
<font color="black"> 720.         :param mode: One or more of the SESS_CACHE_* flags (combine using</font>
<font color="black"> 721.             bitwise or)</font>
<font color="black"> 722.         :returns: The previously set caching mode.</font>
<font color="black"> 723.         &quot;&quot;&quot;</font>
<font color="red"> 724.         if not isinstance(mode, integer_types):</font>
<font color="red"> 725.             raise TypeError(&quot;mode must be an integer&quot;)</font>
<font color="black"> 726. </font>
<font color="red"> 727.         return _lib.SSL_CTX_set_session_cache_mode(self._context, mode)</font>
<font color="black"> 728. </font>
<font color="green"> 729.     def get_session_cache_mode(self):</font>
<font color="black"> 730.         &quot;&quot;&quot;</font>
<font color="black"> 731.         :returns: The currently used cache mode.</font>
<font color="black"> 732.         &quot;&quot;&quot;</font>
<font color="red"> 733.         return _lib.SSL_CTX_get_session_cache_mode(self._context)</font>
<font color="black"> 734. </font>
<font color="green"> 735.     def set_verify(self, mode, callback):</font>
<font color="black"> 736.         &quot;&quot;&quot;</font>
<font color="black"> 737.         Set the verify mode and verify callback</font>
<font color="black"> 738. </font>
<font color="black"> 739.         :param mode: The verify mode, this is either VERIFY_NONE or</font>
<font color="black"> 740.                      VERIFY_PEER combined with possible other flags</font>
<font color="black"> 741.         :param callback: The Python callback to use</font>
<font color="black"> 742.         :return: None</font>
<font color="black"> 743. </font>
<font color="black"> 744.         See SSL_CTX_set_verify(3SSL) for further details.</font>
<font color="black"> 745.         &quot;&quot;&quot;</font>
<font color="red"> 746.         if not isinstance(mode, integer_types):</font>
<font color="red"> 747.             raise TypeError(&quot;mode must be an integer&quot;)</font>
<font color="black"> 748. </font>
<font color="red"> 749.         if not callable(callback):</font>
<font color="red"> 750.             raise TypeError(&quot;callback must be callable&quot;)</font>
<font color="black"> 751. </font>
<font color="red"> 752.         self._verify_helper = _VerifyHelper(callback)</font>
<font color="red"> 753.         self._verify_callback = self._verify_helper.callback</font>
<font color="red"> 754.         _lib.SSL_CTX_set_verify(self._context, mode, self._verify_callback)</font>
<font color="black"> 755. </font>
<font color="green"> 756.     def set_verify_depth(self, depth):</font>
<font color="black"> 757.         &quot;&quot;&quot;</font>
<font color="black"> 758.         Set the verify depth</font>
<font color="black"> 759. </font>
<font color="black"> 760.         :param depth: An integer specifying the verify depth</font>
<font color="black"> 761.         :return: None</font>
<font color="black"> 762.         &quot;&quot;&quot;</font>
<font color="red"> 763.         if not isinstance(depth, integer_types):</font>
<font color="red"> 764.             raise TypeError(&quot;depth must be an integer&quot;)</font>
<font color="black"> 765. </font>
<font color="red"> 766.         _lib.SSL_CTX_set_verify_depth(self._context, depth)</font>
<font color="black"> 767. </font>
<font color="green"> 768.     def get_verify_mode(self):</font>
<font color="black"> 769.         &quot;&quot;&quot;</font>
<font color="black"> 770.         Get the verify mode</font>
<font color="black"> 771. </font>
<font color="black"> 772.         :return: The verify mode</font>
<font color="black"> 773.         &quot;&quot;&quot;</font>
<font color="red"> 774.         return _lib.SSL_CTX_get_verify_mode(self._context)</font>
<font color="black"> 775. </font>
<font color="green"> 776.     def get_verify_depth(self):</font>
<font color="black"> 777.         &quot;&quot;&quot;</font>
<font color="black"> 778.         Get the verify depth</font>
<font color="black"> 779. </font>
<font color="black"> 780.         :return: The verify depth</font>
<font color="black"> 781.         &quot;&quot;&quot;</font>
<font color="red"> 782.         return _lib.SSL_CTX_get_verify_depth(self._context)</font>
<font color="black"> 783. </font>
<font color="green"> 784.     def load_tmp_dh(self, dhfile):</font>
<font color="black"> 785.         &quot;&quot;&quot;</font>
<font color="black"> 786.         Load parameters for Ephemeral Diffie-Hellman</font>
<font color="black"> 787. </font>
<font color="black"> 788.         :param dhfile: The file to load EDH parameters from (``bytes`` or</font>
<font color="black"> 789.             ``unicode``).</font>
<font color="black"> 790. </font>
<font color="black"> 791.         :return: None</font>
<font color="black"> 792.         &quot;&quot;&quot;</font>
<font color="red"> 793.         dhfile = _path_string(dhfile)</font>
<font color="black"> 794. </font>
<font color="red"> 795.         bio = _lib.BIO_new_file(dhfile, b&quot;r&quot;)</font>
<font color="red"> 796.         if bio == _ffi.NULL:</font>
<font color="red"> 797.             _raise_current_error()</font>
<font color="red"> 798.         bio = _ffi.gc(bio, _lib.BIO_free)</font>
<font color="black"> 799. </font>
<font color="red"> 800.         dh = _lib.PEM_read_bio_DHparams(bio, _ffi.NULL, _ffi.NULL, _ffi.NULL)</font>
<font color="red"> 801.         dh = _ffi.gc(dh, _lib.DH_free)</font>
<font color="red"> 802.         _lib.SSL_CTX_set_tmp_dh(self._context, dh)</font>
<font color="black"> 803. </font>
<font color="green"> 804.     def set_tmp_ecdh(self, curve):</font>
<font color="black"> 805.         &quot;&quot;&quot;</font>
<font color="black"> 806.         Select a curve to use for ECDHE key exchange.</font>
<font color="black"> 807. </font>
<font color="black"> 808.         :param curve: A curve object to use as returned by either</font>
<font color="black"> 809.             :py:meth:`OpenSSL.crypto.get_elliptic_curve` or</font>
<font color="black"> 810.             :py:meth:`OpenSSL.crypto.get_elliptic_curves`.</font>
<font color="black"> 811. </font>
<font color="black"> 812.         :return: None</font>
<font color="black"> 813.         &quot;&quot;&quot;</font>
<font color="red"> 814.         _lib.SSL_CTX_set_tmp_ecdh(self._context, curve._to_EC_KEY())</font>
<font color="black"> 815. </font>
<font color="green"> 816.     def set_cipher_list(self, cipher_list):</font>
<font color="black"> 817.         &quot;&quot;&quot;</font>
<font color="black"> 818.         Set the list of ciphers to be used in this context.</font>
<font color="black"> 819. </font>
<font color="black"> 820.         See the OpenSSL manual for more information (e.g.</font>
<font color="black"> 821.         :manpage:`ciphers(1)`).</font>
<font color="black"> 822. </font>
<font color="black"> 823.         :param bytes cipher_list: An OpenSSL cipher string.</font>
<font color="black"> 824.         :return: None</font>
<font color="black"> 825.         &quot;&quot;&quot;</font>
<font color="red"> 826.         cipher_list = _text_to_bytes_and_warn(&quot;cipher_list&quot;, cipher_list)</font>
<font color="black"> 827. </font>
<font color="red"> 828.         if not isinstance(cipher_list, bytes):</font>
<font color="red"> 829.             raise TypeError(&quot;cipher_list must be a byte string.&quot;)</font>
<font color="black"> 830. </font>
<font color="red"> 831.         _openssl_assert(</font>
<font color="red"> 832.             _lib.SSL_CTX_set_cipher_list(self._context, cipher_list) == 1</font>
<font color="black"> 833.         )</font>
<font color="black"> 834. </font>
<font color="green"> 835.     def set_client_ca_list(self, certificate_authorities):</font>
<font color="black"> 836.         &quot;&quot;&quot;</font>
<font color="black"> 837.         Set the list of preferred client certificate signers for this server</font>
<font color="black"> 838.         context.</font>
<font color="black"> 839. </font>
<font color="black"> 840.         This list of certificate authorities will be sent to the client when</font>
<font color="black"> 841.         the server requests a client certificate.</font>
<font color="black"> 842. </font>
<font color="black"> 843.         :param certificate_authorities: a sequence of X509Names.</font>
<font color="black"> 844.         :return: None</font>
<font color="black"> 845.         &quot;&quot;&quot;</font>
<font color="red"> 846.         name_stack = _lib.sk_X509_NAME_new_null()</font>
<font color="red"> 847.         _openssl_assert(name_stack != _ffi.NULL)</font>
<font color="black"> 848. </font>
<font color="red"> 849.         try:</font>
<font color="red"> 850.             for ca_name in certificate_authorities:</font>
<font color="red"> 851.                 if not isinstance(ca_name, X509Name):</font>
<font color="red"> 852.                     raise TypeError(</font>
<font color="red"> 853.                         &quot;client CAs must be X509Name objects, not %s &quot;</font>
<font color="black"> 854.                         &quot;objects&quot; % (</font>
<font color="red"> 855.                             type(ca_name).__name__,</font>
<font color="black"> 856.                         )</font>
<font color="black"> 857.                     )</font>
<font color="red"> 858.                 copy = _lib.X509_NAME_dup(ca_name._name)</font>
<font color="red"> 859.                 _openssl_assert(copy != _ffi.NULL)</font>
<font color="red"> 860.                 push_result = _lib.sk_X509_NAME_push(name_stack, copy)</font>
<font color="red"> 861.                 if not push_result:</font>
<font color="red"> 862.                     _lib.X509_NAME_free(copy)</font>
<font color="red"> 863.                     _raise_current_error()</font>
<font color="red"> 864.         except:</font>
<font color="red"> 865.             _lib.sk_X509_NAME_free(name_stack)</font>
<font color="red"> 866.             raise</font>
<font color="black"> 867. </font>
<font color="red"> 868.         _lib.SSL_CTX_set_client_CA_list(self._context, name_stack)</font>
<font color="black"> 869. </font>
<font color="green"> 870.     def add_client_ca(self, certificate_authority):</font>
<font color="black"> 871.         &quot;&quot;&quot;</font>
<font color="black"> 872.         Add the CA certificate to the list of preferred signers for this</font>
<font color="black"> 873.         context.</font>
<font color="black"> 874. </font>
<font color="black"> 875.         The list of certificate authorities will be sent to the client when the</font>
<font color="black"> 876.         server requests a client certificate.</font>
<font color="black"> 877. </font>
<font color="black"> 878.         :param certificate_authority: certificate authority's X509 certificate.</font>
<font color="black"> 879.         :return: None</font>
<font color="black"> 880.         &quot;&quot;&quot;</font>
<font color="red"> 881.         if not isinstance(certificate_authority, X509):</font>
<font color="red"> 882.             raise TypeError(&quot;certificate_authority must be an X509 instance&quot;)</font>
<font color="black"> 883. </font>
<font color="red"> 884.         add_result = _lib.SSL_CTX_add_client_CA(</font>
<font color="red"> 885.             self._context, certificate_authority._x509)</font>
<font color="red"> 886.         _openssl_assert(add_result == 1)</font>
<font color="black"> 887. </font>
<font color="green"> 888.     def set_timeout(self, timeout):</font>
<font color="black"> 889.         &quot;&quot;&quot;</font>
<font color="black"> 890.         Set session timeout</font>
<font color="black"> 891. </font>
<font color="black"> 892.         :param timeout: The timeout in seconds</font>
<font color="black"> 893.         :return: The previous session timeout</font>
<font color="black"> 894.         &quot;&quot;&quot;</font>
<font color="red"> 895.         if not isinstance(timeout, integer_types):</font>
<font color="red"> 896.             raise TypeError(&quot;timeout must be an integer&quot;)</font>
<font color="black"> 897. </font>
<font color="red"> 898.         return _lib.SSL_CTX_set_timeout(self._context, timeout)</font>
<font color="black"> 899. </font>
<font color="green"> 900.     def get_timeout(self):</font>
<font color="black"> 901.         &quot;&quot;&quot;</font>
<font color="black"> 902.         Get the session timeout</font>
<font color="black"> 903. </font>
<font color="black"> 904.         :return: The session timeout</font>
<font color="black"> 905.         &quot;&quot;&quot;</font>
<font color="red"> 906.         return _lib.SSL_CTX_get_timeout(self._context)</font>
<font color="black"> 907. </font>
<font color="green"> 908.     def set_info_callback(self, callback):</font>
<font color="black"> 909.         &quot;&quot;&quot;</font>
<font color="black"> 910.         Set the info callback</font>
<font color="black"> 911. </font>
<font color="black"> 912.         :param callback: The Python callback to use</font>
<font color="black"> 913.         :return: None</font>
<font color="black"> 914.         &quot;&quot;&quot;</font>
<font color="red"> 915.         @wraps(callback)</font>
<font color="black"> 916.         def wrapper(ssl, where, return_code):</font>
<font color="red"> 917.             callback(Connection._reverse_mapping[ssl], where, return_code)</font>
<font color="red"> 918.         self._info_callback = _ffi.callback(</font>
<font color="red"> 919.             &quot;void (*)(const SSL *, int, int)&quot;, wrapper)</font>
<font color="red"> 920.         _lib.SSL_CTX_set_info_callback(self._context, self._info_callback)</font>
<font color="black"> 921. </font>
<font color="green"> 922.     def get_app_data(self):</font>
<font color="black"> 923.         &quot;&quot;&quot;</font>
<font color="black"> 924.         Get the application data (supplied via set_app_data())</font>
<font color="black"> 925. </font>
<font color="black"> 926.         :return: The application data</font>
<font color="black"> 927.         &quot;&quot;&quot;</font>
<font color="red"> 928.         return self._app_data</font>
<font color="black"> 929. </font>
<font color="green"> 930.     def set_app_data(self, data):</font>
<font color="black"> 931.         &quot;&quot;&quot;</font>
<font color="black"> 932.         Set the application data (will be returned from get_app_data())</font>
<font color="black"> 933. </font>
<font color="black"> 934.         :param data: Any Python object</font>
<font color="black"> 935.         :return: None</font>
<font color="black"> 936.         &quot;&quot;&quot;</font>
<font color="red"> 937.         self._app_data = data</font>
<font color="black"> 938. </font>
<font color="green"> 939.     def get_cert_store(self):</font>
<font color="black"> 940.         &quot;&quot;&quot;</font>
<font color="black"> 941.         Get the certificate store for the context.</font>
<font color="black"> 942. </font>
<font color="black"> 943.         :return: A X509Store object or None if it does not have one.</font>
<font color="black"> 944.         &quot;&quot;&quot;</font>
<font color="red"> 945.         store = _lib.SSL_CTX_get_cert_store(self._context)</font>
<font color="red"> 946.         if store == _ffi.NULL:</font>
<font color="black"> 947.             # TODO: This is untested.</font>
<font color="red"> 948.             return None</font>
<font color="black"> 949. </font>
<font color="red"> 950.         pystore = X509Store.__new__(X509Store)</font>
<font color="red"> 951.         pystore._store = store</font>
<font color="red"> 952.         return pystore</font>
<font color="black"> 953. </font>
<font color="green"> 954.     def set_options(self, options):</font>
<font color="black"> 955.         &quot;&quot;&quot;</font>
<font color="black"> 956.         Add options. Options set before are not cleared!</font>
<font color="black"> 957. </font>
<font color="black"> 958.         :param options: The options to add.</font>
<font color="black"> 959.         :return: The new option bitmask.</font>
<font color="black"> 960.         &quot;&quot;&quot;</font>
<font color="red"> 961.         if not isinstance(options, integer_types):</font>
<font color="red"> 962.             raise TypeError(&quot;options must be an integer&quot;)</font>
<font color="black"> 963. </font>
<font color="red"> 964.         return _lib.SSL_CTX_set_options(self._context, options)</font>
<font color="black"> 965. </font>
<font color="green"> 966.     def set_mode(self, mode):</font>
<font color="black"> 967.         &quot;&quot;&quot;</font>
<font color="black"> 968.         Add modes via bitmask. Modes set before are not cleared!</font>
<font color="black"> 969. </font>
<font color="black"> 970.         :param mode: The mode to add.</font>
<font color="black"> 971.         :return: The new mode bitmask.</font>
<font color="black"> 972.         &quot;&quot;&quot;</font>
<font color="red"> 973.         if not isinstance(mode, integer_types):</font>
<font color="red"> 974.             raise TypeError(&quot;mode must be an integer&quot;)</font>
<font color="black"> 975. </font>
<font color="red"> 976.         return _lib.SSL_CTX_set_mode(self._context, mode)</font>
<font color="black"> 977. </font>
<font color="green"> 978.     @_requires_sni</font>
<font color="black"> 979.     def set_tlsext_servername_callback(self, callback):</font>
<font color="black"> 980.         &quot;&quot;&quot;</font>
<font color="black"> 981.         Specify a callback function to be called when clients specify a server</font>
<font color="black"> 982.         name.</font>
<font color="black"> 983. </font>
<font color="black"> 984.         :param callback: The callback function.  It will be invoked with one</font>
<font color="black"> 985.             argument, the Connection instance.</font>
<font color="black"> 986.         &quot;&quot;&quot;</font>
<font color="red"> 987.         @wraps(callback)</font>
<font color="black"> 988.         def wrapper(ssl, alert, arg):</font>
<font color="red"> 989.             callback(Connection._reverse_mapping[ssl])</font>
<font color="red"> 990.             return 0</font>
<font color="black"> 991. </font>
<font color="red"> 992.         self._tlsext_servername_callback = _ffi.callback(</font>
<font color="red"> 993.             &quot;int (*)(const SSL *, int *, void *)&quot;, wrapper)</font>
<font color="red"> 994.         _lib.SSL_CTX_set_tlsext_servername_callback(</font>
<font color="red"> 995.             self._context, self._tlsext_servername_callback)</font>
<font color="black"> 996. </font>
<font color="green"> 997.     @_requires_npn</font>
<font color="black"> 998.     def set_npn_advertise_callback(self, callback):</font>
<font color="black"> 999.         &quot;&quot;&quot;</font>
<font color="black">1000.         Specify a callback function that will be called when offering `Next</font>
<font color="black">1001.         Protocol Negotiation</font>
<font color="black">1002.         &lt;https://technotes.googlecode.com/git/nextprotoneg.html&gt;`_ as a server.</font>
<font color="black">1003. </font>
<font color="black">1004.         :param callback: The callback function.  It will be invoked with one</font>
<font color="black">1005.             argument, the Connection instance.  It should return a list of</font>
<font color="black">1006.             bytestrings representing the advertised protocols, like</font>
<font color="black">1007.             ``[b'http/1.1', b'spdy/2']``.</font>
<font color="black">1008.         &quot;&quot;&quot;</font>
<font color="red">1009.         self._npn_advertise_helper = _NpnAdvertiseHelper(callback)</font>
<font color="red">1010.         self._npn_advertise_callback = self._npn_advertise_helper.callback</font>
<font color="red">1011.         _lib.SSL_CTX_set_next_protos_advertised_cb(</font>
<font color="red">1012.             self._context, self._npn_advertise_callback, _ffi.NULL)</font>
<font color="black">1013. </font>
<font color="green">1014.     @_requires_npn</font>
<font color="black">1015.     def set_npn_select_callback(self, callback):</font>
<font color="black">1016.         &quot;&quot;&quot;</font>
<font color="black">1017.         Specify a callback function that will be called when a server offers</font>
<font color="black">1018.         Next Protocol Negotiation options.</font>
<font color="black">1019. </font>
<font color="black">1020.         :param callback: The callback function.  It will be invoked with two</font>
<font color="black">1021.             arguments: the Connection, and a list of offered protocols as</font>
<font color="black">1022.             bytestrings, e.g. ``[b'http/1.1', b'spdy/2']``.  It should return</font>
<font color="black">1023.             one of those bytestrings, the chosen protocol.</font>
<font color="black">1024.         &quot;&quot;&quot;</font>
<font color="red">1025.         self._npn_select_helper = _NpnSelectHelper(callback)</font>
<font color="red">1026.         self._npn_select_callback = self._npn_select_helper.callback</font>
<font color="red">1027.         _lib.SSL_CTX_set_next_proto_select_cb(</font>
<font color="red">1028.             self._context, self._npn_select_callback, _ffi.NULL)</font>
<font color="black">1029. </font>
<font color="green">1030.     @_requires_alpn</font>
<font color="black">1031.     def set_alpn_protos(self, protos):</font>
<font color="black">1032.         &quot;&quot;&quot;</font>
<font color="black">1033.         Specify the clients ALPN protocol list.</font>
<font color="black">1034. </font>
<font color="black">1035.         These protocols are offered to the server during protocol negotiation.</font>
<font color="black">1036. </font>
<font color="black">1037.         :param protos: A list of the protocols to be offered to the server.</font>
<font color="black">1038.             This list should be a Python list of bytestrings representing the</font>
<font color="black">1039.             protocols to offer, e.g. ``[b'http/1.1', b'spdy/2']``.</font>
<font color="black">1040.         &quot;&quot;&quot;</font>
<font color="black">1041.         # Take the list of protocols and join them together, prefixing them</font>
<font color="black">1042.         # with their lengths.</font>
<font color="red">1043.         protostr = b''.join(</font>
<font color="red">1044.             chain.from_iterable((int2byte(len(p)), p) for p in protos)</font>
<font color="black">1045.         )</font>
<font color="black">1046. </font>
<font color="black">1047.         # Build a C string from the list. We don't need to save this off</font>
<font color="black">1048.         # because OpenSSL immediately copies the data out.</font>
<font color="red">1049.         input_str = _ffi.new(&quot;unsigned char[]&quot;, protostr)</font>
<font color="red">1050.         input_str_len = _ffi.cast(&quot;unsigned&quot;, len(protostr))</font>
<font color="red">1051.         _lib.SSL_CTX_set_alpn_protos(self._context, input_str, input_str_len)</font>
<font color="black">1052. </font>
<font color="green">1053.     @_requires_alpn</font>
<font color="black">1054.     def set_alpn_select_callback(self, callback):</font>
<font color="black">1055.         &quot;&quot;&quot;</font>
<font color="black">1056.         Set the callback to handle ALPN protocol choice.</font>
<font color="black">1057. </font>
<font color="black">1058.         :param callback: The callback function.  It will be invoked with two</font>
<font color="black">1059.             arguments: the Connection, and a list of offered protocols as</font>
<font color="black">1060.             bytestrings, e.g ``[b'http/1.1', b'spdy/2']``.  It should return</font>
<font color="black">1061.             one of those bytestrings, the chosen protocol.</font>
<font color="black">1062.         &quot;&quot;&quot;</font>
<font color="red">1063.         self._alpn_select_helper = _ALPNSelectHelper(callback)</font>
<font color="red">1064.         self._alpn_select_callback = self._alpn_select_helper.callback</font>
<font color="red">1065.         _lib.SSL_CTX_set_alpn_select_cb(</font>
<font color="red">1066.             self._context, self._alpn_select_callback, _ffi.NULL)</font>
<font color="black">1067. </font>
<font color="green">1068. ContextType = Context</font>
<font color="black">1069. </font>
<font color="black">1070. </font>
<font color="green">1071. class Connection(object):</font>
<font color="black">1072.     &quot;&quot;&quot;</font>
<font color="green">1073.     &quot;&quot;&quot;</font>
<font color="green">1074.     _reverse_mapping = WeakValueDictionary()</font>
<font color="black">1075. </font>
<font color="green">1076.     def __init__(self, context, socket=None):</font>
<font color="black">1077.         &quot;&quot;&quot;</font>
<font color="black">1078.         Create a new Connection object, using the given OpenSSL.SSL.Context</font>
<font color="black">1079.         instance and socket.</font>
<font color="black">1080. </font>
<font color="black">1081.         :param context: An SSL Context to use for this connection</font>
<font color="black">1082.         :param socket: The socket to use for transport layer</font>
<font color="black">1083.         &quot;&quot;&quot;</font>
<font color="red">1084.         if not isinstance(context, Context):</font>
<font color="red">1085.             raise TypeError(&quot;context must be a Context instance&quot;)</font>
<font color="black">1086. </font>
<font color="red">1087.         ssl = _lib.SSL_new(context._context)</font>
<font color="red">1088.         self._ssl = _ffi.gc(ssl, _lib.SSL_free)</font>
<font color="red">1089.         self._context = context</font>
<font color="red">1090.         self._app_data = None</font>
<font color="black">1091. </font>
<font color="black">1092.         # References to strings used for Next Protocol Negotiation. OpenSSL's</font>
<font color="black">1093.         # header files suggest that these might get copied at some point, but</font>
<font color="black">1094.         # doesn't specify when, so we store them here to make sure they don't</font>
<font color="black">1095.         # get freed before OpenSSL uses them.</font>
<font color="red">1096.         self._npn_advertise_callback_args = None</font>
<font color="red">1097.         self._npn_select_callback_args = None</font>
<font color="black">1098. </font>
<font color="black">1099.         # References to strings used for Application Layer Protocol</font>
<font color="black">1100.         # Negotiation. These strings get copied at some point but it's well</font>
<font color="black">1101.         # after the callback returns, so we have to hang them somewhere to</font>
<font color="black">1102.         # avoid them getting freed.</font>
<font color="red">1103.         self._alpn_select_callback_args = None</font>
<font color="black">1104. </font>
<font color="red">1105.         self._reverse_mapping[self._ssl] = self</font>
<font color="black">1106. </font>
<font color="red">1107.         if socket is None:</font>
<font color="red">1108.             self._socket = None</font>
<font color="black">1109.             # Don't set up any gc for these, SSL_free will take care of them.</font>
<font color="red">1110.             self._into_ssl = _lib.BIO_new(_lib.BIO_s_mem())</font>
<font color="red">1111.             _openssl_assert(self._into_ssl != _ffi.NULL)</font>
<font color="black">1112. </font>
<font color="red">1113.             self._from_ssl = _lib.BIO_new(_lib.BIO_s_mem())</font>
<font color="red">1114.             _openssl_assert(self._from_ssl != _ffi.NULL)</font>
<font color="black">1115. </font>
<font color="red">1116.             _lib.SSL_set_bio(self._ssl, self._into_ssl, self._from_ssl)</font>
<font color="black">1117.         else:</font>
<font color="red">1118.             self._into_ssl = None</font>
<font color="red">1119.             self._from_ssl = None</font>
<font color="red">1120.             self._socket = socket</font>
<font color="red">1121.             set_result = _lib.SSL_set_fd(</font>
<font color="red">1122.                 self._ssl, _asFileDescriptor(self._socket))</font>
<font color="red">1123.             _openssl_assert(set_result == 1)</font>
<font color="black">1124. </font>
<font color="green">1125.     def __getattr__(self, name):</font>
<font color="black">1126.         &quot;&quot;&quot;</font>
<font color="black">1127.         Look up attributes on the wrapped socket object if they are not found</font>
<font color="black">1128.         on the Connection object.</font>
<font color="black">1129.         &quot;&quot;&quot;</font>
<font color="red">1130.         if self._socket is None:</font>
<font color="red">1131.             raise AttributeError(&quot;'%s' object has no attribute '%s'&quot; % (</font>
<font color="red">1132.                 self.__class__.__name__, name</font>
<font color="black">1133.             ))</font>
<font color="black">1134.         else:</font>
<font color="red">1135.             return getattr(self._socket, name)</font>
<font color="black">1136. </font>
<font color="green">1137.     def _raise_ssl_error(self, ssl, result):</font>
<font color="red">1138.         if self._context._verify_helper is not None:</font>
<font color="red">1139.             self._context._verify_helper.raise_if_problem()</font>
<font color="red">1140.         if self._context._npn_advertise_helper is not None:</font>
<font color="red">1141.             self._context._npn_advertise_helper.raise_if_problem()</font>
<font color="red">1142.         if self._context._npn_select_helper is not None:</font>
<font color="red">1143.             self._context._npn_select_helper.raise_if_problem()</font>
<font color="red">1144.         if self._context._alpn_select_helper is not None:</font>
<font color="red">1145.             self._context._alpn_select_helper.raise_if_problem()</font>
<font color="black">1146. </font>
<font color="red">1147.         error = _lib.SSL_get_error(ssl, result)</font>
<font color="red">1148.         if error == _lib.SSL_ERROR_WANT_READ:</font>
<font color="red">1149.             raise WantReadError()</font>
<font color="red">1150.         elif error == _lib.SSL_ERROR_WANT_WRITE:</font>
<font color="red">1151.             raise WantWriteError()</font>
<font color="red">1152.         elif error == _lib.SSL_ERROR_ZERO_RETURN:</font>
<font color="red">1153.             raise ZeroReturnError()</font>
<font color="red">1154.         elif error == _lib.SSL_ERROR_WANT_X509_LOOKUP:</font>
<font color="black">1155.             # TODO: This is untested.</font>
<font color="red">1156.             raise WantX509LookupError()</font>
<font color="red">1157.         elif error == _lib.SSL_ERROR_SYSCALL:</font>
<font color="red">1158.             if _lib.ERR_peek_error() == 0:</font>
<font color="red">1159.                 if result &lt; 0:</font>
<font color="red">1160.                     if platform == &quot;win32&quot;:</font>
<font color="red">1161.                         errno = _ffi.getwinerror()[0]</font>
<font color="black">1162.                     else:</font>
<font color="red">1163.                         errno = _ffi.errno</font>
<font color="black">1164. </font>
<font color="red">1165.                     if errno != 0:</font>
<font color="red">1166.                         raise SysCallError(errno, errorcode.get(errno))</font>
<font color="red">1167.                 raise SysCallError(-1, &quot;Unexpected EOF&quot;)</font>
<font color="black">1168.             else:</font>
<font color="black">1169.                 # TODO: This is untested.</font>
<font color="red">1170.                 _raise_current_error()</font>
<font color="red">1171.         elif error == _lib.SSL_ERROR_NONE:</font>
<font color="red">1172.             pass</font>
<font color="black">1173.         else:</font>
<font color="red">1174.             _raise_current_error()</font>
<font color="black">1175. </font>
<font color="green">1176.     def get_context(self):</font>
<font color="black">1177.         &quot;&quot;&quot;</font>
<font color="black">1178.         Get session context</font>
<font color="black">1179.         &quot;&quot;&quot;</font>
<font color="red">1180.         return self._context</font>
<font color="black">1181. </font>
<font color="green">1182.     def set_context(self, context):</font>
<font color="black">1183.         &quot;&quot;&quot;</font>
<font color="black">1184.         Switch this connection to a new session context</font>
<font color="black">1185. </font>
<font color="black">1186.         :param context: A :py:class:`Context` instance giving the new session</font>
<font color="black">1187.             context to use.</font>
<font color="black">1188.         &quot;&quot;&quot;</font>
<font color="red">1189.         if not isinstance(context, Context):</font>
<font color="red">1190.             raise TypeError(&quot;context must be a Context instance&quot;)</font>
<font color="black">1191. </font>
<font color="red">1192.         _lib.SSL_set_SSL_CTX(self._ssl, context._context)</font>
<font color="red">1193.         self._context = context</font>
<font color="black">1194. </font>
<font color="green">1195.     @_requires_sni</font>
<font color="black">1196.     def get_servername(self):</font>
<font color="black">1197.         &quot;&quot;&quot;</font>
<font color="black">1198.         Retrieve the servername extension value if provided in the client hello</font>
<font color="black">1199.         message, or None if there wasn't one.</font>
<font color="black">1200. </font>
<font color="black">1201.         :return: A byte string giving the server name or :py:data:`None`.</font>
<font color="black">1202.         &quot;&quot;&quot;</font>
<font color="red">1203.         name = _lib.SSL_get_servername(</font>
<font color="red">1204.             self._ssl, _lib.TLSEXT_NAMETYPE_host_name</font>
<font color="black">1205.         )</font>
<font color="red">1206.         if name == _ffi.NULL:</font>
<font color="red">1207.             return None</font>
<font color="black">1208. </font>
<font color="red">1209.         return _ffi.string(name)</font>
<font color="black">1210. </font>
<font color="green">1211.     @_requires_sni</font>
<font color="black">1212.     def set_tlsext_host_name(self, name):</font>
<font color="black">1213.         &quot;&quot;&quot;</font>
<font color="black">1214.         Set the value of the servername extension to send in the client hello.</font>
<font color="black">1215. </font>
<font color="black">1216.         :param name: A byte string giving the name.</font>
<font color="black">1217.         &quot;&quot;&quot;</font>
<font color="red">1218.         if not isinstance(name, bytes):</font>
<font color="red">1219.             raise TypeError(&quot;name must be a byte string&quot;)</font>
<font color="red">1220.         elif b&quot;\0&quot; in name:</font>
<font color="red">1221.             raise TypeError(&quot;name must not contain NUL byte&quot;)</font>
<font color="black">1222. </font>
<font color="black">1223.         # XXX I guess this can fail sometimes?</font>
<font color="red">1224.         _lib.SSL_set_tlsext_host_name(self._ssl, name)</font>
<font color="black">1225. </font>
<font color="green">1226.     def pending(self):</font>
<font color="black">1227.         &quot;&quot;&quot;</font>
<font color="black">1228.         Get the number of bytes that can be safely read from the connection</font>
<font color="black">1229. </font>
<font color="black">1230.         :return: The number of bytes available in the receive buffer.</font>
<font color="black">1231.         &quot;&quot;&quot;</font>
<font color="red">1232.         return _lib.SSL_pending(self._ssl)</font>
<font color="black">1233. </font>
<font color="green">1234.     def send(self, buf, flags=0):</font>
<font color="black">1235.         &quot;&quot;&quot;</font>
<font color="black">1236.         Send data on the connection. NOTE: If you get one of the WantRead,</font>
<font color="black">1237.         WantWrite or WantX509Lookup exceptions on this, you have to call the</font>
<font color="black">1238.         method again with the SAME buffer.</font>
<font color="black">1239. </font>
<font color="black">1240.         :param buf: The string, buffer or memoryview to send</font>
<font color="black">1241.         :param flags: (optional) Included for compatibility with the socket</font>
<font color="black">1242.                       API, the value is ignored</font>
<font color="black">1243.         :return: The number of bytes written</font>
<font color="black">1244.         &quot;&quot;&quot;</font>
<font color="black">1245.         # Backward compatibility</font>
<font color="red">1246.         buf = _text_to_bytes_and_warn(&quot;buf&quot;, buf)</font>
<font color="black">1247. </font>
<font color="red">1248.         if isinstance(buf, _memoryview):</font>
<font color="red">1249.             buf = buf.tobytes()</font>
<font color="red">1250.         if isinstance(buf, _buffer):</font>
<font color="red">1251.             buf = str(buf)</font>
<font color="red">1252.         if not isinstance(buf, bytes):</font>
<font color="red">1253.             raise TypeError(&quot;data must be a memoryview, buffer or byte string&quot;)</font>
<font color="black">1254. </font>
<font color="red">1255.         result = _lib.SSL_write(self._ssl, buf, len(buf))</font>
<font color="red">1256.         self._raise_ssl_error(self._ssl, result)</font>
<font color="red">1257.         return result</font>
<font color="green">1258.     write = send</font>
<font color="black">1259. </font>
<font color="green">1260.     def sendall(self, buf, flags=0):</font>
<font color="black">1261.         &quot;&quot;&quot;</font>
<font color="black">1262.         Send &quot;all&quot; data on the connection. This calls send() repeatedly until</font>
<font color="black">1263.         all data is sent. If an error occurs, it's impossible to tell how much</font>
<font color="black">1264.         data has been sent.</font>
<font color="black">1265. </font>
<font color="black">1266.         :param buf: The string, buffer or memoryview to send</font>
<font color="black">1267.         :param flags: (optional) Included for compatibility with the socket</font>
<font color="black">1268.                       API, the value is ignored</font>
<font color="black">1269.         :return: The number of bytes written</font>
<font color="black">1270.         &quot;&quot;&quot;</font>
<font color="red">1271.         buf = _text_to_bytes_and_warn(&quot;buf&quot;, buf)</font>
<font color="black">1272. </font>
<font color="red">1273.         if isinstance(buf, _memoryview):</font>
<font color="red">1274.             buf = buf.tobytes()</font>
<font color="red">1275.         if isinstance(buf, _buffer):</font>
<font color="red">1276.             buf = str(buf)</font>
<font color="red">1277.         if not isinstance(buf, bytes):</font>
<font color="red">1278.             raise TypeError(&quot;buf must be a memoryview, buffer or byte string&quot;)</font>
<font color="black">1279. </font>
<font color="red">1280.         left_to_send = len(buf)</font>
<font color="red">1281.         total_sent = 0</font>
<font color="red">1282.         data = _ffi.new(&quot;char[]&quot;, buf)</font>
<font color="black">1283. </font>
<font color="red">1284.         while left_to_send:</font>
<font color="red">1285.             result = _lib.SSL_write(self._ssl, data + total_sent, left_to_send)</font>
<font color="red">1286.             self._raise_ssl_error(self._ssl, result)</font>
<font color="red">1287.             total_sent += result</font>
<font color="red">1288.             left_to_send -= result</font>
<font color="black">1289. </font>
<font color="green">1290.     def recv(self, bufsiz, flags=None):</font>
<font color="black">1291.         &quot;&quot;&quot;</font>
<font color="black">1292.         Receive data on the connection.</font>
<font color="black">1293. </font>
<font color="black">1294.         :param bufsiz: The maximum number of bytes to read</font>
<font color="black">1295.         :param flags: (optional) The only supported flag is ``MSG_PEEK``,</font>
<font color="black">1296.             all other flags are ignored.</font>
<font color="black">1297.         :return: The string read from the Connection</font>
<font color="black">1298.         &quot;&quot;&quot;</font>
<font color="red">1299.         buf = _ffi.new(&quot;char[]&quot;, bufsiz)</font>
<font color="red">1300.         if flags is not None and flags &amp; socket.MSG_PEEK:</font>
<font color="red">1301.             result = _lib.SSL_peek(self._ssl, buf, bufsiz)</font>
<font color="black">1302.         else:</font>
<font color="red">1303.             result = _lib.SSL_read(self._ssl, buf, bufsiz)</font>
<font color="red">1304.         self._raise_ssl_error(self._ssl, result)</font>
<font color="red">1305.         return _ffi.buffer(buf, result)[:]</font>
<font color="green">1306.     read = recv</font>
<font color="black">1307. </font>
<font color="green">1308.     def recv_into(self, buffer, nbytes=None, flags=None):</font>
<font color="black">1309.         &quot;&quot;&quot;</font>
<font color="black">1310.         Receive data on the connection and store the data into a buffer rather</font>
<font color="black">1311.         than creating a new string.</font>
<font color="black">1312. </font>
<font color="black">1313.         :param buffer: The buffer to copy into.</font>
<font color="black">1314.         :param nbytes: (optional) The maximum number of bytes to read into the</font>
<font color="black">1315.             buffer. If not present, defaults to the size of the buffer. If</font>
<font color="black">1316.             larger than the size of the buffer, is reduced to the size of the</font>
<font color="black">1317.             buffer.</font>
<font color="black">1318.         :param flags: (optional) The only supported flag is ``MSG_PEEK``,</font>
<font color="black">1319.             all other flags are ignored.</font>
<font color="black">1320.         :return: The number of bytes read into the buffer.</font>
<font color="black">1321.         &quot;&quot;&quot;</font>
<font color="red">1322.         if nbytes is None:</font>
<font color="red">1323.             nbytes = len(buffer)</font>
<font color="black">1324.         else:</font>
<font color="red">1325.             nbytes = min(nbytes, len(buffer))</font>
<font color="black">1326. </font>
<font color="black">1327.         # We need to create a temporary buffer. This is annoying, it would be</font>
<font color="black">1328.         # better if we could pass memoryviews straight into the SSL_read call,</font>
<font color="black">1329.         # but right now we can't. Revisit this if CFFI gets that ability.</font>
<font color="red">1330.         buf = _ffi.new(&quot;char[]&quot;, nbytes)</font>
<font color="red">1331.         if flags is not None and flags &amp; socket.MSG_PEEK:</font>
<font color="red">1332.             result = _lib.SSL_peek(self._ssl, buf, nbytes)</font>
<font color="black">1333.         else:</font>
<font color="red">1334.             result = _lib.SSL_read(self._ssl, buf, nbytes)</font>
<font color="red">1335.         self._raise_ssl_error(self._ssl, result)</font>
<font color="black">1336. </font>
<font color="black">1337.         # This strange line is all to avoid a memory copy. The buffer protocol</font>
<font color="black">1338.         # should allow us to assign a CFFI buffer to the LHS of this line, but</font>
<font color="black">1339.         # on CPython 3.3+ that segfaults. As a workaround, we can temporarily</font>
<font color="black">1340.         # wrap it in a memoryview, except on Python 2.6 which doesn't have a</font>
<font color="black">1341.         # memoryview type.</font>
<font color="red">1342.         try:</font>
<font color="red">1343.             buffer[:result] = memoryview(_ffi.buffer(buf, result))</font>
<font color="red">1344.         except NameError:</font>
<font color="red">1345.             buffer[:result] = _ffi.buffer(buf, result)</font>
<font color="black">1346. </font>
<font color="red">1347.         return result</font>
<font color="black">1348. </font>
<font color="green">1349.     def _handle_bio_errors(self, bio, result):</font>
<font color="red">1350.         if _lib.BIO_should_retry(bio):</font>
<font color="red">1351.             if _lib.BIO_should_read(bio):</font>
<font color="red">1352.                 raise WantReadError()</font>
<font color="red">1353.             elif _lib.BIO_should_write(bio):</font>
<font color="black">1354.                 # TODO: This is untested.</font>
<font color="red">1355.                 raise WantWriteError()</font>
<font color="red">1356.             elif _lib.BIO_should_io_special(bio):</font>
<font color="black">1357.                 # TODO: This is untested.  I think io_special means the socket</font>
<font color="black">1358.                 # BIO has a not-yet connected socket.</font>
<font color="red">1359.                 raise ValueError(&quot;BIO_should_io_special&quot;)</font>
<font color="black">1360.             else:</font>
<font color="black">1361.                 # TODO: This is untested.</font>
<font color="red">1362.                 raise ValueError(&quot;unknown bio failure&quot;)</font>
<font color="black">1363.         else:</font>
<font color="black">1364.             # TODO: This is untested.</font>
<font color="red">1365.             _raise_current_error()</font>
<font color="black">1366. </font>
<font color="green">1367.     def bio_read(self, bufsiz):</font>
<font color="black">1368.         &quot;&quot;&quot;</font>
<font color="black">1369.         When using non-socket connections this function reads the &quot;dirty&quot; data</font>
<font color="black">1370.         that would have traveled away on the network.</font>
<font color="black">1371. </font>
<font color="black">1372.         :param bufsiz: The maximum number of bytes to read</font>
<font color="black">1373.         :return: The string read.</font>
<font color="black">1374.         &quot;&quot;&quot;</font>
<font color="red">1375.         if self._from_ssl is None:</font>
<font color="red">1376.             raise TypeError(&quot;Connection sock was not None&quot;)</font>
<font color="black">1377. </font>
<font color="red">1378.         if not isinstance(bufsiz, integer_types):</font>
<font color="red">1379.             raise TypeError(&quot;bufsiz must be an integer&quot;)</font>
<font color="black">1380. </font>
<font color="red">1381.         buf = _ffi.new(&quot;char[]&quot;, bufsiz)</font>
<font color="red">1382.         result = _lib.BIO_read(self._from_ssl, buf, bufsiz)</font>
<font color="red">1383.         if result &lt;= 0:</font>
<font color="red">1384.             self._handle_bio_errors(self._from_ssl, result)</font>
<font color="black">1385. </font>
<font color="red">1386.         return _ffi.buffer(buf, result)[:]</font>
<font color="black">1387. </font>
<font color="green">1388.     def bio_write(self, buf):</font>
<font color="black">1389.         &quot;&quot;&quot;</font>
<font color="black">1390.         When using non-socket connections this function sends &quot;dirty&quot; data that</font>
<font color="black">1391.         would have traveled in on the network.</font>
<font color="black">1392. </font>
<font color="black">1393.         :param buf: The string to put into the memory BIO.</font>
<font color="black">1394.         :return: The number of bytes written</font>
<font color="black">1395.         &quot;&quot;&quot;</font>
<font color="red">1396.         buf = _text_to_bytes_and_warn(&quot;buf&quot;, buf)</font>
<font color="black">1397. </font>
<font color="red">1398.         if self._into_ssl is None:</font>
<font color="red">1399.             raise TypeError(&quot;Connection sock was not None&quot;)</font>
<font color="black">1400. </font>
<font color="red">1401.         result = _lib.BIO_write(self._into_ssl, buf, len(buf))</font>
<font color="red">1402.         if result &lt;= 0:</font>
<font color="red">1403.             self._handle_bio_errors(self._into_ssl, result)</font>
<font color="red">1404.         return result</font>
<font color="black">1405. </font>
<font color="green">1406.     def renegotiate(self):</font>
<font color="black">1407.         &quot;&quot;&quot;</font>
<font color="black">1408.         Renegotiate the session.</font>
<font color="black">1409. </font>
<font color="black">1410.         :return: True if the renegotiation can be started, False otherwise</font>
<font color="black">1411.         :rtype: bool</font>
<font color="black">1412.         &quot;&quot;&quot;</font>
<font color="red">1413.         if not self.renegotiate_pending():</font>
<font color="red">1414.             _openssl_assert(_lib.SSL_renegotiate(self._ssl) == 1)</font>
<font color="red">1415.             return True</font>
<font color="red">1416.         return False</font>
<font color="black">1417. </font>
<font color="green">1418.     def do_handshake(self):</font>
<font color="black">1419.         &quot;&quot;&quot;</font>
<font color="black">1420.         Perform an SSL handshake (usually called after renegotiate() or one of</font>
<font color="black">1421.         set_*_state()). This can raise the same exceptions as send and recv.</font>
<font color="black">1422. </font>
<font color="black">1423.         :return: None.</font>
<font color="black">1424.         &quot;&quot;&quot;</font>
<font color="red">1425.         result = _lib.SSL_do_handshake(self._ssl)</font>
<font color="red">1426.         self._raise_ssl_error(self._ssl, result)</font>
<font color="black">1427. </font>
<font color="green">1428.     def renegotiate_pending(self):</font>
<font color="black">1429.         &quot;&quot;&quot;</font>
<font color="black">1430.         Check if there's a renegotiation in progress, it will return False once</font>
<font color="black">1431.         a renegotiation is finished.</font>
<font color="black">1432. </font>
<font color="black">1433.         :return: Whether there's a renegotiation in progress</font>
<font color="black">1434.         :rtype: bool</font>
<font color="black">1435.         &quot;&quot;&quot;</font>
<font color="red">1436.         return _lib.SSL_renegotiate_pending(self._ssl) == 1</font>
<font color="black">1437. </font>
<font color="green">1438.     def total_renegotiations(self):</font>
<font color="black">1439.         &quot;&quot;&quot;</font>
<font color="black">1440.         Find out the total number of renegotiations.</font>
<font color="black">1441. </font>
<font color="black">1442.         :return: The number of renegotiations.</font>
<font color="black">1443.         :rtype: int</font>
<font color="black">1444.         &quot;&quot;&quot;</font>
<font color="red">1445.         return _lib.SSL_total_renegotiations(self._ssl)</font>
<font color="black">1446. </font>
<font color="green">1447.     def connect(self, addr):</font>
<font color="black">1448.         &quot;&quot;&quot;</font>
<font color="black">1449.         Connect to remote host and set up client-side SSL</font>
<font color="black">1450. </font>
<font color="black">1451.         :param addr: A remote address</font>
<font color="black">1452.         :return: What the socket's connect method returns</font>
<font color="black">1453.         &quot;&quot;&quot;</font>
<font color="red">1454.         _lib.SSL_set_connect_state(self._ssl)</font>
<font color="red">1455.         return self._socket.connect(addr)</font>
<font color="black">1456. </font>
<font color="green">1457.     def connect_ex(self, addr):</font>
<font color="black">1458.         &quot;&quot;&quot;</font>
<font color="black">1459.         Connect to remote host and set up client-side SSL. Note that if the</font>
<font color="black">1460.         socket's connect_ex method doesn't return 0, SSL won't be initialized.</font>
<font color="black">1461. </font>
<font color="black">1462.         :param addr: A remove address</font>
<font color="black">1463.         :return: What the socket's connect_ex method returns</font>
<font color="black">1464.         &quot;&quot;&quot;</font>
<font color="red">1465.         connect_ex = self._socket.connect_ex</font>
<font color="red">1466.         self.set_connect_state()</font>
<font color="red">1467.         return connect_ex(addr)</font>
<font color="black">1468. </font>
<font color="green">1469.     def accept(self):</font>
<font color="black">1470.         &quot;&quot;&quot;</font>
<font color="black">1471.         Accept incoming connection and set up SSL on it</font>
<font color="black">1472. </font>
<font color="black">1473.         :return: A (conn,addr) pair where conn is a Connection and addr is an</font>
<font color="black">1474.                  address</font>
<font color="black">1475.         &quot;&quot;&quot;</font>
<font color="red">1476.         client, addr = self._socket.accept()</font>
<font color="red">1477.         conn = Connection(self._context, client)</font>
<font color="red">1478.         conn.set_accept_state()</font>
<font color="red">1479.         return (conn, addr)</font>
<font color="black">1480. </font>
<font color="green">1481.     def bio_shutdown(self):</font>
<font color="black">1482.         &quot;&quot;&quot;</font>
<font color="black">1483.         When using non-socket connections this function signals end of</font>
<font color="black">1484.         data on the input for this connection.</font>
<font color="black">1485. </font>
<font color="black">1486.         :return: None</font>
<font color="black">1487.         &quot;&quot;&quot;</font>
<font color="red">1488.         if self._from_ssl is None:</font>
<font color="red">1489.             raise TypeError(&quot;Connection sock was not None&quot;)</font>
<font color="black">1490. </font>
<font color="red">1491.         _lib.BIO_set_mem_eof_return(self._into_ssl, 0)</font>
<font color="black">1492. </font>
<font color="green">1493.     def shutdown(self):</font>
<font color="black">1494.         &quot;&quot;&quot;</font>
<font color="black">1495.         Send closure alert</font>
<font color="black">1496. </font>
<font color="black">1497.         :return: True if the shutdown completed successfully (i.e. both sides</font>
<font color="black">1498.                  have sent closure alerts), false otherwise (i.e. you have to</font>
<font color="black">1499.                  wait for a ZeroReturnError on a recv() method call</font>
<font color="black">1500.         &quot;&quot;&quot;</font>
<font color="red">1501.         result = _lib.SSL_shutdown(self._ssl)</font>
<font color="red">1502.         if result &lt; 0:</font>
<font color="red">1503.             self._raise_ssl_error(self._ssl, result)</font>
<font color="red">1504.         elif result &gt; 0:</font>
<font color="red">1505.             return True</font>
<font color="black">1506.         else:</font>
<font color="red">1507.             return False</font>
<font color="black">1508. </font>
<font color="green">1509.     def get_cipher_list(self):</font>
<font color="black">1510.         &quot;&quot;&quot;</font>
<font color="black">1511.         Retrieve the list of ciphers used by the Connection object.</font>
<font color="black">1512. </font>
<font color="black">1513.         :return: A list of native cipher strings.</font>
<font color="black">1514.         &quot;&quot;&quot;</font>
<font color="red">1515.         ciphers = []</font>
<font color="red">1516.         for i in count():</font>
<font color="red">1517.             result = _lib.SSL_get_cipher_list(self._ssl, i)</font>
<font color="red">1518.             if result == _ffi.NULL:</font>
<font color="red">1519.                 break</font>
<font color="red">1520.             ciphers.append(_native(_ffi.string(result)))</font>
<font color="red">1521.         return ciphers</font>
<font color="black">1522. </font>
<font color="green">1523.     def get_client_ca_list(self):</font>
<font color="black">1524.         &quot;&quot;&quot;</font>
<font color="black">1525.         Get CAs whose certificates are suggested for client authentication.</font>
<font color="black">1526. </font>
<font color="black">1527.         :return: If this is a server connection, a list of X509Names</font>
<font color="black">1528.             representing the acceptable CAs as set by</font>
<font color="black">1529.             :py:meth:`OpenSSL.SSL.Context.set_client_ca_list` or</font>
<font color="black">1530.             :py:meth:`OpenSSL.SSL.Context.add_client_ca`.  If this is a client</font>
<font color="black">1531.             connection, the list of such X509Names sent by the server, or an</font>
<font color="black">1532.             empty list if that has not yet happened.</font>
<font color="black">1533.         &quot;&quot;&quot;</font>
<font color="red">1534.         ca_names = _lib.SSL_get_client_CA_list(self._ssl)</font>
<font color="red">1535.         if ca_names == _ffi.NULL:</font>
<font color="black">1536.             # TODO: This is untested.</font>
<font color="red">1537.             return []</font>
<font color="black">1538. </font>
<font color="red">1539.         result = []</font>
<font color="red">1540.         for i in range(_lib.sk_X509_NAME_num(ca_names)):</font>
<font color="red">1541.             name = _lib.sk_X509_NAME_value(ca_names, i)</font>
<font color="red">1542.             copy = _lib.X509_NAME_dup(name)</font>
<font color="red">1543.             _openssl_assert(copy != _ffi.NULL)</font>
<font color="black">1544. </font>
<font color="red">1545.             pyname = X509Name.__new__(X509Name)</font>
<font color="red">1546.             pyname._name = _ffi.gc(copy, _lib.X509_NAME_free)</font>
<font color="red">1547.             result.append(pyname)</font>
<font color="red">1548.         return result</font>
<font color="black">1549. </font>
<font color="green">1550.     def makefile(self):</font>
<font color="black">1551.         &quot;&quot;&quot;</font>
<font color="black">1552.         The makefile() method is not implemented, since there is no dup</font>
<font color="black">1553.         semantics for SSL connections</font>
<font color="black">1554. </font>
<font color="black">1555.         :raise: NotImplementedError</font>
<font color="black">1556.         &quot;&quot;&quot;</font>
<font color="red">1557.         raise NotImplementedError(</font>
<font color="red">1558.             &quot;Cannot make file object of OpenSSL.SSL.Connection&quot;)</font>
<font color="black">1559. </font>
<font color="green">1560.     def get_app_data(self):</font>
<font color="black">1561.         &quot;&quot;&quot;</font>
<font color="black">1562.         Get application data</font>
<font color="black">1563. </font>
<font color="black">1564.         :return: The application data</font>
<font color="black">1565.         &quot;&quot;&quot;</font>
<font color="red">1566.         return self._app_data</font>
<font color="black">1567. </font>
<font color="green">1568.     def set_app_data(self, data):</font>
<font color="black">1569.         &quot;&quot;&quot;</font>
<font color="black">1570.         Set application data</font>
<font color="black">1571. </font>
<font color="black">1572.         :param data - The application data</font>
<font color="black">1573.         :return: None</font>
<font color="black">1574.         &quot;&quot;&quot;</font>
<font color="red">1575.         self._app_data = data</font>
<font color="black">1576. </font>
<font color="green">1577.     def get_shutdown(self):</font>
<font color="black">1578.         &quot;&quot;&quot;</font>
<font color="black">1579.         Get shutdown state</font>
<font color="black">1580. </font>
<font color="black">1581.         :return: The shutdown state, a bitvector of SENT_SHUTDOWN,</font>
<font color="black">1582.             RECEIVED_SHUTDOWN.</font>
<font color="black">1583.         &quot;&quot;&quot;</font>
<font color="red">1584.         return _lib.SSL_get_shutdown(self._ssl)</font>
<font color="black">1585. </font>
<font color="green">1586.     def set_shutdown(self, state):</font>
<font color="black">1587.         &quot;&quot;&quot;</font>
<font color="black">1588.         Set shutdown state</font>
<font color="black">1589. </font>
<font color="black">1590.         :param state - bitvector of SENT_SHUTDOWN, RECEIVED_SHUTDOWN.</font>
<font color="black">1591.         :return: None</font>
<font color="black">1592.         &quot;&quot;&quot;</font>
<font color="red">1593.         if not isinstance(state, integer_types):</font>
<font color="red">1594.             raise TypeError(&quot;state must be an integer&quot;)</font>
<font color="black">1595. </font>
<font color="red">1596.         _lib.SSL_set_shutdown(self._ssl, state)</font>
<font color="black">1597. </font>
<font color="green">1598.     def get_state_string(self):</font>
<font color="black">1599.         &quot;&quot;&quot;</font>
<font color="black">1600.         Retrieve a verbose string detailing the state of the Connection.</font>
<font color="black">1601. </font>
<font color="black">1602.         :return: A string representing the state</font>
<font color="black">1603.         :rtype: bytes</font>
<font color="black">1604.         &quot;&quot;&quot;</font>
<font color="red">1605.         return _ffi.string(_lib.SSL_state_string_long(self._ssl))</font>
<font color="black">1606. </font>
<font color="green">1607.     def server_random(self):</font>
<font color="black">1608.         &quot;&quot;&quot;</font>
<font color="black">1609.         Get a copy of the server hello nonce.</font>
<font color="black">1610. </font>
<font color="black">1611.         :return: A string representing the state</font>
<font color="black">1612.         &quot;&quot;&quot;</font>
<font color="red">1613.         session = _lib.SSL_get_session(self._ssl)</font>
<font color="red">1614.         if session == _ffi.NULL:</font>
<font color="red">1615.             return None</font>
<font color="red">1616.         length = _lib.SSL_get_server_random(self._ssl, _ffi.NULL, 0)</font>
<font color="red">1617.         assert length &gt; 0</font>
<font color="red">1618.         outp = _ffi.new(&quot;unsigned char[]&quot;, length)</font>
<font color="red">1619.         _lib.SSL_get_server_random(self._ssl, outp, length)</font>
<font color="red">1620.         return _ffi.buffer(outp, length)[:]</font>
<font color="black">1621. </font>
<font color="green">1622.     def client_random(self):</font>
<font color="black">1623.         &quot;&quot;&quot;</font>
<font color="black">1624.         Get a copy of the client hello nonce.</font>
<font color="black">1625. </font>
<font color="black">1626.         :return: A string representing the state</font>
<font color="black">1627.         &quot;&quot;&quot;</font>
<font color="red">1628.         session = _lib.SSL_get_session(self._ssl)</font>
<font color="red">1629.         if session == _ffi.NULL:</font>
<font color="red">1630.             return None</font>
<font color="black">1631. </font>
<font color="red">1632.         length = _lib.SSL_get_client_random(self._ssl, _ffi.NULL, 0)</font>
<font color="red">1633.         assert length &gt; 0</font>
<font color="red">1634.         outp = _ffi.new(&quot;unsigned char[]&quot;, length)</font>
<font color="red">1635.         _lib.SSL_get_client_random(self._ssl, outp, length)</font>
<font color="red">1636.         return _ffi.buffer(outp, length)[:]</font>
<font color="black">1637. </font>
<font color="green">1638.     def master_key(self):</font>
<font color="black">1639.         &quot;&quot;&quot;</font>
<font color="black">1640.         Get a copy of the master key.</font>
<font color="black">1641. </font>
<font color="black">1642.         :return: A string representing the state</font>
<font color="black">1643.         &quot;&quot;&quot;</font>
<font color="red">1644.         session = _lib.SSL_get_session(self._ssl)</font>
<font color="red">1645.         if session == _ffi.NULL:</font>
<font color="red">1646.             return None</font>
<font color="black">1647. </font>
<font color="red">1648.         length = _lib.SSL_SESSION_get_master_key(session, _ffi.NULL, 0)</font>
<font color="red">1649.         assert length &gt; 0</font>
<font color="red">1650.         outp = _ffi.new(&quot;unsigned char[]&quot;, length)</font>
<font color="red">1651.         _lib.SSL_SESSION_get_master_key(session, outp, length)</font>
<font color="red">1652.         return _ffi.buffer(outp, length)[:]</font>
<font color="black">1653. </font>
<font color="green">1654.     def sock_shutdown(self, *args, **kwargs):</font>
<font color="black">1655.         &quot;&quot;&quot;</font>
<font color="black">1656.         See shutdown(2)</font>
<font color="black">1657. </font>
<font color="black">1658.         :return: What the socket's shutdown() method returns</font>
<font color="black">1659.         &quot;&quot;&quot;</font>
<font color="red">1660.         return self._socket.shutdown(*args, **kwargs)</font>
<font color="black">1661. </font>
<font color="green">1662.     def get_peer_certificate(self):</font>
<font color="black">1663.         &quot;&quot;&quot;</font>
<font color="black">1664.         Retrieve the other side's certificate (if any)</font>
<font color="black">1665. </font>
<font color="black">1666.         :return: The peer's certificate</font>
<font color="black">1667.         &quot;&quot;&quot;</font>
<font color="red">1668.         cert = _lib.SSL_get_peer_certificate(self._ssl)</font>
<font color="red">1669.         if cert != _ffi.NULL:</font>
<font color="red">1670.             pycert = X509.__new__(X509)</font>
<font color="red">1671.             pycert._x509 = _ffi.gc(cert, _lib.X509_free)</font>
<font color="red">1672.             return pycert</font>
<font color="red">1673.         return None</font>
<font color="black">1674. </font>
<font color="green">1675.     def get_peer_cert_chain(self):</font>
<font color="black">1676.         &quot;&quot;&quot;</font>
<font color="black">1677.         Retrieve the other side's certificate (if any)</font>
<font color="black">1678. </font>
<font color="black">1679.         :return: A list of X509 instances giving the peer's certificate chain,</font>
<font color="black">1680.                  or None if it does not have one.</font>
<font color="black">1681.         &quot;&quot;&quot;</font>
<font color="red">1682.         cert_stack = _lib.SSL_get_peer_cert_chain(self._ssl)</font>
<font color="red">1683.         if cert_stack == _ffi.NULL:</font>
<font color="red">1684.             return None</font>
<font color="black">1685. </font>
<font color="red">1686.         result = []</font>
<font color="red">1687.         for i in range(_lib.sk_X509_num(cert_stack)):</font>
<font color="black">1688.             # TODO could incref instead of dup here</font>
<font color="red">1689.             cert = _lib.X509_dup(_lib.sk_X509_value(cert_stack, i))</font>
<font color="red">1690.             pycert = X509.__new__(X509)</font>
<font color="red">1691.             pycert._x509 = _ffi.gc(cert, _lib.X509_free)</font>
<font color="red">1692.             result.append(pycert)</font>
<font color="red">1693.         return result</font>
<font color="black">1694. </font>
<font color="green">1695.     def want_read(self):</font>
<font color="black">1696.         &quot;&quot;&quot;</font>
<font color="black">1697.         Checks if more data has to be read from the transport layer to complete</font>
<font color="black">1698.         an operation.</font>
<font color="black">1699. </font>
<font color="black">1700.         :return: True iff more data has to be read</font>
<font color="black">1701.         &quot;&quot;&quot;</font>
<font color="red">1702.         return _lib.SSL_want_read(self._ssl)</font>
<font color="black">1703. </font>
<font color="green">1704.     def want_write(self):</font>
<font color="black">1705.         &quot;&quot;&quot;</font>
<font color="black">1706.         Checks if there is data to write to the transport layer to complete an</font>
<font color="black">1707.         operation.</font>
<font color="black">1708. </font>
<font color="black">1709.         :return: True iff there is data to write</font>
<font color="black">1710.         &quot;&quot;&quot;</font>
<font color="red">1711.         return _lib.SSL_want_write(self._ssl)</font>
<font color="black">1712. </font>
<font color="green">1713.     def set_accept_state(self):</font>
<font color="black">1714.         &quot;&quot;&quot;</font>
<font color="black">1715.         Set the connection to work in server mode. The handshake will be</font>
<font color="black">1716.         handled automatically by read/write.</font>
<font color="black">1717. </font>
<font color="black">1718.         :return: None</font>
<font color="black">1719.         &quot;&quot;&quot;</font>
<font color="red">1720.         _lib.SSL_set_accept_state(self._ssl)</font>
<font color="black">1721. </font>
<font color="green">1722.     def set_connect_state(self):</font>
<font color="black">1723.         &quot;&quot;&quot;</font>
<font color="black">1724.         Set the connection to work in client mode. The handshake will be</font>
<font color="black">1725.         handled automatically by read/write.</font>
<font color="black">1726. </font>
<font color="black">1727.         :return: None</font>
<font color="black">1728.         &quot;&quot;&quot;</font>
<font color="red">1729.         _lib.SSL_set_connect_state(self._ssl)</font>
<font color="black">1730. </font>
<font color="green">1731.     def get_session(self):</font>
<font color="black">1732.         &quot;&quot;&quot;</font>
<font color="black">1733.         Returns the Session currently used.</font>
<font color="black">1734. </font>
<font color="black">1735.         @return: An instance of :py:class:`OpenSSL.SSL.Session` or</font>
<font color="black">1736.             :py:obj:`None` if no session exists.</font>
<font color="black">1737.         &quot;&quot;&quot;</font>
<font color="red">1738.         session = _lib.SSL_get1_session(self._ssl)</font>
<font color="red">1739.         if session == _ffi.NULL:</font>
<font color="red">1740.             return None</font>
<font color="black">1741. </font>
<font color="red">1742.         pysession = Session.__new__(Session)</font>
<font color="red">1743.         pysession._session = _ffi.gc(session, _lib.SSL_SESSION_free)</font>
<font color="red">1744.         return pysession</font>
<font color="black">1745. </font>
<font color="green">1746.     def set_session(self, session):</font>
<font color="black">1747.         &quot;&quot;&quot;</font>
<font color="black">1748.         Set the session to be used when the TLS/SSL connection is established.</font>
<font color="black">1749. </font>
<font color="black">1750.         :param session: A Session instance representing the session to use.</font>
<font color="black">1751.         :returns: None</font>
<font color="black">1752.         &quot;&quot;&quot;</font>
<font color="red">1753.         if not isinstance(session, Session):</font>
<font color="red">1754.             raise TypeError(&quot;session must be a Session instance&quot;)</font>
<font color="black">1755. </font>
<font color="red">1756.         result = _lib.SSL_set_session(self._ssl, session._session)</font>
<font color="red">1757.         if not result:</font>
<font color="red">1758.             _raise_current_error()</font>
<font color="black">1759. </font>
<font color="green">1760.     def _get_finished_message(self, function):</font>
<font color="black">1761.         &quot;&quot;&quot;</font>
<font color="black">1762.         Helper to implement :py:meth:`get_finished` and</font>
<font color="black">1763.         :py:meth:`get_peer_finished`.</font>
<font color="black">1764. </font>
<font color="black">1765.         :param function: Either :py:data:`SSL_get_finished`: or</font>
<font color="black">1766.             :py:data:`SSL_get_peer_finished`.</font>
<font color="black">1767. </font>
<font color="black">1768.         :return: :py:data:`None` if the desired message has not yet been</font>
<font color="black">1769.             received, otherwise the contents of the message.</font>
<font color="black">1770.         :rtype: :py:class:`bytes` or :py:class:`NoneType`</font>
<font color="black">1771.         &quot;&quot;&quot;</font>
<font color="black">1772.         # The OpenSSL documentation says nothing about what might happen if the</font>
<font color="black">1773.         # count argument given is zero.  Specifically, it doesn't say whether</font>
<font color="black">1774.         # the output buffer may be NULL in that case or not.  Inspection of the</font>
<font color="black">1775.         # implementation reveals that it calls memcpy() unconditionally.</font>
<font color="black">1776.         # Section 7.1.4, paragraph 1 of the C standard suggests that</font>
<font color="black">1777.         # memcpy(NULL, source, 0) is not guaranteed to produce defined (let</font>
<font color="black">1778.         # alone desirable) behavior (though it probably does on just about</font>
<font color="black">1779.         # every implementation...)</font>
<font color="black">1780.         #</font>
<font color="black">1781.         # Allocate a tiny buffer to pass in (instead of just passing NULL as</font>
<font color="black">1782.         # one might expect) for the initial call so as to be safe against this</font>
<font color="black">1783.         # potentially undefined behavior.</font>
<font color="red">1784.         empty = _ffi.new(&quot;char[]&quot;, 0)</font>
<font color="red">1785.         size = function(self._ssl, empty, 0)</font>
<font color="red">1786.         if size == 0:</font>
<font color="black">1787.             # No Finished message so far.</font>
<font color="red">1788.             return None</font>
<font color="black">1789. </font>
<font color="red">1790.         buf = _ffi.new(&quot;char[]&quot;, size)</font>
<font color="red">1791.         function(self._ssl, buf, size)</font>
<font color="red">1792.         return _ffi.buffer(buf, size)[:]</font>
<font color="black">1793. </font>
<font color="green">1794.     def get_finished(self):</font>
<font color="black">1795.         &quot;&quot;&quot;</font>
<font color="black">1796.         Obtain the latest `handshake finished` message sent to the peer.</font>
<font color="black">1797. </font>
<font color="black">1798.         :return: The contents of the message or :py:obj:`None` if the TLS</font>
<font color="black">1799.             handshake has not yet completed.</font>
<font color="black">1800.         :rtype: :py:class:`bytes` or :py:class:`NoneType`</font>
<font color="black">1801.         &quot;&quot;&quot;</font>
<font color="red">1802.         return self._get_finished_message(_lib.SSL_get_finished)</font>
<font color="black">1803. </font>
<font color="green">1804.     def get_peer_finished(self):</font>
<font color="black">1805.         &quot;&quot;&quot;</font>
<font color="black">1806.         Obtain the latest `handshake finished` message received from the peer.</font>
<font color="black">1807. </font>
<font color="black">1808.         :return: The contents of the message or :py:obj:`None` if the TLS</font>
<font color="black">1809.             handshake has not yet completed.</font>
<font color="black">1810.         :rtype: :py:class:`bytes` or :py:class:`NoneType`</font>
<font color="black">1811.         &quot;&quot;&quot;</font>
<font color="red">1812.         return self._get_finished_message(_lib.SSL_get_peer_finished)</font>
<font color="black">1813. </font>
<font color="green">1814.     def get_cipher_name(self):</font>
<font color="black">1815.         &quot;&quot;&quot;</font>
<font color="black">1816.         Obtain the name of the currently used cipher.</font>
<font color="black">1817. </font>
<font color="black">1818.         :returns: The name of the currently used cipher or :py:obj:`None`</font>
<font color="black">1819.             if no connection has been established.</font>
<font color="black">1820.         :rtype: :py:class:`unicode` or :py:class:`NoneType`</font>
<font color="black">1821.         &quot;&quot;&quot;</font>
<font color="red">1822.         cipher = _lib.SSL_get_current_cipher(self._ssl)</font>
<font color="red">1823.         if cipher == _ffi.NULL:</font>
<font color="red">1824.             return None</font>
<font color="black">1825.         else:</font>
<font color="red">1826.             name = _ffi.string(_lib.SSL_CIPHER_get_name(cipher))</font>
<font color="red">1827.             return name.decode(&quot;utf-8&quot;)</font>
<font color="black">1828. </font>
<font color="green">1829.     def get_cipher_bits(self):</font>
<font color="black">1830.         &quot;&quot;&quot;</font>
<font color="black">1831.         Obtain the number of secret bits of the currently used cipher.</font>
<font color="black">1832. </font>
<font color="black">1833.         :returns: The number of secret bits of the currently used cipher</font>
<font color="black">1834.             or :py:obj:`None` if no connection has been established.</font>
<font color="black">1835.         :rtype: :py:class:`int` or :py:class:`NoneType`</font>
<font color="black">1836.         &quot;&quot;&quot;</font>
<font color="red">1837.         cipher = _lib.SSL_get_current_cipher(self._ssl)</font>
<font color="red">1838.         if cipher == _ffi.NULL:</font>
<font color="red">1839.             return None</font>
<font color="black">1840.         else:</font>
<font color="red">1841.             return _lib.SSL_CIPHER_get_bits(cipher, _ffi.NULL)</font>
<font color="black">1842. </font>
<font color="green">1843.     def get_cipher_version(self):</font>
<font color="black">1844.         &quot;&quot;&quot;</font>
<font color="black">1845.         Obtain the protocol version of the currently used cipher.</font>
<font color="black">1846. </font>
<font color="black">1847.         :returns: The protocol name of the currently used cipher</font>
<font color="black">1848.             or :py:obj:`None` if no connection has been established.</font>
<font color="black">1849.         :rtype: :py:class:`unicode` or :py:class:`NoneType`</font>
<font color="black">1850.         &quot;&quot;&quot;</font>
<font color="red">1851.         cipher = _lib.SSL_get_current_cipher(self._ssl)</font>
<font color="red">1852.         if cipher == _ffi.NULL:</font>
<font color="red">1853.             return None</font>
<font color="black">1854.         else:</font>
<font color="red">1855.             version = _ffi.string(_lib.SSL_CIPHER_get_version(cipher))</font>
<font color="red">1856.             return version.decode(&quot;utf-8&quot;)</font>
<font color="black">1857. </font>
<font color="green">1858.     def get_protocol_version_name(self):</font>
<font color="black">1859.         &quot;&quot;&quot;</font>
<font color="black">1860.         Obtain the protocol version of the current connection.</font>
<font color="black">1861. </font>
<font color="black">1862.         :returns: The TLS version of the current connection, for example</font>
<font color="black">1863.             the value for TLS 1.2 would be ``TLSv1.2``or ``Unknown``</font>
<font color="black">1864.             for connections that were not successfully established.</font>
<font color="black">1865.         :rtype: :py:class:`unicode`</font>
<font color="black">1866.         &quot;&quot;&quot;</font>
<font color="red">1867.         version = _ffi.string(_lib.SSL_get_version(self._ssl))</font>
<font color="red">1868.         return version.decode(&quot;utf-8&quot;)</font>
<font color="black">1869. </font>
<font color="green">1870.     def get_protocol_version(self):</font>
<font color="black">1871.         &quot;&quot;&quot;</font>
<font color="black">1872.         Obtain the protocol version of the current connection.</font>
<font color="black">1873. </font>
<font color="black">1874.         :returns: The TLS version of the current connection, for example</font>
<font color="black">1875.             the value for TLS 1 would be 0x769.</font>
<font color="black">1876.         :rtype: :py:class:`int`</font>
<font color="black">1877.         &quot;&quot;&quot;</font>
<font color="red">1878.         version = _lib.SSL_version(self._ssl)</font>
<font color="red">1879.         return version</font>
<font color="black">1880. </font>
<font color="green">1881.     @_requires_npn</font>
<font color="black">1882.     def get_next_proto_negotiated(self):</font>
<font color="black">1883.         &quot;&quot;&quot;</font>
<font color="black">1884.         Get the protocol that was negotiated by NPN.</font>
<font color="black">1885.         &quot;&quot;&quot;</font>
<font color="red">1886.         data = _ffi.new(&quot;unsigned char **&quot;)</font>
<font color="red">1887.         data_len = _ffi.new(&quot;unsigned int *&quot;)</font>
<font color="black">1888. </font>
<font color="red">1889.         _lib.SSL_get0_next_proto_negotiated(self._ssl, data, data_len)</font>
<font color="black">1890. </font>
<font color="red">1891.         return _ffi.buffer(data[0], data_len[0])[:]</font>
<font color="black">1892. </font>
<font color="green">1893.     @_requires_alpn</font>
<font color="black">1894.     def set_alpn_protos(self, protos):</font>
<font color="black">1895.         &quot;&quot;&quot;</font>
<font color="black">1896.         Specify the client's ALPN protocol list.</font>
<font color="black">1897. </font>
<font color="black">1898.         These protocols are offered to the server during protocol negotiation.</font>
<font color="black">1899. </font>
<font color="black">1900.         :param protos: A list of the protocols to be offered to the server.</font>
<font color="black">1901.             This list should be a Python list of bytestrings representing the</font>
<font color="black">1902.             protocols to offer, e.g. ``[b'http/1.1', b'spdy/2']``.</font>
<font color="black">1903.         &quot;&quot;&quot;</font>
<font color="black">1904.         # Take the list of protocols and join them together, prefixing them</font>
<font color="black">1905.         # with their lengths.</font>
<font color="red">1906.         protostr = b''.join(</font>
<font color="red">1907.             chain.from_iterable((int2byte(len(p)), p) for p in protos)</font>
<font color="black">1908.         )</font>
<font color="black">1909. </font>
<font color="black">1910.         # Build a C string from the list. We don't need to save this off</font>
<font color="black">1911.         # because OpenSSL immediately copies the data out.</font>
<font color="red">1912.         input_str = _ffi.new(&quot;unsigned char[]&quot;, protostr)</font>
<font color="red">1913.         input_str_len = _ffi.cast(&quot;unsigned&quot;, len(protostr))</font>
<font color="red">1914.         _lib.SSL_set_alpn_protos(self._ssl, input_str, input_str_len)</font>
<font color="black">1915. </font>
<font color="green">1916.     @_requires_alpn</font>
<font color="black">1917.     def get_alpn_proto_negotiated(self):</font>
<font color="black">1918.         &quot;&quot;&quot;</font>
<font color="black">1919.         Get the protocol that was negotiated by ALPN.</font>
<font color="black">1920.         &quot;&quot;&quot;</font>
<font color="red">1921.         data = _ffi.new(&quot;unsigned char **&quot;)</font>
<font color="red">1922.         data_len = _ffi.new(&quot;unsigned int *&quot;)</font>
<font color="black">1923. </font>
<font color="red">1924.         _lib.SSL_get0_alpn_selected(self._ssl, data, data_len)</font>
<font color="black">1925. </font>
<font color="red">1926.         if not data_len:</font>
<font color="red">1927.             return b''</font>
<font color="black">1928. </font>
<font color="red">1929.         return _ffi.buffer(data[0], data_len[0])[:]</font>
<font color="black">1930. </font>
<font color="black">1931. </font>
<font color="green">1932. ConnectionType = Connection</font>
<font color="black">1933. </font>
<font color="black">1934. # This is similar to the initialization calls at the end of OpenSSL/crypto.py</font>
<font color="black">1935. # but is exercised mostly by the Context initializer.</font>
<font color="green">1936. _lib.SSL_library_init()</font>
</pre>

