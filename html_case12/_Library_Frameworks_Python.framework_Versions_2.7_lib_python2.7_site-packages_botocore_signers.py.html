source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/signers.py</b><br>


file stats: <b>259 lines, 103 executed: 39.8% covered</b>
<pre>
<font color="black">   1. # Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="green">  13. import datetime</font>
<font color="green">  14. import weakref</font>
<font color="green">  15. import json</font>
<font color="green">  16. import base64</font>
<font color="black">  17. </font>
<font color="green">  18. import botocore</font>
<font color="green">  19. import botocore.auth</font>
<font color="green">  20. from botocore.compat import six, OrderedDict</font>
<font color="green">  21. from botocore.awsrequest import create_request_object, prepare_request_dict</font>
<font color="green">  22. from botocore.exceptions import UnknownSignatureVersionError</font>
<font color="green">  23. from botocore.exceptions import UnknownClientMethodError</font>
<font color="green">  24. from botocore.exceptions import UnsupportedSignatureVersionError</font>
<font color="green">  25. from botocore.utils import fix_s3_host, datetime2timestamp</font>
<font color="black">  26. </font>
<font color="black">  27. </font>
<font color="green">  28. class RequestSigner(object):</font>
<font color="black">  29.     &quot;&quot;&quot;</font>
<font color="black">  30.     An object to sign requests before they go out over the wire using</font>
<font color="black">  31.     one of the authentication mechanisms defined in ``auth.py``. This</font>
<font color="black">  32.     class fires two events scoped to a service and operation name:</font>
<font color="black">  33. </font>
<font color="black">  34.     * choose-signer: Allows overriding the auth signer name.</font>
<font color="black">  35.     * before-sign: Allows mutating the request before signing.</font>
<font color="black">  36. </font>
<font color="black">  37.     Together these events allow for customization of the request</font>
<font color="black">  38.     signing pipeline, including overrides, request path manipulation,</font>
<font color="black">  39.     and disabling signing per operation.</font>
<font color="black">  40. </font>
<font color="black">  41.     :type service_name: string</font>
<font color="black">  42.     :param service_name: Name of the service, e.g. ``S3``</font>
<font color="black">  43. </font>
<font color="black">  44.     :type region_name: string</font>
<font color="black">  45.     :param region_name: Name of the service region, e.g. ``us-east-1``</font>
<font color="black">  46. </font>
<font color="black">  47.     :type signing_name: string</font>
<font color="black">  48.     :param signing_name: Service signing name. This is usually the</font>
<font color="black">  49.                          same as the service name, but can differ. E.g.</font>
<font color="black">  50.                          ``emr`` vs. ``elasticmapreduce``.</font>
<font color="black">  51. </font>
<font color="black">  52.     :type signature_version: string</font>
<font color="black">  53.     :param signature_version: Signature name like ``v4``.</font>
<font color="black">  54. </font>
<font color="black">  55.     :type credentials: :py:class:`~botocore.credentials.Credentials`</font>
<font color="black">  56.     :param credentials: User credentials with which to sign requests.</font>
<font color="black">  57. </font>
<font color="black">  58.     :type event_emitter: :py:class:`~botocore.hooks.BaseEventHooks`</font>
<font color="black">  59.     :param event_emitter: Extension mechanism to fire events.</font>
<font color="black">  60. </font>
<font color="green">  61.     &quot;&quot;&quot;</font>
<font color="green">  62.     def __init__(self, service_name, region_name, signing_name,</font>
<font color="black">  63.                  signature_version, credentials, event_emitter):</font>
<font color="green">  64.         self._service_name = service_name</font>
<font color="green">  65.         self._region_name = region_name</font>
<font color="green">  66.         self._signing_name = signing_name</font>
<font color="green">  67.         self._signature_version = signature_version</font>
<font color="green">  68.         self._credentials = credentials</font>
<font color="black">  69. </font>
<font color="black">  70.         # We need weakref to prevent leaking memory in Python 2.6 on Linux 2.6</font>
<font color="green">  71.         self._event_emitter = weakref.proxy(event_emitter)</font>
<font color="black">  72. </font>
<font color="green">  73.     @property</font>
<font color="black">  74.     def region_name(self):</font>
<font color="red">  75.         return self._region_name</font>
<font color="black">  76. </font>
<font color="green">  77.     @property</font>
<font color="black">  78.     def signature_version(self):</font>
<font color="red">  79.         return self._signature_version</font>
<font color="black">  80. </font>
<font color="green">  81.     @property</font>
<font color="black">  82.     def signing_name(self):</font>
<font color="red">  83.         return self._signing_name</font>
<font color="black">  84. </font>
<font color="green">  85.     def handler(self, operation_name=None, request=None, **kwargs):</font>
<font color="black">  86.         # This is typically hooked up to the &quot;request-created&quot; event</font>
<font color="black">  87.         # from a client's event emitter.  When a new request is created</font>
<font color="black">  88.         # this method is invoked to sign the request.</font>
<font color="black">  89.         # Don't call this method directly.</font>
<font color="green">  90.         return self.sign(operation_name, request)</font>
<font color="black">  91. </font>
<font color="green">  92.     def sign(self, operation_name, request, region_name=None,</font>
<font color="green">  93.              signing_type='standard', expires_in=None, signing_name=None):</font>
<font color="black">  94.         &quot;&quot;&quot;Sign a request before it goes out over the wire.</font>
<font color="black">  95. </font>
<font color="black">  96.         :type operation_name: string</font>
<font color="black">  97.         :param operation_name: The name of the current operation, e.g.</font>
<font color="black">  98.                                ``ListBuckets``.</font>
<font color="black">  99.         :type request: AWSRequest</font>
<font color="black"> 100.         :param request: The request object to be sent over the wire.</font>
<font color="black"> 101. </font>
<font color="black"> 102.         :type region_name: str</font>
<font color="black"> 103.         :param region_name: The region to sign the request for.</font>
<font color="black"> 104. </font>
<font color="black"> 105.         :type signing_type: str</font>
<font color="black"> 106.         :param signing_type: The type of signing to perform. This can be one of</font>
<font color="black"> 107.             three possible values:</font>
<font color="black"> 108. </font>
<font color="black"> 109.             * 'standard'     - This should be used for most requests.</font>
<font color="black"> 110.             * 'presign-url'  - This should be used when pre-signing a request.</font>
<font color="black"> 111.             * 'presign-post' - This should be used when pre-signing an S3 post.</font>
<font color="black"> 112. </font>
<font color="black"> 113.         :type expires_in: int</font>
<font color="black"> 114.         :param expires_in: The number of seconds the presigned url is valid</font>
<font color="black"> 115.             for. This parameter is only valid for signing type 'presign-url'.</font>
<font color="black"> 116. </font>
<font color="black"> 117.         :type signing_name: str</font>
<font color="black"> 118.         :param signing_name: The name to use for the service when signing.</font>
<font color="black"> 119.         &quot;&quot;&quot;</font>
<font color="green"> 120.         if region_name is None:</font>
<font color="green"> 121.             region_name = self._region_name</font>
<font color="black"> 122. </font>
<font color="green"> 123.         if signing_name is None:</font>
<font color="green"> 124.             signing_name = self._signing_name</font>
<font color="black"> 125. </font>
<font color="green"> 126.         signature_version = self._choose_signer(</font>
<font color="green"> 127.             operation_name, signing_type, request.context)</font>
<font color="black"> 128. </font>
<font color="black"> 129.         # Allow mutating request before signing</font>
<font color="green"> 130.         self._event_emitter.emit(</font>
<font color="green"> 131.             'before-sign.{0}.{1}'.format(self._service_name, operation_name),</font>
<font color="green"> 132.             request=request, signing_name=signing_name,</font>
<font color="green"> 133.             region_name=self._region_name,</font>
<font color="green"> 134.             signature_version=signature_version, request_signer=self,</font>
<font color="green"> 135.             operation_name=operation_name</font>
<font color="black"> 136.         )</font>
<font color="black"> 137. </font>
<font color="green"> 138.         if signature_version != botocore.UNSIGNED:</font>
<font color="green"> 139.             kwargs = {</font>
<font color="green"> 140.                 'signing_name': signing_name,</font>
<font color="green"> 141.                 'region_name': region_name,</font>
<font color="green"> 142.                 'signature_version': signature_version</font>
<font color="black"> 143.             }</font>
<font color="green"> 144.             if expires_in is not None:</font>
<font color="red"> 145.                 kwargs['expires'] = expires_in</font>
<font color="black"> 146. </font>
<font color="green"> 147.             try:</font>
<font color="green"> 148.                 auth = self.get_auth_instance(**kwargs)</font>
<font color="red"> 149.             except UnknownSignatureVersionError as e:</font>
<font color="red"> 150.                 if signing_type != 'standard':</font>
<font color="red"> 151.                     raise UnsupportedSignatureVersionError(</font>
<font color="red"> 152.                         signature_version=signature_version)</font>
<font color="black"> 153.                 else:</font>
<font color="red"> 154.                     raise e</font>
<font color="black"> 155. </font>
<font color="green"> 156.             auth.add_auth(request)</font>
<font color="black"> 157. </font>
<font color="green"> 158.     def _choose_signer(self, operation_name, signing_type, context):</font>
<font color="black"> 159.         &quot;&quot;&quot;</font>
<font color="black"> 160.         Allow setting the signature version via the choose-signer event.</font>
<font color="black"> 161.         A value of `botocore.UNSIGNED` means no signing will be performed.</font>
<font color="black"> 162. </font>
<font color="black"> 163.         :param operation_name: The operation to sign.</font>
<font color="black"> 164.         :param signing_type: The type of signing that the signer is to be used</font>
<font color="black"> 165.             for.</font>
<font color="black"> 166.         :return: The signature version to sign with.</font>
<font color="black"> 167.         &quot;&quot;&quot;</font>
<font color="green"> 168.         signing_type_suffix_map = {</font>
<font color="green"> 169.             'presign-post': '-presign-post',</font>
<font color="green"> 170.             'presign-url': '-query'</font>
<font color="black"> 171.         }</font>
<font color="green"> 172.         suffix = signing_type_suffix_map.get(signing_type, '')</font>
<font color="black"> 173. </font>
<font color="green"> 174.         signature_version = self._signature_version</font>
<font color="green"> 175.         if signature_version is not botocore.UNSIGNED and not \</font>
<font color="green"> 176.                 signature_version.endswith(suffix):</font>
<font color="red"> 177.             signature_version += suffix</font>
<font color="black"> 178. </font>
<font color="green"> 179.         handler, response = self._event_emitter.emit_until_response(</font>
<font color="green"> 180.             'choose-signer.{0}.{1}'.format(self._service_name, operation_name),</font>
<font color="green"> 181.             signing_name=self._signing_name, region_name=self._region_name,</font>
<font color="green"> 182.             signature_version=signature_version, context=context)</font>
<font color="black"> 183. </font>
<font color="green"> 184.         if response is not None:</font>
<font color="red"> 185.             signature_version = response</font>
<font color="black"> 186.             # The suffix needs to be checked again in case we get an improper</font>
<font color="black"> 187.             # signature version from choose-signer.</font>
<font color="red"> 188.             if signature_version is not botocore.UNSIGNED and not \</font>
<font color="red"> 189.                     signature_version.endswith(suffix):</font>
<font color="red"> 190.                 signature_version += suffix</font>
<font color="black"> 191. </font>
<font color="green"> 192.         return signature_version</font>
<font color="black"> 193. </font>
<font color="black"> 194.     def get_auth_instance(self, signing_name, region_name,</font>
<font color="green"> 195.                           signature_version=None, **kwargs):</font>
<font color="black"> 196.         &quot;&quot;&quot;</font>
<font color="black"> 197.         Get an auth instance which can be used to sign a request</font>
<font color="black"> 198.         using the given signature version.</font>
<font color="black"> 199. </font>
<font color="black"> 200.         :type signing_name: string</font>
<font color="black"> 201.         :param signing_name: Service signing name. This is usually the</font>
<font color="black"> 202.                              same as the service name, but can differ. E.g.</font>
<font color="black"> 203.                              ``emr`` vs. ``elasticmapreduce``.</font>
<font color="black"> 204. </font>
<font color="black"> 205.         :type region_name: string</font>
<font color="black"> 206.         :param region_name: Name of the service region, e.g. ``us-east-1``</font>
<font color="black"> 207. </font>
<font color="black"> 208.         :type signature_version: string</font>
<font color="black"> 209.         :param signature_version: Signature name like ``v4``.</font>
<font color="black"> 210. </font>
<font color="black"> 211.         :rtype: :py:class:`~botocore.auth.BaseSigner`</font>
<font color="black"> 212.         :return: Auth instance to sign a request.</font>
<font color="black"> 213.         &quot;&quot;&quot;</font>
<font color="green"> 214.         if signature_version is None:</font>
<font color="red"> 215.             signature_version = self._signature_version</font>
<font color="black"> 216. </font>
<font color="green"> 217.         cls = botocore.auth.AUTH_TYPE_MAPS.get(signature_version)</font>
<font color="green"> 218.         if cls is None:</font>
<font color="red"> 219.             raise UnknownSignatureVersionError(</font>
<font color="red"> 220.                 signature_version=signature_version)</font>
<font color="black"> 221.         # If there's no credentials provided (i.e credentials is None),</font>
<font color="black"> 222.         # then we'll pass a value of &quot;None&quot; over to the auth classes,</font>
<font color="black"> 223.         # which already handle the cases where no credentials have</font>
<font color="black"> 224.         # been provided.</font>
<font color="green"> 225.         frozen_credentials = None</font>
<font color="green"> 226.         if self._credentials is not None:</font>
<font color="green"> 227.             frozen_credentials = self._credentials.get_frozen_credentials()</font>
<font color="green"> 228.         kwargs['credentials'] = frozen_credentials</font>
<font color="green"> 229.         if cls.REQUIRES_REGION:</font>
<font color="green"> 230.             if self._region_name is None:</font>
<font color="red"> 231.                 raise botocore.exceptions.NoRegionError()</font>
<font color="green"> 232.             kwargs['region_name'] = region_name</font>
<font color="green"> 233.             kwargs['service_name'] = signing_name</font>
<font color="green"> 234.         auth = cls(**kwargs)</font>
<font color="green"> 235.         return auth</font>
<font color="black"> 236. </font>
<font color="black"> 237.     # Alias get_auth for backwards compatibility.</font>
<font color="green"> 238.     get_auth = get_auth_instance</font>
<font color="black"> 239. </font>
<font color="black"> 240.     def generate_presigned_url(self, request_dict, operation_name,</font>
<font color="green"> 241.                                expires_in=3600, region_name=None,</font>
<font color="green"> 242.                                signing_name=None):</font>
<font color="black"> 243.         &quot;&quot;&quot;Generates a presigned url</font>
<font color="black"> 244. </font>
<font color="black"> 245.         :type request_dict: dict</font>
<font color="black"> 246.         :param request_dict: The prepared request dictionary returned by</font>
<font color="black"> 247.             ``botocore.awsrequest.prepare_request_dict()``</font>
<font color="black"> 248. </font>
<font color="black"> 249.         :type operation_name: str</font>
<font color="black"> 250.         :param operation_name: The operation being signed.</font>
<font color="black"> 251. </font>
<font color="black"> 252.         :type expires_in: int</font>
<font color="black"> 253.         :param expires_in: The number of seconds the presigned url is valid</font>
<font color="black"> 254.             for. By default it expires in an hour (3600 seconds)</font>
<font color="black"> 255. </font>
<font color="black"> 256.         :type region_name: string</font>
<font color="black"> 257.         :param region_name: The region name to sign the presigned url.</font>
<font color="black"> 258. </font>
<font color="black"> 259.         :type signing_name: str</font>
<font color="black"> 260.         :param signing_name: The name to use for the service when signing.</font>
<font color="black"> 261. </font>
<font color="black"> 262.         :returns: The presigned url</font>
<font color="black"> 263.         &quot;&quot;&quot;</font>
<font color="red"> 264.         request = create_request_object(request_dict)</font>
<font color="red"> 265.         self.sign(operation_name, request, region_name,</font>
<font color="red"> 266.                   'presign-url', expires_in, signing_name)</font>
<font color="black"> 267. </font>
<font color="red"> 268.         request.prepare()</font>
<font color="red"> 269.         return request.url</font>
<font color="black"> 270. </font>
<font color="black"> 271. </font>
<font color="green"> 272. class CloudFrontSigner(object):</font>
<font color="black"> 273.     '''A signer to create a signed CloudFront URL.</font>
<font color="black"> 274. </font>
<font color="black"> 275.     First you create a cloudfront signer based on a normalized RSA signer::</font>
<font color="black"> 276. </font>
<font color="black"> 277.         import rsa</font>
<font color="black"> 278.         def rsa_signer(message):</font>
<font color="black"> 279.             private_key = open('private_key.pem', 'r').read()</font>
<font color="black"> 280.             return rsa.sign(</font>
<font color="black"> 281.                 message,</font>
<font color="black"> 282.                 rsa.PrivateKey.load_pkcs1(private_key.encode('utf8')),</font>
<font color="black"> 283.                 'SHA-1')  # CloudFront requires SHA-1 hash</font>
<font color="black"> 284.         cf_signer = CloudFrontSigner(key_id, rsa_signer)</font>
<font color="black"> 285. </font>
<font color="black"> 286.     To sign with a canned policy::</font>
<font color="black"> 287. </font>
<font color="black"> 288.         signed_url = cf_signer.generate_signed_url(</font>
<font color="black"> 289.             url, date_less_than=datetime(2015, 12, 1))</font>
<font color="black"> 290. </font>
<font color="black"> 291.     To sign with a custom policy::</font>
<font color="black"> 292. </font>
<font color="black"> 293.         signed_url = cf_signer.generate_signed_url(url, policy=my_policy)</font>
<font color="green"> 294.     '''</font>
<font color="black"> 295. </font>
<font color="green"> 296.     def __init__(self, key_id, rsa_signer):</font>
<font color="black"> 297.         &quot;&quot;&quot;Create a CloudFrontSigner.</font>
<font color="black"> 298. </font>
<font color="black"> 299.         :type key_id: str</font>
<font color="black"> 300.         :param key_id: The CloudFront Key Pair ID</font>
<font color="black"> 301. </font>
<font color="black"> 302.         :type rsa_signer: callable</font>
<font color="black"> 303.         :param rsa_signer: An RSA signer.</font>
<font color="black"> 304.                Its only input parameter will be the message to be signed,</font>
<font color="black"> 305.                and its output will be the signed content as a binary string.</font>
<font color="black"> 306.                The hash algorithm needed by CloudFront is SHA-1.</font>
<font color="black"> 307.         &quot;&quot;&quot;</font>
<font color="red"> 308.         self.key_id = key_id</font>
<font color="red"> 309.         self.rsa_signer = rsa_signer</font>
<font color="black"> 310. </font>
<font color="green"> 311.     def generate_presigned_url(self, url, date_less_than=None, policy=None):</font>
<font color="black"> 312.         &quot;&quot;&quot;Creates a signed CloudFront URL based on given parameters.</font>
<font color="black"> 313. </font>
<font color="black"> 314.         :type url: str</font>
<font color="black"> 315.         :param url: The URL of the protected object</font>
<font color="black"> 316. </font>
<font color="black"> 317.         :type date_less_than: datetime</font>
<font color="black"> 318.         :param date_less_than: The URL will expire after that date and time</font>
<font color="black"> 319. </font>
<font color="black"> 320.         :type policy: str</font>
<font color="black"> 321.         :param policy: The custom policy, possibly built by self.build_policy()</font>
<font color="black"> 322. </font>
<font color="black"> 323.         :rtype: str</font>
<font color="black"> 324.         :return: The signed URL.</font>
<font color="black"> 325.         &quot;&quot;&quot;</font>
<font color="red"> 326.         if (date_less_than is not None and policy is not None or</font>
<font color="red"> 327.                 date_less_than is None and policy is None):</font>
<font color="red"> 328.             e = 'Need to provide either date_less_than or policy, but not both'</font>
<font color="red"> 329.             raise ValueError(e)</font>
<font color="red"> 330.         if date_less_than is not None:</font>
<font color="black"> 331.             # We still need to build a canned policy for signing purpose</font>
<font color="red"> 332.             policy = self.build_policy(url, date_less_than)</font>
<font color="red"> 333.         if isinstance(policy, six.text_type):</font>
<font color="red"> 334.             policy = policy.encode('utf8')</font>
<font color="red"> 335.         if date_less_than is not None:</font>
<font color="red"> 336.             params = ['Expires=%s' % int(datetime2timestamp(date_less_than))]</font>
<font color="black"> 337.         else:</font>
<font color="red"> 338.             params = ['Policy=%s' % self._url_b64encode(policy).decode('utf8')]</font>
<font color="red"> 339.         signature = self.rsa_signer(policy)</font>
<font color="red"> 340.         params.extend([</font>
<font color="red"> 341.             'Signature=%s' % self._url_b64encode(signature).decode('utf8'),</font>
<font color="red"> 342.             'Key-Pair-Id=%s' % self.key_id,</font>
<font color="black"> 343.             ])</font>
<font color="red"> 344.         return self._build_url(url, params)</font>
<font color="black"> 345. </font>
<font color="green"> 346.     def _build_url(self, base_url, extra_params):</font>
<font color="red"> 347.         separator = '&amp;' if '?' in base_url else '?'</font>
<font color="red"> 348.         return base_url + separator + '&amp;'.join(extra_params)</font>
<font color="black"> 349. </font>
<font color="black"> 350.     def build_policy(self, resource, date_less_than,</font>
<font color="green"> 351.                      date_greater_than=None, ip_address=None):</font>
<font color="black"> 352.         &quot;&quot;&quot;A helper to build policy.</font>
<font color="black"> 353. </font>
<font color="black"> 354.         :type resource: str</font>
<font color="black"> 355.         :param resource: The URL or the stream filename of the protected object</font>
<font color="black"> 356. </font>
<font color="black"> 357.         :type date_less_than: datetime</font>
<font color="black"> 358.         :param date_less_than: The URL will expire after the time has passed</font>
<font color="black"> 359. </font>
<font color="black"> 360.         :type date_greater_than: datetime</font>
<font color="black"> 361.         :param date_greater_than: The URL will not be valid until this time</font>
<font color="black"> 362. </font>
<font color="black"> 363.         :type ip_address: str</font>
<font color="black"> 364.         :param ip_address: Use 'x.x.x.x' for an IP, or 'x.x.x.x/x' for a subnet</font>
<font color="black"> 365. </font>
<font color="black"> 366.         :rtype: str</font>
<font color="black"> 367.         :return: The policy in a compact string.</font>
<font color="black"> 368.         &quot;&quot;&quot;</font>
<font color="black"> 369.         # Note:</font>
<font color="black"> 370.         # 1. Order in canned policy is significant. Special care has been taken</font>
<font color="black"> 371.         #    to ensure the output will match the order defined by the document.</font>
<font color="black"> 372.         #    There is also a test case to ensure that order.</font>
<font color="black"> 373.         #    SEE: http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-canned-policy.html#private-content-canned-policy-creating-policy-statement</font>
<font color="black"> 374.         # 2. Albeit the order in custom policy is not required by CloudFront,</font>
<font color="black"> 375.         #    we still use OrderedDict internally to ensure the result is stable</font>
<font color="black"> 376.         #    and also matches canned policy requirement.</font>
<font color="black"> 377.         #    SEE: http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html</font>
<font color="red"> 378.         moment = int(datetime2timestamp(date_less_than))</font>
<font color="red"> 379.         condition = OrderedDict({&quot;DateLessThan&quot;: {&quot;AWS:EpochTime&quot;: moment}})</font>
<font color="red"> 380.         if ip_address:</font>
<font color="red"> 381.             if '/' not in ip_address:</font>
<font color="red"> 382.                 ip_address += '/32'</font>
<font color="red"> 383.             condition[&quot;IpAddress&quot;] = {&quot;AWS:SourceIp&quot;: ip_address}</font>
<font color="red"> 384.         if date_greater_than:</font>
<font color="red"> 385.             moment = int(datetime2timestamp(date_greater_than))</font>
<font color="red"> 386.             condition[&quot;DateGreaterThan&quot;] = {&quot;AWS:EpochTime&quot;: moment}</font>
<font color="red"> 387.         ordered_payload = [('Resource', resource), ('Condition', condition)]</font>
<font color="red"> 388.         custom_policy = {&quot;Statement&quot;: [OrderedDict(ordered_payload)]}</font>
<font color="red"> 389.         return json.dumps(custom_policy, separators=(',', ':'))</font>
<font color="black"> 390. </font>
<font color="green"> 391.     def _url_b64encode(self, data):</font>
<font color="black"> 392.         # Required by CloudFront. See also:</font>
<font color="black"> 393.         # http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-linux-openssl.html</font>
<font color="red"> 394.         return base64.b64encode(</font>
<font color="red"> 395.             data).replace(b'+', b'-').replace(b'=', b'_').replace(b'/', b'~')</font>
<font color="black"> 396. </font>
<font color="black"> 397. </font>
<font color="green"> 398. def add_generate_db_auth_token(class_attributes, **kwargs):</font>
<font color="red"> 399.     class_attributes['generate_db_auth_token'] = generate_db_auth_token</font>
<font color="black"> 400. </font>
<font color="black"> 401. </font>
<font color="green"> 402. def generate_db_auth_token(self, DBHostname, Port, DBUsername, Region=None):</font>
<font color="black"> 403.     &quot;&quot;&quot;Generates an auth token used to connect to a db with IAM credentials.</font>
<font color="black"> 404. </font>
<font color="black"> 405.     :type DBHostname: str</font>
<font color="black"> 406.     :param DBHostname: The hostname of the database to connect to.</font>
<font color="black"> 407. </font>
<font color="black"> 408.     :type Port: int</font>
<font color="black"> 409.     :param Port: The port number the database is listening on.</font>
<font color="black"> 410. </font>
<font color="black"> 411.     :type DBUsername: str</font>
<font color="black"> 412.     :param DBUsername: The username to log in as.</font>
<font color="black"> 413. </font>
<font color="black"> 414.     :type Region: str</font>
<font color="black"> 415.     :param Region: The region the database is in. If None, the client</font>
<font color="black"> 416.         region will be used.</font>
<font color="black"> 417. </font>
<font color="black"> 418.     :return: A presigned url which can be used as an auth token.</font>
<font color="black"> 419.     &quot;&quot;&quot;</font>
<font color="red"> 420.     region = Region</font>
<font color="red"> 421.     if region is None:</font>
<font color="red"> 422.         region = self.meta.region_name</font>
<font color="black"> 423. </font>
<font color="red"> 424.     params = {</font>
<font color="red"> 425.         'Action': 'connect',</font>
<font color="red"> 426.         'DBUser': DBUsername,</font>
<font color="black"> 427.     }</font>
<font color="black"> 428. </font>
<font color="red"> 429.     request_dict = {</font>
<font color="red"> 430.         'url_path': '/',</font>
<font color="red"> 431.         'query_string': '',</font>
<font color="red"> 432.         'headers': {},</font>
<font color="red"> 433.         'body': params,</font>
<font color="red"> 434.         'method': 'GET'</font>
<font color="black"> 435.     }</font>
<font color="black"> 436. </font>
<font color="black"> 437.     # RDS requires that the scheme not be set when sent over. This can cause</font>
<font color="black"> 438.     # issues when signing because the Python url parsing libraries follow</font>
<font color="black"> 439.     # RFC 1808 closely, which states that a netloc must be introduced by `//`.</font>
<font color="black"> 440.     # Otherwise the url is presumed to be relative, and thus the whole</font>
<font color="black"> 441.     # netloc would be treated as a path component. To work around this we</font>
<font color="black"> 442.     # introduce https here and remove it once we're done processing it.</font>
<font color="red"> 443.     scheme = 'https://'</font>
<font color="red"> 444.     endpoint_url = '%s%s:%s' % (scheme, DBHostname, Port)</font>
<font color="red"> 445.     prepare_request_dict(request_dict, endpoint_url)</font>
<font color="red"> 446.     presigned_url = self._request_signer.generate_presigned_url(</font>
<font color="red"> 447.         operation_name='connect', request_dict=request_dict,</font>
<font color="red"> 448.         region_name=region, expires_in=900, signing_name='rds-db'</font>
<font color="black"> 449.     )</font>
<font color="red"> 450.     return presigned_url[len(scheme):]</font>
<font color="black"> 451. </font>
<font color="black"> 452. </font>
<font color="green"> 453. class S3PostPresigner(object):</font>
<font color="green"> 454.     def __init__(self, request_signer):</font>
<font color="red"> 455.         self._request_signer = request_signer</font>
<font color="black"> 456. </font>
<font color="green"> 457.     def generate_presigned_post(self, request_dict, fields=None,</font>
<font color="green"> 458.                                 conditions=None, expires_in=3600,</font>
<font color="green"> 459.                                 region_name=None):</font>
<font color="black"> 460.         &quot;&quot;&quot;Generates the url and the form fields used for a presigned s3 post</font>
<font color="black"> 461. </font>
<font color="black"> 462.         :type request_dict: dict</font>
<font color="black"> 463.         :param request_dict: The prepared request dictionary returned by</font>
<font color="black"> 464.             ``botocore.awsrequest.prepare_request_dict()``</font>
<font color="black"> 465. </font>
<font color="black"> 466.         :type fields: dict</font>
<font color="black"> 467.         :param fields: A dictionary of prefilled form fields to build on top</font>
<font color="black"> 468.             of.</font>
<font color="black"> 469. </font>
<font color="black"> 470.         :type conditions: list</font>
<font color="black"> 471.         :param conditions: A list of conditions to include in the policy. Each</font>
<font color="black"> 472.             element can be either a list or a structure. For example:</font>
<font color="black"> 473.             [</font>
<font color="black"> 474.              {&quot;acl&quot;: &quot;public-read&quot;},</font>
<font color="black"> 475.              {&quot;bucket&quot;: &quot;mybucket&quot;},</font>
<font color="black"> 476.              [&quot;starts-with&quot;, &quot;$key&quot;, &quot;mykey&quot;]</font>
<font color="black"> 477.             ]</font>
<font color="black"> 478. </font>
<font color="black"> 479.         :type expires_in: int</font>
<font color="black"> 480.         :param expires_in: The number of seconds the presigned post is valid</font>
<font color="black"> 481.             for.</font>
<font color="black"> 482. </font>
<font color="black"> 483.         :type region_name: string</font>
<font color="black"> 484.         :param region_name: The region name to sign the presigned post to.</font>
<font color="black"> 485. </font>
<font color="black"> 486.         :rtype: dict</font>
<font color="black"> 487.         :returns: A dictionary with two elements: ``url`` and ``fields``.</font>
<font color="black"> 488.             Url is the url to post to. Fields is a dictionary filled with</font>
<font color="black"> 489.             the form fields and respective values to use when submitting the</font>
<font color="black"> 490.             post. For example:</font>
<font color="black"> 491. </font>
<font color="black"> 492.             {'url': 'https://mybucket.s3.amazonaws.com</font>
<font color="black"> 493.              'fields': {'acl': 'public-read',</font>
<font color="black"> 494.                         'key': 'mykey',</font>
<font color="black"> 495.                         'signature': 'mysignature',</font>
<font color="black"> 496.                         'policy': 'mybase64 encoded policy'}</font>
<font color="black"> 497.             }</font>
<font color="black"> 498.         &quot;&quot;&quot;</font>
<font color="red"> 499.         if fields is None:</font>
<font color="red"> 500.             fields = {}</font>
<font color="black"> 501. </font>
<font color="red"> 502.         if conditions is None:</font>
<font color="red"> 503.             conditions = []</font>
<font color="black"> 504. </font>
<font color="black"> 505.         # Create the policy for the post.</font>
<font color="red"> 506.         policy = {}</font>
<font color="black"> 507. </font>
<font color="black"> 508.         # Create an expiration date for the policy</font>
<font color="red"> 509.         datetime_now = datetime.datetime.utcnow()</font>
<font color="red"> 510.         expire_date = datetime_now + datetime.timedelta(seconds=expires_in)</font>
<font color="red"> 511.         policy['expiration'] = expire_date.strftime(botocore.auth.ISO8601)</font>
<font color="black"> 512. </font>
<font color="black"> 513.         # Append all of the conditions that the user supplied.</font>
<font color="red"> 514.         policy['conditions'] = []</font>
<font color="red"> 515.         for condition in conditions:</font>
<font color="red"> 516.             policy['conditions'].append(condition)</font>
<font color="black"> 517. </font>
<font color="black"> 518.         # Store the policy and the fields in the request for signing</font>
<font color="red"> 519.         request = create_request_object(request_dict)</font>
<font color="red"> 520.         request.context['s3-presign-post-fields'] = fields</font>
<font color="red"> 521.         request.context['s3-presign-post-policy'] = policy</font>
<font color="black"> 522. </font>
<font color="red"> 523.         self._request_signer.sign(</font>
<font color="red"> 524.             'PutObject', request, region_name, 'presign-post')</font>
<font color="black"> 525.         # Return the url and the fields for th form to post.</font>
<font color="red"> 526.         return {'url': request.url, 'fields': fields}</font>
<font color="black"> 527. </font>
<font color="black"> 528. </font>
<font color="green"> 529. def add_generate_presigned_url(class_attributes, **kwargs):</font>
<font color="green"> 530.     class_attributes['generate_presigned_url'] = generate_presigned_url</font>
<font color="black"> 531. </font>
<font color="black"> 532. </font>
<font color="green"> 533. def generate_presigned_url(self, ClientMethod, Params=None, ExpiresIn=3600,</font>
<font color="green"> 534.                            HttpMethod=None):</font>
<font color="black"> 535.     &quot;&quot;&quot;Generate a presigned url given a client, its method, and arguments</font>
<font color="black"> 536. </font>
<font color="black"> 537.     :type ClientMethod: string</font>
<font color="black"> 538.     :param ClientMethod: The client method to presign for</font>
<font color="black"> 539. </font>
<font color="black"> 540.     :type Params: dict</font>
<font color="black"> 541.     :param Params: The parameters normally passed to</font>
<font color="black"> 542.         ``ClientMethod``.</font>
<font color="black"> 543. </font>
<font color="black"> 544.     :type ExpiresIn: int</font>
<font color="black"> 545.     :param ExpiresIn: The number of seconds the presigned url is valid</font>
<font color="black"> 546.         for. By default it expires in an hour (3600 seconds)</font>
<font color="black"> 547. </font>
<font color="black"> 548.     :type HttpMethod: string</font>
<font color="black"> 549.     :param HttpMethod: The http method to use on the generated url. By</font>
<font color="black"> 550.         default, the http method is whatever is used in the method's model.</font>
<font color="black"> 551. </font>
<font color="black"> 552.     :returns: The presigned url</font>
<font color="black"> 553.     &quot;&quot;&quot;</font>
<font color="red"> 554.     client_method = ClientMethod</font>
<font color="red"> 555.     params = Params</font>
<font color="red"> 556.     if params is None:</font>
<font color="red"> 557.         params = {}</font>
<font color="red"> 558.     expires_in = ExpiresIn</font>
<font color="red"> 559.     http_method = HttpMethod</font>
<font color="red"> 560.     context = {</font>
<font color="red"> 561.         'is_presign_request': True,</font>
<font color="red"> 562.         'use_global_endpoint': _should_use_global_endpoint(self),</font>
<font color="black"> 563.     }</font>
<font color="black"> 564. </font>
<font color="red"> 565.     request_signer = self._request_signer</font>
<font color="red"> 566.     serializer = self._serializer</font>
<font color="black"> 567. </font>
<font color="red"> 568.     try:</font>
<font color="red"> 569.         operation_name = self._PY_TO_OP_NAME[client_method]</font>
<font color="red"> 570.     except KeyError:</font>
<font color="red"> 571.         raise UnknownClientMethodError(method_name=client_method)</font>
<font color="black"> 572. </font>
<font color="red"> 573.     operation_model = self.meta.service_model.operation_model(</font>
<font color="red"> 574.         operation_name)</font>
<font color="black"> 575. </font>
<font color="red"> 576.     params = self._emit_api_params(params, operation_model, context)</font>
<font color="black"> 577. </font>
<font color="black"> 578.     # Create a request dict based on the params to serialize.</font>
<font color="red"> 579.     request_dict = serializer.serialize_to_request(</font>
<font color="red"> 580.         params, operation_model)</font>
<font color="black"> 581. </font>
<font color="black"> 582.     # Switch out the http method if user specified it.</font>
<font color="red"> 583.     if http_method is not None:</font>
<font color="red"> 584.         request_dict['method'] = http_method</font>
<font color="black"> 585. </font>
<font color="black"> 586.     # Prepare the request dict by including the client's endpoint url.</font>
<font color="red"> 587.     prepare_request_dict(</font>
<font color="red"> 588.         request_dict, endpoint_url=self.meta.endpoint_url, context=context)</font>
<font color="black"> 589. </font>
<font color="black"> 590.     # Generate the presigned url.</font>
<font color="red"> 591.     return request_signer.generate_presigned_url(</font>
<font color="red"> 592.         request_dict=request_dict, expires_in=expires_in,</font>
<font color="red"> 593.         operation_name=operation_name)</font>
<font color="black"> 594. </font>
<font color="black"> 595. </font>
<font color="green"> 596. def add_generate_presigned_post(class_attributes, **kwargs):</font>
<font color="green"> 597.     class_attributes['generate_presigned_post'] = generate_presigned_post</font>
<font color="black"> 598. </font>
<font color="black"> 599. </font>
<font color="green"> 600. def generate_presigned_post(self, Bucket, Key, Fields=None, Conditions=None,</font>
<font color="green"> 601.                             ExpiresIn=3600):</font>
<font color="black"> 602.     &quot;&quot;&quot;Builds the url and the form fields used for a presigned s3 post</font>
<font color="black"> 603. </font>
<font color="black"> 604.     :type Bucket: string</font>
<font color="black"> 605.     :param Bucket: The name of the bucket to presign the post to. Note that</font>
<font color="black"> 606.         bucket related conditions should not be included in the</font>
<font color="black"> 607.         ``conditions`` parameter.</font>
<font color="black"> 608. </font>
<font color="black"> 609.     :type Key: string</font>
<font color="black"> 610.     :param Key: Key name, optionally add ${filename} to the end to</font>
<font color="black"> 611.         attach the submitted filename. Note that key related conditions and</font>
<font color="black"> 612.         fields are filled out for you and should not be included in the</font>
<font color="black"> 613.         ``Fields`` or ``Conditions`` parameter.</font>
<font color="black"> 614. </font>
<font color="black"> 615.     :type Fields: dict</font>
<font color="black"> 616.     :param Fields: A dictionary of prefilled form fields to build on top</font>
<font color="black"> 617.         of. Elements that may be included are acl, Cache-Control,</font>
<font color="black"> 618.         Content-Type, Content-Disposition, Content-Encoding, Expires,</font>
<font color="black"> 619.         success_action_redirect, redirect, success_action_status,</font>
<font color="black"> 620.         and x-amz-meta-.</font>
<font color="black"> 621. </font>
<font color="black"> 622.         Note that if a particular element is included in the fields</font>
<font color="black"> 623.         dictionary it will not be automatically added to the conditions</font>
<font color="black"> 624.         list. You must specify a condition for the element as well.</font>
<font color="black"> 625. </font>
<font color="black"> 626.     :type Conditions: list</font>
<font color="black"> 627.     :param Conditions: A list of conditions to include in the policy. Each</font>
<font color="black"> 628.         element can be either a list or a structure. For example:</font>
<font color="black"> 629. </font>
<font color="black"> 630.         [</font>
<font color="black"> 631.          {&quot;acl&quot;: &quot;public-read&quot;},</font>
<font color="black"> 632.          [&quot;content-length-range&quot;, 2, 5],</font>
<font color="black"> 633.          [&quot;starts-with&quot;, &quot;$success_action_redirect&quot;, &quot;&quot;]</font>
<font color="black"> 634.         ]</font>
<font color="black"> 635. </font>
<font color="black"> 636.         Conditions that are included may pertain to acl,</font>
<font color="black"> 637.         content-length-range, Cache-Control, Content-Type,</font>
<font color="black"> 638.         Content-Disposition, Content-Encoding, Expires,</font>
<font color="black"> 639.         success_action_redirect, redirect, success_action_status,</font>
<font color="black"> 640.         and/or x-amz-meta-.</font>
<font color="black"> 641. </font>
<font color="black"> 642.         Note that if you include a condition, you must specify</font>
<font color="black"> 643.         the a valid value in the fields dictionary as well. A value will</font>
<font color="black"> 644.         not be added automatically to the fields dictionary based on the</font>
<font color="black"> 645.         conditions.</font>
<font color="black"> 646. </font>
<font color="black"> 647.     :type ExpiresIn: int</font>
<font color="black"> 648.     :param ExpiresIn: The number of seconds the presigned post</font>
<font color="black"> 649.         is valid for.</font>
<font color="black"> 650. </font>
<font color="black"> 651.     :rtype: dict</font>
<font color="black"> 652.     :returns: A dictionary with two elements: ``url`` and ``fields``.</font>
<font color="black"> 653.         Url is the url to post to. Fields is a dictionary filled with</font>
<font color="black"> 654.         the form fields and respective values to use when submitting the</font>
<font color="black"> 655.         post. For example:</font>
<font color="black"> 656. </font>
<font color="black"> 657.         {'url': 'https://mybucket.s3.amazonaws.com</font>
<font color="black"> 658.          'fields': {'acl': 'public-read',</font>
<font color="black"> 659.                     'key': 'mykey',</font>
<font color="black"> 660.                     'signature': 'mysignature',</font>
<font color="black"> 661.                     'policy': 'mybase64 encoded policy'}</font>
<font color="black"> 662.         }</font>
<font color="black"> 663.     &quot;&quot;&quot;</font>
<font color="red"> 664.     bucket = Bucket</font>
<font color="red"> 665.     key = Key</font>
<font color="red"> 666.     fields = Fields</font>
<font color="red"> 667.     conditions = Conditions</font>
<font color="red"> 668.     expires_in = ExpiresIn</font>
<font color="black"> 669. </font>
<font color="red"> 670.     if fields is None:</font>
<font color="red"> 671.         fields = {}</font>
<font color="black"> 672. </font>
<font color="red"> 673.     if conditions is None:</font>
<font color="red"> 674.         conditions = []</font>
<font color="black"> 675. </font>
<font color="red"> 676.     post_presigner = S3PostPresigner(self._request_signer)</font>
<font color="red"> 677.     serializer = self._serializer</font>
<font color="black"> 678. </font>
<font color="black"> 679.     # We choose the CreateBucket operation model because its url gets</font>
<font color="black"> 680.     # serialized to what a presign post requires.</font>
<font color="red"> 681.     operation_model = self.meta.service_model.operation_model(</font>
<font color="red"> 682.         'CreateBucket')</font>
<font color="black"> 683. </font>
<font color="black"> 684.     # Create a request dict based on the params to serialize.</font>
<font color="red"> 685.     request_dict = serializer.serialize_to_request(</font>
<font color="red"> 686.         {'Bucket': bucket}, operation_model)</font>
<font color="black"> 687. </font>
<font color="black"> 688.     # Prepare the request dict by including the client's endpoint url.</font>
<font color="red"> 689.     prepare_request_dict(</font>
<font color="red"> 690.         request_dict, endpoint_url=self.meta.endpoint_url,</font>
<font color="red"> 691.         context={</font>
<font color="red"> 692.             'is_presign_request': True,</font>
<font color="red"> 693.             'use_global_endpoint': _should_use_global_endpoint(self),</font>
<font color="black"> 694.         },</font>
<font color="black"> 695.     )</font>
<font color="black"> 696. </font>
<font color="black"> 697.     # Append that the bucket name to the list of conditions.</font>
<font color="red"> 698.     conditions.append({'bucket': bucket})</font>
<font color="black"> 699. </font>
<font color="black"> 700.     # If the key ends with filename, the only constraint that can be</font>
<font color="black"> 701.     # imposed is if it starts with the specified prefix.</font>
<font color="red"> 702.     if key.endswith('${filename}'):</font>
<font color="red"> 703.         conditions.append([&quot;starts-with&quot;, '$key', key[:-len('${filename}')]])</font>
<font color="black"> 704.     else:</font>
<font color="red"> 705.         conditions.append({'key': key})</font>
<font color="black"> 706. </font>
<font color="black"> 707.     # Add the key to the fields.</font>
<font color="red"> 708.     fields['key'] = key</font>
<font color="black"> 709. </font>
<font color="red"> 710.     return post_presigner.generate_presigned_post(</font>
<font color="red"> 711.         request_dict=request_dict, fields=fields, conditions=conditions,</font>
<font color="red"> 712.         expires_in=expires_in)</font>
<font color="black"> 713. </font>
<font color="black"> 714. </font>
<font color="green"> 715. def _should_use_global_endpoint(client):</font>
<font color="red"> 716.     use_dualstack_endpoint = False</font>
<font color="red"> 717.     if client.meta.config.s3 is not None:</font>
<font color="red"> 718.         use_dualstack_endpoint = client.meta.config.s3.get(</font>
<font color="red"> 719.             'use_dualstack_endpoint', False)</font>
<font color="red"> 720.     return (client.meta.partition == 'aws' and</font>
<font color="red"> 721.             not use_dualstack_endpoint)</font>
</pre>

