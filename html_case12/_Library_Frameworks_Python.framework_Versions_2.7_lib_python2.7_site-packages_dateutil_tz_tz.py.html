source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/dateutil/tz/tz.py</b><br>


file stats: <b>629 lines, 99 executed: 15.7% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. &quot;&quot;&quot;</font>
<font color="black">   3. This module offers timezone implementations subclassing the abstract</font>
<font color="black">   4. :py:`datetime.tzinfo` type. There are classes to handle tzfile format files</font>
<font color="black">   5. (usually are in :file:`/etc/localtime`, :file:`/usr/share/zoneinfo`, etc), TZ</font>
<font color="black">   6. environment string (in all known formats), given ranges (with help from</font>
<font color="black">   7. relative deltas), local machine timezone, fixed offset timezone, and UTC</font>
<font color="black">   8. timezone.</font>
<font color="green">   9. &quot;&quot;&quot;</font>
<font color="green">  10. import datetime</font>
<font color="green">  11. import struct</font>
<font color="green">  12. import time</font>
<font color="green">  13. import sys</font>
<font color="green">  14. import os</font>
<font color="black">  15. </font>
<font color="green">  16. from six import string_types, PY3</font>
<font color="green">  17. from ._common import tzname_in_python2</font>
<font color="black">  18. </font>
<font color="green">  19. try:</font>
<font color="green">  20.     from .win import tzwin, tzwinlocal</font>
<font color="green">  21. except ImportError:</font>
<font color="green">  22.     tzwin = tzwinlocal = None</font>
<font color="black">  23. </font>
<font color="green">  24. relativedelta = None</font>
<font color="green">  25. parser = None</font>
<font color="green">  26. rrule = None</font>
<font color="black">  27. </font>
<font color="green">  28. ZERO = datetime.timedelta(0)</font>
<font color="green">  29. EPOCHORDINAL = datetime.datetime.utcfromtimestamp(0).toordinal()</font>
<font color="black">  30. </font>
<font color="green">  31. class tzutc(datetime.tzinfo):</font>
<font color="black">  32. </font>
<font color="green">  33.     def utcoffset(self, dt):</font>
<font color="red">  34.         return ZERO</font>
<font color="black">  35. </font>
<font color="green">  36.     def dst(self, dt):</font>
<font color="red">  37.         return ZERO</font>
<font color="black">  38. </font>
<font color="green">  39.     @tzname_in_python2</font>
<font color="black">  40.     def tzname(self, dt):</font>
<font color="red">  41.         return &quot;UTC&quot;</font>
<font color="black">  42. </font>
<font color="green">  43.     def __eq__(self, other):</font>
<font color="red">  44.         return (isinstance(other, tzutc) or</font>
<font color="red">  45.                 (isinstance(other, tzoffset) and other._offset == ZERO))</font>
<font color="black">  46. </font>
<font color="green">  47.     def __ne__(self, other):</font>
<font color="red">  48.         return not self.__eq__(other)</font>
<font color="black">  49. </font>
<font color="green">  50.     def __repr__(self):</font>
<font color="red">  51.         return &quot;%s()&quot; % self.__class__.__name__</font>
<font color="black">  52. </font>
<font color="green">  53.     __reduce__ = object.__reduce__</font>
<font color="black">  54. </font>
<font color="black">  55. </font>
<font color="green">  56. class tzoffset(datetime.tzinfo):</font>
<font color="black">  57. </font>
<font color="green">  58.     def __init__(self, name, offset):</font>
<font color="red">  59.         self._name = name</font>
<font color="red">  60.         self._offset = datetime.timedelta(seconds=offset)</font>
<font color="black">  61. </font>
<font color="green">  62.     def utcoffset(self, dt):</font>
<font color="red">  63.         return self._offset</font>
<font color="black">  64. </font>
<font color="green">  65.     def dst(self, dt):</font>
<font color="red">  66.         return ZERO</font>
<font color="black">  67. </font>
<font color="green">  68.     @tzname_in_python2</font>
<font color="black">  69.     def tzname(self, dt):</font>
<font color="red">  70.         return self._name</font>
<font color="black">  71. </font>
<font color="green">  72.     def __eq__(self, other):</font>
<font color="red">  73.         return (isinstance(other, tzoffset) and</font>
<font color="red">  74.                 self._offset == other._offset)</font>
<font color="black">  75. </font>
<font color="green">  76.     def __ne__(self, other):</font>
<font color="red">  77.         return not self.__eq__(other)</font>
<font color="black">  78. </font>
<font color="green">  79.     def __repr__(self):</font>
<font color="red">  80.         return &quot;%s(%s, %s)&quot; % (self.__class__.__name__,</font>
<font color="red">  81.                                repr(self._name),</font>
<font color="red">  82.                                self._offset.days*86400+self._offset.seconds)</font>
<font color="black">  83. </font>
<font color="green">  84.     __reduce__ = object.__reduce__</font>
<font color="black">  85. </font>
<font color="black">  86. </font>
<font color="green">  87. class tzlocal(datetime.tzinfo):</font>
<font color="green">  88.     def __init__(self):</font>
<font color="red">  89.         self._std_offset = datetime.timedelta(seconds=-time.timezone)</font>
<font color="red">  90.         if time.daylight:</font>
<font color="red">  91.             self._dst_offset = datetime.timedelta(seconds=-time.altzone)</font>
<font color="black">  92.         else:</font>
<font color="red">  93.             self._dst_offset = self._std_offset</font>
<font color="black">  94. </font>
<font color="green">  95.     def utcoffset(self, dt):</font>
<font color="red">  96.         if dt is None:</font>
<font color="red">  97.             return dt</font>
<font color="black">  98. </font>
<font color="red">  99.         if self._isdst(dt):</font>
<font color="red"> 100.             return self._dst_offset</font>
<font color="black"> 101.         else:</font>
<font color="red"> 102.             return self._std_offset</font>
<font color="black"> 103. </font>
<font color="green"> 104.     def dst(self, dt):</font>
<font color="red"> 105.         if self._isdst(dt):</font>
<font color="red"> 106.             return self._dst_offset-self._std_offset</font>
<font color="black"> 107.         else:</font>
<font color="red"> 108.             return ZERO</font>
<font color="black"> 109. </font>
<font color="green"> 110.     @tzname_in_python2</font>
<font color="black"> 111.     def tzname(self, dt):</font>
<font color="red"> 112.         return time.tzname[self._isdst(dt)]</font>
<font color="black"> 113. </font>
<font color="green"> 114.     def _isdst(self, dt):</font>
<font color="black"> 115.         # We can't use mktime here. It is unstable when deciding if</font>
<font color="black"> 116.         # the hour near to a change is DST or not.</font>
<font color="black"> 117.         #</font>
<font color="black"> 118.         # timestamp = time.mktime((dt.year, dt.month, dt.day, dt.hour,</font>
<font color="black"> 119.         #                         dt.minute, dt.second, dt.weekday(), 0, -1))</font>
<font color="black"> 120.         # return time.localtime(timestamp).tm_isdst</font>
<font color="black"> 121.         #</font>
<font color="black"> 122.         # The code above yields the following result:</font>
<font color="black"> 123.         #</font>
<font color="black"> 124.         # &gt;&gt;&gt; import tz, datetime</font>
<font color="black"> 125.         # &gt;&gt;&gt; t = tz.tzlocal()</font>
<font color="black"> 126.         # &gt;&gt;&gt; datetime.datetime(2003,2,15,23,tzinfo=t).tzname()</font>
<font color="black"> 127.         # 'BRDT'</font>
<font color="black"> 128.         # &gt;&gt;&gt; datetime.datetime(2003,2,16,0,tzinfo=t).tzname()</font>
<font color="black"> 129.         # 'BRST'</font>
<font color="black"> 130.         # &gt;&gt;&gt; datetime.datetime(2003,2,15,23,tzinfo=t).tzname()</font>
<font color="black"> 131.         # 'BRST'</font>
<font color="black"> 132.         # &gt;&gt;&gt; datetime.datetime(2003,2,15,22,tzinfo=t).tzname()</font>
<font color="black"> 133.         # 'BRDT'</font>
<font color="black"> 134.         # &gt;&gt;&gt; datetime.datetime(2003,2,15,23,tzinfo=t).tzname()</font>
<font color="black"> 135.         # 'BRDT'</font>
<font color="black"> 136.         #</font>
<font color="black"> 137.         # Here is a more stable implementation:</font>
<font color="black"> 138.         #</font>
<font color="black"> 139.         timestamp = ((dt.toordinal() - EPOCHORDINAL) * 86400</font>
<font color="black"> 140.                      + dt.hour * 3600</font>
<font color="black"> 141.                      + dt.minute * 60</font>
<font color="red"> 142.                      + dt.second)</font>
<font color="red"> 143.         return time.localtime(timestamp+time.timezone).tm_isdst</font>
<font color="black"> 144. </font>
<font color="green"> 145.     def __eq__(self, other):</font>
<font color="red"> 146.         return (isinstance(other, tzlocal) and</font>
<font color="red"> 147.                 (self._std_offset == other._std_offset and</font>
<font color="red"> 148.                  self._dst_offset == other._dst_offset))</font>
<font color="black"> 149. </font>
<font color="green"> 150.     def __ne__(self, other):</font>
<font color="red"> 151.         return not self.__eq__(other)</font>
<font color="black"> 152. </font>
<font color="green"> 153.     def __repr__(self):</font>
<font color="red"> 154.         return &quot;%s()&quot; % self.__class__.__name__</font>
<font color="black"> 155. </font>
<font color="green"> 156.     __reduce__ = object.__reduce__</font>
<font color="black"> 157. </font>
<font color="black"> 158. </font>
<font color="green"> 159. class _ttinfo(object):</font>
<font color="green"> 160.     __slots__ = [&quot;offset&quot;, &quot;delta&quot;, &quot;isdst&quot;, &quot;abbr&quot;, &quot;isstd&quot;, &quot;isgmt&quot;]</font>
<font color="black"> 161. </font>
<font color="green"> 162.     def __init__(self):</font>
<font color="red"> 163.         for attr in self.__slots__:</font>
<font color="red"> 164.             setattr(self, attr, None)</font>
<font color="black"> 165. </font>
<font color="green"> 166.     def __repr__(self):</font>
<font color="red"> 167.         l = []</font>
<font color="red"> 168.         for attr in self.__slots__:</font>
<font color="red"> 169.             value = getattr(self, attr)</font>
<font color="red"> 170.             if value is not None:</font>
<font color="red"> 171.                 l.append(&quot;%s=%s&quot; % (attr, repr(value)))</font>
<font color="red"> 172.         return &quot;%s(%s)&quot; % (self.__class__.__name__, &quot;, &quot;.join(l))</font>
<font color="black"> 173. </font>
<font color="green"> 174.     def __eq__(self, other):</font>
<font color="red"> 175.         if not isinstance(other, _ttinfo):</font>
<font color="red"> 176.             return False</font>
<font color="red"> 177.         return (self.offset == other.offset and</font>
<font color="red"> 178.                 self.delta == other.delta and</font>
<font color="red"> 179.                 self.isdst == other.isdst and</font>
<font color="red"> 180.                 self.abbr == other.abbr and</font>
<font color="red"> 181.                 self.isstd == other.isstd and</font>
<font color="red"> 182.                 self.isgmt == other.isgmt)</font>
<font color="black"> 183. </font>
<font color="green"> 184.     def __ne__(self, other):</font>
<font color="red"> 185.         return not self.__eq__(other)</font>
<font color="black"> 186. </font>
<font color="green"> 187.     def __getstate__(self):</font>
<font color="red"> 188.         state = {}</font>
<font color="red"> 189.         for name in self.__slots__:</font>
<font color="red"> 190.             state[name] = getattr(self, name, None)</font>
<font color="red"> 191.         return state</font>
<font color="black"> 192. </font>
<font color="green"> 193.     def __setstate__(self, state):</font>
<font color="red"> 194.         for name in self.__slots__:</font>
<font color="red"> 195.             if name in state:</font>
<font color="red"> 196.                 setattr(self, name, state[name])</font>
<font color="black"> 197. </font>
<font color="black"> 198. </font>
<font color="green"> 199. class tzfile(datetime.tzinfo):</font>
<font color="black"> 200. </font>
<font color="black"> 201.     # http://www.twinsun.com/tz/tz-link.htm</font>
<font color="black"> 202.     # ftp://ftp.iana.org/tz/tz*.tar.gz</font>
<font color="black"> 203. </font>
<font color="green"> 204.     def __init__(self, fileobj, filename=None):</font>
<font color="red"> 205.         file_opened_here = False</font>
<font color="red"> 206.         if isinstance(fileobj, string_types):</font>
<font color="red"> 207.             self._filename = fileobj</font>
<font color="red"> 208.             fileobj = open(fileobj, 'rb')</font>
<font color="red"> 209.             file_opened_here = True</font>
<font color="red"> 210.         elif filename is not None:</font>
<font color="red"> 211.             self._filename = filename</font>
<font color="red"> 212.         elif hasattr(fileobj, &quot;name&quot;):</font>
<font color="red"> 213.             self._filename = fileobj.name</font>
<font color="black"> 214.         else:</font>
<font color="red"> 215.             self._filename = repr(fileobj)</font>
<font color="black"> 216. </font>
<font color="black"> 217.         # From tzfile(5):</font>
<font color="black"> 218.         #</font>
<font color="black"> 219.         # The time zone information files used by tzset(3)</font>
<font color="black"> 220.         # begin with the magic characters &quot;TZif&quot; to identify</font>
<font color="black"> 221.         # them as time zone information files, followed by</font>
<font color="black"> 222.         # sixteen bytes reserved for future use, followed by</font>
<font color="black"> 223.         # six four-byte values of type long, written in a</font>
<font color="black"> 224.         # ``standard'' byte order (the high-order  byte</font>
<font color="black"> 225.         # of the value is written first).</font>
<font color="red"> 226.         try:</font>
<font color="red"> 227.             if fileobj.read(4).decode() != &quot;TZif&quot;:</font>
<font color="red"> 228.                 raise ValueError(&quot;magic not found&quot;)</font>
<font color="black"> 229. </font>
<font color="red"> 230.             fileobj.read(16)</font>
<font color="black"> 231. </font>
<font color="black"> 232.             (</font>
<font color="black"> 233.                 # The number of UTC/local indicators stored in the file.</font>
<font color="black"> 234.                 ttisgmtcnt,</font>
<font color="black"> 235. </font>
<font color="black"> 236.                 # The number of standard/wall indicators stored in the file.</font>
<font color="black"> 237.                 ttisstdcnt,</font>
<font color="black"> 238. </font>
<font color="black"> 239.                 # The number of leap seconds for which data is</font>
<font color="black"> 240.                 # stored in the file.</font>
<font color="black"> 241.                 leapcnt,</font>
<font color="black"> 242. </font>
<font color="black"> 243.                 # The number of &quot;transition times&quot; for which data</font>
<font color="black"> 244.                 # is stored in the file.</font>
<font color="black"> 245.                 timecnt,</font>
<font color="black"> 246. </font>
<font color="black"> 247.                 # The number of &quot;local time types&quot; for which data</font>
<font color="black"> 248.                 # is stored in the file (must not be zero).</font>
<font color="black"> 249.                 typecnt,</font>
<font color="black"> 250. </font>
<font color="black"> 251.                 # The  number  of  characters  of &quot;time zone</font>
<font color="black"> 252.                 # abbreviation strings&quot; stored in the file.</font>
<font color="black"> 253.                 charcnt,</font>
<font color="black"> 254. </font>
<font color="red"> 255.             ) = struct.unpack(&quot;&gt;6l&quot;, fileobj.read(24))</font>
<font color="black"> 256. </font>
<font color="black"> 257.             # The above header is followed by tzh_timecnt four-byte</font>
<font color="black"> 258.             # values  of  type long,  sorted  in ascending order.</font>
<font color="black"> 259.             # These values are written in ``standard'' byte order.</font>
<font color="black"> 260.             # Each is used as a transition time (as  returned  by</font>
<font color="black"> 261.             # time(2)) at which the rules for computing local time</font>
<font color="black"> 262.             # change.</font>
<font color="black"> 263. </font>
<font color="red"> 264.             if timecnt:</font>
<font color="red"> 265.                 self._trans_list = struct.unpack(&quot;&gt;%dl&quot; % timecnt,</font>
<font color="red"> 266.                                                  fileobj.read(timecnt*4))</font>
<font color="black"> 267.             else:</font>
<font color="red"> 268.                 self._trans_list = []</font>
<font color="black"> 269. </font>
<font color="black"> 270.             # Next come tzh_timecnt one-byte values of type unsigned</font>
<font color="black"> 271.             # char; each one tells which of the different types of</font>
<font color="black"> 272.             # ``local time'' types described in the file is associated</font>
<font color="black"> 273.             # with the same-indexed transition time. These values</font>
<font color="black"> 274.             # serve as indices into an array of ttinfo structures that</font>
<font color="black"> 275.             # appears next in the file.</font>
<font color="black"> 276. </font>
<font color="red"> 277.             if timecnt:</font>
<font color="red"> 278.                 self._trans_idx = struct.unpack(&quot;&gt;%dB&quot; % timecnt,</font>
<font color="red"> 279.                                                 fileobj.read(timecnt))</font>
<font color="black"> 280.             else:</font>
<font color="red"> 281.                 self._trans_idx = []</font>
<font color="black"> 282. </font>
<font color="black"> 283.             # Each ttinfo structure is written as a four-byte value</font>
<font color="black"> 284.             # for tt_gmtoff  of  type long,  in  a  standard  byte</font>
<font color="black"> 285.             # order, followed  by a one-byte value for tt_isdst</font>
<font color="black"> 286.             # and a one-byte  value  for  tt_abbrind.   In  each</font>
<font color="black"> 287.             # structure, tt_gmtoff  gives  the  number  of</font>
<font color="black"> 288.             # seconds to be added to UTC, tt_isdst tells whether</font>
<font color="black"> 289.             # tm_isdst should be set by  localtime(3),  and</font>
<font color="black"> 290.             # tt_abbrind serves  as an index into the array of</font>
<font color="black"> 291.             # time zone abbreviation characters that follow the</font>
<font color="black"> 292.             # ttinfo structure(s) in the file.</font>
<font color="black"> 293. </font>
<font color="red"> 294.             ttinfo = []</font>
<font color="black"> 295. </font>
<font color="red"> 296.             for i in range(typecnt):</font>
<font color="red"> 297.                 ttinfo.append(struct.unpack(&quot;&gt;lbb&quot;, fileobj.read(6)))</font>
<font color="black"> 298. </font>
<font color="red"> 299.             abbr = fileobj.read(charcnt).decode()</font>
<font color="black"> 300. </font>
<font color="black"> 301.             # Then there are tzh_leapcnt pairs of four-byte</font>
<font color="black"> 302.             # values, written in  standard byte  order;  the</font>
<font color="black"> 303.             # first  value  of  each pair gives the time (as</font>
<font color="black"> 304.             # returned by time(2)) at which a leap second</font>
<font color="black"> 305.             # occurs;  the  second  gives the  total  number of</font>
<font color="black"> 306.             # leap seconds to be applied after the given time.</font>
<font color="black"> 307.             # The pairs of values are sorted in ascending order</font>
<font color="black"> 308.             # by time.</font>
<font color="black"> 309. </font>
<font color="black"> 310.             # Not used, for now (but read anyway for correct file position)</font>
<font color="red"> 311.             if leapcnt:</font>
<font color="red"> 312.                 leap = struct.unpack(&quot;&gt;%dl&quot; % (leapcnt*2),</font>
<font color="red"> 313.                                      fileobj.read(leapcnt*8))</font>
<font color="black"> 314. </font>
<font color="black"> 315.             # Then there are tzh_ttisstdcnt standard/wall</font>
<font color="black"> 316.             # indicators, each stored as a one-byte value;</font>
<font color="black"> 317.             # they tell whether the transition times associated</font>
<font color="black"> 318.             # with local time types were specified as standard</font>
<font color="black"> 319.             # time or wall clock time, and are used when</font>
<font color="black"> 320.             # a time zone file is used in handling POSIX-style</font>
<font color="black"> 321.             # time zone environment variables.</font>
<font color="black"> 322. </font>
<font color="red"> 323.             if ttisstdcnt:</font>
<font color="red"> 324.                 isstd = struct.unpack(&quot;&gt;%db&quot; % ttisstdcnt,</font>
<font color="red"> 325.                                       fileobj.read(ttisstdcnt))</font>
<font color="black"> 326. </font>
<font color="black"> 327.             # Finally, there are tzh_ttisgmtcnt UTC/local</font>
<font color="black"> 328.             # indicators, each stored as a one-byte value;</font>
<font color="black"> 329.             # they tell whether the transition times associated</font>
<font color="black"> 330.             # with local time types were specified as UTC or</font>
<font color="black"> 331.             # local time, and are used when a time zone file</font>
<font color="black"> 332.             # is used in handling POSIX-style time zone envi-</font>
<font color="black"> 333.             # ronment variables.</font>
<font color="black"> 334. </font>
<font color="red"> 335.             if ttisgmtcnt:</font>
<font color="red"> 336.                 isgmt = struct.unpack(&quot;&gt;%db&quot; % ttisgmtcnt,</font>
<font color="red"> 337.                                       fileobj.read(ttisgmtcnt))</font>
<font color="black"> 338. </font>
<font color="black"> 339.             # ** Everything has been read **</font>
<font color="black"> 340.         finally:</font>
<font color="red"> 341.             if file_opened_here:</font>
<font color="red"> 342.                 fileobj.close()</font>
<font color="black"> 343. </font>
<font color="black"> 344.         # Build ttinfo list</font>
<font color="red"> 345.         self._ttinfo_list = []</font>
<font color="red"> 346.         for i in range(typecnt):</font>
<font color="red"> 347.             gmtoff, isdst, abbrind = ttinfo[i]</font>
<font color="black"> 348.             # Round to full-minutes if that's not the case. Python's</font>
<font color="black"> 349.             # datetime doesn't accept sub-minute timezones. Check</font>
<font color="black"> 350.             # http://python.org/sf/1447945 for some information.</font>
<font color="red"> 351.             gmtoff = (gmtoff+30)//60*60</font>
<font color="red"> 352.             tti = _ttinfo()</font>
<font color="red"> 353.             tti.offset = gmtoff</font>
<font color="red"> 354.             tti.delta = datetime.timedelta(seconds=gmtoff)</font>
<font color="red"> 355.             tti.isdst = isdst</font>
<font color="red"> 356.             tti.abbr = abbr[abbrind:abbr.find('\x00', abbrind)]</font>
<font color="red"> 357.             tti.isstd = (ttisstdcnt &gt; i and isstd[i] != 0)</font>
<font color="red"> 358.             tti.isgmt = (ttisgmtcnt &gt; i and isgmt[i] != 0)</font>
<font color="red"> 359.             self._ttinfo_list.append(tti)</font>
<font color="black"> 360. </font>
<font color="black"> 361.         # Replace ttinfo indexes for ttinfo objects.</font>
<font color="red"> 362.         trans_idx = []</font>
<font color="red"> 363.         for idx in self._trans_idx:</font>
<font color="red"> 364.             trans_idx.append(self._ttinfo_list[idx])</font>
<font color="red"> 365.         self._trans_idx = tuple(trans_idx)</font>
<font color="black"> 366. </font>
<font color="black"> 367.         # Set standard, dst, and before ttinfos. before will be</font>
<font color="black"> 368.         # used when a given time is before any transitions,</font>
<font color="black"> 369.         # and will be set to the first non-dst ttinfo, or to</font>
<font color="black"> 370.         # the first dst, if all of them are dst.</font>
<font color="red"> 371.         self._ttinfo_std = None</font>
<font color="red"> 372.         self._ttinfo_dst = None</font>
<font color="red"> 373.         self._ttinfo_before = None</font>
<font color="red"> 374.         if self._ttinfo_list:</font>
<font color="red"> 375.             if not self._trans_list:</font>
<font color="red"> 376.                 self._ttinfo_std = self._ttinfo_first = self._ttinfo_list[0]</font>
<font color="black"> 377.             else:</font>
<font color="red"> 378.                 for i in range(timecnt-1, -1, -1):</font>
<font color="red"> 379.                     tti = self._trans_idx[i]</font>
<font color="red"> 380.                     if not self._ttinfo_std and not tti.isdst:</font>
<font color="red"> 381.                         self._ttinfo_std = tti</font>
<font color="red"> 382.                     elif not self._ttinfo_dst and tti.isdst:</font>
<font color="red"> 383.                         self._ttinfo_dst = tti</font>
<font color="red"> 384.                     if self._ttinfo_std and self._ttinfo_dst:</font>
<font color="red"> 385.                         break</font>
<font color="black"> 386.                 else:</font>
<font color="red"> 387.                     if self._ttinfo_dst and not self._ttinfo_std:</font>
<font color="red"> 388.                         self._ttinfo_std = self._ttinfo_dst</font>
<font color="black"> 389. </font>
<font color="red"> 390.                 for tti in self._ttinfo_list:</font>
<font color="red"> 391.                     if not tti.isdst:</font>
<font color="red"> 392.                         self._ttinfo_before = tti</font>
<font color="red"> 393.                         break</font>
<font color="black"> 394.                 else:</font>
<font color="red"> 395.                     self._ttinfo_before = self._ttinfo_list[0]</font>
<font color="black"> 396. </font>
<font color="black"> 397.         # Now fix transition times to become relative to wall time.</font>
<font color="black"> 398.         #</font>
<font color="black"> 399.         # I'm not sure about this. In my tests, the tz source file</font>
<font color="black"> 400.         # is setup to wall time, and in the binary file isstd and</font>
<font color="black"> 401.         # isgmt are off, so it should be in wall time. OTOH, it's</font>
<font color="black"> 402.         # always in gmt time. Let me know if you have comments</font>
<font color="black"> 403.         # about this.</font>
<font color="red"> 404.         laststdoffset = 0</font>
<font color="red"> 405.         self._trans_list = list(self._trans_list)</font>
<font color="red"> 406.         for i in range(len(self._trans_list)):</font>
<font color="red"> 407.             tti = self._trans_idx[i]</font>
<font color="red"> 408.             if not tti.isdst:</font>
<font color="black"> 409.                 # This is std time.</font>
<font color="red"> 410.                 self._trans_list[i] += tti.offset</font>
<font color="red"> 411.                 laststdoffset = tti.offset</font>
<font color="black"> 412.             else:</font>
<font color="black"> 413.                 # This is dst time. Convert to std.</font>
<font color="red"> 414.                 self._trans_list[i] += laststdoffset</font>
<font color="red"> 415.         self._trans_list = tuple(self._trans_list)</font>
<font color="black"> 416. </font>
<font color="green"> 417.     def _find_ttinfo(self, dt, laststd=0):</font>
<font color="black"> 418.         timestamp = ((dt.toordinal() - EPOCHORDINAL) * 86400</font>
<font color="black"> 419.                      + dt.hour * 3600</font>
<font color="black"> 420.                      + dt.minute * 60</font>
<font color="red"> 421.                      + dt.second)</font>
<font color="red"> 422.         idx = 0</font>
<font color="red"> 423.         for trans in self._trans_list:</font>
<font color="red"> 424.             if timestamp &lt; trans:</font>
<font color="red"> 425.                 break</font>
<font color="red"> 426.             idx += 1</font>
<font color="black"> 427.         else:</font>
<font color="red"> 428.             return self._ttinfo_std</font>
<font color="red"> 429.         if idx == 0:</font>
<font color="red"> 430.             return self._ttinfo_before</font>
<font color="red"> 431.         if laststd:</font>
<font color="red"> 432.             while idx &gt; 0:</font>
<font color="red"> 433.                 tti = self._trans_idx[idx-1]</font>
<font color="red"> 434.                 if not tti.isdst:</font>
<font color="red"> 435.                     return tti</font>
<font color="red"> 436.                 idx -= 1</font>
<font color="black"> 437.             else:</font>
<font color="red"> 438.                 return self._ttinfo_std</font>
<font color="black"> 439.         else:</font>
<font color="red"> 440.             return self._trans_idx[idx-1]</font>
<font color="black"> 441. </font>
<font color="green"> 442.     def utcoffset(self, dt):</font>
<font color="red"> 443.         if dt is None:</font>
<font color="red"> 444.             return None</font>
<font color="black"> 445. </font>
<font color="red"> 446.         if not self._ttinfo_std:</font>
<font color="red"> 447.             return ZERO</font>
<font color="red"> 448.         return self._find_ttinfo(dt).delta</font>
<font color="black"> 449. </font>
<font color="green"> 450.     def dst(self, dt):</font>
<font color="red"> 451.         if not self._ttinfo_dst:</font>
<font color="red"> 452.             return ZERO</font>
<font color="red"> 453.         tti = self._find_ttinfo(dt)</font>
<font color="red"> 454.         if not tti.isdst:</font>
<font color="red"> 455.             return ZERO</font>
<font color="black"> 456. </font>
<font color="black"> 457.         # The documentation says that utcoffset()-dst() must</font>
<font color="black"> 458.         # be constant for every dt.</font>
<font color="red"> 459.         return tti.delta-self._find_ttinfo(dt, laststd=1).delta</font>
<font color="black"> 460. </font>
<font color="black"> 461.         # An alternative for that would be:</font>
<font color="black"> 462.         #</font>
<font color="black"> 463.         # return self._ttinfo_dst.offset-self._ttinfo_std.offset</font>
<font color="black"> 464.         #</font>
<font color="black"> 465.         # However, this class stores historical changes in the</font>
<font color="black"> 466.         # dst offset, so I belive that this wouldn't be the right</font>
<font color="black"> 467.         # way to implement this.</font>
<font color="black"> 468. </font>
<font color="green"> 469.     @tzname_in_python2</font>
<font color="black"> 470.     def tzname(self, dt):</font>
<font color="red"> 471.         if not self._ttinfo_std:</font>
<font color="red"> 472.             return None</font>
<font color="red"> 473.         return self._find_ttinfo(dt).abbr</font>
<font color="black"> 474. </font>
<font color="green"> 475.     def __eq__(self, other):</font>
<font color="red"> 476.         if not isinstance(other, tzfile):</font>
<font color="red"> 477.             return False</font>
<font color="red"> 478.         return (self._trans_list == other._trans_list and</font>
<font color="red"> 479.                 self._trans_idx == other._trans_idx and</font>
<font color="red"> 480.                 self._ttinfo_list == other._ttinfo_list)</font>
<font color="black"> 481. </font>
<font color="green"> 482.     def __ne__(self, other):</font>
<font color="red"> 483.         return not self.__eq__(other)</font>
<font color="black"> 484. </font>
<font color="green"> 485.     def __repr__(self):</font>
<font color="red"> 486.         return &quot;%s(%s)&quot; % (self.__class__.__name__, repr(self._filename))</font>
<font color="black"> 487. </font>
<font color="green"> 488.     def __reduce__(self):</font>
<font color="red"> 489.         if not os.path.isfile(self._filename):</font>
<font color="red"> 490.             raise ValueError(&quot;Unpickable %s class&quot; % self.__class__.__name__)</font>
<font color="red"> 491.         return (self.__class__, (self._filename,))</font>
<font color="black"> 492. </font>
<font color="black"> 493. </font>
<font color="green"> 494. class tzrange(datetime.tzinfo):</font>
<font color="green"> 495.     def __init__(self, stdabbr, stdoffset=None,</font>
<font color="green"> 496.                  dstabbr=None, dstoffset=None,</font>
<font color="green"> 497.                  start=None, end=None):</font>
<font color="black"> 498.         global relativedelta</font>
<font color="red"> 499.         if not relativedelta:</font>
<font color="red"> 500.             from dateutil import relativedelta</font>
<font color="red"> 501.         self._std_abbr = stdabbr</font>
<font color="red"> 502.         self._dst_abbr = dstabbr</font>
<font color="red"> 503.         if stdoffset is not None:</font>
<font color="red"> 504.             self._std_offset = datetime.timedelta(seconds=stdoffset)</font>
<font color="black"> 505.         else:</font>
<font color="red"> 506.             self._std_offset = ZERO</font>
<font color="red"> 507.         if dstoffset is not None:</font>
<font color="red"> 508.             self._dst_offset = datetime.timedelta(seconds=dstoffset)</font>
<font color="red"> 509.         elif dstabbr and stdoffset is not None:</font>
<font color="red"> 510.             self._dst_offset = self._std_offset+datetime.timedelta(hours=+1)</font>
<font color="black"> 511.         else:</font>
<font color="red"> 512.             self._dst_offset = ZERO</font>
<font color="red"> 513.         if dstabbr and start is None:</font>
<font color="red"> 514.             self._start_delta = relativedelta.relativedelta(</font>
<font color="red"> 515.                 hours=+2, month=4, day=1, weekday=relativedelta.SU(+1))</font>
<font color="black"> 516.         else:</font>
<font color="red"> 517.             self._start_delta = start</font>
<font color="red"> 518.         if dstabbr and end is None:</font>
<font color="red"> 519.             self._end_delta = relativedelta.relativedelta(</font>
<font color="red"> 520.                 hours=+1, month=10, day=31, weekday=relativedelta.SU(-1))</font>
<font color="black"> 521.         else:</font>
<font color="red"> 522.             self._end_delta = end</font>
<font color="black"> 523. </font>
<font color="green"> 524.     def utcoffset(self, dt):</font>
<font color="red"> 525.         if dt is None:</font>
<font color="red"> 526.             return None</font>
<font color="black"> 527. </font>
<font color="red"> 528.         if self._isdst(dt):</font>
<font color="red"> 529.             return self._dst_offset</font>
<font color="black"> 530.         else:</font>
<font color="red"> 531.             return self._std_offset</font>
<font color="black"> 532. </font>
<font color="green"> 533.     def dst(self, dt):</font>
<font color="red"> 534.         if self._isdst(dt):</font>
<font color="red"> 535.             return self._dst_offset-self._std_offset</font>
<font color="black"> 536.         else:</font>
<font color="red"> 537.             return ZERO</font>
<font color="black"> 538. </font>
<font color="green"> 539.     @tzname_in_python2</font>
<font color="black"> 540.     def tzname(self, dt):</font>
<font color="red"> 541.         if self._isdst(dt):</font>
<font color="red"> 542.             return self._dst_abbr</font>
<font color="black"> 543.         else:</font>
<font color="red"> 544.             return self._std_abbr</font>
<font color="black"> 545. </font>
<font color="green"> 546.     def _isdst(self, dt):</font>
<font color="red"> 547.         if not self._start_delta:</font>
<font color="red"> 548.             return False</font>
<font color="red"> 549.         year = datetime.datetime(dt.year, 1, 1)</font>
<font color="red"> 550.         start = year+self._start_delta</font>
<font color="red"> 551.         end = year+self._end_delta</font>
<font color="red"> 552.         dt = dt.replace(tzinfo=None)</font>
<font color="red"> 553.         if start &lt; end:</font>
<font color="red"> 554.             return dt &gt;= start and dt &lt; end</font>
<font color="black"> 555.         else:</font>
<font color="red"> 556.             return dt &gt;= start or dt &lt; end</font>
<font color="black"> 557. </font>
<font color="green"> 558.     def __eq__(self, other):</font>
<font color="red"> 559.         if not isinstance(other, tzrange):</font>
<font color="red"> 560.             return False</font>
<font color="red"> 561.         return (self._std_abbr == other._std_abbr and</font>
<font color="red"> 562.                 self._dst_abbr == other._dst_abbr and</font>
<font color="red"> 563.                 self._std_offset == other._std_offset and</font>
<font color="red"> 564.                 self._dst_offset == other._dst_offset and</font>
<font color="red"> 565.                 self._start_delta == other._start_delta and</font>
<font color="red"> 566.                 self._end_delta == other._end_delta)</font>
<font color="black"> 567. </font>
<font color="green"> 568.     def __ne__(self, other):</font>
<font color="red"> 569.         return not self.__eq__(other)</font>
<font color="black"> 570. </font>
<font color="green"> 571.     def __repr__(self):</font>
<font color="red"> 572.         return &quot;%s(...)&quot; % self.__class__.__name__</font>
<font color="black"> 573. </font>
<font color="green"> 574.     __reduce__ = object.__reduce__</font>
<font color="black"> 575. </font>
<font color="black"> 576. </font>
<font color="green"> 577. class tzstr(tzrange):</font>
<font color="black"> 578. </font>
<font color="green"> 579.     def __init__(self, s):</font>
<font color="black"> 580.         global parser</font>
<font color="red"> 581.         if not parser:</font>
<font color="red"> 582.             from dateutil import parser</font>
<font color="red"> 583.         self._s = s</font>
<font color="black"> 584. </font>
<font color="red"> 585.         res = parser._parsetz(s)</font>
<font color="red"> 586.         if res is None:</font>
<font color="red"> 587.             raise ValueError(&quot;unknown string format&quot;)</font>
<font color="black"> 588. </font>
<font color="black"> 589.         # Here we break the compatibility with the TZ variable handling.</font>
<font color="black"> 590.         # GMT-3 actually *means* the timezone -3.</font>
<font color="red"> 591.         if res.stdabbr in (&quot;GMT&quot;, &quot;UTC&quot;):</font>
<font color="red"> 592.             res.stdoffset *= -1</font>
<font color="black"> 593. </font>
<font color="black"> 594.         # We must initialize it first, since _delta() needs</font>
<font color="black"> 595.         # _std_offset and _dst_offset set. Use False in start/end</font>
<font color="black"> 596.         # to avoid building it two times.</font>
<font color="red"> 597.         tzrange.__init__(self, res.stdabbr, res.stdoffset,</font>
<font color="red"> 598.                          res.dstabbr, res.dstoffset,</font>
<font color="red"> 599.                          start=False, end=False)</font>
<font color="black"> 600. </font>
<font color="red"> 601.         if not res.dstabbr:</font>
<font color="red"> 602.             self._start_delta = None</font>
<font color="red"> 603.             self._end_delta = None</font>
<font color="black"> 604.         else:</font>
<font color="red"> 605.             self._start_delta = self._delta(res.start)</font>
<font color="red"> 606.             if self._start_delta:</font>
<font color="red"> 607.                 self._end_delta = self._delta(res.end, isend=1)</font>
<font color="black"> 608. </font>
<font color="green"> 609.     def _delta(self, x, isend=0):</font>
<font color="red"> 610.         kwargs = {}</font>
<font color="red"> 611.         if x.month is not None:</font>
<font color="red"> 612.             kwargs[&quot;month&quot;] = x.month</font>
<font color="red"> 613.             if x.weekday is not None:</font>
<font color="red"> 614.                 kwargs[&quot;weekday&quot;] = relativedelta.weekday(x.weekday, x.week)</font>
<font color="red"> 615.                 if x.week &gt; 0:</font>
<font color="red"> 616.                     kwargs[&quot;day&quot;] = 1</font>
<font color="black"> 617.                 else:</font>
<font color="red"> 618.                     kwargs[&quot;day&quot;] = 31</font>
<font color="red"> 619.             elif x.day:</font>
<font color="red"> 620.                 kwargs[&quot;day&quot;] = x.day</font>
<font color="red"> 621.         elif x.yday is not None:</font>
<font color="red"> 622.             kwargs[&quot;yearday&quot;] = x.yday</font>
<font color="red"> 623.         elif x.jyday is not None:</font>
<font color="red"> 624.             kwargs[&quot;nlyearday&quot;] = x.jyday</font>
<font color="red"> 625.         if not kwargs:</font>
<font color="black"> 626.             # Default is to start on first sunday of april, and end</font>
<font color="black"> 627.             # on last sunday of october.</font>
<font color="red"> 628.             if not isend:</font>
<font color="red"> 629.                 kwargs[&quot;month&quot;] = 4</font>
<font color="red"> 630.                 kwargs[&quot;day&quot;] = 1</font>
<font color="red"> 631.                 kwargs[&quot;weekday&quot;] = relativedelta.SU(+1)</font>
<font color="black"> 632.             else:</font>
<font color="red"> 633.                 kwargs[&quot;month&quot;] = 10</font>
<font color="red"> 634.                 kwargs[&quot;day&quot;] = 31</font>
<font color="red"> 635.                 kwargs[&quot;weekday&quot;] = relativedelta.SU(-1)</font>
<font color="red"> 636.         if x.time is not None:</font>
<font color="red"> 637.             kwargs[&quot;seconds&quot;] = x.time</font>
<font color="black"> 638.         else:</font>
<font color="black"> 639.             # Default is 2AM.</font>
<font color="red"> 640.             kwargs[&quot;seconds&quot;] = 7200</font>
<font color="red"> 641.         if isend:</font>
<font color="black"> 642.             # Convert to standard time, to follow the documented way</font>
<font color="black"> 643.             # of working with the extra hour. See the documentation</font>
<font color="black"> 644.             # of the tzinfo class.</font>
<font color="red"> 645.             delta = self._dst_offset-self._std_offset</font>
<font color="red"> 646.             kwargs[&quot;seconds&quot;] -= delta.seconds+delta.days*86400</font>
<font color="red"> 647.         return relativedelta.relativedelta(**kwargs)</font>
<font color="black"> 648. </font>
<font color="green"> 649.     def __repr__(self):</font>
<font color="red"> 650.         return &quot;%s(%s)&quot; % (self.__class__.__name__, repr(self._s))</font>
<font color="black"> 651. </font>
<font color="black"> 652. </font>
<font color="green"> 653. class _tzicalvtzcomp(object):</font>
<font color="black"> 654.     def __init__(self, tzoffsetfrom, tzoffsetto, isdst,</font>
<font color="green"> 655.                  tzname=None, rrule=None):</font>
<font color="red"> 656.         self.tzoffsetfrom = datetime.timedelta(seconds=tzoffsetfrom)</font>
<font color="red"> 657.         self.tzoffsetto = datetime.timedelta(seconds=tzoffsetto)</font>
<font color="red"> 658.         self.tzoffsetdiff = self.tzoffsetto-self.tzoffsetfrom</font>
<font color="red"> 659.         self.isdst = isdst</font>
<font color="red"> 660.         self.tzname = tzname</font>
<font color="red"> 661.         self.rrule = rrule</font>
<font color="black"> 662. </font>
<font color="black"> 663. </font>
<font color="green"> 664. class _tzicalvtz(datetime.tzinfo):</font>
<font color="green"> 665.     def __init__(self, tzid, comps=[]):</font>
<font color="red"> 666.         self._tzid = tzid</font>
<font color="red"> 667.         self._comps = comps</font>
<font color="red"> 668.         self._cachedate = []</font>
<font color="red"> 669.         self._cachecomp = []</font>
<font color="black"> 670. </font>
<font color="green"> 671.     def _find_comp(self, dt):</font>
<font color="red"> 672.         if len(self._comps) == 1:</font>
<font color="red"> 673.             return self._comps[0]</font>
<font color="red"> 674.         dt = dt.replace(tzinfo=None)</font>
<font color="red"> 675.         try:</font>
<font color="red"> 676.             return self._cachecomp[self._cachedate.index(dt)]</font>
<font color="red"> 677.         except ValueError:</font>
<font color="red"> 678.             pass</font>
<font color="red"> 679.         lastcomp = None</font>
<font color="red"> 680.         lastcompdt = None</font>
<font color="red"> 681.         for comp in self._comps:</font>
<font color="red"> 682.             if not comp.isdst:</font>
<font color="black"> 683.                 # Handle the extra hour in DST -&gt; STD</font>
<font color="red"> 684.                 compdt = comp.rrule.before(dt-comp.tzoffsetdiff, inc=True)</font>
<font color="black"> 685.             else:</font>
<font color="red"> 686.                 compdt = comp.rrule.before(dt, inc=True)</font>
<font color="red"> 687.             if compdt and (not lastcompdt or lastcompdt &lt; compdt):</font>
<font color="red"> 688.                 lastcompdt = compdt</font>
<font color="red"> 689.                 lastcomp = comp</font>
<font color="red"> 690.         if not lastcomp:</font>
<font color="black"> 691.             # RFC says nothing about what to do when a given</font>
<font color="black"> 692.             # time is before the first onset date. We'll look for the</font>
<font color="black"> 693.             # first standard component, or the first component, if</font>
<font color="black"> 694.             # none is found.</font>
<font color="red"> 695.             for comp in self._comps:</font>
<font color="red"> 696.                 if not comp.isdst:</font>
<font color="red"> 697.                     lastcomp = comp</font>
<font color="red"> 698.                     break</font>
<font color="black"> 699.             else:</font>
<font color="red"> 700.                 lastcomp = comp[0]</font>
<font color="red"> 701.         self._cachedate.insert(0, dt)</font>
<font color="red"> 702.         self._cachecomp.insert(0, lastcomp)</font>
<font color="red"> 703.         if len(self._cachedate) &gt; 10:</font>
<font color="red"> 704.             self._cachedate.pop()</font>
<font color="red"> 705.             self._cachecomp.pop()</font>
<font color="red"> 706.         return lastcomp</font>
<font color="black"> 707. </font>
<font color="green"> 708.     def utcoffset(self, dt):</font>
<font color="red"> 709.         if dt is None:</font>
<font color="red"> 710.             return None</font>
<font color="black"> 711. </font>
<font color="red"> 712.         return self._find_comp(dt).tzoffsetto</font>
<font color="black"> 713. </font>
<font color="green"> 714.     def dst(self, dt):</font>
<font color="red"> 715.         comp = self._find_comp(dt)</font>
<font color="red"> 716.         if comp.isdst:</font>
<font color="red"> 717.             return comp.tzoffsetdiff</font>
<font color="black"> 718.         else:</font>
<font color="red"> 719.             return ZERO</font>
<font color="black"> 720. </font>
<font color="green"> 721.     @tzname_in_python2</font>
<font color="black"> 722.     def tzname(self, dt):</font>
<font color="red"> 723.         return self._find_comp(dt).tzname</font>
<font color="black"> 724. </font>
<font color="green"> 725.     def __repr__(self):</font>
<font color="red"> 726.         return &quot;&lt;tzicalvtz %s&gt;&quot; % repr(self._tzid)</font>
<font color="black"> 727. </font>
<font color="green"> 728.     __reduce__ = object.__reduce__</font>
<font color="black"> 729. </font>
<font color="black"> 730. </font>
<font color="green"> 731. class tzical(object):</font>
<font color="green"> 732.     def __init__(self, fileobj):</font>
<font color="black"> 733.         global rrule</font>
<font color="red"> 734.         if not rrule:</font>
<font color="red"> 735.             from dateutil import rrule</font>
<font color="black"> 736. </font>
<font color="red"> 737.         if isinstance(fileobj, string_types):</font>
<font color="red"> 738.             self._s = fileobj</font>
<font color="black"> 739.             # ical should be encoded in UTF-8 with CRLF</font>
<font color="red"> 740.             fileobj = open(fileobj, 'r')</font>
<font color="red"> 741.         elif hasattr(fileobj, &quot;name&quot;):</font>
<font color="red"> 742.             self._s = fileobj.name</font>
<font color="black"> 743.         else:</font>
<font color="red"> 744.             self._s = repr(fileobj)</font>
<font color="black"> 745. </font>
<font color="red"> 746.         self._vtz = {}</font>
<font color="black"> 747. </font>
<font color="red"> 748.         self._parse_rfc(fileobj.read())</font>
<font color="black"> 749. </font>
<font color="green"> 750.     def keys(self):</font>
<font color="red"> 751.         return list(self._vtz.keys())</font>
<font color="black"> 752. </font>
<font color="green"> 753.     def get(self, tzid=None):</font>
<font color="red"> 754.         if tzid is None:</font>
<font color="red"> 755.             keys = list(self._vtz.keys())</font>
<font color="red"> 756.             if len(keys) == 0:</font>
<font color="red"> 757.                 raise ValueError(&quot;no timezones defined&quot;)</font>
<font color="red"> 758.             elif len(keys) &gt; 1:</font>
<font color="red"> 759.                 raise ValueError(&quot;more than one timezone available&quot;)</font>
<font color="red"> 760.             tzid = keys[0]</font>
<font color="red"> 761.         return self._vtz.get(tzid)</font>
<font color="black"> 762. </font>
<font color="green"> 763.     def _parse_offset(self, s):</font>
<font color="red"> 764.         s = s.strip()</font>
<font color="red"> 765.         if not s:</font>
<font color="red"> 766.             raise ValueError(&quot;empty offset&quot;)</font>
<font color="red"> 767.         if s[0] in ('+', '-'):</font>
<font color="red"> 768.             signal = (-1, +1)[s[0] == '+']</font>
<font color="red"> 769.             s = s[1:]</font>
<font color="black"> 770.         else:</font>
<font color="red"> 771.             signal = +1</font>
<font color="red"> 772.         if len(s) == 4:</font>
<font color="red"> 773.             return (int(s[:2])*3600+int(s[2:])*60)*signal</font>
<font color="red"> 774.         elif len(s) == 6:</font>
<font color="red"> 775.             return (int(s[:2])*3600+int(s[2:4])*60+int(s[4:]))*signal</font>
<font color="black"> 776.         else:</font>
<font color="red"> 777.             raise ValueError(&quot;invalid offset: &quot;+s)</font>
<font color="black"> 778. </font>
<font color="green"> 779.     def _parse_rfc(self, s):</font>
<font color="red"> 780.         lines = s.splitlines()</font>
<font color="red"> 781.         if not lines:</font>
<font color="red"> 782.             raise ValueError(&quot;empty string&quot;)</font>
<font color="black"> 783. </font>
<font color="black"> 784.         # Unfold</font>
<font color="red"> 785.         i = 0</font>
<font color="red"> 786.         while i &lt; len(lines):</font>
<font color="red"> 787.             line = lines[i].rstrip()</font>
<font color="red"> 788.             if not line:</font>
<font color="red"> 789.                 del lines[i]</font>
<font color="red"> 790.             elif i &gt; 0 and line[0] == &quot; &quot;:</font>
<font color="red"> 791.                 lines[i-1] += line[1:]</font>
<font color="red"> 792.                 del lines[i]</font>
<font color="black"> 793.             else:</font>
<font color="red"> 794.                 i += 1</font>
<font color="black"> 795. </font>
<font color="red"> 796.         tzid = None</font>
<font color="red"> 797.         comps = []</font>
<font color="red"> 798.         invtz = False</font>
<font color="red"> 799.         comptype = None</font>
<font color="red"> 800.         for line in lines:</font>
<font color="red"> 801.             if not line:</font>
<font color="red"> 802.                 continue</font>
<font color="red"> 803.             name, value = line.split(':', 1)</font>
<font color="red"> 804.             parms = name.split(';')</font>
<font color="red"> 805.             if not parms:</font>
<font color="red"> 806.                 raise ValueError(&quot;empty property name&quot;)</font>
<font color="red"> 807.             name = parms[0].upper()</font>
<font color="red"> 808.             parms = parms[1:]</font>
<font color="red"> 809.             if invtz:</font>
<font color="red"> 810.                 if name == &quot;BEGIN&quot;:</font>
<font color="red"> 811.                     if value in (&quot;STANDARD&quot;, &quot;DAYLIGHT&quot;):</font>
<font color="black"> 812.                         # Process component</font>
<font color="red"> 813.                         pass</font>
<font color="black"> 814.                     else:</font>
<font color="red"> 815.                         raise ValueError(&quot;unknown component: &quot;+value)</font>
<font color="red"> 816.                     comptype = value</font>
<font color="red"> 817.                     founddtstart = False</font>
<font color="red"> 818.                     tzoffsetfrom = None</font>
<font color="red"> 819.                     tzoffsetto = None</font>
<font color="red"> 820.                     rrulelines = []</font>
<font color="red"> 821.                     tzname = None</font>
<font color="red"> 822.                 elif name == &quot;END&quot;:</font>
<font color="red"> 823.                     if value == &quot;VTIMEZONE&quot;:</font>
<font color="red"> 824.                         if comptype:</font>
<font color="red"> 825.                             raise ValueError(&quot;component not closed: &quot;+comptype)</font>
<font color="red"> 826.                         if not tzid:</font>
<font color="red"> 827.                             raise ValueError(&quot;mandatory TZID not found&quot;)</font>
<font color="red"> 828.                         if not comps:</font>
<font color="red"> 829.                             raise ValueError(</font>
<font color="red"> 830.                                 &quot;at least one component is needed&quot;)</font>
<font color="black"> 831.                         # Process vtimezone</font>
<font color="red"> 832.                         self._vtz[tzid] = _tzicalvtz(tzid, comps)</font>
<font color="red"> 833.                         invtz = False</font>
<font color="red"> 834.                     elif value == comptype:</font>
<font color="red"> 835.                         if not founddtstart:</font>
<font color="red"> 836.                             raise ValueError(&quot;mandatory DTSTART not found&quot;)</font>
<font color="red"> 837.                         if tzoffsetfrom is None:</font>
<font color="red"> 838.                             raise ValueError(</font>
<font color="red"> 839.                                 &quot;mandatory TZOFFSETFROM not found&quot;)</font>
<font color="red"> 840.                         if tzoffsetto is None:</font>
<font color="red"> 841.                             raise ValueError(</font>
<font color="red"> 842.                                 &quot;mandatory TZOFFSETFROM not found&quot;)</font>
<font color="black"> 843.                         # Process component</font>
<font color="red"> 844.                         rr = None</font>
<font color="red"> 845.                         if rrulelines:</font>
<font color="red"> 846.                             rr = rrule.rrulestr(&quot;\n&quot;.join(rrulelines),</font>
<font color="red"> 847.                                                 compatible=True,</font>
<font color="red"> 848.                                                 ignoretz=True,</font>
<font color="red"> 849.                                                 cache=True)</font>
<font color="red"> 850.                         comp = _tzicalvtzcomp(tzoffsetfrom, tzoffsetto,</font>
<font color="red"> 851.                                               (comptype == &quot;DAYLIGHT&quot;),</font>
<font color="red"> 852.                                               tzname, rr)</font>
<font color="red"> 853.                         comps.append(comp)</font>
<font color="red"> 854.                         comptype = None</font>
<font color="black"> 855.                     else:</font>
<font color="red"> 856.                         raise ValueError(&quot;invalid component end: &quot;+value)</font>
<font color="red"> 857.                 elif comptype:</font>
<font color="red"> 858.                     if name == &quot;DTSTART&quot;:</font>
<font color="red"> 859.                         rrulelines.append(line)</font>
<font color="red"> 860.                         founddtstart = True</font>
<font color="red"> 861.                     elif name in (&quot;RRULE&quot;, &quot;RDATE&quot;, &quot;EXRULE&quot;, &quot;EXDATE&quot;):</font>
<font color="red"> 862.                         rrulelines.append(line)</font>
<font color="red"> 863.                     elif name == &quot;TZOFFSETFROM&quot;:</font>
<font color="red"> 864.                         if parms:</font>
<font color="red"> 865.                             raise ValueError(</font>
<font color="red"> 866.                                 &quot;unsupported %s parm: %s &quot; % (name, parms[0]))</font>
<font color="red"> 867.                         tzoffsetfrom = self._parse_offset(value)</font>
<font color="red"> 868.                     elif name == &quot;TZOFFSETTO&quot;:</font>
<font color="red"> 869.                         if parms:</font>
<font color="red"> 870.                             raise ValueError(</font>
<font color="red"> 871.                                 &quot;unsupported TZOFFSETTO parm: &quot;+parms[0])</font>
<font color="red"> 872.                         tzoffsetto = self._parse_offset(value)</font>
<font color="red"> 873.                     elif name == &quot;TZNAME&quot;:</font>
<font color="red"> 874.                         if parms:</font>
<font color="red"> 875.                             raise ValueError(</font>
<font color="red"> 876.                                 &quot;unsupported TZNAME parm: &quot;+parms[0])</font>
<font color="red"> 877.                         tzname = value</font>
<font color="red"> 878.                     elif name == &quot;COMMENT&quot;:</font>
<font color="red"> 879.                         pass</font>
<font color="black"> 880.                     else:</font>
<font color="red"> 881.                         raise ValueError(&quot;unsupported property: &quot;+name)</font>
<font color="black"> 882.                 else:</font>
<font color="red"> 883.                     if name == &quot;TZID&quot;:</font>
<font color="red"> 884.                         if parms:</font>
<font color="red"> 885.                             raise ValueError(</font>
<font color="red"> 886.                                 &quot;unsupported TZID parm: &quot;+parms[0])</font>
<font color="red"> 887.                         tzid = value</font>
<font color="red"> 888.                     elif name in (&quot;TZURL&quot;, &quot;LAST-MODIFIED&quot;, &quot;COMMENT&quot;):</font>
<font color="red"> 889.                         pass</font>
<font color="black"> 890.                     else:</font>
<font color="red"> 891.                         raise ValueError(&quot;unsupported property: &quot;+name)</font>
<font color="red"> 892.             elif name == &quot;BEGIN&quot; and value == &quot;VTIMEZONE&quot;:</font>
<font color="red"> 893.                 tzid = None</font>
<font color="red"> 894.                 comps = []</font>
<font color="red"> 895.                 invtz = True</font>
<font color="black"> 896. </font>
<font color="green"> 897.     def __repr__(self):</font>
<font color="red"> 898.         return &quot;%s(%s)&quot; % (self.__class__.__name__, repr(self._s))</font>
<font color="black"> 899. </font>
<font color="green"> 900. if sys.platform != &quot;win32&quot;:</font>
<font color="green"> 901.     TZFILES = [&quot;/etc/localtime&quot;, &quot;localtime&quot;]</font>
<font color="green"> 902.     TZPATHS = [&quot;/usr/share/zoneinfo&quot;, &quot;/usr/lib/zoneinfo&quot;, &quot;/etc/zoneinfo&quot;]</font>
<font color="black"> 903. else:</font>
<font color="red"> 904.     TZFILES = []</font>
<font color="red"> 905.     TZPATHS = []</font>
<font color="black"> 906. </font>
<font color="black"> 907. </font>
<font color="green"> 908. def gettz(name=None):</font>
<font color="red"> 909.     tz = None</font>
<font color="red"> 910.     if not name:</font>
<font color="red"> 911.         try:</font>
<font color="red"> 912.             name = os.environ[&quot;TZ&quot;]</font>
<font color="red"> 913.         except KeyError:</font>
<font color="red"> 914.             pass</font>
<font color="red"> 915.     if name is None or name == &quot;:&quot;:</font>
<font color="red"> 916.         for filepath in TZFILES:</font>
<font color="red"> 917.             if not os.path.isabs(filepath):</font>
<font color="red"> 918.                 filename = filepath</font>
<font color="red"> 919.                 for path in TZPATHS:</font>
<font color="red"> 920.                     filepath = os.path.join(path, filename)</font>
<font color="red"> 921.                     if os.path.isfile(filepath):</font>
<font color="red"> 922.                         break</font>
<font color="black"> 923.                 else:</font>
<font color="red"> 924.                     continue</font>
<font color="red"> 925.             if os.path.isfile(filepath):</font>
<font color="red"> 926.                 try:</font>
<font color="red"> 927.                     tz = tzfile(filepath)</font>
<font color="red"> 928.                     break</font>
<font color="red"> 929.                 except (IOError, OSError, ValueError):</font>
<font color="red"> 930.                     pass</font>
<font color="black"> 931.         else:</font>
<font color="red"> 932.             tz = tzlocal()</font>
<font color="black"> 933.     else:</font>
<font color="red"> 934.         if name.startswith(&quot;:&quot;):</font>
<font color="red"> 935.             name = name[:-1]</font>
<font color="red"> 936.         if os.path.isabs(name):</font>
<font color="red"> 937.             if os.path.isfile(name):</font>
<font color="red"> 938.                 tz = tzfile(name)</font>
<font color="black"> 939.             else:</font>
<font color="red"> 940.                 tz = None</font>
<font color="black"> 941.         else:</font>
<font color="red"> 942.             for path in TZPATHS:</font>
<font color="red"> 943.                 filepath = os.path.join(path, name)</font>
<font color="red"> 944.                 if not os.path.isfile(filepath):</font>
<font color="red"> 945.                     filepath = filepath.replace(' ', '_')</font>
<font color="red"> 946.                     if not os.path.isfile(filepath):</font>
<font color="red"> 947.                         continue</font>
<font color="red"> 948.                 try:</font>
<font color="red"> 949.                     tz = tzfile(filepath)</font>
<font color="red"> 950.                     break</font>
<font color="red"> 951.                 except (IOError, OSError, ValueError):</font>
<font color="red"> 952.                     pass</font>
<font color="black"> 953.             else:</font>
<font color="red"> 954.                 tz = None</font>
<font color="red"> 955.                 if tzwin is not None:</font>
<font color="red"> 956.                     try:</font>
<font color="red"> 957.                         tz = tzwin(name)</font>
<font color="red"> 958.                     except WindowsError:</font>
<font color="red"> 959.                         tz = None</font>
<font color="red"> 960.                 if not tz:</font>
<font color="red"> 961.                     from dateutil.zoneinfo import gettz</font>
<font color="red"> 962.                     tz = gettz(name)</font>
<font color="red"> 963.                 if not tz:</font>
<font color="red"> 964.                     for c in name:</font>
<font color="black"> 965.                         # name must have at least one offset to be a tzstr</font>
<font color="red"> 966.                         if c in &quot;0123456789&quot;:</font>
<font color="red"> 967.                             try:</font>
<font color="red"> 968.                                 tz = tzstr(name)</font>
<font color="red"> 969.                             except ValueError:</font>
<font color="red"> 970.                                 pass</font>
<font color="red"> 971.                             break</font>
<font color="black"> 972.                     else:</font>
<font color="red"> 973.                         if name in (&quot;GMT&quot;, &quot;UTC&quot;):</font>
<font color="red"> 974.                             tz = tzutc()</font>
<font color="red"> 975.                         elif name in time.tzname:</font>
<font color="red"> 976.                             tz = tzlocal()</font>
<font color="red"> 977.     return tz</font>
<font color="black"> 978. </font>
<font color="black"> 979. # vim:ts=4:sw=4:et</font>
</pre>

