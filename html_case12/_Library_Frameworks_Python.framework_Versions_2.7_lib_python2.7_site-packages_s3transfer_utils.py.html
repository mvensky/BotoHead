source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/s3transfer/utils.py</b><br>


file stats: <b>348 lines, 97 executed: 27.9% covered</b>
<pre>
<font color="black">   1. # Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="green">  13. import random</font>
<font color="green">  14. import time</font>
<font color="green">  15. import functools</font>
<font color="green">  16. import math</font>
<font color="green">  17. import os</font>
<font color="green">  18. import stat</font>
<font color="green">  19. import string</font>
<font color="green">  20. import logging</font>
<font color="green">  21. import threading</font>
<font color="green">  22. import io</font>
<font color="green">  23. from collections import defaultdict</font>
<font color="black">  24. </font>
<font color="green">  25. from s3transfer.compat import rename_file</font>
<font color="green">  26. from s3transfer.compat import seekable</font>
<font color="black">  27. </font>
<font color="black">  28. </font>
<font color="green">  29. MAX_PARTS = 10000</font>
<font color="black">  30. # The maximum file size you can upload via S3 per request.</font>
<font color="black">  31. # See: http://docs.aws.amazon.com/AmazonS3/latest/dev/UploadingObjects.html</font>
<font color="black">  32. # and: http://docs.aws.amazon.com/AmazonS3/latest/dev/qfacts.html</font>
<font color="green">  33. MAX_SINGLE_UPLOAD_SIZE = 5 * (1024 ** 3)</font>
<font color="green">  34. MIN_UPLOAD_CHUNKSIZE = 5 * (1024 ** 2)</font>
<font color="green">  35. logger = logging.getLogger(__name__)</font>
<font color="black">  36. </font>
<font color="black">  37. </font>
<font color="green">  38. def random_file_extension(num_digits=8):</font>
<font color="red">  39.     return ''.join(random.choice(string.hexdigits) for _ in range(num_digits))</font>
<font color="black">  40. </font>
<font color="black">  41. </font>
<font color="green">  42. def signal_not_transferring(request, operation_name, **kwargs):</font>
<font color="red">  43.     if operation_name in ['PutObject', 'UploadPart'] and \</font>
<font color="red">  44.             hasattr(request.body, 'signal_not_transferring'):</font>
<font color="red">  45.         request.body.signal_not_transferring()</font>
<font color="black">  46. </font>
<font color="black">  47. </font>
<font color="green">  48. def signal_transferring(request, operation_name, **kwargs):</font>
<font color="red">  49.     if operation_name in ['PutObject', 'UploadPart'] and \</font>
<font color="red">  50.             hasattr(request.body, 'signal_transferring'):</font>
<font color="red">  51.         request.body.signal_transferring()</font>
<font color="black">  52. </font>
<font color="black">  53. </font>
<font color="black">  54. def calculate_range_parameter(part_size, part_index, num_parts,</font>
<font color="green">  55.                               total_size=None):</font>
<font color="black">  56.     &quot;&quot;&quot;Calculate the range parameter for multipart downloads/copies</font>
<font color="black">  57. </font>
<font color="black">  58.     :type part_size: int</font>
<font color="black">  59.     :param part_size: The size of the part</font>
<font color="black">  60. </font>
<font color="black">  61.     :type part_index: int</font>
<font color="black">  62.     :param part_index: The index for which this parts starts. This index starts</font>
<font color="black">  63.         at zero</font>
<font color="black">  64. </font>
<font color="black">  65.     :type num_parts: int</font>
<font color="black">  66.     :param num_parts: The total number of parts in the transfer</font>
<font color="black">  67. </font>
<font color="black">  68.     :returns: The value to use for Range parameter on downloads or</font>
<font color="black">  69.         the CopySourceRange parameter for copies</font>
<font color="black">  70.     &quot;&quot;&quot;</font>
<font color="black">  71.     # Used to calculate the Range parameter</font>
<font color="red">  72.     start_range = part_index * part_size</font>
<font color="red">  73.     if part_index == num_parts - 1:</font>
<font color="red">  74.         end_range = ''</font>
<font color="red">  75.         if total_size is not None:</font>
<font color="red">  76.             end_range = str(total_size - 1)</font>
<font color="black">  77.     else:</font>
<font color="red">  78.         end_range = start_range + part_size - 1</font>
<font color="red">  79.     range_param = 'bytes=%s-%s' % (start_range, end_range)</font>
<font color="red">  80.     return range_param</font>
<font color="black">  81. </font>
<font color="black">  82. </font>
<font color="green">  83. def get_callbacks(transfer_future, callback_type):</font>
<font color="black">  84.     &quot;&quot;&quot;Retrieves callbacks from a subscriber</font>
<font color="black">  85. </font>
<font color="black">  86.     :type transfer_future: s3transfer.futures.TransferFuture</font>
<font color="black">  87.     :param transfer_future: The transfer future the subscriber is associated</font>
<font color="black">  88.         to.</font>
<font color="black">  89. </font>
<font color="black">  90.     :type callback_type: str</font>
<font color="black">  91.     :param callback_type: The type of callback to retrieve from the subscriber.</font>
<font color="black">  92.         Valid types include:</font>
<font color="black">  93.             * 'queued'</font>
<font color="black">  94.             * 'progress'</font>
<font color="black">  95.             * 'done'</font>
<font color="black">  96. </font>
<font color="black">  97.     :returns: A list of callbacks for the type specified. All callbacks are</font>
<font color="black">  98.         preinjected with the transfer future.</font>
<font color="black">  99.     &quot;&quot;&quot;</font>
<font color="red"> 100.     callbacks = []</font>
<font color="red"> 101.     for subscriber in transfer_future.meta.call_args.subscribers:</font>
<font color="red"> 102.         callback_name = 'on_' + callback_type</font>
<font color="red"> 103.         if hasattr(subscriber, callback_name):</font>
<font color="red"> 104.             callbacks.append(</font>
<font color="red"> 105.                 functools.partial(</font>
<font color="red"> 106.                     getattr(subscriber, callback_name),</font>
<font color="red"> 107.                     future=transfer_future</font>
<font color="black"> 108.                 )</font>
<font color="black"> 109.             )</font>
<font color="red"> 110.     return callbacks</font>
<font color="black"> 111. </font>
<font color="black"> 112. </font>
<font color="green"> 113. def invoke_progress_callbacks(callbacks, bytes_transferred):</font>
<font color="black"> 114.     &quot;&quot;&quot;Calls all progress callbacks</font>
<font color="black"> 115. </font>
<font color="black"> 116.     :param callbacks: A list of progress callbacks to invoke</font>
<font color="black"> 117.     :param bytes_transferred: The number of bytes transferred. This is passed</font>
<font color="black"> 118.         to the callbacks. If no bytes were transferred the callbacks will not</font>
<font color="black"> 119.         be invoked because no progress was achieved. It is also possible</font>
<font color="black"> 120.         to receive a negative amount which comes from retrying a transfer</font>
<font color="black"> 121.         request.</font>
<font color="black"> 122.     &quot;&quot;&quot;</font>
<font color="black"> 123.     # Only invoke the callbacks if bytes were actually transferred.</font>
<font color="red"> 124.     if bytes_transferred:</font>
<font color="red"> 125.         for callback in callbacks:</font>
<font color="red"> 126.             callback(bytes_transferred=bytes_transferred)</font>
<font color="black"> 127. </font>
<font color="black"> 128. </font>
<font color="green"> 129. def get_filtered_dict(original_dict, whitelisted_keys):</font>
<font color="black"> 130.     &quot;&quot;&quot;Gets a dictionary filtered by whitelisted keys</font>
<font color="black"> 131. </font>
<font color="black"> 132.     :param original_dict: The original dictionary of arguments to source keys</font>
<font color="black"> 133.         and values.</font>
<font color="black"> 134.     :param whitelisted_key: A list of keys to include in the filtered</font>
<font color="black"> 135.         dictionary.</font>
<font color="black"> 136. </font>
<font color="black"> 137.     :returns: A dictionary containing key/values from the original dictionary</font>
<font color="black"> 138.         whose key was included in the whitelist</font>
<font color="black"> 139.     &quot;&quot;&quot;</font>
<font color="red"> 140.     filtered_dict = {}</font>
<font color="red"> 141.     for key, value in original_dict.items():</font>
<font color="red"> 142.         if key in whitelisted_keys:</font>
<font color="red"> 143.             filtered_dict[key] = value</font>
<font color="red"> 144.     return filtered_dict</font>
<font color="black"> 145. </font>
<font color="black"> 146. </font>
<font color="green"> 147. class CallArgs(object):</font>
<font color="green"> 148.     def __init__(self, **kwargs):</font>
<font color="black"> 149.         &quot;&quot;&quot;A class that records call arguments</font>
<font color="black"> 150. </font>
<font color="black"> 151.         The call arguments must be passed as keyword arguments. It will set</font>
<font color="black"> 152.         each keyword argument as an attribute of the object along with its</font>
<font color="black"> 153.         associated value.</font>
<font color="black"> 154.         &quot;&quot;&quot;</font>
<font color="red"> 155.         for arg, value in kwargs.items():</font>
<font color="red"> 156.             setattr(self, arg, value)</font>
<font color="black"> 157. </font>
<font color="black"> 158. </font>
<font color="green"> 159. class FunctionContainer(object):</font>
<font color="black"> 160.     &quot;&quot;&quot;An object that contains a function and any args or kwargs to call it</font>
<font color="black"> 161. </font>
<font color="black"> 162.     When called the provided function will be called with provided args</font>
<font color="black"> 163.     and kwargs.</font>
<font color="green"> 164.     &quot;&quot;&quot;</font>
<font color="green"> 165.     def __init__(self, func, *args, **kwargs):</font>
<font color="red"> 166.         self._func = func</font>
<font color="red"> 167.         self._args = args</font>
<font color="red"> 168.         self._kwargs = kwargs</font>
<font color="black"> 169. </font>
<font color="green"> 170.     def __repr__(self):</font>
<font color="red"> 171.         return 'Function: %s with args %s and kwargs %s' % (</font>
<font color="red"> 172.             self._func, self._args, self._kwargs)</font>
<font color="black"> 173. </font>
<font color="green"> 174.     def __call__(self):</font>
<font color="red"> 175.         return self._func(*self._args, **self._kwargs)</font>
<font color="black"> 176. </font>
<font color="black"> 177. </font>
<font color="green"> 178. class CountCallbackInvoker(object):</font>
<font color="black"> 179.     &quot;&quot;&quot;An abstraction to invoke a callback when a shared count reaches zero</font>
<font color="black"> 180. </font>
<font color="black"> 181.     :param callback: Callback invoke when finalized count reaches zero</font>
<font color="green"> 182.     &quot;&quot;&quot;</font>
<font color="green"> 183.     def __init__(self, callback):</font>
<font color="red"> 184.         self._lock = threading.Lock()</font>
<font color="red"> 185.         self._callback = callback</font>
<font color="red"> 186.         self._count = 0</font>
<font color="red"> 187.         self._is_finalized = False</font>
<font color="black"> 188. </font>
<font color="green"> 189.     @property</font>
<font color="black"> 190.     def current_count(self):</font>
<font color="red"> 191.         with self._lock:</font>
<font color="red"> 192.             return self._count</font>
<font color="black"> 193. </font>
<font color="green"> 194.     def increment(self):</font>
<font color="black"> 195.         &quot;&quot;&quot;Increment the count by one&quot;&quot;&quot;</font>
<font color="red"> 196.         with self._lock:</font>
<font color="red"> 197.             if self._is_finalized:</font>
<font color="red"> 198.                 raise RuntimeError(</font>
<font color="red"> 199.                     'Counter has been finalized it can no longer be '</font>
<font color="black"> 200.                     'incremented.'</font>
<font color="black"> 201.                 )</font>
<font color="red"> 202.             self._count += 1</font>
<font color="black"> 203. </font>
<font color="green"> 204.     def decrement(self):</font>
<font color="black"> 205.         &quot;&quot;&quot;Decrement the count by one&quot;&quot;&quot;</font>
<font color="red"> 206.         with self._lock:</font>
<font color="red"> 207.             if self._count == 0:</font>
<font color="red"> 208.                 raise RuntimeError(</font>
<font color="red"> 209.                     'Counter is at zero. It cannot dip below zero')</font>
<font color="red"> 210.             self._count -= 1</font>
<font color="red"> 211.             if self._is_finalized and self._count == 0:</font>
<font color="red"> 212.                 self._callback()</font>
<font color="black"> 213. </font>
<font color="green"> 214.     def finalize(self):</font>
<font color="black"> 215.         &quot;&quot;&quot;Finalize the counter</font>
<font color="black"> 216. </font>
<font color="black"> 217.         Once finalized, the counter never be incremented and the callback</font>
<font color="black"> 218.         can be invoked once the count reaches zero</font>
<font color="black"> 219.         &quot;&quot;&quot;</font>
<font color="red"> 220.         with self._lock:</font>
<font color="red"> 221.             self._is_finalized = True</font>
<font color="red"> 222.             if self._count == 0:</font>
<font color="red"> 223.                 self._callback()</font>
<font color="black"> 224. </font>
<font color="black"> 225. </font>
<font color="green"> 226. class OSUtils(object):</font>
<font color="green"> 227.     def get_file_size(self, filename):</font>
<font color="red"> 228.         return os.path.getsize(filename)</font>
<font color="black"> 229. </font>
<font color="green"> 230.     def open_file_chunk_reader(self, filename, start_byte, size, callbacks):</font>
<font color="red"> 231.         return ReadFileChunk.from_filename(filename, start_byte,</font>
<font color="red"> 232.                                            size, callbacks,</font>
<font color="red"> 233.                                            enable_callbacks=False)</font>
<font color="black"> 234. </font>
<font color="black"> 235.     def open_file_chunk_reader_from_fileobj(self, fileobj, chunk_size,</font>
<font color="black"> 236.                                             full_file_size, callbacks,</font>
<font color="green"> 237.                                             close_callbacks=None):</font>
<font color="red"> 238.         return ReadFileChunk(</font>
<font color="red"> 239.             fileobj, chunk_size, full_file_size,</font>
<font color="red"> 240.             callbacks=callbacks, enable_callbacks=False,</font>
<font color="red"> 241.             close_callbacks=close_callbacks)</font>
<font color="black"> 242. </font>
<font color="green"> 243.     def open(self, filename, mode):</font>
<font color="red"> 244.         return open(filename, mode)</font>
<font color="black"> 245. </font>
<font color="green"> 246.     def remove_file(self, filename):</font>
<font color="black"> 247.         &quot;&quot;&quot;Remove a file, noop if file does not exist.&quot;&quot;&quot;</font>
<font color="black"> 248.         # Unlike os.remove, if the file does not exist,</font>
<font color="black"> 249.         # then this method does nothing.</font>
<font color="red"> 250.         try:</font>
<font color="red"> 251.             os.remove(filename)</font>
<font color="red"> 252.         except OSError:</font>
<font color="red"> 253.             pass</font>
<font color="black"> 254. </font>
<font color="green"> 255.     def rename_file(self, current_filename, new_filename):</font>
<font color="red"> 256.         rename_file(current_filename, new_filename)</font>
<font color="black"> 257. </font>
<font color="green"> 258.     def is_special_file(cls, filename):</font>
<font color="black"> 259.         &quot;&quot;&quot;Checks to see if a file is a special UNIX file.</font>
<font color="black"> 260. </font>
<font color="black"> 261.         It checks if the file is a character special device, block special</font>
<font color="black"> 262.         device, FIFO, or socket.</font>
<font color="black"> 263. </font>
<font color="black"> 264.         :param filename: Name of the file</font>
<font color="black"> 265. </font>
<font color="black"> 266.         :returns: True if the file is a special file. False, if is not.</font>
<font color="black"> 267.         &quot;&quot;&quot;</font>
<font color="black"> 268.         # If it does not exist, it must be a new file so it cannot be</font>
<font color="black"> 269.         # a special file.</font>
<font color="red"> 270.         if not os.path.exists(filename):</font>
<font color="red"> 271.             return False</font>
<font color="red"> 272.         mode = os.stat(filename).st_mode</font>
<font color="black"> 273.         # Character special device.</font>
<font color="red"> 274.         if stat.S_ISCHR(mode):</font>
<font color="red"> 275.             return True</font>
<font color="black"> 276.         # Block special device</font>
<font color="red"> 277.         if stat.S_ISBLK(mode):</font>
<font color="red"> 278.             return True</font>
<font color="black"> 279.         # Named pipe / FIFO</font>
<font color="red"> 280.         if stat.S_ISFIFO(mode):</font>
<font color="red"> 281.             return True</font>
<font color="black"> 282.         # Socket.</font>
<font color="red"> 283.         if stat.S_ISSOCK(mode):</font>
<font color="red"> 284.             return True</font>
<font color="red"> 285.         return False</font>
<font color="black"> 286. </font>
<font color="black"> 287. </font>
<font color="green"> 288. class DeferredOpenFile(object):</font>
<font color="green"> 289.     def __init__(self, filename, start_byte=0, mode='rb', open_function=open):</font>
<font color="black"> 290.         &quot;&quot;&quot;A class that defers the opening of a file till needed</font>
<font color="black"> 291. </font>
<font color="black"> 292.         This is useful for deferring opening of a file till it is needed</font>
<font color="black"> 293.         in a separate thread, as there is a limit of how many open files</font>
<font color="black"> 294.         there can be in a single thread for most operating systems. The</font>
<font color="black"> 295.         file gets opened in the following methods: ``read()``, ``seek()``,</font>
<font color="black"> 296.         and ``__enter__()``</font>
<font color="black"> 297. </font>
<font color="black"> 298.         :type filename: str</font>
<font color="black"> 299.         :param filename: The name of the file to open</font>
<font color="black"> 300. </font>
<font color="black"> 301.         :type start_byte: int</font>
<font color="black"> 302.         :param start_byte: The byte to seek to when the file is opened.</font>
<font color="black"> 303. </font>
<font color="black"> 304.         :type mode: str</font>
<font color="black"> 305.         :param mode: The mode to use to open the file</font>
<font color="black"> 306. </font>
<font color="black"> 307.         :type open_function: function</font>
<font color="black"> 308.         :param open_function: The function to use to open the file</font>
<font color="black"> 309.         &quot;&quot;&quot;</font>
<font color="red"> 310.         self._filename = filename</font>
<font color="red"> 311.         self._fileobj = None</font>
<font color="red"> 312.         self._start_byte = start_byte</font>
<font color="red"> 313.         self._mode = mode</font>
<font color="red"> 314.         self._open_function = open_function</font>
<font color="black"> 315. </font>
<font color="green"> 316.     def _open_if_needed(self):</font>
<font color="red"> 317.         if self._fileobj is None:</font>
<font color="red"> 318.             self._fileobj = self._open_function(self._filename, self._mode)</font>
<font color="red"> 319.             if self._start_byte != 0:</font>
<font color="red"> 320.                 self._fileobj.seek(self._start_byte)</font>
<font color="black"> 321. </font>
<font color="green"> 322.     @property</font>
<font color="black"> 323.     def name(self):</font>
<font color="red"> 324.         return self._filename</font>
<font color="black"> 325. </font>
<font color="green"> 326.     def read(self, amount=None):</font>
<font color="red"> 327.         self._open_if_needed()</font>
<font color="red"> 328.         return self._fileobj.read(amount)</font>
<font color="black"> 329. </font>
<font color="green"> 330.     def write(self, data):</font>
<font color="red"> 331.         self._open_if_needed()</font>
<font color="red"> 332.         self._fileobj.write(data)</font>
<font color="black"> 333. </font>
<font color="green"> 334.     def seek(self, where):</font>
<font color="red"> 335.         self._open_if_needed()</font>
<font color="red"> 336.         self._fileobj.seek(where)</font>
<font color="black"> 337. </font>
<font color="green"> 338.     def tell(self):</font>
<font color="red"> 339.         if self._fileobj is None:</font>
<font color="red"> 340.             return self._start_byte</font>
<font color="red"> 341.         return self._fileobj.tell()</font>
<font color="black"> 342. </font>
<font color="green"> 343.     def close(self):</font>
<font color="red"> 344.         if self._fileobj:</font>
<font color="red"> 345.             self._fileobj.close()</font>
<font color="black"> 346. </font>
<font color="green"> 347.     def __enter__(self):</font>
<font color="red"> 348.         self._open_if_needed()</font>
<font color="red"> 349.         return self</font>
<font color="black"> 350. </font>
<font color="green"> 351.     def __exit__(self, *args, **kwargs):</font>
<font color="red"> 352.         self.close()</font>
<font color="black"> 353. </font>
<font color="black"> 354. </font>
<font color="green"> 355. class ReadFileChunk(object):</font>
<font color="black"> 356.     def __init__(self, fileobj, chunk_size, full_file_size,</font>
<font color="green"> 357.                  callbacks=None, enable_callbacks=True, close_callbacks=None):</font>
<font color="black"> 358.         &quot;&quot;&quot;</font>
<font color="black"> 359. </font>
<font color="black"> 360.         Given a file object shown below::</font>
<font color="black"> 361. </font>
<font color="black"> 362.             |___________________________________________________|</font>
<font color="black"> 363.             0          |                 |                 full_file_size</font>
<font color="black"> 364.                        |----chunk_size---|</font>
<font color="black"> 365.                     f.tell()</font>
<font color="black"> 366. </font>
<font color="black"> 367.         :type fileobj: file</font>
<font color="black"> 368.         :param fileobj: File like object</font>
<font color="black"> 369. </font>
<font color="black"> 370.         :type chunk_size: int</font>
<font color="black"> 371.         :param chunk_size: The max chunk size to read.  Trying to read</font>
<font color="black"> 372.             pass the end of the chunk size will behave like you've</font>
<font color="black"> 373.             reached the end of the file.</font>
<font color="black"> 374. </font>
<font color="black"> 375.         :type full_file_size: int</font>
<font color="black"> 376.         :param full_file_size: The entire content length associated</font>
<font color="black"> 377.             with ``fileobj``.</font>
<font color="black"> 378. </font>
<font color="black"> 379.         :type callbacks: A list of function(amount_read)</font>
<font color="black"> 380.         :param callbacks: Called whenever data is read from this object in the</font>
<font color="black"> 381.             order provided.</font>
<font color="black"> 382. </font>
<font color="black"> 383.         :type enable_callbacks: boolean</font>
<font color="black"> 384.         :param enable_callbacks: True if to run callbacks. Otherwise, do not</font>
<font color="black"> 385.             run callbacks</font>
<font color="black"> 386. </font>
<font color="black"> 387.         :type close_callbacks: A list of function()</font>
<font color="black"> 388.         :param close_callbacks: Called when close is called. The function</font>
<font color="black"> 389.             should take no arguments.</font>
<font color="black"> 390.         &quot;&quot;&quot;</font>
<font color="red"> 391.         self._fileobj = fileobj</font>
<font color="red"> 392.         self._start_byte = self._fileobj.tell()</font>
<font color="red"> 393.         self._size = self._calculate_file_size(</font>
<font color="red"> 394.             self._fileobj, requested_size=chunk_size,</font>
<font color="red"> 395.             start_byte=self._start_byte, actual_file_size=full_file_size)</font>
<font color="red"> 396.         self._amount_read = 0</font>
<font color="red"> 397.         self._callbacks = callbacks</font>
<font color="red"> 398.         if callbacks is None:</font>
<font color="red"> 399.             self._callbacks = []</font>
<font color="red"> 400.         self._callbacks_enabled = enable_callbacks</font>
<font color="red"> 401.         self._close_callbacks = close_callbacks</font>
<font color="red"> 402.         if close_callbacks is None:</font>
<font color="red"> 403.             self._close_callbacks = close_callbacks</font>
<font color="black"> 404. </font>
<font color="green"> 405.     @classmethod</font>
<font color="green"> 406.     def from_filename(cls, filename, start_byte, chunk_size, callbacks=None,</font>
<font color="green"> 407.                       enable_callbacks=True):</font>
<font color="black"> 408.         &quot;&quot;&quot;Convenience factory function to create from a filename.</font>
<font color="black"> 409. </font>
<font color="black"> 410.         :type start_byte: int</font>
<font color="black"> 411.         :param start_byte: The first byte from which to start reading.</font>
<font color="black"> 412. </font>
<font color="black"> 413.         :type chunk_size: int</font>
<font color="black"> 414.         :param chunk_size: The max chunk size to read.  Trying to read</font>
<font color="black"> 415.             pass the end of the chunk size will behave like you've</font>
<font color="black"> 416.             reached the end of the file.</font>
<font color="black"> 417. </font>
<font color="black"> 418.         :type full_file_size: int</font>
<font color="black"> 419.         :param full_file_size: The entire content length associated</font>
<font color="black"> 420.             with ``fileobj``.</font>
<font color="black"> 421. </font>
<font color="black"> 422.         :type callbacks: function(amount_read)</font>
<font color="black"> 423.         :param callbacks: Called whenever data is read from this object.</font>
<font color="black"> 424. </font>
<font color="black"> 425.         :type enable_callbacks: bool</font>
<font color="black"> 426.         :param enable_callbacks: Indicate whether to invoke callback</font>
<font color="black"> 427.             during read() calls.</font>
<font color="black"> 428. </font>
<font color="black"> 429.         :rtype: ``ReadFileChunk``</font>
<font color="black"> 430.         :return: A new instance of ``ReadFileChunk``</font>
<font color="black"> 431. </font>
<font color="black"> 432.         &quot;&quot;&quot;</font>
<font color="red"> 433.         f = open(filename, 'rb')</font>
<font color="red"> 434.         f.seek(start_byte)</font>
<font color="red"> 435.         file_size = os.fstat(f.fileno()).st_size</font>
<font color="red"> 436.         return cls(f, chunk_size, file_size, callbacks, enable_callbacks)</font>
<font color="black"> 437. </font>
<font color="green"> 438.     def _calculate_file_size(self, fileobj, requested_size, start_byte,</font>
<font color="black"> 439.                              actual_file_size):</font>
<font color="red"> 440.         max_chunk_size = actual_file_size - start_byte</font>
<font color="red"> 441.         return min(max_chunk_size, requested_size)</font>
<font color="black"> 442. </font>
<font color="green"> 443.     def read(self, amount=None):</font>
<font color="red"> 444.         if amount is None:</font>
<font color="red"> 445.             amount_to_read = self._size - self._amount_read</font>
<font color="black"> 446.         else:</font>
<font color="red"> 447.             amount_to_read = min(self._size - self._amount_read, amount)</font>
<font color="red"> 448.         data = self._fileobj.read(amount_to_read)</font>
<font color="red"> 449.         self._amount_read += len(data)</font>
<font color="red"> 450.         if self._callbacks is not None and self._callbacks_enabled:</font>
<font color="red"> 451.             invoke_progress_callbacks(self._callbacks, len(data))</font>
<font color="red"> 452.         return data</font>
<font color="black"> 453. </font>
<font color="green"> 454.     def signal_transferring(self):</font>
<font color="red"> 455.         self.enable_callback()</font>
<font color="red"> 456.         if hasattr(self._fileobj, 'signal_transferring'):</font>
<font color="red"> 457.             self._fileobj.signal_transferring()</font>
<font color="black"> 458. </font>
<font color="green"> 459.     def signal_not_transferring(self):</font>
<font color="red"> 460.         self.disable_callback()</font>
<font color="red"> 461.         if hasattr(self._fileobj, 'signal_not_transferring'):</font>
<font color="red"> 462.             self._fileobj.signal_not_transferring()</font>
<font color="black"> 463. </font>
<font color="green"> 464.     def enable_callback(self):</font>
<font color="red"> 465.         self._callbacks_enabled = True</font>
<font color="black"> 466. </font>
<font color="green"> 467.     def disable_callback(self):</font>
<font color="red"> 468.         self._callbacks_enabled = False</font>
<font color="black"> 469. </font>
<font color="green"> 470.     def seek(self, where):</font>
<font color="red"> 471.         self._fileobj.seek(self._start_byte + where)</font>
<font color="red"> 472.         if self._callbacks is not None and self._callbacks_enabled:</font>
<font color="black"> 473.             # To also rewind the callback() for an accurate progress report</font>
<font color="red"> 474.             invoke_progress_callbacks(</font>
<font color="red"> 475.                 self._callbacks, bytes_transferred=where - self._amount_read)</font>
<font color="red"> 476.         self._amount_read = where</font>
<font color="black"> 477. </font>
<font color="green"> 478.     def close(self):</font>
<font color="red"> 479.         if self._close_callbacks is not None and self._callbacks_enabled:</font>
<font color="red"> 480.             for callback in self._close_callbacks:</font>
<font color="red"> 481.                 callback()</font>
<font color="red"> 482.         self._fileobj.close()</font>
<font color="black"> 483. </font>
<font color="green"> 484.     def tell(self):</font>
<font color="red"> 485.         return self._amount_read</font>
<font color="black"> 486. </font>
<font color="green"> 487.     def __len__(self):</font>
<font color="black"> 488.         # __len__ is defined because requests will try to determine the length</font>
<font color="black"> 489.         # of the stream to set a content length.  In the normal case</font>
<font color="black"> 490.         # of the file it will just stat the file, but we need to change that</font>
<font color="black"> 491.         # behavior.  By providing a __len__, requests will use that instead</font>
<font color="black"> 492.         # of stat'ing the file.</font>
<font color="red"> 493.         return self._size</font>
<font color="black"> 494. </font>
<font color="green"> 495.     def __enter__(self):</font>
<font color="red"> 496.         return self</font>
<font color="black"> 497. </font>
<font color="green"> 498.     def __exit__(self, *args, **kwargs):</font>
<font color="red"> 499.         self.close()</font>
<font color="black"> 500. </font>
<font color="green"> 501.     def __iter__(self):</font>
<font color="black"> 502.         # This is a workaround for http://bugs.python.org/issue17575</font>
<font color="black"> 503.         # Basically httplib will try to iterate over the contents, even</font>
<font color="black"> 504.         # if its a file like object.  This wasn't noticed because we've</font>
<font color="black"> 505.         # already exhausted the stream so iterating over the file immediately</font>
<font color="black"> 506.         # stops, which is what we're simulating here.</font>
<font color="red"> 507.         return iter([])</font>
<font color="black"> 508. </font>
<font color="black"> 509. </font>
<font color="green"> 510. class StreamReaderProgress(object):</font>
<font color="green"> 511.     &quot;&quot;&quot;Wrapper for a read only stream that adds progress callbacks.&quot;&quot;&quot;</font>
<font color="green"> 512.     def __init__(self, stream, callbacks=None):</font>
<font color="red"> 513.         self._stream = stream</font>
<font color="red"> 514.         self._callbacks = callbacks</font>
<font color="red"> 515.         if callbacks is None:</font>
<font color="red"> 516.             self._callbacks = []</font>
<font color="black"> 517. </font>
<font color="green"> 518.     def read(self, *args, **kwargs):</font>
<font color="red"> 519.         value = self._stream.read(*args, **kwargs)</font>
<font color="red"> 520.         invoke_progress_callbacks(self._callbacks, len(value))</font>
<font color="red"> 521.         return value</font>
<font color="black"> 522. </font>
<font color="black"> 523. </font>
<font color="green"> 524. class NoResourcesAvailable(Exception):</font>
<font color="green"> 525.     pass</font>
<font color="black"> 526. </font>
<font color="black"> 527. </font>
<font color="green"> 528. class TaskSemaphore(object):</font>
<font color="green"> 529.     def __init__(self, count):</font>
<font color="black"> 530.         &quot;&quot;&quot;A semaphore for the purpose of limiting the number of tasks</font>
<font color="black"> 531. </font>
<font color="black"> 532.         :param count: The size of semaphore</font>
<font color="black"> 533.         &quot;&quot;&quot;</font>
<font color="red"> 534.         self._semaphore = threading.Semaphore(count)</font>
<font color="black"> 535. </font>
<font color="green"> 536.     def acquire(self, tag, blocking=True):</font>
<font color="black"> 537.         &quot;&quot;&quot;Acquire the semaphore</font>
<font color="black"> 538. </font>
<font color="black"> 539.         :param tag: A tag identifying what is acquiring the semaphore. Note</font>
<font color="black"> 540.             that this is not really needed to directly use this class but is</font>
<font color="black"> 541.             needed for API compatibility with the SlidingWindowSemaphore</font>
<font color="black"> 542.             implementation.</font>
<font color="black"> 543.         :param block: If True, block until it can be acquired. If False,</font>
<font color="black"> 544.             do not block and raise an exception if cannot be aquired.</font>
<font color="black"> 545. </font>
<font color="black"> 546.         :returns: A token (can be None) to use when releasing the semaphore</font>
<font color="black"> 547.         &quot;&quot;&quot;</font>
<font color="red"> 548.         logger.debug(&quot;Acquiring %s&quot;, tag)</font>
<font color="red"> 549.         if not self._semaphore.acquire(blocking):</font>
<font color="red"> 550.             raise NoResourcesAvailable(&quot;Cannot acquire tag '%s'&quot; % tag)</font>
<font color="black"> 551. </font>
<font color="green"> 552.     def release(self, tag, acquire_token):</font>
<font color="black"> 553.         &quot;&quot;&quot;Release the semaphore</font>
<font color="black"> 554. </font>
<font color="black"> 555.         :param tag: A tag identifying what is releasing the semaphore</font>
<font color="black"> 556.         :param acquire_token:  The token returned from when the semaphore was</font>
<font color="black"> 557.             acquired. Note that this is not really needed to directly use this</font>
<font color="black"> 558.             class but is needed for API compatibility with the</font>
<font color="black"> 559.             SlidingWindowSemaphore implementation.</font>
<font color="black"> 560.         &quot;&quot;&quot;</font>
<font color="red"> 561.         logger.debug(&quot;Releasing acquire %s/%s&quot; % (tag, acquire_token))</font>
<font color="red"> 562.         self._semaphore.release()</font>
<font color="black"> 563. </font>
<font color="black"> 564. </font>
<font color="green"> 565. class SlidingWindowSemaphore(TaskSemaphore):</font>
<font color="black"> 566.     &quot;&quot;&quot;A semaphore used to coordinate sequential resource access.</font>
<font color="black"> 567. </font>
<font color="black"> 568.     This class is similar to the stdlib BoundedSemaphore:</font>
<font color="black"> 569. </font>
<font color="black"> 570.     * It's initialized with a count.</font>
<font color="black"> 571.     * Each call to ``acquire()`` decrements the counter.</font>
<font color="black"> 572.     * If the count is at zero, then ``acquire()`` will either block until the</font>
<font color="black"> 573.       count increases, or if ``blocking=False``, then it will raise</font>
<font color="black"> 574.       a NoResourcesAvailable exception indicating that it failed to acquire the</font>
<font color="black"> 575.       semaphore.</font>
<font color="black"> 576. </font>
<font color="black"> 577.     The main difference is that this semaphore is used to limit</font>
<font color="black"> 578.     access to a resource that requires sequential access.  For example,</font>
<font color="black"> 579.     if I want to access resource R that has 20 subresources R_0 - R_19,</font>
<font color="black"> 580.     this semaphore can also enforce that you only have a max range of</font>
<font color="black"> 581.     10 at any given point in time.  You must also specify a tag name</font>
<font color="black"> 582.     when you acquire the semaphore.  The sliding window semantics apply</font>
<font color="black"> 583.     on a per tag basis.  The internal count will only be incremented</font>
<font color="black"> 584.     when the minimum sequence number for a tag is released.</font>
<font color="black"> 585. </font>
<font color="green"> 586.     &quot;&quot;&quot;</font>
<font color="green"> 587.     def __init__(self, count):</font>
<font color="red"> 588.         self._count = count</font>
<font color="black"> 589.         # Dict[tag, next_sequence_number].</font>
<font color="red"> 590.         self._tag_sequences = defaultdict(int)</font>
<font color="red"> 591.         self._lowest_sequence = {}</font>
<font color="red"> 592.         self._lock = threading.Lock()</font>
<font color="red"> 593.         self._condition = threading.Condition(self._lock)</font>
<font color="black"> 594.         # Dict[tag, List[sequence_number]]</font>
<font color="red"> 595.         self._pending_release = {}</font>
<font color="black"> 596. </font>
<font color="green"> 597.     def current_count(self):</font>
<font color="red"> 598.         with self._lock:</font>
<font color="red"> 599.             return self._count</font>
<font color="black"> 600. </font>
<font color="green"> 601.     def acquire(self, tag, blocking=True):</font>
<font color="red"> 602.         logger.debug(&quot;Acquiring %s&quot;, tag)</font>
<font color="red"> 603.         self._condition.acquire()</font>
<font color="red"> 604.         try:</font>
<font color="red"> 605.             if self._count == 0:</font>
<font color="red"> 606.                 if not blocking:</font>
<font color="red"> 607.                     raise NoResourcesAvailable(&quot;Cannot acquire tag '%s'&quot; % tag)</font>
<font color="black"> 608.                 else:</font>
<font color="red"> 609.                     while self._count == 0:</font>
<font color="red"> 610.                         self._condition.wait()</font>
<font color="black"> 611.             # self._count is no longer zero.</font>
<font color="black"> 612.             # First, check if this is the first time we're seeing this tag.</font>
<font color="red"> 613.             sequence_number = self._tag_sequences[tag]</font>
<font color="red"> 614.             if sequence_number == 0:</font>
<font color="black"> 615.                 # First time seeing the tag, so record we're at 0.</font>
<font color="red"> 616.                 self._lowest_sequence[tag] = sequence_number</font>
<font color="red"> 617.             self._tag_sequences[tag] += 1</font>
<font color="red"> 618.             self._count -= 1</font>
<font color="red"> 619.             return sequence_number</font>
<font color="black"> 620.         finally:</font>
<font color="red"> 621.             self._condition.release()</font>
<font color="black"> 622. </font>
<font color="green"> 623.     def release(self, tag, acquire_token):</font>
<font color="red"> 624.         sequence_number = acquire_token</font>
<font color="red"> 625.         logger.debug(&quot;Releasing acquire %s/%s&quot;, tag, sequence_number)</font>
<font color="red"> 626.         self._condition.acquire()</font>
<font color="red"> 627.         try:</font>
<font color="red"> 628.             if tag not in self._tag_sequences:</font>
<font color="red"> 629.                 raise ValueError(&quot;Attempted to release unknown tag: %s&quot; % tag)</font>
<font color="red"> 630.             max_sequence = self._tag_sequences[tag]</font>
<font color="red"> 631.             if self._lowest_sequence[tag] == sequence_number:</font>
<font color="black"> 632.                 # We can immediately process this request and free up</font>
<font color="black"> 633.                 # resources.</font>
<font color="red"> 634.                 self._lowest_sequence[tag] += 1</font>
<font color="red"> 635.                 self._count += 1</font>
<font color="red"> 636.                 self._condition.notify()</font>
<font color="red"> 637.                 queued = self._pending_release.get(tag, [])</font>
<font color="red"> 638.                 while queued:</font>
<font color="red"> 639.                     if self._lowest_sequence[tag] == queued[-1]:</font>
<font color="red"> 640.                         queued.pop()</font>
<font color="red"> 641.                         self._lowest_sequence[tag] += 1</font>
<font color="red"> 642.                         self._count += 1</font>
<font color="black"> 643.                     else:</font>
<font color="red"> 644.                         break</font>
<font color="red"> 645.             elif self._lowest_sequence[tag] &lt; sequence_number &lt; max_sequence:</font>
<font color="black"> 646.                 # We can't do anything right now because we're still waiting</font>
<font color="black"> 647.                 # for the min sequence for the tag to be released.  We have</font>
<font color="black"> 648.                 # to queue this for pending release.</font>
<font color="red"> 649.                 self._pending_release.setdefault(</font>
<font color="red"> 650.                     tag, []).append(sequence_number)</font>
<font color="red"> 651.                 self._pending_release[tag].sort(reverse=True)</font>
<font color="black"> 652.             else:</font>
<font color="red"> 653.                 raise ValueError(</font>
<font color="red"> 654.                     &quot;Attempted to release unknown sequence number &quot;</font>
<font color="red"> 655.                     &quot;%s for tag: %s&quot; % (sequence_number, tag))</font>
<font color="black"> 656.         finally:</font>
<font color="red"> 657.             self._condition.release()</font>
<font color="black"> 658. </font>
<font color="black"> 659. </font>
<font color="green"> 660. class ChunksizeAdjuster(object):</font>
<font color="green"> 661.     def __init__(self, max_size=MAX_SINGLE_UPLOAD_SIZE,</font>
<font color="green"> 662.                  min_size=MIN_UPLOAD_CHUNKSIZE, max_parts=MAX_PARTS):</font>
<font color="red"> 663.         self.max_size = max_size</font>
<font color="red"> 664.         self.min_size = min_size</font>
<font color="red"> 665.         self.max_parts = max_parts</font>
<font color="black"> 666. </font>
<font color="green"> 667.     def adjust_chunksize(self, current_chunksize, file_size=None):</font>
<font color="black"> 668.         &quot;&quot;&quot;Get a chunksize close to current that fits within all S3 limits.</font>
<font color="black"> 669. </font>
<font color="black"> 670.         :type current_chunksize: int</font>
<font color="black"> 671.         :param current_chunksize: The currently configured chunksize.</font>
<font color="black"> 672. </font>
<font color="black"> 673.         :type file_size: int or None</font>
<font color="black"> 674.         :param file_size: The size of the file to upload. This might be None</font>
<font color="black"> 675.             if the object being transferred has an unknown size.</font>
<font color="black"> 676. </font>
<font color="black"> 677.         :returns: A valid chunksize that fits within configured limits.</font>
<font color="black"> 678.         &quot;&quot;&quot;</font>
<font color="red"> 679.         chunksize = current_chunksize</font>
<font color="red"> 680.         if file_size is not None:</font>
<font color="red"> 681.             chunksize = self._adjust_for_max_parts(chunksize, file_size)</font>
<font color="red"> 682.         return self._adjust_for_chunksize_limits(chunksize)</font>
<font color="black"> 683. </font>
<font color="green"> 684.     def _adjust_for_chunksize_limits(self, current_chunksize):</font>
<font color="red"> 685.         if current_chunksize &gt; self.max_size:</font>
<font color="red"> 686.             logger.debug(</font>
<font color="red"> 687.                 &quot;Chunksize greater than maximum chunksize. &quot;</font>
<font color="red"> 688.                 &quot;Setting to %s from %s.&quot; % (self.max_size, current_chunksize))</font>
<font color="red"> 689.             return self.max_size</font>
<font color="red"> 690.         elif current_chunksize &lt; self.min_size:</font>
<font color="red"> 691.             logger.debug(</font>
<font color="red"> 692.                 &quot;Chunksize less than minimum chunksize. &quot;</font>
<font color="red"> 693.                 &quot;Setting to %s from %s.&quot; % (self.min_size, current_chunksize))</font>
<font color="red"> 694.             return self.min_size</font>
<font color="black"> 695.         else:</font>
<font color="red"> 696.             return current_chunksize</font>
<font color="black"> 697. </font>
<font color="green"> 698.     def _adjust_for_max_parts(self, current_chunksize, file_size):</font>
<font color="red"> 699.         chunksize = current_chunksize</font>
<font color="red"> 700.         num_parts = int(math.ceil(file_size / float(chunksize)))</font>
<font color="black"> 701. </font>
<font color="red"> 702.         while num_parts &gt; self.max_parts:</font>
<font color="red"> 703.             chunksize *= 2</font>
<font color="red"> 704.             num_parts = int(math.ceil(file_size / float(chunksize)))</font>
<font color="black"> 705. </font>
<font color="red"> 706.         if chunksize != current_chunksize:</font>
<font color="red"> 707.             logger.debug(</font>
<font color="red"> 708.                 &quot;Chunksize would result in the number of parts exceeding the &quot;</font>
<font color="black"> 709.                 &quot;maximum. Setting to %s from %s.&quot; %</font>
<font color="red"> 710.                 (chunksize, current_chunksize))</font>
<font color="black"> 711. </font>
<font color="red"> 712.         return chunksize</font>
</pre>

