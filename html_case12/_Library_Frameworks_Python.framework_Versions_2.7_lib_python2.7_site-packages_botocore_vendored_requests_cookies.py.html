source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/cookies.py</b><br>


file stats: <b>260 lines, 83 executed: 31.9% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. </font>
<font color="black">   3. &quot;&quot;&quot;</font>
<font color="black">   4. Compatibility code to be able to use `cookielib.CookieJar` with requests.</font>
<font color="black">   5. </font>
<font color="black">   6. requests.utils imports from here, so be careful with imports.</font>
<font color="green">   7. &quot;&quot;&quot;</font>
<font color="black">   8. </font>
<font color="green">   9. import copy</font>
<font color="green">  10. import time</font>
<font color="green">  11. import collections</font>
<font color="green">  12. from .compat import cookielib, urlparse, urlunparse, Morsel</font>
<font color="black">  13. </font>
<font color="green">  14. try:</font>
<font color="green">  15.     import threading</font>
<font color="black">  16.     # grr, pyflakes: this fixes &quot;redefinition of unused 'threading'&quot;</font>
<font color="green">  17.     threading</font>
<font color="red">  18. except ImportError:</font>
<font color="red">  19.     import dummy_threading as threading</font>
<font color="black">  20. </font>
<font color="black">  21. </font>
<font color="green">  22. class MockRequest(object):</font>
<font color="black">  23.     &quot;&quot;&quot;Wraps a `requests.Request` to mimic a `urllib2.Request`.</font>
<font color="black">  24. </font>
<font color="black">  25.     The code in `cookielib.CookieJar` expects this interface in order to correctly</font>
<font color="black">  26.     manage cookie policies, i.e., determine whether a cookie can be set, given the</font>
<font color="black">  27.     domains of the request and the cookie.</font>
<font color="black">  28. </font>
<font color="black">  29.     The original request object is read-only. The client is responsible for collecting</font>
<font color="black">  30.     the new headers via `get_new_headers()` and interpreting them appropriately. You</font>
<font color="black">  31.     probably want `get_cookie_header`, defined below.</font>
<font color="green">  32.     &quot;&quot;&quot;</font>
<font color="black">  33. </font>
<font color="green">  34.     def __init__(self, request):</font>
<font color="green">  35.         self._r = request</font>
<font color="green">  36.         self._new_headers = {}</font>
<font color="green">  37.         self.type = urlparse(self._r.url).scheme</font>
<font color="black">  38. </font>
<font color="green">  39.     def get_type(self):</font>
<font color="red">  40.         return self.type</font>
<font color="black">  41. </font>
<font color="green">  42.     def get_host(self):</font>
<font color="red">  43.         return urlparse(self._r.url).netloc</font>
<font color="black">  44. </font>
<font color="green">  45.     def get_origin_req_host(self):</font>
<font color="red">  46.         return self.get_host()</font>
<font color="black">  47. </font>
<font color="green">  48.     def get_full_url(self):</font>
<font color="black">  49.         # Only return the response's URL if the user hadn't set the Host</font>
<font color="black">  50.         # header</font>
<font color="red">  51.         if not self._r.headers.get('Host'):</font>
<font color="red">  52.             return self._r.url</font>
<font color="black">  53.         # If they did set it, retrieve it and reconstruct the expected domain</font>
<font color="red">  54.         host = self._r.headers['Host']</font>
<font color="red">  55.         parsed = urlparse(self._r.url)</font>
<font color="black">  56.         # Reconstruct the URL as we expect it</font>
<font color="red">  57.         return urlunparse([</font>
<font color="red">  58.             parsed.scheme, host, parsed.path, parsed.params, parsed.query,</font>
<font color="red">  59.             parsed.fragment</font>
<font color="black">  60.         ])</font>
<font color="black">  61. </font>
<font color="green">  62.     def is_unverifiable(self):</font>
<font color="red">  63.         return True</font>
<font color="black">  64. </font>
<font color="green">  65.     def has_header(self, name):</font>
<font color="red">  66.         return name in self._r.headers or name in self._new_headers</font>
<font color="black">  67. </font>
<font color="green">  68.     def get_header(self, name, default=None):</font>
<font color="red">  69.         return self._r.headers.get(name, self._new_headers.get(name, default))</font>
<font color="black">  70. </font>
<font color="green">  71.     def add_header(self, key, val):</font>
<font color="black">  72.         &quot;&quot;&quot;cookielib has no legitimate use for this method; add it back if you find one.&quot;&quot;&quot;</font>
<font color="red">  73.         raise NotImplementedError(&quot;Cookie headers should be added with add_unredirected_header()&quot;)</font>
<font color="black">  74. </font>
<font color="green">  75.     def add_unredirected_header(self, name, value):</font>
<font color="red">  76.         self._new_headers[name] = value</font>
<font color="black">  77. </font>
<font color="green">  78.     def get_new_headers(self):</font>
<font color="green">  79.         return self._new_headers</font>
<font color="black">  80. </font>
<font color="green">  81.     @property</font>
<font color="black">  82.     def unverifiable(self):</font>
<font color="red">  83.         return self.is_unverifiable()</font>
<font color="black">  84. </font>
<font color="green">  85.     @property</font>
<font color="black">  86.     def origin_req_host(self):</font>
<font color="red">  87.         return self.get_origin_req_host()</font>
<font color="black">  88. </font>
<font color="green">  89.     @property</font>
<font color="black">  90.     def host(self):</font>
<font color="red">  91.         return self.get_host()</font>
<font color="black">  92. </font>
<font color="black">  93. </font>
<font color="green">  94. class MockResponse(object):</font>
<font color="black">  95.     &quot;&quot;&quot;Wraps a `httplib.HTTPMessage` to mimic a `urllib.addinfourl`.</font>
<font color="black">  96. </font>
<font color="black">  97.     ...what? Basically, expose the parsed HTTP headers from the server response</font>
<font color="black">  98.     the way `cookielib` expects to see them.</font>
<font color="green">  99.     &quot;&quot;&quot;</font>
<font color="black"> 100. </font>
<font color="green"> 101.     def __init__(self, headers):</font>
<font color="black"> 102.         &quot;&quot;&quot;Make a MockResponse for `cookielib` to read.</font>
<font color="black"> 103. </font>
<font color="black"> 104.         :param headers: a httplib.HTTPMessage or analogous carrying the headers</font>
<font color="black"> 105.         &quot;&quot;&quot;</font>
<font color="green"> 106.         self._headers = headers</font>
<font color="black"> 107. </font>
<font color="green"> 108.     def info(self):</font>
<font color="green"> 109.         return self._headers</font>
<font color="black"> 110. </font>
<font color="green"> 111.     def getheaders(self, name):</font>
<font color="red"> 112.         self._headers.getheaders(name)</font>
<font color="black"> 113. </font>
<font color="black"> 114. </font>
<font color="green"> 115. def extract_cookies_to_jar(jar, request, response):</font>
<font color="black"> 116.     &quot;&quot;&quot;Extract the cookies from the response into a CookieJar.</font>
<font color="black"> 117. </font>
<font color="black"> 118.     :param jar: cookielib.CookieJar (not necessarily a RequestsCookieJar)</font>
<font color="black"> 119.     :param request: our own requests.Request object</font>
<font color="black"> 120.     :param response: urllib3.HTTPResponse object</font>
<font color="black"> 121.     &quot;&quot;&quot;</font>
<font color="green"> 122.     if not (hasattr(response, '_original_response') and</font>
<font color="green"> 123.             response._original_response):</font>
<font color="red"> 124.         return</font>
<font color="black"> 125.     # the _original_response field is the wrapped httplib.HTTPResponse object,</font>
<font color="green"> 126.     req = MockRequest(request)</font>
<font color="black"> 127.     # pull out the HTTPMessage with the headers and put it in the mock:</font>
<font color="green"> 128.     res = MockResponse(response._original_response.msg)</font>
<font color="green"> 129.     jar.extract_cookies(res, req)</font>
<font color="black"> 130. </font>
<font color="black"> 131. </font>
<font color="green"> 132. def get_cookie_header(jar, request):</font>
<font color="black"> 133.     &quot;&quot;&quot;Produce an appropriate Cookie header string to be sent with `request`, or None.&quot;&quot;&quot;</font>
<font color="green"> 134.     r = MockRequest(request)</font>
<font color="green"> 135.     jar.add_cookie_header(r)</font>
<font color="green"> 136.     return r.get_new_headers().get('Cookie')</font>
<font color="black"> 137. </font>
<font color="black"> 138. </font>
<font color="green"> 139. def remove_cookie_by_name(cookiejar, name, domain=None, path=None):</font>
<font color="black"> 140.     &quot;&quot;&quot;Unsets a cookie by name, by default over all domains and paths.</font>
<font color="black"> 141. </font>
<font color="black"> 142.     Wraps CookieJar.clear(), is O(n).</font>
<font color="black"> 143.     &quot;&quot;&quot;</font>
<font color="red"> 144.     clearables = []</font>
<font color="red"> 145.     for cookie in cookiejar:</font>
<font color="red"> 146.         if cookie.name == name:</font>
<font color="red"> 147.             if domain is None or domain == cookie.domain:</font>
<font color="red"> 148.                 if path is None or path == cookie.path:</font>
<font color="red"> 149.                     clearables.append((cookie.domain, cookie.path, cookie.name))</font>
<font color="black"> 150. </font>
<font color="red"> 151.     for domain, path, name in clearables:</font>
<font color="red"> 152.         cookiejar.clear(domain, path, name)</font>
<font color="black"> 153. </font>
<font color="black"> 154. </font>
<font color="green"> 155. class CookieConflictError(RuntimeError):</font>
<font color="black"> 156.     &quot;&quot;&quot;There are two cookies that meet the criteria specified in the cookie jar.</font>
<font color="green"> 157.     Use .get and .set and include domain and path args in order to be more specific.&quot;&quot;&quot;</font>
<font color="black"> 158. </font>
<font color="black"> 159. </font>
<font color="green"> 160. class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):</font>
<font color="black"> 161.     &quot;&quot;&quot;Compatibility class; is a cookielib.CookieJar, but exposes a dict</font>
<font color="black"> 162.     interface.</font>
<font color="black"> 163. </font>
<font color="black"> 164.     This is the CookieJar we create by default for requests and sessions that</font>
<font color="black"> 165.     don't specify one, since some clients may expect response.cookies and</font>
<font color="black"> 166.     session.cookies to support dict operations.</font>
<font color="black"> 167. </font>
<font color="black"> 168.     Requests does not use the dict interface internally; it's just for</font>
<font color="black"> 169.     compatibility with external client code. All requests code should work</font>
<font color="black"> 170.     out of the box with externally provided instances of ``CookieJar``, e.g.</font>
<font color="black"> 171.     ``LWPCookieJar`` and ``FileCookieJar``.</font>
<font color="black"> 172. </font>
<font color="black"> 173.     Unlike a regular CookieJar, this class is pickleable.</font>
<font color="black"> 174. </font>
<font color="black"> 175.     .. warning:: dictionary operations that are normally O(1) may be O(n).</font>
<font color="green"> 176.     &quot;&quot;&quot;</font>
<font color="green"> 177.     def get(self, name, default=None, domain=None, path=None):</font>
<font color="black"> 178.         &quot;&quot;&quot;Dict-like get() that also supports optional domain and path args in</font>
<font color="black"> 179.         order to resolve naming collisions from using one cookie jar over</font>
<font color="black"> 180.         multiple domains.</font>
<font color="black"> 181. </font>
<font color="black"> 182.         .. warning:: operation is O(n), not O(1).&quot;&quot;&quot;</font>
<font color="red"> 183.         try:</font>
<font color="red"> 184.             return self._find_no_duplicates(name, domain, path)</font>
<font color="red"> 185.         except KeyError:</font>
<font color="red"> 186.             return default</font>
<font color="black"> 187. </font>
<font color="green"> 188.     def set(self, name, value, **kwargs):</font>
<font color="black"> 189.         &quot;&quot;&quot;Dict-like set() that also supports optional domain and path args in</font>
<font color="black"> 190.         order to resolve naming collisions from using one cookie jar over</font>
<font color="black"> 191.         multiple domains.&quot;&quot;&quot;</font>
<font color="black"> 192.         # support client code that unsets cookies by assignment of a None value:</font>
<font color="red"> 193.         if value is None:</font>
<font color="red"> 194.             remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))</font>
<font color="red"> 195.             return</font>
<font color="black"> 196. </font>
<font color="red"> 197.         if isinstance(value, Morsel):</font>
<font color="red"> 198.             c = morsel_to_cookie(value)</font>
<font color="black"> 199.         else:</font>
<font color="red"> 200.             c = create_cookie(name, value, **kwargs)</font>
<font color="red"> 201.         self.set_cookie(c)</font>
<font color="red"> 202.         return c</font>
<font color="black"> 203. </font>
<font color="green"> 204.     def iterkeys(self):</font>
<font color="black"> 205.         &quot;&quot;&quot;Dict-like iterkeys() that returns an iterator of names of cookies</font>
<font color="black"> 206.         from the jar. See itervalues() and iteritems().&quot;&quot;&quot;</font>
<font color="red"> 207.         for cookie in iter(self):</font>
<font color="red"> 208.             yield cookie.name</font>
<font color="black"> 209. </font>
<font color="green"> 210.     def keys(self):</font>
<font color="black"> 211.         &quot;&quot;&quot;Dict-like keys() that returns a list of names of cookies from the</font>
<font color="black"> 212.         jar. See values() and items().&quot;&quot;&quot;</font>
<font color="red"> 213.         return list(self.iterkeys())</font>
<font color="black"> 214. </font>
<font color="green"> 215.     def itervalues(self):</font>
<font color="black"> 216.         &quot;&quot;&quot;Dict-like itervalues() that returns an iterator of values of cookies</font>
<font color="black"> 217.         from the jar. See iterkeys() and iteritems().&quot;&quot;&quot;</font>
<font color="red"> 218.         for cookie in iter(self):</font>
<font color="red"> 219.             yield cookie.value</font>
<font color="black"> 220. </font>
<font color="green"> 221.     def values(self):</font>
<font color="black"> 222.         &quot;&quot;&quot;Dict-like values() that returns a list of values of cookies from the</font>
<font color="black"> 223.         jar. See keys() and items().&quot;&quot;&quot;</font>
<font color="red"> 224.         return list(self.itervalues())</font>
<font color="black"> 225. </font>
<font color="green"> 226.     def iteritems(self):</font>
<font color="black"> 227.         &quot;&quot;&quot;Dict-like iteritems() that returns an iterator of name-value tuples</font>
<font color="black"> 228.         from the jar. See iterkeys() and itervalues().&quot;&quot;&quot;</font>
<font color="red"> 229.         for cookie in iter(self):</font>
<font color="red"> 230.             yield cookie.name, cookie.value</font>
<font color="black"> 231. </font>
<font color="green"> 232.     def items(self):</font>
<font color="black"> 233.         &quot;&quot;&quot;Dict-like items() that returns a list of name-value tuples from the</font>
<font color="black"> 234.         jar. See keys() and values(). Allows client-code to call</font>
<font color="black"> 235.         ``dict(RequestsCookieJar)`` and get a vanilla python dict of key value</font>
<font color="black"> 236.         pairs.&quot;&quot;&quot;</font>
<font color="red"> 237.         return list(self.iteritems())</font>
<font color="black"> 238. </font>
<font color="green"> 239.     def list_domains(self):</font>
<font color="black"> 240.         &quot;&quot;&quot;Utility method to list all the domains in the jar.&quot;&quot;&quot;</font>
<font color="red"> 241.         domains = []</font>
<font color="red"> 242.         for cookie in iter(self):</font>
<font color="red"> 243.             if cookie.domain not in domains:</font>
<font color="red"> 244.                 domains.append(cookie.domain)</font>
<font color="red"> 245.         return domains</font>
<font color="black"> 246. </font>
<font color="green"> 247.     def list_paths(self):</font>
<font color="black"> 248.         &quot;&quot;&quot;Utility method to list all the paths in the jar.&quot;&quot;&quot;</font>
<font color="red"> 249.         paths = []</font>
<font color="red"> 250.         for cookie in iter(self):</font>
<font color="red"> 251.             if cookie.path not in paths:</font>
<font color="red"> 252.                 paths.append(cookie.path)</font>
<font color="red"> 253.         return paths</font>
<font color="black"> 254. </font>
<font color="green"> 255.     def multiple_domains(self):</font>
<font color="black"> 256.         &quot;&quot;&quot;Returns True if there are multiple domains in the jar.</font>
<font color="black"> 257.         Returns False otherwise.&quot;&quot;&quot;</font>
<font color="red"> 258.         domains = []</font>
<font color="red"> 259.         for cookie in iter(self):</font>
<font color="red"> 260.             if cookie.domain is not None and cookie.domain in domains:</font>
<font color="red"> 261.                 return True</font>
<font color="red"> 262.             domains.append(cookie.domain)</font>
<font color="red"> 263.         return False  # there is only one domain in jar</font>
<font color="black"> 264. </font>
<font color="green"> 265.     def get_dict(self, domain=None, path=None):</font>
<font color="black"> 266.         &quot;&quot;&quot;Takes as an argument an optional domain and path and returns a plain</font>
<font color="black"> 267.         old Python dict of name-value pairs of cookies that meet the</font>
<font color="black"> 268.         requirements.&quot;&quot;&quot;</font>
<font color="red"> 269.         dictionary = {}</font>
<font color="red"> 270.         for cookie in iter(self):</font>
<font color="red"> 271.             if (domain is None or cookie.domain == domain) and (path is None</font>
<font color="red"> 272.                                                 or cookie.path == path):</font>
<font color="red"> 273.                 dictionary[cookie.name] = cookie.value</font>
<font color="red"> 274.         return dictionary</font>
<font color="black"> 275. </font>
<font color="green"> 276.     def __getitem__(self, name):</font>
<font color="black"> 277.         &quot;&quot;&quot;Dict-like __getitem__() for compatibility with client code. Throws</font>
<font color="black"> 278.         exception if there are more than one cookie with name. In that case,</font>
<font color="black"> 279.         use the more explicit get() method instead.</font>
<font color="black"> 280. </font>
<font color="black"> 281.         .. warning:: operation is O(n), not O(1).&quot;&quot;&quot;</font>
<font color="black"> 282. </font>
<font color="red"> 283.         return self._find_no_duplicates(name)</font>
<font color="black"> 284. </font>
<font color="green"> 285.     def __setitem__(self, name, value):</font>
<font color="black"> 286.         &quot;&quot;&quot;Dict-like __setitem__ for compatibility with client code. Throws</font>
<font color="black"> 287.         exception if there is already a cookie of that name in the jar. In that</font>
<font color="black"> 288.         case, use the more explicit set() method instead.&quot;&quot;&quot;</font>
<font color="black"> 289. </font>
<font color="red"> 290.         self.set(name, value)</font>
<font color="black"> 291. </font>
<font color="green"> 292.     def __delitem__(self, name):</font>
<font color="black"> 293.         &quot;&quot;&quot;Deletes a cookie given a name. Wraps ``cookielib.CookieJar``'s</font>
<font color="black"> 294.         ``remove_cookie_by_name()``.&quot;&quot;&quot;</font>
<font color="red"> 295.         remove_cookie_by_name(self, name)</font>
<font color="black"> 296. </font>
<font color="green"> 297.     def set_cookie(self, cookie, *args, **kwargs):</font>
<font color="red"> 298.         if hasattr(cookie.value, 'startswith') and cookie.value.startswith('&quot;') and cookie.value.endswith('&quot;'):</font>
<font color="red"> 299.             cookie.value = cookie.value.replace('\\&quot;', '')</font>
<font color="red"> 300.         return super(RequestsCookieJar, self).set_cookie(cookie, *args, **kwargs)</font>
<font color="black"> 301. </font>
<font color="green"> 302.     def update(self, other):</font>
<font color="black"> 303.         &quot;&quot;&quot;Updates this jar with cookies from another CookieJar or dict-like&quot;&quot;&quot;</font>
<font color="red"> 304.         if isinstance(other, cookielib.CookieJar):</font>
<font color="red"> 305.             for cookie in other:</font>
<font color="red"> 306.                 self.set_cookie(copy.copy(cookie))</font>
<font color="black"> 307.         else:</font>
<font color="red"> 308.             super(RequestsCookieJar, self).update(other)</font>
<font color="black"> 309. </font>
<font color="green"> 310.     def _find(self, name, domain=None, path=None):</font>
<font color="black"> 311.         &quot;&quot;&quot;Requests uses this method internally to get cookie values. Takes as</font>
<font color="black"> 312.         args name and optional domain and path. Returns a cookie.value. If</font>
<font color="black"> 313.         there are conflicting cookies, _find arbitrarily chooses one. See</font>
<font color="black"> 314.         _find_no_duplicates if you want an exception thrown if there are</font>
<font color="black"> 315.         conflicting cookies.&quot;&quot;&quot;</font>
<font color="red"> 316.         for cookie in iter(self):</font>
<font color="red"> 317.             if cookie.name == name:</font>
<font color="red"> 318.                 if domain is None or cookie.domain == domain:</font>
<font color="red"> 319.                     if path is None or cookie.path == path:</font>
<font color="red"> 320.                         return cookie.value</font>
<font color="black"> 321. </font>
<font color="red"> 322.         raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))</font>
<font color="black"> 323. </font>
<font color="green"> 324.     def _find_no_duplicates(self, name, domain=None, path=None):</font>
<font color="black"> 325.         &quot;&quot;&quot;Both ``__get_item__`` and ``get`` call this function: it's never</font>
<font color="black"> 326.         used elsewhere in Requests. Takes as args name and optional domain and</font>
<font color="black"> 327.         path. Returns a cookie.value. Throws KeyError if cookie is not found</font>
<font color="black"> 328.         and CookieConflictError if there are multiple cookies that match name</font>
<font color="black"> 329.         and optionally domain and path.&quot;&quot;&quot;</font>
<font color="red"> 330.         toReturn = None</font>
<font color="red"> 331.         for cookie in iter(self):</font>
<font color="red"> 332.             if cookie.name == name:</font>
<font color="red"> 333.                 if domain is None or cookie.domain == domain:</font>
<font color="red"> 334.                     if path is None or cookie.path == path:</font>
<font color="red"> 335.                         if toReturn is not None:  # if there are multiple cookies that meet passed in criteria</font>
<font color="red"> 336.                             raise CookieConflictError('There are multiple cookies with name, %r' % (name))</font>
<font color="red"> 337.                         toReturn = cookie.value  # we will eventually return this as long as no cookie conflict</font>
<font color="black"> 338. </font>
<font color="red"> 339.         if toReturn:</font>
<font color="red"> 340.             return toReturn</font>
<font color="red"> 341.         raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))</font>
<font color="black"> 342. </font>
<font color="green"> 343.     def __getstate__(self):</font>
<font color="black"> 344.         &quot;&quot;&quot;Unlike a normal CookieJar, this class is pickleable.&quot;&quot;&quot;</font>
<font color="red"> 345.         state = self.__dict__.copy()</font>
<font color="black"> 346.         # remove the unpickleable RLock object</font>
<font color="red"> 347.         state.pop('_cookies_lock')</font>
<font color="red"> 348.         return state</font>
<font color="black"> 349. </font>
<font color="green"> 350.     def __setstate__(self, state):</font>
<font color="black"> 351.         &quot;&quot;&quot;Unlike a normal CookieJar, this class is pickleable.&quot;&quot;&quot;</font>
<font color="red"> 352.         self.__dict__.update(state)</font>
<font color="red"> 353.         if '_cookies_lock' not in self.__dict__:</font>
<font color="red"> 354.             self._cookies_lock = threading.RLock()</font>
<font color="black"> 355. </font>
<font color="green"> 356.     def copy(self):</font>
<font color="black"> 357.         &quot;&quot;&quot;Return a copy of this RequestsCookieJar.&quot;&quot;&quot;</font>
<font color="red"> 358.         new_cj = RequestsCookieJar()</font>
<font color="red"> 359.         new_cj.update(self)</font>
<font color="red"> 360.         return new_cj</font>
<font color="black"> 361. </font>
<font color="black"> 362. </font>
<font color="green"> 363. def _copy_cookie_jar(jar):</font>
<font color="red"> 364.     if jar is None:</font>
<font color="red"> 365.         return None</font>
<font color="black"> 366. </font>
<font color="red"> 367.     if hasattr(jar, 'copy'):</font>
<font color="black"> 368.         # We're dealing with an instane of RequestsCookieJar</font>
<font color="red"> 369.         return jar.copy()</font>
<font color="black"> 370.     # We're dealing with a generic CookieJar instance</font>
<font color="red"> 371.     new_jar = copy.copy(jar)</font>
<font color="red"> 372.     new_jar.clear()</font>
<font color="red"> 373.     for cookie in jar:</font>
<font color="red"> 374.         new_jar.set_cookie(copy.copy(cookie))</font>
<font color="red"> 375.     return new_jar</font>
<font color="black"> 376. </font>
<font color="black"> 377. </font>
<font color="green"> 378. def create_cookie(name, value, **kwargs):</font>
<font color="black"> 379.     &quot;&quot;&quot;Make a cookie from underspecified parameters.</font>
<font color="black"> 380. </font>
<font color="black"> 381.     By default, the pair of `name` and `value` will be set for the domain ''</font>
<font color="black"> 382.     and sent on every request (this is sometimes called a &quot;supercookie&quot;).</font>
<font color="black"> 383.     &quot;&quot;&quot;</font>
<font color="red"> 384.     result = dict(</font>
<font color="red"> 385.         version=0,</font>
<font color="red"> 386.         name=name,</font>
<font color="red"> 387.         value=value,</font>
<font color="red"> 388.         port=None,</font>
<font color="red"> 389.         domain='',</font>
<font color="red"> 390.         path='/',</font>
<font color="red"> 391.         secure=False,</font>
<font color="red"> 392.         expires=None,</font>
<font color="red"> 393.         discard=True,</font>
<font color="red"> 394.         comment=None,</font>
<font color="red"> 395.         comment_url=None,</font>
<font color="red"> 396.         rest={'HttpOnly': None},</font>
<font color="red"> 397.         rfc2109=False,)</font>
<font color="black"> 398. </font>
<font color="red"> 399.     badargs = set(kwargs) - set(result)</font>
<font color="red"> 400.     if badargs:</font>
<font color="red"> 401.         err = 'create_cookie() got unexpected keyword arguments: %s'</font>
<font color="red"> 402.         raise TypeError(err % list(badargs))</font>
<font color="black"> 403. </font>
<font color="red"> 404.     result.update(kwargs)</font>
<font color="red"> 405.     result['port_specified'] = bool(result['port'])</font>
<font color="red"> 406.     result['domain_specified'] = bool(result['domain'])</font>
<font color="red"> 407.     result['domain_initial_dot'] = result['domain'].startswith('.')</font>
<font color="red"> 408.     result['path_specified'] = bool(result['path'])</font>
<font color="black"> 409. </font>
<font color="red"> 410.     return cookielib.Cookie(**result)</font>
<font color="black"> 411. </font>
<font color="black"> 412. </font>
<font color="green"> 413. def morsel_to_cookie(morsel):</font>
<font color="black"> 414.     &quot;&quot;&quot;Convert a Morsel object into a Cookie containing the one k/v pair.&quot;&quot;&quot;</font>
<font color="black"> 415. </font>
<font color="red"> 416.     expires = None</font>
<font color="red"> 417.     if morsel['max-age']:</font>
<font color="red"> 418.         expires = time.time() + morsel['max-age']</font>
<font color="red"> 419.     elif morsel['expires']:</font>
<font color="red"> 420.         time_template = '%a, %d-%b-%Y %H:%M:%S GMT'</font>
<font color="red"> 421.         expires = time.mktime(</font>
<font color="red"> 422.             time.strptime(morsel['expires'], time_template)) - time.timezone</font>
<font color="red"> 423.     return create_cookie(</font>
<font color="red"> 424.         comment=morsel['comment'],</font>
<font color="red"> 425.         comment_url=bool(morsel['comment']),</font>
<font color="red"> 426.         discard=False,</font>
<font color="red"> 427.         domain=morsel['domain'],</font>
<font color="red"> 428.         expires=expires,</font>
<font color="red"> 429.         name=morsel.key,</font>
<font color="red"> 430.         path=morsel['path'],</font>
<font color="red"> 431.         port=None,</font>
<font color="red"> 432.         rest={'HttpOnly': morsel['httponly']},</font>
<font color="red"> 433.         rfc2109=False,</font>
<font color="red"> 434.         secure=bool(morsel['secure']),</font>
<font color="red"> 435.         value=morsel.value,</font>
<font color="red"> 436.         version=morsel['version'] or 0,</font>
<font color="black"> 437.     )</font>
<font color="black"> 438. </font>
<font color="black"> 439. </font>
<font color="green"> 440. def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):</font>
<font color="black"> 441.     &quot;&quot;&quot;Returns a CookieJar from a key/value dictionary.</font>
<font color="black"> 442. </font>
<font color="black"> 443.     :param cookie_dict: Dict of key/values to insert into CookieJar.</font>
<font color="black"> 444.     :param cookiejar: (optional) A cookiejar to add the cookies to.</font>
<font color="black"> 445.     :param overwrite: (optional) If False, will not replace cookies</font>
<font color="black"> 446.         already in the jar with new ones.</font>
<font color="black"> 447.     &quot;&quot;&quot;</font>
<font color="green"> 448.     if cookiejar is None:</font>
<font color="green"> 449.         cookiejar = RequestsCookieJar()</font>
<font color="black"> 450. </font>
<font color="green"> 451.     if cookie_dict is not None:</font>
<font color="green"> 452.         names_from_jar = [cookie.name for cookie in cookiejar]</font>
<font color="green"> 453.         for name in cookie_dict:</font>
<font color="red"> 454.             if overwrite or (name not in names_from_jar):</font>
<font color="red"> 455.                 cookiejar.set_cookie(create_cookie(name, cookie_dict[name]))</font>
<font color="black"> 456. </font>
<font color="green"> 457.     return cookiejar</font>
<font color="black"> 458. </font>
<font color="black"> 459. </font>
<font color="green"> 460. def merge_cookies(cookiejar, cookies):</font>
<font color="black"> 461.     &quot;&quot;&quot;Add cookies to cookiejar and returns a merged CookieJar.</font>
<font color="black"> 462. </font>
<font color="black"> 463.     :param cookiejar: CookieJar object to add the cookies to.</font>
<font color="black"> 464.     :param cookies: Dictionary or CookieJar object to be added.</font>
<font color="black"> 465.     &quot;&quot;&quot;</font>
<font color="red"> 466.     if not isinstance(cookiejar, cookielib.CookieJar):</font>
<font color="red"> 467.         raise ValueError('You can only merge into CookieJar')</font>
<font color="black"> 468. </font>
<font color="red"> 469.     if isinstance(cookies, dict):</font>
<font color="red"> 470.         cookiejar = cookiejar_from_dict(</font>
<font color="red"> 471.             cookies, cookiejar=cookiejar, overwrite=False)</font>
<font color="red"> 472.     elif isinstance(cookies, cookielib.CookieJar):</font>
<font color="red"> 473.         try:</font>
<font color="red"> 474.             cookiejar.update(cookies)</font>
<font color="red"> 475.         except AttributeError:</font>
<font color="red"> 476.             for cookie_in_jar in cookies:</font>
<font color="red"> 477.                 cookiejar.set_cookie(cookie_in_jar)</font>
<font color="black"> 478. </font>
<font color="red"> 479.     return cookiejar</font>
</pre>

