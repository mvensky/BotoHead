source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/awsrequest.py</b><br>


file stats: <b>233 lines, 141 executed: 60.5% covered</b>
<pre>
<font color="black">   1. # Copyright (c) 2012-2013 Mitch Garnaat http://garnaat.org/</font>
<font color="black">   2. # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   3. #</font>
<font color="black">   4. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   5. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   6. # the License is located at</font>
<font color="black">   7. #</font>
<font color="black">   8. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   9. #</font>
<font color="black">  10. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  11. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  12. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  13. # language governing permissions and limitations under the License.</font>
<font color="green">  14. import sys</font>
<font color="green">  15. import logging</font>
<font color="green">  16. import select</font>
<font color="green">  17. import functools</font>
<font color="green">  18. import socket</font>
<font color="green">  19. import inspect</font>
<font color="black">  20. </font>
<font color="green">  21. from botocore.compat import six</font>
<font color="green">  22. from botocore.compat import HTTPHeaders, HTTPResponse, urlunsplit, urlsplit,\</font>
<font color="black">  23.     urlparse</font>
<font color="green">  24. from botocore.exceptions import UnseekableStreamError</font>
<font color="green">  25. from botocore.utils import percent_encode_sequence</font>
<font color="green">  26. from botocore.vendored.requests import models</font>
<font color="green">  27. from botocore.vendored.requests.sessions import REDIRECT_STATI</font>
<font color="green">  28. from botocore.vendored.requests.packages.urllib3.connection import \</font>
<font color="black">  29.     VerifiedHTTPSConnection</font>
<font color="green">  30. from botocore.vendored.requests.packages.urllib3.connection import \</font>
<font color="black">  31.     HTTPConnection</font>
<font color="green">  32. from botocore.vendored.requests.packages.urllib3.connectionpool import \</font>
<font color="black">  33.     HTTPConnectionPool</font>
<font color="green">  34. from botocore.vendored.requests.packages.urllib3.connectionpool import \</font>
<font color="black">  35.     HTTPSConnectionPool</font>
<font color="black">  36. </font>
<font color="black">  37. </font>
<font color="green">  38. logger = logging.getLogger(__name__)</font>
<font color="black">  39. </font>
<font color="black">  40. </font>
<font color="green">  41. class AWSHTTPResponse(HTTPResponse):</font>
<font color="black">  42.     # The *args, **kwargs is used because the args are slightly</font>
<font color="black">  43.     # different in py2.6 than in py2.7/py3.</font>
<font color="green">  44.     def __init__(self, *args, **kwargs):</font>
<font color="red">  45.         self._status_tuple = kwargs.pop('status_tuple')</font>
<font color="red">  46.         HTTPResponse.__init__(self, *args, **kwargs)</font>
<font color="black">  47. </font>
<font color="green">  48.     def _read_status(self):</font>
<font color="red">  49.         if self._status_tuple is not None:</font>
<font color="red">  50.             status_tuple = self._status_tuple</font>
<font color="red">  51.             self._status_tuple = None</font>
<font color="red">  52.             return status_tuple</font>
<font color="black">  53.         else:</font>
<font color="red">  54.             return HTTPResponse._read_status(self)</font>
<font color="black">  55. </font>
<font color="black">  56. </font>
<font color="green">  57. class AWSHTTPConnection(HTTPConnection):</font>
<font color="black">  58.     &quot;&quot;&quot;HTTPConnection that supports Expect 100-continue.</font>
<font color="black">  59. </font>
<font color="black">  60.     This is conceptually a subclass of httplib.HTTPConnection (though</font>
<font color="black">  61.     technically we subclass from urllib3, which subclasses</font>
<font color="black">  62.     httplib.HTTPConnection) and we only override this class to support Expect</font>
<font color="black">  63.     100-continue, which we need for S3.  As far as I can tell, this is</font>
<font color="black">  64.     general purpose enough to not be specific to S3, but I'm being</font>
<font color="black">  65.     tentative and keeping it in botocore because I've only tested</font>
<font color="black">  66.     this against AWS services.</font>
<font color="black">  67. </font>
<font color="green">  68.     &quot;&quot;&quot;</font>
<font color="green">  69.     def __init__(self, *args, **kwargs):</font>
<font color="green">  70.         HTTPConnection.__init__(self, *args, **kwargs)</font>
<font color="green">  71.         self._original_response_cls = self.response_class</font>
<font color="black">  72.         # We'd ideally hook into httplib's states, but they're all</font>
<font color="black">  73.         # __mangled_vars so we use our own state var.  This variable is set</font>
<font color="black">  74.         # when we receive an early response from the server.  If this value is</font>
<font color="black">  75.         # set to True, any calls to send() are noops.  This value is reset to</font>
<font color="black">  76.         # false every time _send_request is called.  This is to workaround the</font>
<font color="black">  77.         # fact that py2.6 (and only py2.6) has a separate send() call for the</font>
<font color="black">  78.         # body in _send_request, as opposed to endheaders(), which is where the</font>
<font color="black">  79.         # body is sent in all versions &gt; 2.6.</font>
<font color="green">  80.         self._response_received = False</font>
<font color="green">  81.         self._expect_header_set = False</font>
<font color="black">  82. </font>
<font color="green">  83.     def close(self):</font>
<font color="green">  84.         HTTPConnection.close(self)</font>
<font color="black">  85.         # Reset all of our instance state we were tracking.</font>
<font color="green">  86.         self._response_received = False</font>
<font color="green">  87.         self._expect_header_set = False</font>
<font color="green">  88.         self.response_class = self._original_response_cls</font>
<font color="black">  89. </font>
<font color="green">  90.     def _tunnel(self):</font>
<font color="black">  91.         # Works around a bug in py26 which is fixed in later versions of</font>
<font color="black">  92.         # python. Bug involves hitting an infinite loop if readline() returns</font>
<font color="black">  93.         # nothing as opposed to just ``\r\n``.</font>
<font color="black">  94.         # As much as I don't like having if py2: &lt;foo&gt; code blocks, this seems</font>
<font color="black">  95.         # the cleanest way to handle this workaround.  Fortunately, the</font>
<font color="black">  96.         # difference from py26 to py3 is very minimal.  We're essentially</font>
<font color="black">  97.         # just overriding the while loop.</font>
<font color="red">  98.         if sys.version_info[:2] != (2, 6):</font>
<font color="red">  99.             return HTTPConnection._tunnel(self)</font>
<font color="black"> 100. </font>
<font color="black"> 101.         # Otherwise we workaround the issue.</font>
<font color="red"> 102.         self._set_hostport(self._tunnel_host, self._tunnel_port)</font>
<font color="red"> 103.         self.send(&quot;CONNECT %s:%d HTTP/1.0\r\n&quot; % (self.host, self.port))</font>
<font color="red"> 104.         for header, value in self._tunnel_headers.iteritems():</font>
<font color="red"> 105.             self.send(&quot;%s: %s\r\n&quot; % (header, value))</font>
<font color="red"> 106.         self.send(&quot;\r\n&quot;)</font>
<font color="red"> 107.         response = self.response_class(self.sock, strict=self.strict,</font>
<font color="red"> 108.                                        method=self._method)</font>
<font color="red"> 109.         (version, code, message) = response._read_status()</font>
<font color="black"> 110. </font>
<font color="red"> 111.         if code != 200:</font>
<font color="red"> 112.             self.close()</font>
<font color="red"> 113.             raise socket.error(&quot;Tunnel connection failed: %d %s&quot; %</font>
<font color="red"> 114.                                (code, message.strip()))</font>
<font color="red"> 115.         while True:</font>
<font color="red"> 116.             line = response.fp.readline()</font>
<font color="red"> 117.             if not line:</font>
<font color="red"> 118.                 break</font>
<font color="red"> 119.             if line in (b'\r\n', b'\n', b''):</font>
<font color="red"> 120.                 break</font>
<font color="black"> 121. </font>
<font color="green"> 122.     def _send_request(self, method, url, body, headers, *args, **kwargs):</font>
<font color="green"> 123.         self._response_received = False</font>
<font color="green"> 124.         if headers.get('Expect', b'') == b'100-continue':</font>
<font color="red"> 125.             self._expect_header_set = True</font>
<font color="black"> 126.         else:</font>
<font color="green"> 127.             self._expect_header_set = False</font>
<font color="green"> 128.             self.response_class = self._original_response_cls</font>
<font color="green"> 129.         rval = HTTPConnection._send_request(</font>
<font color="green"> 130.             self, method, url, body, headers, *args, **kwargs)</font>
<font color="green"> 131.         self._expect_header_set = False</font>
<font color="green"> 132.         return rval</font>
<font color="black"> 133. </font>
<font color="green"> 134.     def _convert_to_bytes(self, mixed_buffer):</font>
<font color="black"> 135.         # Take a list of mixed str/bytes and convert it</font>
<font color="black"> 136.         # all into a single bytestring.</font>
<font color="black"> 137.         # Any six.text_types will be encoded as utf-8.</font>
<font color="green"> 138.         bytes_buffer = []</font>
<font color="green"> 139.         for chunk in mixed_buffer:</font>
<font color="green"> 140.             if isinstance(chunk, six.text_type):</font>
<font color="green"> 141.                 bytes_buffer.append(chunk.encode('utf-8'))</font>
<font color="black"> 142.             else:</font>
<font color="green"> 143.                 bytes_buffer.append(chunk)</font>
<font color="green"> 144.         msg = b&quot;\r\n&quot;.join(bytes_buffer)</font>
<font color="green"> 145.         return msg</font>
<font color="black"> 146. </font>
<font color="green"> 147.     def _send_output(self, message_body=None, *args, **kwargs):</font>
<font color="green"> 148.         self._buffer.extend((b&quot;&quot;, b&quot;&quot;))</font>
<font color="green"> 149.         msg = self._convert_to_bytes(self._buffer)</font>
<font color="green"> 150.         del self._buffer[:]</font>
<font color="black"> 151.         # If msg and message_body are sent in a single send() call,</font>
<font color="black"> 152.         # it will avoid performance problems caused by the interaction</font>
<font color="black"> 153.         # between delayed ack and the Nagle algorithm.</font>
<font color="green"> 154.         if isinstance(message_body, bytes):</font>
<font color="green"> 155.             msg += message_body</font>
<font color="green"> 156.             message_body = None</font>
<font color="green"> 157.         self.send(msg)</font>
<font color="green"> 158.         if self._expect_header_set:</font>
<font color="black"> 159.             # This is our custom behavior.  If the Expect header was</font>
<font color="black"> 160.             # set, it will trigger this custom behavior.</font>
<font color="red"> 161.             logger.debug(&quot;Waiting for 100 Continue response.&quot;)</font>
<font color="black"> 162.             # Wait for 1 second for the server to send a response.</font>
<font color="red"> 163.             read, write, exc = select.select([self.sock], [], [self.sock], 1)</font>
<font color="red"> 164.             if read:</font>
<font color="red"> 165.                 self._handle_expect_response(message_body)</font>
<font color="red"> 166.                 return</font>
<font color="black"> 167.             else:</font>
<font color="black"> 168.                 # From the RFC:</font>
<font color="black"> 169.                 # Because of the presence of older implementations, the</font>
<font color="black"> 170.                 # protocol allows ambiguous situations in which a client may</font>
<font color="black"> 171.                 # send &quot;Expect: 100-continue&quot; without receiving either a 417</font>
<font color="black"> 172.                 # (Expectation Failed) status or a 100 (Continue) status.</font>
<font color="black"> 173.                 # Therefore, when a client sends this header field to an origin</font>
<font color="black"> 174.                 # server (possibly via a proxy) from which it has never seen a</font>
<font color="black"> 175.                 # 100 (Continue) status, the client SHOULD NOT wait for an</font>
<font color="black"> 176.                 # indefinite period before sending the request body.</font>
<font color="red"> 177.                 logger.debug(&quot;No response seen from server, continuing to &quot;</font>
<font color="black"> 178.                              &quot;send the response body.&quot;)</font>
<font color="green"> 179.         if message_body is not None:</font>
<font color="black"> 180.             # message_body was not a string (i.e. it is a file), and</font>
<font color="black"> 181.             # we must run the risk of Nagle.</font>
<font color="red"> 182.             self.send(message_body)</font>
<font color="black"> 183. </font>
<font color="green"> 184.     def _consume_headers(self, fp):</font>
<font color="black"> 185.         # Most servers (including S3) will just return</font>
<font color="black"> 186.         # the CLRF after the 100 continue response.  However,</font>
<font color="black"> 187.         # some servers (I've specifically seen this for squid when</font>
<font color="black"> 188.         # used as a straight HTTP proxy) will also inject a</font>
<font color="black"> 189.         # Connection: keep-alive header.  To account for this</font>
<font color="black"> 190.         # we'll read until we read '\r\n', and ignore any headers</font>
<font color="black"> 191.         # that come immediately after the 100 continue response.</font>
<font color="red"> 192.         current = None</font>
<font color="red"> 193.         while current != b'\r\n':</font>
<font color="red"> 194.             current = fp.readline()</font>
<font color="black"> 195. </font>
<font color="green"> 196.     def _handle_expect_response(self, message_body):</font>
<font color="black"> 197.         # This is called when we sent the request headers containing</font>
<font color="black"> 198.         # an Expect: 100-continue header and received a response.</font>
<font color="black"> 199.         # We now need to figure out what to do.</font>
<font color="red"> 200.         fp = self.sock.makefile('rb', 0)</font>
<font color="red"> 201.         try:</font>
<font color="red"> 202.             maybe_status_line = fp.readline()</font>
<font color="red"> 203.             parts = maybe_status_line.split(None, 2)</font>
<font color="red"> 204.             if self._is_100_continue_status(maybe_status_line):</font>
<font color="red"> 205.                 self._consume_headers(fp)</font>
<font color="red"> 206.                 logger.debug(&quot;100 Continue response seen, &quot;</font>
<font color="black"> 207.                              &quot;now sending request body.&quot;)</font>
<font color="red"> 208.                 self._send_message_body(message_body)</font>
<font color="red"> 209.             elif len(parts) == 3 and parts[0].startswith(b'HTTP/'):</font>
<font color="black"> 210.                 # From the RFC:</font>
<font color="black"> 211.                 # Requirements for HTTP/1.1 origin servers:</font>
<font color="black"> 212.                 #</font>
<font color="black"> 213.                 # - Upon receiving a request which includes an Expect</font>
<font color="black"> 214.                 #   request-header field with the &quot;100-continue&quot;</font>
<font color="black"> 215.                 #   expectation, an origin server MUST either respond with</font>
<font color="black"> 216.                 #   100 (Continue) status and continue to read from the</font>
<font color="black"> 217.                 #   input stream, or respond with a final status code.</font>
<font color="black"> 218.                 #</font>
<font color="black"> 219.                 # So if we don't get a 100 Continue response, then</font>
<font color="black"> 220.                 # whatever the server has sent back is the final response</font>
<font color="black"> 221.                 # and don't send the message_body.</font>
<font color="red"> 222.                 logger.debug(&quot;Received a non 100 Continue response &quot;</font>
<font color="black"> 223.                              &quot;from the server, NOT sending request body.&quot;)</font>
<font color="red"> 224.                 status_tuple = (parts[0].decode('ascii'),</font>
<font color="red"> 225.                                 int(parts[1]), parts[2].decode('ascii'))</font>
<font color="red"> 226.                 response_class = functools.partial(</font>
<font color="red"> 227.                     AWSHTTPResponse, status_tuple=status_tuple)</font>
<font color="red"> 228.                 self.response_class = response_class</font>
<font color="red"> 229.                 self._response_received = True</font>
<font color="black"> 230.         finally:</font>
<font color="red"> 231.             fp.close()</font>
<font color="black"> 232. </font>
<font color="green"> 233.     def _send_message_body(self, message_body):</font>
<font color="red"> 234.         if message_body is not None:</font>
<font color="red"> 235.             self.send(message_body)</font>
<font color="black"> 236. </font>
<font color="green"> 237.     def send(self, str):</font>
<font color="green"> 238.         if self._response_received:</font>
<font color="red"> 239.             logger.debug(&quot;send() called, but reseponse already received. &quot;</font>
<font color="black"> 240.                          &quot;Not sending data.&quot;)</font>
<font color="red"> 241.             return</font>
<font color="green"> 242.         return HTTPConnection.send(self, str)</font>
<font color="black"> 243. </font>
<font color="green"> 244.     def _is_100_continue_status(self, maybe_status_line):</font>
<font color="red"> 245.         parts = maybe_status_line.split(None, 2)</font>
<font color="black"> 246.         # Check for HTTP/&lt;version&gt; 100 Continue\r\n</font>
<font color="black"> 247.         return (</font>
<font color="red"> 248.             len(parts) &gt;= 3 and parts[0].startswith(b'HTTP/') and</font>
<font color="red"> 249.             parts[1] == b'100')</font>
<font color="black"> 250. </font>
<font color="black"> 251. </font>
<font color="green"> 252. class AWSHTTPSConnection(VerifiedHTTPSConnection):</font>
<font color="green"> 253.     pass</font>
<font color="black"> 254. </font>
<font color="black"> 255. </font>
<font color="black"> 256. # Now we need to set the methods we overrode from AWSHTTPConnection</font>
<font color="black"> 257. # onto AWSHTTPSConnection.  This is just a shortcut to avoid</font>
<font color="black"> 258. # copy/pasting the same code into AWSHTTPSConnection.</font>
<font color="green"> 259. for name, function in AWSHTTPConnection.__dict__.items():</font>
<font color="green"> 260.     if inspect.isfunction(function):</font>
<font color="green"> 261.         setattr(AWSHTTPSConnection, name, function)</font>
<font color="black"> 262. </font>
<font color="black"> 263. </font>
<font color="green"> 264. def prepare_request_dict(request_dict, endpoint_url, context=None,</font>
<font color="green"> 265.                          user_agent=None):</font>
<font color="black"> 266.     &quot;&quot;&quot;</font>
<font color="black"> 267.     This method prepares a request dict to be created into an</font>
<font color="black"> 268.     AWSRequestObject. This prepares the request dict by adding the</font>
<font color="black"> 269.     url and the user agent to the request dict.</font>
<font color="black"> 270. </font>
<font color="black"> 271.     :type request_dict: dict</font>
<font color="black"> 272.     :param request_dict:  The request dict (created from the</font>
<font color="black"> 273.         ``serialize`` module).</font>
<font color="black"> 274. </font>
<font color="black"> 275.     :type user_agent: string</font>
<font color="black"> 276.     :param user_agent: The user agent to use for this request.</font>
<font color="black"> 277. </font>
<font color="black"> 278.     :type endpoint_url: string</font>
<font color="black"> 279.     :param endpoint_url: The full endpoint url, which contains at least</font>
<font color="black"> 280.         the scheme, the hostname, and optionally any path components.</font>
<font color="black"> 281.     &quot;&quot;&quot;</font>
<font color="green"> 282.     r = request_dict</font>
<font color="green"> 283.     if user_agent is not None:</font>
<font color="green"> 284.         headers = r['headers']</font>
<font color="green"> 285.         headers['User-Agent'] = user_agent</font>
<font color="green"> 286.     url = _urljoin(endpoint_url, r['url_path'])</font>
<font color="green"> 287.     if r['query_string']:</font>
<font color="red"> 288.         encoded_query_string = percent_encode_sequence(r['query_string'])</font>
<font color="red"> 289.         if '?' not in url:</font>
<font color="red"> 290.             url += '?%s' % encoded_query_string</font>
<font color="black"> 291.         else:</font>
<font color="red"> 292.             url += '&amp;%s' % encoded_query_string</font>
<font color="green"> 293.     r['url'] = url</font>
<font color="green"> 294.     r['context'] = context</font>
<font color="green"> 295.     if context is None:</font>
<font color="red"> 296.         r['context'] = {}</font>
<font color="black"> 297. </font>
<font color="black"> 298. </font>
<font color="green"> 299. def create_request_object(request_dict):</font>
<font color="black"> 300.     &quot;&quot;&quot;</font>
<font color="black"> 301.     This method takes a request dict and creates an AWSRequest object</font>
<font color="black"> 302.     from it.</font>
<font color="black"> 303. </font>
<font color="black"> 304.     :type request_dict: dict</font>
<font color="black"> 305.     :param request_dict:  The request dict (created from the</font>
<font color="black"> 306.         ``prepare_request_dict`` method).</font>
<font color="black"> 307. </font>
<font color="black"> 308.     :rtype: ``botocore.awsrequest.AWSRequest``</font>
<font color="black"> 309.     :return: An AWSRequest object based on the request_dict.</font>
<font color="black"> 310. </font>
<font color="black"> 311.     &quot;&quot;&quot;</font>
<font color="green"> 312.     r = request_dict</font>
<font color="green"> 313.     request_object = AWSRequest(</font>
<font color="green"> 314.         method=r['method'], url=r['url'], data=r['body'], headers=r['headers'])</font>
<font color="green"> 315.     request_object.context.update(r['context'])</font>
<font color="green"> 316.     return request_object</font>
<font color="black"> 317. </font>
<font color="black"> 318. </font>
<font color="green"> 319. def _urljoin(endpoint_url, url_path):</font>
<font color="green"> 320.     p = urlsplit(endpoint_url)</font>
<font color="black"> 321.     # &lt;part&gt;   - &lt;index&gt;</font>
<font color="black"> 322.     # scheme   - p[0]</font>
<font color="black"> 323.     # netloc   - p[1]</font>
<font color="black"> 324.     # path     - p[2]</font>
<font color="black"> 325.     # query    - p[3]</font>
<font color="black"> 326.     # fragment - p[4]</font>
<font color="green"> 327.     if not url_path or url_path == '/':</font>
<font color="black"> 328.         # If there's no path component, ensure the URL ends with</font>
<font color="black"> 329.         # a '/' for backwards compatibility.</font>
<font color="green"> 330.         if not p[2]:</font>
<font color="green"> 331.             return endpoint_url + '/'</font>
<font color="red"> 332.         return endpoint_url</font>
<font color="green"> 333.     if p[2].endswith('/') and url_path.startswith('/'):</font>
<font color="red"> 334.         new_path = p[2][:-1] + url_path</font>
<font color="black"> 335.     else:</font>
<font color="green"> 336.         new_path = p[2] + url_path</font>
<font color="green"> 337.     reconstructed = urlunsplit((p[0], p[1], new_path, p[3], p[4]))</font>
<font color="green"> 338.     return reconstructed</font>
<font color="black"> 339. </font>
<font color="black"> 340. </font>
<font color="green"> 341. class AWSRequest(models.RequestEncodingMixin, models.Request):</font>
<font color="green"> 342.     def __init__(self, *args, **kwargs):</font>
<font color="green"> 343.         self.auth_path = None</font>
<font color="green"> 344.         if 'auth_path' in kwargs:</font>
<font color="red"> 345.             self.auth_path = kwargs['auth_path']</font>
<font color="red"> 346.             del kwargs['auth_path']</font>
<font color="green"> 347.         models.Request.__init__(self, *args, **kwargs)</font>
<font color="green"> 348.         headers = HTTPHeaders()</font>
<font color="green"> 349.         if self.headers is not None:</font>
<font color="green"> 350.             for key, value in self.headers.items():</font>
<font color="green"> 351.                 headers[key] = value</font>
<font color="green"> 352.         self.headers = headers</font>
<font color="black"> 353.         # This is a dictionary to hold information that is used when</font>
<font color="black"> 354.         # processing the request. What is inside of ``context`` is open-ended.</font>
<font color="black"> 355.         # For example, it may have a timestamp key that is used for holding</font>
<font color="black"> 356.         # what the timestamp is when signing the request. Note that none</font>
<font color="black"> 357.         # of the information that is inside of ``context`` is directly</font>
<font color="black"> 358.         # sent over the wire; the information is only used to assist in</font>
<font color="black"> 359.         # creating what is sent over the wire.</font>
<font color="green"> 360.         self.context = {}</font>
<font color="black"> 361. </font>
<font color="green"> 362.     def prepare(self):</font>
<font color="black"> 363.         &quot;&quot;&quot;Constructs a :class:`AWSPreparedRequest &lt;AWSPreparedRequest&gt;`.&quot;&quot;&quot;</font>
<font color="black"> 364.         # Eventually I think it would be nice to add hooks into this process.</font>
<font color="green"> 365.         p = AWSPreparedRequest(self)</font>
<font color="green"> 366.         p.prepare_method(self.method)</font>
<font color="green"> 367.         p.prepare_url(self.url, self.params)</font>
<font color="green"> 368.         p.prepare_headers(self.headers)</font>
<font color="green"> 369.         p.prepare_cookies(self.cookies)</font>
<font color="green"> 370.         p.prepare_body(self.data, self.files)</font>
<font color="green"> 371.         p.prepare_auth(self.auth)</font>
<font color="green"> 372.         return p</font>
<font color="black"> 373. </font>
<font color="green"> 374.     @property</font>
<font color="black"> 375.     def body(self):</font>
<font color="green"> 376.         p = models.PreparedRequest()</font>
<font color="green"> 377.         p.prepare_headers({})</font>
<font color="green"> 378.         p.prepare_body(self.data, self.files)</font>
<font color="green"> 379.         if isinstance(p.body, six.text_type):</font>
<font color="red"> 380.             p.body = p.body.encode('utf-8')</font>
<font color="green"> 381.         return p.body</font>
<font color="black"> 382. </font>
<font color="black"> 383. </font>
<font color="green"> 384. class AWSPreparedRequest(models.PreparedRequest):</font>
<font color="black"> 385.     &quot;&quot;&quot;Represents a prepared request.</font>
<font color="black"> 386. </font>
<font color="black"> 387.     :ivar method: HTTP Method</font>
<font color="black"> 388.     :ivar url: The full url</font>
<font color="black"> 389.     :ivar headers: The HTTP headers to send.</font>
<font color="black"> 390.     :ivar body: The HTTP body.</font>
<font color="black"> 391.     :ivar hooks: The set of callback hooks.</font>
<font color="black"> 392. </font>
<font color="black"> 393.     In addition to the above attributes, the following attributes are</font>
<font color="black"> 394.     available:</font>
<font color="black"> 395. </font>
<font color="black"> 396.     :ivar query_params: The original query parameters.</font>
<font color="black"> 397.     :ivar post_param: The original POST params (dict).</font>
<font color="black"> 398. </font>
<font color="green"> 399.     &quot;&quot;&quot;</font>
<font color="green"> 400.     def __init__(self, original_request):</font>
<font color="green"> 401.         self.original = original_request</font>
<font color="green"> 402.         super(AWSPreparedRequest, self).__init__()</font>
<font color="green"> 403.         self.hooks.setdefault('response', []).append(</font>
<font color="green"> 404.             self.reset_stream_on_redirect)</font>
<font color="black"> 405. </font>
<font color="green"> 406.     def reset_stream_on_redirect(self, response, **kwargs):</font>
<font color="green"> 407.         if response.status_code in REDIRECT_STATI and \</font>
<font color="red"> 408.                 self._looks_like_file(self.body):</font>
<font color="red"> 409.             logger.debug(&quot;Redirect received, rewinding stream: %s&quot;, self.body)</font>
<font color="red"> 410.             self.reset_stream()</font>
<font color="black"> 411. </font>
<font color="green"> 412.     def _looks_like_file(self, body):</font>
<font color="red"> 413.         return hasattr(body, 'read') and hasattr(body, 'seek')</font>
<font color="black"> 414. </font>
<font color="green"> 415.     def reset_stream(self):</font>
<font color="black"> 416.         # Trying to reset a stream when there is a no stream will</font>
<font color="black"> 417.         # just immediately return.  It's not an error, it will produce</font>
<font color="black"> 418.         # the same result as if we had actually reset the stream (we'll send</font>
<font color="black"> 419.         # the entire body contents again if we need to).</font>
<font color="black"> 420.         # Same case if the body is a string/bytes type.</font>
<font color="red"> 421.         if self.body is None or isinstance(self.body, six.text_type) or \</font>
<font color="red"> 422.                 isinstance(self.body, six.binary_type):</font>
<font color="red"> 423.             return</font>
<font color="red"> 424.         try:</font>
<font color="red"> 425.             logger.debug(&quot;Rewinding stream: %s&quot;, self.body)</font>
<font color="red"> 426.             self.body.seek(0)</font>
<font color="red"> 427.         except Exception as e:</font>
<font color="red"> 428.             logger.debug(&quot;Unable to rewind stream: %s&quot;, e)</font>
<font color="red"> 429.             raise UnseekableStreamError(stream_object=self.body)</font>
<font color="black"> 430. </font>
<font color="green"> 431.     def prepare_body(self, data, files, json=None):</font>
<font color="black"> 432.         &quot;&quot;&quot;Prepares the given HTTP body data.&quot;&quot;&quot;</font>
<font color="green"> 433.         super(AWSPreparedRequest, self).prepare_body(data, files, json)</font>
<font color="black"> 434. </font>
<font color="black"> 435.         # Calculate the Content-Length by trying to seek the file as</font>
<font color="black"> 436.         # requests cannot determine content length for some seekable file-like</font>
<font color="black"> 437.         # objects.</font>
<font color="green"> 438.         if 'Content-Length' not in self.headers:</font>
<font color="green"> 439.             if hasattr(data, 'seek') and hasattr(data, 'tell'):</font>
<font color="red"> 440.                 orig_pos = data.tell()</font>
<font color="red"> 441.                 data.seek(0, 2)</font>
<font color="red"> 442.                 end_file_pos = data.tell()</font>
<font color="red"> 443.                 self.headers['Content-Length'] = str(end_file_pos - orig_pos)</font>
<font color="red"> 444.                 data.seek(orig_pos)</font>
<font color="black"> 445.                 # If the Content-Length was added this way, a</font>
<font color="black"> 446.                 # Transfer-Encoding was added by requests because it did</font>
<font color="black"> 447.                 # not add a Content-Length header. However, the</font>
<font color="black"> 448.                 # Transfer-Encoding header is not supported for</font>
<font color="black"> 449.                 # AWS Services so remove it if it is added.</font>
<font color="red"> 450.                 if 'Transfer-Encoding' in self.headers:</font>
<font color="red"> 451.                     self.headers.pop('Transfer-Encoding')</font>
<font color="black"> 452. </font>
<font color="black"> 453. </font>
<font color="green"> 454. HTTPSConnectionPool.ConnectionCls = AWSHTTPSConnection</font>
<font color="green"> 455. HTTPConnectionPool.ConnectionCls = AWSHTTPConnection</font>
</pre>

