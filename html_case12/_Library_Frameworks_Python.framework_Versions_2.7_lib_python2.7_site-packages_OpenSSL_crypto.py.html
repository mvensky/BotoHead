source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/OpenSSL/crypto.py</b><br>


file stats: <b>1197 lines, 240 executed: 20.1% covered</b>
<pre>
<font color="green">   1. import datetime</font>
<font color="black">   2. </font>
<font color="green">   3. from base64 import b16encode</font>
<font color="green">   4. from functools import partial</font>
<font color="green">   5. from operator import __eq__, __ne__, __lt__, __le__, __gt__, __ge__</font>
<font color="green">   6. from warnings import warn as _warn</font>
<font color="black">   7. </font>
<font color="green">   8. from six import (</font>
<font color="black">   9.     integer_types as _integer_types,</font>
<font color="black">  10.     text_type as _text_type,</font>
<font color="black">  11.     PY3 as _PY3)</font>
<font color="black">  12. </font>
<font color="green">  13. from cryptography.hazmat.primitives.asymmetric import dsa, rsa</font>
<font color="black">  14. </font>
<font color="green">  15. from OpenSSL._util import (</font>
<font color="black">  16.     ffi as _ffi,</font>
<font color="black">  17.     lib as _lib,</font>
<font color="black">  18.     exception_from_error_queue as _exception_from_error_queue,</font>
<font color="black">  19.     byte_string as _byte_string,</font>
<font color="black">  20.     native as _native,</font>
<font color="black">  21.     UNSPECIFIED as _UNSPECIFIED,</font>
<font color="black">  22.     text_to_bytes_and_warn as _text_to_bytes_and_warn,</font>
<font color="black">  23.     make_assert as _make_assert,</font>
<font color="black">  24. )</font>
<font color="black">  25. </font>
<font color="green">  26. FILETYPE_PEM = _lib.SSL_FILETYPE_PEM</font>
<font color="green">  27. FILETYPE_ASN1 = _lib.SSL_FILETYPE_ASN1</font>
<font color="black">  28. </font>
<font color="black">  29. # TODO This was an API mistake.  OpenSSL has no such constant.</font>
<font color="green">  30. FILETYPE_TEXT = 2 ** 16 - 1</font>
<font color="black">  31. </font>
<font color="green">  32. TYPE_RSA = _lib.EVP_PKEY_RSA</font>
<font color="green">  33. TYPE_DSA = _lib.EVP_PKEY_DSA</font>
<font color="black">  34. </font>
<font color="black">  35. </font>
<font color="green">  36. class Error(Exception):</font>
<font color="black">  37.     &quot;&quot;&quot;</font>
<font color="black">  38.     An error occurred in an `OpenSSL.crypto` API.</font>
<font color="green">  39.     &quot;&quot;&quot;</font>
<font color="black">  40. </font>
<font color="black">  41. </font>
<font color="green">  42. _raise_current_error = partial(_exception_from_error_queue, Error)</font>
<font color="green">  43. _openssl_assert = _make_assert(Error)</font>
<font color="black">  44. </font>
<font color="black">  45. </font>
<font color="green">  46. def _get_backend():</font>
<font color="black">  47.     &quot;&quot;&quot;</font>
<font color="black">  48.     Importing the backend from cryptography has the side effect of activating</font>
<font color="black">  49.     the osrandom engine. This mutates the global state of OpenSSL in the</font>
<font color="black">  50.     process and causes issues for various programs that use subinterpreters or</font>
<font color="black">  51.     embed Python. By putting the import in this function we can avoid</font>
<font color="black">  52.     triggering this side effect unless _get_backend is called.</font>
<font color="black">  53.     &quot;&quot;&quot;</font>
<font color="red">  54.     from cryptography.hazmat.backends.openssl.backend import backend</font>
<font color="red">  55.     return backend</font>
<font color="black">  56. </font>
<font color="black">  57. </font>
<font color="green">  58. def _untested_error(where):</font>
<font color="black">  59.     &quot;&quot;&quot;</font>
<font color="black">  60.     An OpenSSL API failed somehow.  Additionally, the failure which was</font>
<font color="black">  61.     encountered isn't one that's exercised by the test suite so future behavior</font>
<font color="black">  62.     of pyOpenSSL is now somewhat less predictable.</font>
<font color="black">  63.     &quot;&quot;&quot;</font>
<font color="red">  64.     raise RuntimeError(&quot;Unknown %s failure&quot; % (where,))</font>
<font color="black">  65. </font>
<font color="black">  66. </font>
<font color="green">  67. def _new_mem_buf(buffer=None):</font>
<font color="black">  68.     &quot;&quot;&quot;</font>
<font color="black">  69.     Allocate a new OpenSSL memory BIO.</font>
<font color="black">  70. </font>
<font color="black">  71.     Arrange for the garbage collector to clean it up automatically.</font>
<font color="black">  72. </font>
<font color="black">  73.     :param buffer: None or some bytes to use to put into the BIO so that they</font>
<font color="black">  74.         can be read out.</font>
<font color="black">  75.     &quot;&quot;&quot;</font>
<font color="red">  76.     if buffer is None:</font>
<font color="red">  77.         bio = _lib.BIO_new(_lib.BIO_s_mem())</font>
<font color="red">  78.         free = _lib.BIO_free</font>
<font color="black">  79.     else:</font>
<font color="red">  80.         data = _ffi.new(&quot;char[]&quot;, buffer)</font>
<font color="red">  81.         bio = _lib.BIO_new_mem_buf(data, len(buffer))</font>
<font color="black">  82. </font>
<font color="black">  83.         # Keep the memory alive as long as the bio is alive!</font>
<font color="red">  84.         def free(bio, ref=data):</font>
<font color="red">  85.             return _lib.BIO_free(bio)</font>
<font color="black">  86. </font>
<font color="red">  87.     _openssl_assert(bio != _ffi.NULL)</font>
<font color="black">  88. </font>
<font color="red">  89.     bio = _ffi.gc(bio, free)</font>
<font color="red">  90.     return bio</font>
<font color="black">  91. </font>
<font color="black">  92. </font>
<font color="green">  93. def _bio_to_string(bio):</font>
<font color="black">  94.     &quot;&quot;&quot;</font>
<font color="black">  95.     Copy the contents of an OpenSSL BIO object into a Python byte string.</font>
<font color="black">  96.     &quot;&quot;&quot;</font>
<font color="red">  97.     result_buffer = _ffi.new('char**')</font>
<font color="red">  98.     buffer_length = _lib.BIO_get_mem_data(bio, result_buffer)</font>
<font color="red">  99.     return _ffi.buffer(result_buffer[0], buffer_length)[:]</font>
<font color="black"> 100. </font>
<font color="black"> 101. </font>
<font color="green"> 102. def _set_asn1_time(boundary, when):</font>
<font color="black"> 103.     &quot;&quot;&quot;</font>
<font color="black"> 104.     The the time value of an ASN1 time object.</font>
<font color="black"> 105. </font>
<font color="black"> 106.     @param boundary: An ASN1_GENERALIZEDTIME pointer (or an object safely</font>
<font color="black"> 107.         castable to that type) which will have its value set.</font>
<font color="black"> 108.     @param when: A string representation of the desired time value.</font>
<font color="black"> 109. </font>
<font color="black"> 110.     @raise TypeError: If C{when} is not a L{bytes} string.</font>
<font color="black"> 111.     @raise ValueError: If C{when} does not represent a time in the required</font>
<font color="black"> 112.         format.</font>
<font color="black"> 113.     @raise RuntimeError: If the time value cannot be set for some other</font>
<font color="black"> 114.         (unspecified) reason.</font>
<font color="black"> 115.     &quot;&quot;&quot;</font>
<font color="red"> 116.     if not isinstance(when, bytes):</font>
<font color="red"> 117.         raise TypeError(&quot;when must be a byte string&quot;)</font>
<font color="black"> 118. </font>
<font color="red"> 119.     set_result = _lib.ASN1_GENERALIZEDTIME_set_string(</font>
<font color="red"> 120.         _ffi.cast('ASN1_GENERALIZEDTIME*', boundary), when)</font>
<font color="red"> 121.     if set_result == 0:</font>
<font color="red"> 122.         dummy = _ffi.gc(_lib.ASN1_STRING_new(), _lib.ASN1_STRING_free)</font>
<font color="red"> 123.         _lib.ASN1_STRING_set(dummy, when, len(when))</font>
<font color="red"> 124.         check_result = _lib.ASN1_GENERALIZEDTIME_check(</font>
<font color="red"> 125.             _ffi.cast('ASN1_GENERALIZEDTIME*', dummy))</font>
<font color="red"> 126.         if not check_result:</font>
<font color="red"> 127.             raise ValueError(&quot;Invalid string&quot;)</font>
<font color="black"> 128.         else:</font>
<font color="red"> 129.             _untested_error()</font>
<font color="black"> 130. </font>
<font color="black"> 131. </font>
<font color="green"> 132. def _get_asn1_time(timestamp):</font>
<font color="black"> 133.     &quot;&quot;&quot;</font>
<font color="black"> 134.     Retrieve the time value of an ASN1 time object.</font>
<font color="black"> 135. </font>
<font color="black"> 136.     @param timestamp: An ASN1_GENERALIZEDTIME* (or an object safely castable to</font>
<font color="black"> 137.         that type) from which the time value will be retrieved.</font>
<font color="black"> 138. </font>
<font color="black"> 139.     @return: The time value from C{timestamp} as a L{bytes} string in a certain</font>
<font color="black"> 140.         format.  Or C{None} if the object contains no time value.</font>
<font color="black"> 141.     &quot;&quot;&quot;</font>
<font color="red"> 142.     string_timestamp = _ffi.cast('ASN1_STRING*', timestamp)</font>
<font color="red"> 143.     if _lib.ASN1_STRING_length(string_timestamp) == 0:</font>
<font color="red"> 144.         return None</font>
<font color="black"> 145.     elif (</font>
<font color="red"> 146.         _lib.ASN1_STRING_type(string_timestamp) == _lib.V_ASN1_GENERALIZEDTIME</font>
<font color="black"> 147.     ):</font>
<font color="red"> 148.         return _ffi.string(_lib.ASN1_STRING_data(string_timestamp))</font>
<font color="black"> 149.     else:</font>
<font color="red"> 150.         generalized_timestamp = _ffi.new(&quot;ASN1_GENERALIZEDTIME**&quot;)</font>
<font color="red"> 151.         _lib.ASN1_TIME_to_generalizedtime(timestamp, generalized_timestamp)</font>
<font color="red"> 152.         if generalized_timestamp[0] == _ffi.NULL:</font>
<font color="black"> 153.             # This may happen:</font>
<font color="black"> 154.             #   - if timestamp was not an ASN1_TIME</font>
<font color="black"> 155.             #   - if allocating memory for the ASN1_GENERALIZEDTIME failed</font>
<font color="black"> 156.             #   - if a copy of the time data from timestamp cannot be made for</font>
<font color="black"> 157.             #     the newly allocated ASN1_GENERALIZEDTIME</font>
<font color="black"> 158.             #</font>
<font color="black"> 159.             # These are difficult to test.  cffi enforces the ASN1_TIME type.</font>
<font color="black"> 160.             # Memory allocation failures are a pain to trigger</font>
<font color="black"> 161.             # deterministically.</font>
<font color="red"> 162.             _untested_error(&quot;ASN1_TIME_to_generalizedtime&quot;)</font>
<font color="black"> 163.         else:</font>
<font color="red"> 164.             string_timestamp = _ffi.cast(</font>
<font color="red"> 165.                 &quot;ASN1_STRING*&quot;, generalized_timestamp[0])</font>
<font color="red"> 166.             string_data = _lib.ASN1_STRING_data(string_timestamp)</font>
<font color="red"> 167.             string_result = _ffi.string(string_data)</font>
<font color="red"> 168.             _lib.ASN1_GENERALIZEDTIME_free(generalized_timestamp[0])</font>
<font color="red"> 169.             return string_result</font>
<font color="black"> 170. </font>
<font color="black"> 171. </font>
<font color="green"> 172. class PKey(object):</font>
<font color="black"> 173.     &quot;&quot;&quot;</font>
<font color="black"> 174.     A class representing an DSA or RSA public key or key pair.</font>
<font color="green"> 175.     &quot;&quot;&quot;</font>
<font color="green"> 176.     _only_public = False</font>
<font color="green"> 177.     _initialized = True</font>
<font color="black"> 178. </font>
<font color="green"> 179.     def __init__(self):</font>
<font color="red"> 180.         pkey = _lib.EVP_PKEY_new()</font>
<font color="red"> 181.         self._pkey = _ffi.gc(pkey, _lib.EVP_PKEY_free)</font>
<font color="red"> 182.         self._initialized = False</font>
<font color="black"> 183. </font>
<font color="green"> 184.     def to_cryptography_key(self):</font>
<font color="black"> 185.         &quot;&quot;&quot;</font>
<font color="black"> 186.         Export as a ``cryptography`` key.</font>
<font color="black"> 187. </font>
<font color="black"> 188.         :rtype: One of ``cryptography``'s `key interfaces`_.</font>
<font color="black"> 189. </font>
<font color="black"> 190.         .. _key interfaces: https://cryptography.io/en/latest/hazmat/\</font>
<font color="black"> 191.             primitives/asymmetric/rsa/#key-interfaces</font>
<font color="black"> 192. </font>
<font color="black"> 193.         .. versionadded:: 16.1.0</font>
<font color="black"> 194.         &quot;&quot;&quot;</font>
<font color="red"> 195.         backend = _get_backend()</font>
<font color="red"> 196.         if self._only_public:</font>
<font color="red"> 197.             return backend._evp_pkey_to_public_key(self._pkey)</font>
<font color="black"> 198.         else:</font>
<font color="red"> 199.             return backend._evp_pkey_to_private_key(self._pkey)</font>
<font color="black"> 200. </font>
<font color="green"> 201.     @classmethod</font>
<font color="black"> 202.     def from_cryptography_key(cls, crypto_key):</font>
<font color="black"> 203.         &quot;&quot;&quot;</font>
<font color="black"> 204.         Construct based on a ``cryptography`` *crypto_key*.</font>
<font color="black"> 205. </font>
<font color="black"> 206.         :param crypto_key: A ``cryptography`` key.</font>
<font color="black"> 207.         :type crypto_key: One of ``cryptography``'s `key interfaces`_.</font>
<font color="black"> 208. </font>
<font color="black"> 209.         :rtype: PKey</font>
<font color="black"> 210. </font>
<font color="black"> 211.         .. versionadded:: 16.1.0</font>
<font color="black"> 212.         &quot;&quot;&quot;</font>
<font color="red"> 213.         pkey = cls()</font>
<font color="red"> 214.         if not isinstance(crypto_key, (rsa.RSAPublicKey, rsa.RSAPrivateKey,</font>
<font color="red"> 215.                                        dsa.DSAPublicKey, dsa.DSAPrivateKey)):</font>
<font color="red"> 216.             raise TypeError(&quot;Unsupported key type&quot;)</font>
<font color="black"> 217. </font>
<font color="red"> 218.         pkey._pkey = crypto_key._evp_pkey</font>
<font color="red"> 219.         if isinstance(crypto_key, (rsa.RSAPublicKey, dsa.DSAPublicKey)):</font>
<font color="red"> 220.             pkey._only_public = True</font>
<font color="red"> 221.         pkey._initialized = True</font>
<font color="red"> 222.         return pkey</font>
<font color="black"> 223. </font>
<font color="green"> 224.     def generate_key(self, type, bits):</font>
<font color="black"> 225.         &quot;&quot;&quot;</font>
<font color="black"> 226.         Generate a key pair of the given type, with the given number of bits.</font>
<font color="black"> 227. </font>
<font color="black"> 228.         This generates a key &quot;into&quot; the this object.</font>
<font color="black"> 229. </font>
<font color="black"> 230.         :param type: The key type.</font>
<font color="black"> 231.         :type type: :py:data:`TYPE_RSA` or :py:data:`TYPE_DSA`</font>
<font color="black"> 232.         :param bits: The number of bits.</font>
<font color="black"> 233.         :type bits: :py:data:`int` ``&gt;= 0``</font>
<font color="black"> 234.         :raises TypeError: If :py:data:`type` or :py:data:`bits` isn't</font>
<font color="black"> 235.             of the appropriate type.</font>
<font color="black"> 236.         :raises ValueError: If the number of bits isn't an integer of</font>
<font color="black"> 237.             the appropriate size.</font>
<font color="black"> 238.         :return: ``None``</font>
<font color="black"> 239.         &quot;&quot;&quot;</font>
<font color="red"> 240.         if not isinstance(type, int):</font>
<font color="red"> 241.             raise TypeError(&quot;type must be an integer&quot;)</font>
<font color="black"> 242. </font>
<font color="red"> 243.         if not isinstance(bits, int):</font>
<font color="red"> 244.             raise TypeError(&quot;bits must be an integer&quot;)</font>
<font color="black"> 245. </font>
<font color="black"> 246.         # TODO Check error return</font>
<font color="red"> 247.         exponent = _lib.BN_new()</font>
<font color="red"> 248.         exponent = _ffi.gc(exponent, _lib.BN_free)</font>
<font color="red"> 249.         _lib.BN_set_word(exponent, _lib.RSA_F4)</font>
<font color="black"> 250. </font>
<font color="red"> 251.         if type == TYPE_RSA:</font>
<font color="red"> 252.             if bits &lt;= 0:</font>
<font color="red"> 253.                 raise ValueError(&quot;Invalid number of bits&quot;)</font>
<font color="black"> 254. </font>
<font color="red"> 255.             rsa = _lib.RSA_new()</font>
<font color="black"> 256. </font>
<font color="red"> 257.             result = _lib.RSA_generate_key_ex(rsa, bits, exponent, _ffi.NULL)</font>
<font color="red"> 258.             _openssl_assert(result == 1)</font>
<font color="black"> 259. </font>
<font color="red"> 260.             result = _lib.EVP_PKEY_assign_RSA(self._pkey, rsa)</font>
<font color="red"> 261.             _openssl_assert(result == 1)</font>
<font color="black"> 262. </font>
<font color="red"> 263.         elif type == TYPE_DSA:</font>
<font color="red"> 264.             dsa = _lib.DSA_new()</font>
<font color="red"> 265.             _openssl_assert(dsa != _ffi.NULL)</font>
<font color="black"> 266. </font>
<font color="red"> 267.             dsa = _ffi.gc(dsa, _lib.DSA_free)</font>
<font color="red"> 268.             res = _lib.DSA_generate_parameters_ex(</font>
<font color="red"> 269.                 dsa, bits, _ffi.NULL, 0, _ffi.NULL, _ffi.NULL, _ffi.NULL</font>
<font color="black"> 270.             )</font>
<font color="red"> 271.             _openssl_assert(res == 1)</font>
<font color="black"> 272. </font>
<font color="red"> 273.             _openssl_assert(_lib.DSA_generate_key(dsa) == 1)</font>
<font color="red"> 274.             _openssl_assert(_lib.EVP_PKEY_set1_DSA(self._pkey, dsa) == 1)</font>
<font color="black"> 275.         else:</font>
<font color="red"> 276.             raise Error(&quot;No such key type&quot;)</font>
<font color="black"> 277. </font>
<font color="red"> 278.         self._initialized = True</font>
<font color="black"> 279. </font>
<font color="green"> 280.     def check(self):</font>
<font color="black"> 281.         &quot;&quot;&quot;</font>
<font color="black"> 282.         Check the consistency of an RSA private key.</font>
<font color="black"> 283. </font>
<font color="black"> 284.         This is the Python equivalent of OpenSSL's ``RSA_check_key``.</font>
<font color="black"> 285. </font>
<font color="black"> 286.         :return: True if key is consistent.</font>
<font color="black"> 287.         :raise Error: if the key is inconsistent.</font>
<font color="black"> 288.         :raise TypeError: if the key is of a type which cannot be checked.</font>
<font color="black"> 289.             Only RSA keys can currently be checked.</font>
<font color="black"> 290.         &quot;&quot;&quot;</font>
<font color="red"> 291.         if self._only_public:</font>
<font color="red"> 292.             raise TypeError(&quot;public key only&quot;)</font>
<font color="black"> 293. </font>
<font color="red"> 294.         if _lib.EVP_PKEY_type(self.type()) != _lib.EVP_PKEY_RSA:</font>
<font color="red"> 295.             raise TypeError(&quot;key type unsupported&quot;)</font>
<font color="black"> 296. </font>
<font color="red"> 297.         rsa = _lib.EVP_PKEY_get1_RSA(self._pkey)</font>
<font color="red"> 298.         rsa = _ffi.gc(rsa, _lib.RSA_free)</font>
<font color="red"> 299.         result = _lib.RSA_check_key(rsa)</font>
<font color="red"> 300.         if result:</font>
<font color="red"> 301.             return True</font>
<font color="red"> 302.         _raise_current_error()</font>
<font color="black"> 303. </font>
<font color="green"> 304.     def type(self):</font>
<font color="black"> 305.         &quot;&quot;&quot;</font>
<font color="black"> 306.         Returns the type of the key</font>
<font color="black"> 307. </font>
<font color="black"> 308.         :return: The type of the key.</font>
<font color="black"> 309.         &quot;&quot;&quot;</font>
<font color="red"> 310.         return _lib.Cryptography_EVP_PKEY_id(self._pkey)</font>
<font color="black"> 311. </font>
<font color="green"> 312.     def bits(self):</font>
<font color="black"> 313.         &quot;&quot;&quot;</font>
<font color="black"> 314.         Returns the number of bits of the key</font>
<font color="black"> 315. </font>
<font color="black"> 316.         :return: The number of bits of the key.</font>
<font color="black"> 317.         &quot;&quot;&quot;</font>
<font color="red"> 318.         return _lib.EVP_PKEY_bits(self._pkey)</font>
<font color="green"> 319. PKeyType = PKey</font>
<font color="black"> 320. </font>
<font color="black"> 321. </font>
<font color="green"> 322. class _EllipticCurve(object):</font>
<font color="black"> 323.     &quot;&quot;&quot;</font>
<font color="black"> 324.     A representation of a supported elliptic curve.</font>
<font color="black"> 325. </font>
<font color="black"> 326.     @cvar _curves: :py:obj:`None` until an attempt is made to load the curves.</font>
<font color="black"> 327.         Thereafter, a :py:type:`set` containing :py:type:`_EllipticCurve`</font>
<font color="black"> 328.         instances each of which represents one curve supported by the system.</font>
<font color="black"> 329.     @type _curves: :py:type:`NoneType` or :py:type:`set`</font>
<font color="green"> 330.     &quot;&quot;&quot;</font>
<font color="green"> 331.     _curves = None</font>
<font color="black"> 332. </font>
<font color="green"> 333.     if _PY3:</font>
<font color="black"> 334.         # This only necessary on Python 3.  Morever, it is broken on Python 2.</font>
<font color="red"> 335.         def __ne__(self, other):</font>
<font color="black"> 336.             &quot;&quot;&quot;</font>
<font color="black"> 337.             Implement cooperation with the right-hand side argument of ``!=``.</font>
<font color="black"> 338. </font>
<font color="black"> 339.             Python 3 seems to have dropped this cooperation in this very narrow</font>
<font color="black"> 340.             circumstance.</font>
<font color="black"> 341.             &quot;&quot;&quot;</font>
<font color="red"> 342.             if isinstance(other, _EllipticCurve):</font>
<font color="red"> 343.                 return super(_EllipticCurve, self).__ne__(other)</font>
<font color="red"> 344.             return NotImplemented</font>
<font color="black"> 345. </font>
<font color="green"> 346.     @classmethod</font>
<font color="black"> 347.     def _load_elliptic_curves(cls, lib):</font>
<font color="black"> 348.         &quot;&quot;&quot;</font>
<font color="black"> 349.         Get the curves supported by OpenSSL.</font>
<font color="black"> 350. </font>
<font color="black"> 351.         :param lib: The OpenSSL library binding object.</font>
<font color="black"> 352. </font>
<font color="black"> 353.         :return: A :py:type:`set` of ``cls`` instances giving the names of the</font>
<font color="black"> 354.             elliptic curves the underlying library supports.</font>
<font color="black"> 355.         &quot;&quot;&quot;</font>
<font color="red"> 356.         if lib.Cryptography_HAS_EC:</font>
<font color="red"> 357.             num_curves = lib.EC_get_builtin_curves(_ffi.NULL, 0)</font>
<font color="red"> 358.             builtin_curves = _ffi.new('EC_builtin_curve[]', num_curves)</font>
<font color="black"> 359.             # The return value on this call should be num_curves again.  We</font>
<font color="black"> 360.             # could check it to make sure but if it *isn't* then.. what could</font>
<font color="black"> 361.             # we do? Abort the whole process, I suppose...?  -exarkun</font>
<font color="red"> 362.             lib.EC_get_builtin_curves(builtin_curves, num_curves)</font>
<font color="red"> 363.             return set(</font>
<font color="red"> 364.                 cls.from_nid(lib, c.nid)</font>
<font color="red"> 365.                 for c in builtin_curves)</font>
<font color="red"> 366.         return set()</font>
<font color="black"> 367. </font>
<font color="green"> 368.     @classmethod</font>
<font color="black"> 369.     def _get_elliptic_curves(cls, lib):</font>
<font color="black"> 370.         &quot;&quot;&quot;</font>
<font color="black"> 371.         Get, cache, and return the curves supported by OpenSSL.</font>
<font color="black"> 372. </font>
<font color="black"> 373.         :param lib: The OpenSSL library binding object.</font>
<font color="black"> 374. </font>
<font color="black"> 375.         :return: A :py:type:`set` of ``cls`` instances giving the names of the</font>
<font color="black"> 376.             elliptic curves the underlying library supports.</font>
<font color="black"> 377.         &quot;&quot;&quot;</font>
<font color="red"> 378.         if cls._curves is None:</font>
<font color="red"> 379.             cls._curves = cls._load_elliptic_curves(lib)</font>
<font color="red"> 380.         return cls._curves</font>
<font color="black"> 381. </font>
<font color="green"> 382.     @classmethod</font>
<font color="black"> 383.     def from_nid(cls, lib, nid):</font>
<font color="black"> 384.         &quot;&quot;&quot;</font>
<font color="black"> 385.         Instantiate a new :py:class:`_EllipticCurve` associated with the given</font>
<font color="black"> 386.         OpenSSL NID.</font>
<font color="black"> 387. </font>
<font color="black"> 388.         :param lib: The OpenSSL library binding object.</font>
<font color="black"> 389. </font>
<font color="black"> 390.         :param nid: The OpenSSL NID the resulting curve object will represent.</font>
<font color="black"> 391.             This must be a curve NID (and not, for example, a hash NID) or</font>
<font color="black"> 392.             subsequent operations will fail in unpredictable ways.</font>
<font color="black"> 393.         :type nid: :py:class:`int`</font>
<font color="black"> 394. </font>
<font color="black"> 395.         :return: The curve object.</font>
<font color="black"> 396.         &quot;&quot;&quot;</font>
<font color="red"> 397.         return cls(lib, nid, _ffi.string(lib.OBJ_nid2sn(nid)).decode(&quot;ascii&quot;))</font>
<font color="black"> 398. </font>
<font color="green"> 399.     def __init__(self, lib, nid, name):</font>
<font color="black"> 400.         &quot;&quot;&quot;</font>
<font color="black"> 401.         :param _lib: The :py:mod:`cryptography` binding instance used to</font>
<font color="black"> 402.             interface with OpenSSL.</font>
<font color="black"> 403. </font>
<font color="black"> 404.         :param _nid: The OpenSSL NID identifying the curve this object</font>
<font color="black"> 405.             represents.</font>
<font color="black"> 406.         :type _nid: :py:class:`int`</font>
<font color="black"> 407. </font>
<font color="black"> 408.         :param name: The OpenSSL short name identifying the curve this object</font>
<font color="black"> 409.             represents.</font>
<font color="black"> 410.         :type name: :py:class:`unicode`</font>
<font color="black"> 411.         &quot;&quot;&quot;</font>
<font color="red"> 412.         self._lib = lib</font>
<font color="red"> 413.         self._nid = nid</font>
<font color="red"> 414.         self.name = name</font>
<font color="black"> 415. </font>
<font color="green"> 416.     def __repr__(self):</font>
<font color="red"> 417.         return &quot;&lt;Curve %r&gt;&quot; % (self.name,)</font>
<font color="black"> 418. </font>
<font color="green"> 419.     def _to_EC_KEY(self):</font>
<font color="black"> 420.         &quot;&quot;&quot;</font>
<font color="black"> 421.         Create a new OpenSSL EC_KEY structure initialized to use this curve.</font>
<font color="black"> 422. </font>
<font color="black"> 423.         The structure is automatically garbage collected when the Python object</font>
<font color="black"> 424.         is garbage collected.</font>
<font color="black"> 425.         &quot;&quot;&quot;</font>
<font color="red"> 426.         key = self._lib.EC_KEY_new_by_curve_name(self._nid)</font>
<font color="red"> 427.         return _ffi.gc(key, _lib.EC_KEY_free)</font>
<font color="black"> 428. </font>
<font color="black"> 429. </font>
<font color="green"> 430. def get_elliptic_curves():</font>
<font color="black"> 431.     &quot;&quot;&quot;</font>
<font color="black"> 432.     Return a set of objects representing the elliptic curves supported in the</font>
<font color="black"> 433.     OpenSSL build in use.</font>
<font color="black"> 434. </font>
<font color="black"> 435.     The curve objects have a :py:class:`unicode` ``name`` attribute by which</font>
<font color="black"> 436.     they identify themselves.</font>
<font color="black"> 437. </font>
<font color="black"> 438.     The curve objects are useful as values for the argument accepted by</font>
<font color="black"> 439.     :py:meth:`Context.set_tmp_ecdh` to specify which elliptical curve should be</font>
<font color="black"> 440.     used for ECDHE key exchange.</font>
<font color="black"> 441.     &quot;&quot;&quot;</font>
<font color="red"> 442.     return _EllipticCurve._get_elliptic_curves(_lib)</font>
<font color="black"> 443. </font>
<font color="black"> 444. </font>
<font color="green"> 445. def get_elliptic_curve(name):</font>
<font color="black"> 446.     &quot;&quot;&quot;</font>
<font color="black"> 447.     Return a single curve object selected by name.</font>
<font color="black"> 448. </font>
<font color="black"> 449.     See :py:func:`get_elliptic_curves` for information about curve objects.</font>
<font color="black"> 450. </font>
<font color="black"> 451.     :param name: The OpenSSL short name identifying the curve object to</font>
<font color="black"> 452.         retrieve.</font>
<font color="black"> 453.     :type name: :py:class:`unicode`</font>
<font color="black"> 454. </font>
<font color="black"> 455.     If the named curve is not supported then :py:class:`ValueError` is raised.</font>
<font color="black"> 456.     &quot;&quot;&quot;</font>
<font color="red"> 457.     for curve in get_elliptic_curves():</font>
<font color="red"> 458.         if curve.name == name:</font>
<font color="red"> 459.             return curve</font>
<font color="red"> 460.     raise ValueError(&quot;unknown curve name&quot;, name)</font>
<font color="black"> 461. </font>
<font color="black"> 462. </font>
<font color="green"> 463. class X509Name(object):</font>
<font color="black"> 464.     &quot;&quot;&quot;</font>
<font color="black"> 465.     An X.509 Distinguished Name.</font>
<font color="black"> 466. </font>
<font color="black"> 467.     :ivar countryName: The country of the entity.</font>
<font color="black"> 468.     :ivar C: Alias for  :py:attr:`countryName`.</font>
<font color="black"> 469. </font>
<font color="black"> 470.     :ivar stateOrProvinceName: The state or province of the entity.</font>
<font color="black"> 471.     :ivar ST: Alias for :py:attr:`stateOrProvinceName`.</font>
<font color="black"> 472. </font>
<font color="black"> 473.     :ivar localityName: The locality of the entity.</font>
<font color="black"> 474.     :ivar L: Alias for :py:attr:`localityName`.</font>
<font color="black"> 475. </font>
<font color="black"> 476.     :ivar organizationName: The organization name of the entity.</font>
<font color="black"> 477.     :ivar O: Alias for :py:attr:`organizationName`.</font>
<font color="black"> 478. </font>
<font color="black"> 479.     :ivar organizationalUnitName: The organizational unit of the entity.</font>
<font color="black"> 480.     :ivar OU: Alias for :py:attr:`organizationalUnitName`</font>
<font color="black"> 481. </font>
<font color="black"> 482.     :ivar commonName: The common name of the entity.</font>
<font color="black"> 483.     :ivar CN: Alias for :py:attr:`commonName`.</font>
<font color="black"> 484. </font>
<font color="black"> 485.     :ivar emailAddress: The e-mail address of the entity.</font>
<font color="green"> 486.     &quot;&quot;&quot;</font>
<font color="black"> 487. </font>
<font color="green"> 488.     def __init__(self, name):</font>
<font color="black"> 489.         &quot;&quot;&quot;</font>
<font color="black"> 490.         Create a new X509Name, copying the given X509Name instance.</font>
<font color="black"> 491. </font>
<font color="black"> 492.         :param name: The name to copy.</font>
<font color="black"> 493.         :type name: :py:class:`X509Name`</font>
<font color="black"> 494.         &quot;&quot;&quot;</font>
<font color="red"> 495.         name = _lib.X509_NAME_dup(name._name)</font>
<font color="red"> 496.         self._name = _ffi.gc(name, _lib.X509_NAME_free)</font>
<font color="black"> 497. </font>
<font color="green"> 498.     def __setattr__(self, name, value):</font>
<font color="red"> 499.         if name.startswith('_'):</font>
<font color="red"> 500.             return super(X509Name, self).__setattr__(name, value)</font>
<font color="black"> 501. </font>
<font color="black"> 502.         # Note: we really do not want str subclasses here, so we do not use</font>
<font color="black"> 503.         # isinstance.</font>
<font color="red"> 504.         if type(name) is not str:</font>
<font color="red"> 505.             raise TypeError(&quot;attribute name must be string, not '%.200s'&quot; % (</font>
<font color="red"> 506.                 type(value).__name__,))</font>
<font color="black"> 507. </font>
<font color="red"> 508.         nid = _lib.OBJ_txt2nid(_byte_string(name))</font>
<font color="red"> 509.         if nid == _lib.NID_undef:</font>
<font color="red"> 510.             try:</font>
<font color="red"> 511.                 _raise_current_error()</font>
<font color="red"> 512.             except Error:</font>
<font color="red"> 513.                 pass</font>
<font color="red"> 514.             raise AttributeError(&quot;No such attribute&quot;)</font>
<font color="black"> 515. </font>
<font color="black"> 516.         # If there's an old entry for this NID, remove it</font>
<font color="red"> 517.         for i in range(_lib.X509_NAME_entry_count(self._name)):</font>
<font color="red"> 518.             ent = _lib.X509_NAME_get_entry(self._name, i)</font>
<font color="red"> 519.             ent_obj = _lib.X509_NAME_ENTRY_get_object(ent)</font>
<font color="red"> 520.             ent_nid = _lib.OBJ_obj2nid(ent_obj)</font>
<font color="red"> 521.             if nid == ent_nid:</font>
<font color="red"> 522.                 ent = _lib.X509_NAME_delete_entry(self._name, i)</font>
<font color="red"> 523.                 _lib.X509_NAME_ENTRY_free(ent)</font>
<font color="red"> 524.                 break</font>
<font color="black"> 525. </font>
<font color="red"> 526.         if isinstance(value, _text_type):</font>
<font color="red"> 527.             value = value.encode('utf-8')</font>
<font color="black"> 528. </font>
<font color="red"> 529.         add_result = _lib.X509_NAME_add_entry_by_NID(</font>
<font color="red"> 530.             self._name, nid, _lib.MBSTRING_UTF8, value, -1, -1, 0)</font>
<font color="red"> 531.         if not add_result:</font>
<font color="red"> 532.             _raise_current_error()</font>
<font color="black"> 533. </font>
<font color="green"> 534.     def __getattr__(self, name):</font>
<font color="black"> 535.         &quot;&quot;&quot;</font>
<font color="black"> 536.         Find attribute. An X509Name object has the following attributes:</font>
<font color="black"> 537.         countryName (alias C), stateOrProvince (alias ST), locality (alias L),</font>
<font color="black"> 538.         organization (alias O), organizationalUnit (alias OU), commonName</font>
<font color="black"> 539.         (alias CN) and more...</font>
<font color="black"> 540.         &quot;&quot;&quot;</font>
<font color="red"> 541.         nid = _lib.OBJ_txt2nid(_byte_string(name))</font>
<font color="red"> 542.         if nid == _lib.NID_undef:</font>
<font color="black"> 543.             # This is a bit weird.  OBJ_txt2nid indicated failure, but it seems</font>
<font color="black"> 544.             # a lower level function, a2d_ASN1_OBJECT, also feels the need to</font>
<font color="black"> 545.             # push something onto the error queue.  If we don't clean that up</font>
<font color="black"> 546.             # now, someone else will bump into it later and be quite confused.</font>
<font color="black"> 547.             # See lp#314814.</font>
<font color="red"> 548.             try:</font>
<font color="red"> 549.                 _raise_current_error()</font>
<font color="red"> 550.             except Error:</font>
<font color="red"> 551.                 pass</font>
<font color="red"> 552.             return super(X509Name, self).__getattr__(name)</font>
<font color="black"> 553. </font>
<font color="red"> 554.         entry_index = _lib.X509_NAME_get_index_by_NID(self._name, nid, -1)</font>
<font color="red"> 555.         if entry_index == -1:</font>
<font color="red"> 556.             return None</font>
<font color="black"> 557. </font>
<font color="red"> 558.         entry = _lib.X509_NAME_get_entry(self._name, entry_index)</font>
<font color="red"> 559.         data = _lib.X509_NAME_ENTRY_get_data(entry)</font>
<font color="black"> 560. </font>
<font color="red"> 561.         result_buffer = _ffi.new(&quot;unsigned char**&quot;)</font>
<font color="red"> 562.         data_length = _lib.ASN1_STRING_to_UTF8(result_buffer, data)</font>
<font color="red"> 563.         _openssl_assert(data_length &gt;= 0)</font>
<font color="black"> 564. </font>
<font color="red"> 565.         try:</font>
<font color="red"> 566.             result = _ffi.buffer(</font>
<font color="red"> 567.                 result_buffer[0], data_length</font>
<font color="red"> 568.             )[:].decode('utf-8')</font>
<font color="black"> 569.         finally:</font>
<font color="black"> 570.             # XXX untested</font>
<font color="red"> 571.             _lib.OPENSSL_free(result_buffer[0])</font>
<font color="red"> 572.         return result</font>
<font color="black"> 573. </font>
<font color="green"> 574.     def _cmp(op):</font>
<font color="green"> 575.         def f(self, other):</font>
<font color="red"> 576.             if not isinstance(other, X509Name):</font>
<font color="red"> 577.                 return NotImplemented</font>
<font color="red"> 578.             result = _lib.X509_NAME_cmp(self._name, other._name)</font>
<font color="red"> 579.             return op(result, 0)</font>
<font color="green"> 580.         return f</font>
<font color="black"> 581. </font>
<font color="green"> 582.     __eq__ = _cmp(__eq__)</font>
<font color="green"> 583.     __ne__ = _cmp(__ne__)</font>
<font color="black"> 584. </font>
<font color="green"> 585.     __lt__ = _cmp(__lt__)</font>
<font color="green"> 586.     __le__ = _cmp(__le__)</font>
<font color="black"> 587. </font>
<font color="green"> 588.     __gt__ = _cmp(__gt__)</font>
<font color="green"> 589.     __ge__ = _cmp(__ge__)</font>
<font color="black"> 590. </font>
<font color="green"> 591.     def __repr__(self):</font>
<font color="black"> 592.         &quot;&quot;&quot;</font>
<font color="black"> 593.         String representation of an X509Name</font>
<font color="black"> 594.         &quot;&quot;&quot;</font>
<font color="red"> 595.         result_buffer = _ffi.new(&quot;char[]&quot;, 512)</font>
<font color="red"> 596.         format_result = _lib.X509_NAME_oneline(</font>
<font color="red"> 597.             self._name, result_buffer, len(result_buffer))</font>
<font color="red"> 598.         _openssl_assert(format_result != _ffi.NULL)</font>
<font color="black"> 599. </font>
<font color="red"> 600.         return &quot;&lt;X509Name object '%s'&gt;&quot; % (</font>
<font color="red"> 601.             _native(_ffi.string(result_buffer)),)</font>
<font color="black"> 602. </font>
<font color="green"> 603.     def hash(self):</font>
<font color="black"> 604.         &quot;&quot;&quot;</font>
<font color="black"> 605.         Return an integer representation of the first four bytes of the</font>
<font color="black"> 606.         MD5 digest of the DER representation of the name.</font>
<font color="black"> 607. </font>
<font color="black"> 608.         This is the Python equivalent of OpenSSL's ``X509_NAME_hash``.</font>
<font color="black"> 609. </font>
<font color="black"> 610.         :return: The (integer) hash of this name.</font>
<font color="black"> 611.         :rtype: :py:class:`int`</font>
<font color="black"> 612.         &quot;&quot;&quot;</font>
<font color="red"> 613.         return _lib.X509_NAME_hash(self._name)</font>
<font color="black"> 614. </font>
<font color="green"> 615.     def der(self):</font>
<font color="black"> 616.         &quot;&quot;&quot;</font>
<font color="black"> 617.         Return the DER encoding of this name.</font>
<font color="black"> 618. </font>
<font color="black"> 619.         :return: The DER encoded form of this name.</font>
<font color="black"> 620.         :rtype: :py:class:`bytes`</font>
<font color="black"> 621.         &quot;&quot;&quot;</font>
<font color="red"> 622.         result_buffer = _ffi.new('unsigned char**')</font>
<font color="red"> 623.         encode_result = _lib.i2d_X509_NAME(self._name, result_buffer)</font>
<font color="red"> 624.         _openssl_assert(encode_result &gt;= 0)</font>
<font color="black"> 625. </font>
<font color="red"> 626.         string_result = _ffi.buffer(result_buffer[0], encode_result)[:]</font>
<font color="red"> 627.         _lib.OPENSSL_free(result_buffer[0])</font>
<font color="red"> 628.         return string_result</font>
<font color="black"> 629. </font>
<font color="green"> 630.     def get_components(self):</font>
<font color="black"> 631.         &quot;&quot;&quot;</font>
<font color="black"> 632.         Returns the components of this name, as a sequence of 2-tuples.</font>
<font color="black"> 633. </font>
<font color="black"> 634.         :return: The components of this name.</font>
<font color="black"> 635.         :rtype: :py:class:`list` of ``name, value`` tuples.</font>
<font color="black"> 636.         &quot;&quot;&quot;</font>
<font color="red"> 637.         result = []</font>
<font color="red"> 638.         for i in range(_lib.X509_NAME_entry_count(self._name)):</font>
<font color="red"> 639.             ent = _lib.X509_NAME_get_entry(self._name, i)</font>
<font color="black"> 640. </font>
<font color="red"> 641.             fname = _lib.X509_NAME_ENTRY_get_object(ent)</font>
<font color="red"> 642.             fval = _lib.X509_NAME_ENTRY_get_data(ent)</font>
<font color="black"> 643. </font>
<font color="red"> 644.             nid = _lib.OBJ_obj2nid(fname)</font>
<font color="red"> 645.             name = _lib.OBJ_nid2sn(nid)</font>
<font color="black"> 646. </font>
<font color="red"> 647.             result.append((</font>
<font color="red"> 648.                 _ffi.string(name),</font>
<font color="red"> 649.                 _ffi.string(</font>
<font color="red"> 650.                     _lib.ASN1_STRING_data(fval),</font>
<font color="red"> 651.                     _lib.ASN1_STRING_length(fval))))</font>
<font color="black"> 652. </font>
<font color="red"> 653.         return result</font>
<font color="black"> 654. </font>
<font color="black"> 655. </font>
<font color="green"> 656. X509NameType = X509Name</font>
<font color="black"> 657. </font>
<font color="black"> 658. </font>
<font color="green"> 659. class X509Extension(object):</font>
<font color="black"> 660.     &quot;&quot;&quot;</font>
<font color="black"> 661.     An X.509 v3 certificate extension.</font>
<font color="green"> 662.     &quot;&quot;&quot;</font>
<font color="black"> 663. </font>
<font color="green"> 664.     def __init__(self, type_name, critical, value, subject=None, issuer=None):</font>
<font color="black"> 665.         &quot;&quot;&quot;</font>
<font color="black"> 666.         Initializes an X509 extension.</font>
<font color="black"> 667. </font>
<font color="black"> 668.         :param type_name: The name of the type of extension_ to create.</font>
<font color="black"> 669.         :type type_name: :py:data:`bytes`</font>
<font color="black"> 670. </font>
<font color="black"> 671.         :param bool critical: A flag indicating whether this is a critical</font>
<font color="black"> 672.             extension.</font>
<font color="black"> 673. </font>
<font color="black"> 674.         :param value: The value of the extension.</font>
<font color="black"> 675.         :type value: :py:data:`bytes`</font>
<font color="black"> 676. </font>
<font color="black"> 677.         :param subject: Optional X509 certificate to use as subject.</font>
<font color="black"> 678.         :type subject: :py:class:`X509`</font>
<font color="black"> 679. </font>
<font color="black"> 680.         :param issuer: Optional X509 certificate to use as issuer.</font>
<font color="black"> 681.         :type issuer: :py:class:`X509`</font>
<font color="black"> 682. </font>
<font color="black"> 683.         .. _extension: https://www.openssl.org/docs/manmaster/apps/</font>
<font color="black"> 684.             x509v3_config.html#STANDARD-EXTENSIONS</font>
<font color="black"> 685.         &quot;&quot;&quot;</font>
<font color="red"> 686.         ctx = _ffi.new(&quot;X509V3_CTX*&quot;)</font>
<font color="black"> 687. </font>
<font color="black"> 688.         # A context is necessary for any extension which uses the r2i</font>
<font color="black"> 689.         # conversion method.  That is, X509V3_EXT_nconf may segfault if passed</font>
<font color="black"> 690.         # a NULL ctx. Start off by initializing most of the fields to NULL.</font>
<font color="red"> 691.         _lib.X509V3_set_ctx(ctx, _ffi.NULL, _ffi.NULL, _ffi.NULL, _ffi.NULL, 0)</font>
<font color="black"> 692. </font>
<font color="black"> 693.         # We have no configuration database - but perhaps we should (some</font>
<font color="black"> 694.         # extensions may require it).</font>
<font color="red"> 695.         _lib.X509V3_set_ctx_nodb(ctx)</font>
<font color="black"> 696. </font>
<font color="black"> 697.         # Initialize the subject and issuer, if appropriate.  ctx is a local,</font>
<font color="black"> 698.         # and as far as I can tell none of the X509V3_* APIs invoked here steal</font>
<font color="black"> 699.         # any references, so no need to mess with reference counts or</font>
<font color="black"> 700.         # duplicates.</font>
<font color="red"> 701.         if issuer is not None:</font>
<font color="red"> 702.             if not isinstance(issuer, X509):</font>
<font color="red"> 703.                 raise TypeError(&quot;issuer must be an X509 instance&quot;)</font>
<font color="red"> 704.             ctx.issuer_cert = issuer._x509</font>
<font color="red"> 705.         if subject is not None:</font>
<font color="red"> 706.             if not isinstance(subject, X509):</font>
<font color="red"> 707.                 raise TypeError(&quot;subject must be an X509 instance&quot;)</font>
<font color="red"> 708.             ctx.subject_cert = subject._x509</font>
<font color="black"> 709. </font>
<font color="red"> 710.         if critical:</font>
<font color="black"> 711.             # There are other OpenSSL APIs which would let us pass in critical</font>
<font color="black"> 712.             # separately, but they're harder to use, and since value is already</font>
<font color="black"> 713.             # a pile of crappy junk smuggling a ton of utterly important</font>
<font color="black"> 714.             # structured data, what's the point of trying to avoid nasty stuff</font>
<font color="black"> 715.             # with strings? (However, X509V3_EXT_i2d in particular seems like</font>
<font color="black"> 716.             # it would be a better API to invoke.  I do not know where to get</font>
<font color="black"> 717.             # the ext_struc it desires for its last parameter, though.)</font>
<font color="red"> 718.             value = b&quot;critical,&quot; + value</font>
<font color="black"> 719. </font>
<font color="red"> 720.         extension = _lib.X509V3_EXT_nconf(_ffi.NULL, ctx, type_name, value)</font>
<font color="red"> 721.         if extension == _ffi.NULL:</font>
<font color="red"> 722.             _raise_current_error()</font>
<font color="red"> 723.         self._extension = _ffi.gc(extension, _lib.X509_EXTENSION_free)</font>
<font color="black"> 724. </font>
<font color="green"> 725.     @property</font>
<font color="black"> 726.     def _nid(self):</font>
<font color="red"> 727.         return _lib.OBJ_obj2nid(</font>
<font color="red"> 728.             _lib.X509_EXTENSION_get_object(self._extension)</font>
<font color="black"> 729.         )</font>
<font color="black"> 730. </font>
<font color="green"> 731.     _prefixes = {</font>
<font color="green"> 732.         _lib.GEN_EMAIL: &quot;email&quot;,</font>
<font color="green"> 733.         _lib.GEN_DNS: &quot;DNS&quot;,</font>
<font color="green"> 734.         _lib.GEN_URI: &quot;URI&quot;,</font>
<font color="black"> 735.     }</font>
<font color="black"> 736. </font>
<font color="green"> 737.     def _subjectAltNameString(self):</font>
<font color="red"> 738.         method = _lib.X509V3_EXT_get(self._extension)</font>
<font color="red"> 739.         _openssl_assert(method != _ffi.NULL)</font>
<font color="red"> 740.         ext_data = _lib.X509_EXTENSION_get_data(self._extension)</font>
<font color="red"> 741.         payload = ext_data.data</font>
<font color="red"> 742.         length = ext_data.length</font>
<font color="black"> 743. </font>
<font color="red"> 744.         payloadptr = _ffi.new(&quot;unsigned char**&quot;)</font>
<font color="red"> 745.         payloadptr[0] = payload</font>
<font color="black"> 746. </font>
<font color="red"> 747.         if method.it != _ffi.NULL:</font>
<font color="red"> 748.             ptr = _lib.ASN1_ITEM_ptr(method.it)</font>
<font color="red"> 749.             data = _lib.ASN1_item_d2i(_ffi.NULL, payloadptr, length, ptr)</font>
<font color="red"> 750.             names = _ffi.cast(&quot;GENERAL_NAMES*&quot;, data)</font>
<font color="black"> 751.         else:</font>
<font color="red"> 752.             names = _ffi.cast(</font>
<font color="red"> 753.                 &quot;GENERAL_NAMES*&quot;,</font>
<font color="red"> 754.                 method.d2i(_ffi.NULL, payloadptr, length))</font>
<font color="black"> 755. </font>
<font color="red"> 756.         names = _ffi.gc(names, _lib.GENERAL_NAMES_free)</font>
<font color="red"> 757.         parts = []</font>
<font color="red"> 758.         for i in range(_lib.sk_GENERAL_NAME_num(names)):</font>
<font color="red"> 759.             name = _lib.sk_GENERAL_NAME_value(names, i)</font>
<font color="red"> 760.             try:</font>
<font color="red"> 761.                 label = self._prefixes[name.type]</font>
<font color="red"> 762.             except KeyError:</font>
<font color="red"> 763.                 bio = _new_mem_buf()</font>
<font color="red"> 764.                 _lib.GENERAL_NAME_print(bio, name)</font>
<font color="red"> 765.                 parts.append(_native(_bio_to_string(bio)))</font>
<font color="black"> 766.             else:</font>
<font color="red"> 767.                 value = _native(</font>
<font color="red"> 768.                     _ffi.buffer(name.d.ia5.data, name.d.ia5.length)[:])</font>
<font color="red"> 769.                 parts.append(label + &quot;:&quot; + value)</font>
<font color="red"> 770.         return &quot;, &quot;.join(parts)</font>
<font color="black"> 771. </font>
<font color="green"> 772.     def __str__(self):</font>
<font color="black"> 773.         &quot;&quot;&quot;</font>
<font color="black"> 774.         :return: a nice text representation of the extension</font>
<font color="black"> 775.         &quot;&quot;&quot;</font>
<font color="red"> 776.         if _lib.NID_subject_alt_name == self._nid:</font>
<font color="red"> 777.             return self._subjectAltNameString()</font>
<font color="black"> 778. </font>
<font color="red"> 779.         bio = _new_mem_buf()</font>
<font color="red"> 780.         print_result = _lib.X509V3_EXT_print(bio, self._extension, 0, 0)</font>
<font color="red"> 781.         _openssl_assert(print_result != 0)</font>
<font color="black"> 782. </font>
<font color="red"> 783.         return _native(_bio_to_string(bio))</font>
<font color="black"> 784. </font>
<font color="green"> 785.     def get_critical(self):</font>
<font color="black"> 786.         &quot;&quot;&quot;</font>
<font color="black"> 787.         Returns the critical field of this X.509 extension.</font>
<font color="black"> 788. </font>
<font color="black"> 789.         :return: The critical field.</font>
<font color="black"> 790.         &quot;&quot;&quot;</font>
<font color="red"> 791.         return _lib.X509_EXTENSION_get_critical(self._extension)</font>
<font color="black"> 792. </font>
<font color="green"> 793.     def get_short_name(self):</font>
<font color="black"> 794.         &quot;&quot;&quot;</font>
<font color="black"> 795.         Returns the short type name of this X.509 extension.</font>
<font color="black"> 796. </font>
<font color="black"> 797.         The result is a byte string such as :py:const:`b&quot;basicConstraints&quot;`.</font>
<font color="black"> 798. </font>
<font color="black"> 799.         :return: The short type name.</font>
<font color="black"> 800.         :rtype: :py:data:`bytes`</font>
<font color="black"> 801. </font>
<font color="black"> 802.         .. versionadded:: 0.12</font>
<font color="black"> 803.         &quot;&quot;&quot;</font>
<font color="red"> 804.         obj = _lib.X509_EXTENSION_get_object(self._extension)</font>
<font color="red"> 805.         nid = _lib.OBJ_obj2nid(obj)</font>
<font color="red"> 806.         return _ffi.string(_lib.OBJ_nid2sn(nid))</font>
<font color="black"> 807. </font>
<font color="green"> 808.     def get_data(self):</font>
<font color="black"> 809.         &quot;&quot;&quot;</font>
<font color="black"> 810.         Returns the data of the X509 extension, encoded as ASN.1.</font>
<font color="black"> 811. </font>
<font color="black"> 812.         :return: The ASN.1 encoded data of this X509 extension.</font>
<font color="black"> 813.         :rtype: :py:data:`bytes`</font>
<font color="black"> 814. </font>
<font color="black"> 815.         .. versionadded:: 0.12</font>
<font color="black"> 816.         &quot;&quot;&quot;</font>
<font color="red"> 817.         octet_result = _lib.X509_EXTENSION_get_data(self._extension)</font>
<font color="red"> 818.         string_result = _ffi.cast('ASN1_STRING*', octet_result)</font>
<font color="red"> 819.         char_result = _lib.ASN1_STRING_data(string_result)</font>
<font color="red"> 820.         result_length = _lib.ASN1_STRING_length(string_result)</font>
<font color="red"> 821.         return _ffi.buffer(char_result, result_length)[:]</font>
<font color="black"> 822. </font>
<font color="black"> 823. </font>
<font color="green"> 824. X509ExtensionType = X509Extension</font>
<font color="black"> 825. </font>
<font color="black"> 826. </font>
<font color="green"> 827. class X509Req(object):</font>
<font color="black"> 828.     &quot;&quot;&quot;</font>
<font color="black"> 829.     An X.509 certificate signing requests.</font>
<font color="green"> 830.     &quot;&quot;&quot;</font>
<font color="black"> 831. </font>
<font color="green"> 832.     def __init__(self):</font>
<font color="red"> 833.         req = _lib.X509_REQ_new()</font>
<font color="red"> 834.         self._req = _ffi.gc(req, _lib.X509_REQ_free)</font>
<font color="black"> 835.         # Default to version 0.</font>
<font color="red"> 836.         self.set_version(0)</font>
<font color="black"> 837. </font>
<font color="green"> 838.     def set_pubkey(self, pkey):</font>
<font color="black"> 839.         &quot;&quot;&quot;</font>
<font color="black"> 840.         Set the public key of the certificate signing request.</font>
<font color="black"> 841. </font>
<font color="black"> 842.         :param pkey: The public key to use.</font>
<font color="black"> 843.         :type pkey: :py:class:`PKey`</font>
<font color="black"> 844. </font>
<font color="black"> 845.         :return: ``None``</font>
<font color="black"> 846.         &quot;&quot;&quot;</font>
<font color="red"> 847.         set_result = _lib.X509_REQ_set_pubkey(self._req, pkey._pkey)</font>
<font color="red"> 848.         _openssl_assert(set_result == 1)</font>
<font color="black"> 849. </font>
<font color="green"> 850.     def get_pubkey(self):</font>
<font color="black"> 851.         &quot;&quot;&quot;</font>
<font color="black"> 852.         Get the public key of the certificate signing request.</font>
<font color="black"> 853. </font>
<font color="black"> 854.         :return: The public key.</font>
<font color="black"> 855.         :rtype: :py:class:`PKey`</font>
<font color="black"> 856.         &quot;&quot;&quot;</font>
<font color="red"> 857.         pkey = PKey.__new__(PKey)</font>
<font color="red"> 858.         pkey._pkey = _lib.X509_REQ_get_pubkey(self._req)</font>
<font color="red"> 859.         _openssl_assert(pkey._pkey != _ffi.NULL)</font>
<font color="red"> 860.         pkey._pkey = _ffi.gc(pkey._pkey, _lib.EVP_PKEY_free)</font>
<font color="red"> 861.         pkey._only_public = True</font>
<font color="red"> 862.         return pkey</font>
<font color="black"> 863. </font>
<font color="green"> 864.     def set_version(self, version):</font>
<font color="black"> 865.         &quot;&quot;&quot;</font>
<font color="black"> 866.         Set the version subfield (RFC 2459, section 4.1.2.1) of the certificate</font>
<font color="black"> 867.         request.</font>
<font color="black"> 868. </font>
<font color="black"> 869.         :param int version: The version number.</font>
<font color="black"> 870.         :return: ``None``</font>
<font color="black"> 871.         &quot;&quot;&quot;</font>
<font color="red"> 872.         set_result = _lib.X509_REQ_set_version(self._req, version)</font>
<font color="red"> 873.         _openssl_assert(set_result == 1)</font>
<font color="black"> 874. </font>
<font color="green"> 875.     def get_version(self):</font>
<font color="black"> 876.         &quot;&quot;&quot;</font>
<font color="black"> 877.         Get the version subfield (RFC 2459, section 4.1.2.1) of the certificate</font>
<font color="black"> 878.         request.</font>
<font color="black"> 879. </font>
<font color="black"> 880.         :return: The value of the version subfield.</font>
<font color="black"> 881.         :rtype: :py:class:`int`</font>
<font color="black"> 882.         &quot;&quot;&quot;</font>
<font color="red"> 883.         return _lib.X509_REQ_get_version(self._req)</font>
<font color="black"> 884. </font>
<font color="green"> 885.     def get_subject(self):</font>
<font color="black"> 886.         &quot;&quot;&quot;</font>
<font color="black"> 887.         Return the subject of this certificate signing request.</font>
<font color="black"> 888. </font>
<font color="black"> 889.         This creates a new :class:`X509Name` that wraps the underlying subject</font>
<font color="black"> 890.         name field on the certificate signing request. Modifying it will modify</font>
<font color="black"> 891.         the underlying signing request, and will have the effect of modifying</font>
<font color="black"> 892.         any other :class:`X509Name` that refers to this subject.</font>
<font color="black"> 893. </font>
<font color="black"> 894.         :return: The subject of this certificate signing request.</font>
<font color="black"> 895.         :rtype: :class:`X509Name`</font>
<font color="black"> 896.         &quot;&quot;&quot;</font>
<font color="red"> 897.         name = X509Name.__new__(X509Name)</font>
<font color="red"> 898.         name._name = _lib.X509_REQ_get_subject_name(self._req)</font>
<font color="red"> 899.         _openssl_assert(name._name != _ffi.NULL)</font>
<font color="black"> 900. </font>
<font color="black"> 901.         # The name is owned by the X509Req structure.  As long as the X509Name</font>
<font color="black"> 902.         # Python object is alive, keep the X509Req Python object alive.</font>
<font color="red"> 903.         name._owner = self</font>
<font color="black"> 904. </font>
<font color="red"> 905.         return name</font>
<font color="black"> 906. </font>
<font color="green"> 907.     def add_extensions(self, extensions):</font>
<font color="black"> 908.         &quot;&quot;&quot;</font>
<font color="black"> 909.         Add extensions to the certificate signing request.</font>
<font color="black"> 910. </font>
<font color="black"> 911.         :param extensions: The X.509 extensions to add.</font>
<font color="black"> 912.         :type extensions: iterable of :py:class:`X509Extension`</font>
<font color="black"> 913.         :return: ``None``</font>
<font color="black"> 914.         &quot;&quot;&quot;</font>
<font color="red"> 915.         stack = _lib.sk_X509_EXTENSION_new_null()</font>
<font color="red"> 916.         _openssl_assert(stack != _ffi.NULL)</font>
<font color="black"> 917. </font>
<font color="red"> 918.         stack = _ffi.gc(stack, _lib.sk_X509_EXTENSION_free)</font>
<font color="black"> 919. </font>
<font color="red"> 920.         for ext in extensions:</font>
<font color="red"> 921.             if not isinstance(ext, X509Extension):</font>
<font color="red"> 922.                 raise ValueError(&quot;One of the elements is not an X509Extension&quot;)</font>
<font color="black"> 923. </font>
<font color="black"> 924.             # TODO push can fail (here and elsewhere)</font>
<font color="red"> 925.             _lib.sk_X509_EXTENSION_push(stack, ext._extension)</font>
<font color="black"> 926. </font>
<font color="red"> 927.         add_result = _lib.X509_REQ_add_extensions(self._req, stack)</font>
<font color="red"> 928.         _openssl_assert(add_result == 1)</font>
<font color="black"> 929. </font>
<font color="green"> 930.     def get_extensions(self):</font>
<font color="black"> 931.         &quot;&quot;&quot;</font>
<font color="black"> 932.         Get X.509 extensions in the certificate signing request.</font>
<font color="black"> 933. </font>
<font color="black"> 934.         :return: The X.509 extensions in this request.</font>
<font color="black"> 935.         :rtype: :py:class:`list` of :py:class:`X509Extension` objects.</font>
<font color="black"> 936. </font>
<font color="black"> 937.         .. versionadded:: 0.15</font>
<font color="black"> 938.         &quot;&quot;&quot;</font>
<font color="red"> 939.         exts = []</font>
<font color="red"> 940.         native_exts_obj = _lib.X509_REQ_get_extensions(self._req)</font>
<font color="red"> 941.         for i in range(_lib.sk_X509_EXTENSION_num(native_exts_obj)):</font>
<font color="red"> 942.             ext = X509Extension.__new__(X509Extension)</font>
<font color="red"> 943.             ext._extension = _lib.sk_X509_EXTENSION_value(native_exts_obj, i)</font>
<font color="red"> 944.             exts.append(ext)</font>
<font color="red"> 945.         return exts</font>
<font color="black"> 946. </font>
<font color="green"> 947.     def sign(self, pkey, digest):</font>
<font color="black"> 948.         &quot;&quot;&quot;</font>
<font color="black"> 949.         Sign the certificate signing request with this key and digest type.</font>
<font color="black"> 950. </font>
<font color="black"> 951.         :param pkey: The key pair to sign with.</font>
<font color="black"> 952.         :type pkey: :py:class:`PKey`</font>
<font color="black"> 953.         :param digest: The name of the message digest to use for the signature,</font>
<font color="black"> 954.             e.g. :py:data:`b&quot;sha256&quot;`.</font>
<font color="black"> 955.         :type digest: :py:class:`bytes`</font>
<font color="black"> 956.         :return: ``None``</font>
<font color="black"> 957.         &quot;&quot;&quot;</font>
<font color="red"> 958.         if pkey._only_public:</font>
<font color="red"> 959.             raise ValueError(&quot;Key has only public part&quot;)</font>
<font color="black"> 960. </font>
<font color="red"> 961.         if not pkey._initialized:</font>
<font color="red"> 962.             raise ValueError(&quot;Key is uninitialized&quot;)</font>
<font color="black"> 963. </font>
<font color="red"> 964.         digest_obj = _lib.EVP_get_digestbyname(_byte_string(digest))</font>
<font color="red"> 965.         if digest_obj == _ffi.NULL:</font>
<font color="red"> 966.             raise ValueError(&quot;No such digest method&quot;)</font>
<font color="black"> 967. </font>
<font color="red"> 968.         sign_result = _lib.X509_REQ_sign(self._req, pkey._pkey, digest_obj)</font>
<font color="red"> 969.         _openssl_assert(sign_result &gt; 0)</font>
<font color="black"> 970. </font>
<font color="green"> 971.     def verify(self, pkey):</font>
<font color="black"> 972.         &quot;&quot;&quot;</font>
<font color="black"> 973.         Verifies the signature on this certificate signing request.</font>
<font color="black"> 974. </font>
<font color="black"> 975.         :param key: A public key.</font>
<font color="black"> 976.         :type key: :py:class:`PKey`</font>
<font color="black"> 977.         :return: :py:data:`True` if the signature is correct.</font>
<font color="black"> 978.         :rtype: :py:class:`bool`</font>
<font color="black"> 979.         :raises Error: If the signature is invalid or there is a</font>
<font color="black"> 980.             problem verifying the signature.</font>
<font color="black"> 981.         &quot;&quot;&quot;</font>
<font color="red"> 982.         if not isinstance(pkey, PKey):</font>
<font color="red"> 983.             raise TypeError(&quot;pkey must be a PKey instance&quot;)</font>
<font color="black"> 984. </font>
<font color="red"> 985.         result = _lib.X509_REQ_verify(self._req, pkey._pkey)</font>
<font color="red"> 986.         if result &lt;= 0:</font>
<font color="red"> 987.             _raise_current_error()</font>
<font color="black"> 988. </font>
<font color="red"> 989.         return result</font>
<font color="black"> 990. </font>
<font color="black"> 991. </font>
<font color="green"> 992. X509ReqType = X509Req</font>
<font color="black"> 993. </font>
<font color="black"> 994. </font>
<font color="green"> 995. class X509(object):</font>
<font color="black"> 996.     &quot;&quot;&quot;</font>
<font color="black"> 997.     An X.509 certificate.</font>
<font color="green"> 998.     &quot;&quot;&quot;</font>
<font color="green"> 999.     def __init__(self):</font>
<font color="red">1000.         x509 = _lib.X509_new()</font>
<font color="red">1001.         _openssl_assert(x509 != _ffi.NULL)</font>
<font color="red">1002.         self._x509 = _ffi.gc(x509, _lib.X509_free)</font>
<font color="black">1003. </font>
<font color="green">1004.     def set_version(self, version):</font>
<font color="black">1005.         &quot;&quot;&quot;</font>
<font color="black">1006.         Set the version number of the certificate.</font>
<font color="black">1007. </font>
<font color="black">1008.         :param version: The version number of the certificate.</font>
<font color="black">1009.         :type version: :py:class:`int`</font>
<font color="black">1010. </font>
<font color="black">1011.         :return: ``None``</font>
<font color="black">1012.         &quot;&quot;&quot;</font>
<font color="red">1013.         if not isinstance(version, int):</font>
<font color="red">1014.             raise TypeError(&quot;version must be an integer&quot;)</font>
<font color="black">1015. </font>
<font color="red">1016.         _lib.X509_set_version(self._x509, version)</font>
<font color="black">1017. </font>
<font color="green">1018.     def get_version(self):</font>
<font color="black">1019.         &quot;&quot;&quot;</font>
<font color="black">1020.         Return the version number of the certificate.</font>
<font color="black">1021. </font>
<font color="black">1022.         :return: The version number of the certificate.</font>
<font color="black">1023.         :rtype: :py:class:`int`</font>
<font color="black">1024.         &quot;&quot;&quot;</font>
<font color="red">1025.         return _lib.X509_get_version(self._x509)</font>
<font color="black">1026. </font>
<font color="green">1027.     def get_pubkey(self):</font>
<font color="black">1028.         &quot;&quot;&quot;</font>
<font color="black">1029.         Get the public key of the certificate.</font>
<font color="black">1030. </font>
<font color="black">1031.         :return: The public key.</font>
<font color="black">1032.         :rtype: :py:class:`PKey`</font>
<font color="black">1033.         &quot;&quot;&quot;</font>
<font color="red">1034.         pkey = PKey.__new__(PKey)</font>
<font color="red">1035.         pkey._pkey = _lib.X509_get_pubkey(self._x509)</font>
<font color="red">1036.         if pkey._pkey == _ffi.NULL:</font>
<font color="red">1037.             _raise_current_error()</font>
<font color="red">1038.         pkey._pkey = _ffi.gc(pkey._pkey, _lib.EVP_PKEY_free)</font>
<font color="red">1039.         pkey._only_public = True</font>
<font color="red">1040.         return pkey</font>
<font color="black">1041. </font>
<font color="green">1042.     def set_pubkey(self, pkey):</font>
<font color="black">1043.         &quot;&quot;&quot;</font>
<font color="black">1044.         Set the public key of the certificate.</font>
<font color="black">1045. </font>
<font color="black">1046.         :param pkey: The public key.</font>
<font color="black">1047.         :type pkey: :py:class:`PKey`</font>
<font color="black">1048. </font>
<font color="black">1049.         :return: :py:data:`None`</font>
<font color="black">1050.         &quot;&quot;&quot;</font>
<font color="red">1051.         if not isinstance(pkey, PKey):</font>
<font color="red">1052.             raise TypeError(&quot;pkey must be a PKey instance&quot;)</font>
<font color="black">1053. </font>
<font color="red">1054.         set_result = _lib.X509_set_pubkey(self._x509, pkey._pkey)</font>
<font color="red">1055.         _openssl_assert(set_result == 1)</font>
<font color="black">1056. </font>
<font color="green">1057.     def sign(self, pkey, digest):</font>
<font color="black">1058.         &quot;&quot;&quot;</font>
<font color="black">1059.         Sign the certificate with this key and digest type.</font>
<font color="black">1060. </font>
<font color="black">1061.         :param pkey: The key to sign with.</font>
<font color="black">1062.         :type pkey: :py:class:`PKey`</font>
<font color="black">1063. </font>
<font color="black">1064.         :param digest: The name of the message digest to use.</font>
<font color="black">1065.         :type digest: :py:class:`bytes`</font>
<font color="black">1066. </font>
<font color="black">1067.         :return: :py:data:`None`</font>
<font color="black">1068.         &quot;&quot;&quot;</font>
<font color="red">1069.         if not isinstance(pkey, PKey):</font>
<font color="red">1070.             raise TypeError(&quot;pkey must be a PKey instance&quot;)</font>
<font color="black">1071. </font>
<font color="red">1072.         if pkey._only_public:</font>
<font color="red">1073.             raise ValueError(&quot;Key only has public part&quot;)</font>
<font color="black">1074. </font>
<font color="red">1075.         if not pkey._initialized:</font>
<font color="red">1076.             raise ValueError(&quot;Key is uninitialized&quot;)</font>
<font color="black">1077. </font>
<font color="red">1078.         evp_md = _lib.EVP_get_digestbyname(_byte_string(digest))</font>
<font color="red">1079.         if evp_md == _ffi.NULL:</font>
<font color="red">1080.             raise ValueError(&quot;No such digest method&quot;)</font>
<font color="black">1081. </font>
<font color="red">1082.         sign_result = _lib.X509_sign(self._x509, pkey._pkey, evp_md)</font>
<font color="red">1083.         _openssl_assert(sign_result &gt; 0)</font>
<font color="black">1084. </font>
<font color="green">1085.     def get_signature_algorithm(self):</font>
<font color="black">1086.         &quot;&quot;&quot;</font>
<font color="black">1087.         Return the signature algorithm used in the certificate.</font>
<font color="black">1088. </font>
<font color="black">1089.         :return: The name of the algorithm.</font>
<font color="black">1090.         :rtype: :py:class:`bytes`</font>
<font color="black">1091. </font>
<font color="black">1092.         :raises ValueError: If the signature algorithm is undefined.</font>
<font color="black">1093. </font>
<font color="black">1094.         .. versionadded:: 0.13</font>
<font color="black">1095.         &quot;&quot;&quot;</font>
<font color="red">1096.         algor = _lib.X509_get0_tbs_sigalg(self._x509)</font>
<font color="red">1097.         nid = _lib.OBJ_obj2nid(algor.algorithm)</font>
<font color="red">1098.         if nid == _lib.NID_undef:</font>
<font color="red">1099.             raise ValueError(&quot;Undefined signature algorithm&quot;)</font>
<font color="red">1100.         return _ffi.string(_lib.OBJ_nid2ln(nid))</font>
<font color="black">1101. </font>
<font color="green">1102.     def digest(self, digest_name):</font>
<font color="black">1103.         &quot;&quot;&quot;</font>
<font color="black">1104.         Return the digest of the X509 object.</font>
<font color="black">1105. </font>
<font color="black">1106.         :param digest_name: The name of the digest algorithm to use.</font>
<font color="black">1107.         :type digest_name: :py:class:`bytes`</font>
<font color="black">1108. </font>
<font color="black">1109.         :return: The digest of the object, formatted as</font>
<font color="black">1110.             :py:const:`b&quot;:&quot;`-delimited hex pairs.</font>
<font color="black">1111.         :rtype: :py:class:`bytes`</font>
<font color="black">1112.         &quot;&quot;&quot;</font>
<font color="red">1113.         digest = _lib.EVP_get_digestbyname(_byte_string(digest_name))</font>
<font color="red">1114.         if digest == _ffi.NULL:</font>
<font color="red">1115.             raise ValueError(&quot;No such digest method&quot;)</font>
<font color="black">1116. </font>
<font color="red">1117.         result_buffer = _ffi.new(&quot;unsigned char[]&quot;, _lib.EVP_MAX_MD_SIZE)</font>
<font color="red">1118.         result_length = _ffi.new(&quot;unsigned int[]&quot;, 1)</font>
<font color="red">1119.         result_length[0] = len(result_buffer)</font>
<font color="black">1120. </font>
<font color="red">1121.         digest_result = _lib.X509_digest(</font>
<font color="red">1122.             self._x509, digest, result_buffer, result_length)</font>
<font color="red">1123.         _openssl_assert(digest_result == 1)</font>
<font color="black">1124. </font>
<font color="red">1125.         return b&quot;:&quot;.join([</font>
<font color="red">1126.             b16encode(ch).upper() for ch</font>
<font color="red">1127.             in _ffi.buffer(result_buffer, result_length[0])])</font>
<font color="black">1128. </font>
<font color="green">1129.     def subject_name_hash(self):</font>
<font color="black">1130.         &quot;&quot;&quot;</font>
<font color="black">1131.         Return the hash of the X509 subject.</font>
<font color="black">1132. </font>
<font color="black">1133.         :return: The hash of the subject.</font>
<font color="black">1134.         :rtype: :py:class:`bytes`</font>
<font color="black">1135.         &quot;&quot;&quot;</font>
<font color="red">1136.         return _lib.X509_subject_name_hash(self._x509)</font>
<font color="black">1137. </font>
<font color="green">1138.     def set_serial_number(self, serial):</font>
<font color="black">1139.         &quot;&quot;&quot;</font>
<font color="black">1140.         Set the serial number of the certificate.</font>
<font color="black">1141. </font>
<font color="black">1142.         :param serial: The new serial number.</font>
<font color="black">1143.         :type serial: :py:class:`int`</font>
<font color="black">1144. </font>
<font color="black">1145.         :return: :py:data`None`</font>
<font color="black">1146.         &quot;&quot;&quot;</font>
<font color="red">1147.         if not isinstance(serial, _integer_types):</font>
<font color="red">1148.             raise TypeError(&quot;serial must be an integer&quot;)</font>
<font color="black">1149. </font>
<font color="red">1150.         hex_serial = hex(serial)[2:]</font>
<font color="red">1151.         if not isinstance(hex_serial, bytes):</font>
<font color="red">1152.             hex_serial = hex_serial.encode('ascii')</font>
<font color="black">1153. </font>
<font color="red">1154.         bignum_serial = _ffi.new(&quot;BIGNUM**&quot;)</font>
<font color="black">1155. </font>
<font color="black">1156.         # BN_hex2bn stores the result in &amp;bignum.  Unless it doesn't feel like</font>
<font color="black">1157.         # it.  If bignum is still NULL after this call, then the return value</font>
<font color="black">1158.         # is actually the result.  I hope.  -exarkun</font>
<font color="red">1159.         small_serial = _lib.BN_hex2bn(bignum_serial, hex_serial)</font>
<font color="black">1160. </font>
<font color="red">1161.         if bignum_serial[0] == _ffi.NULL:</font>
<font color="red">1162.             set_result = _lib.ASN1_INTEGER_set(</font>
<font color="red">1163.                 _lib.X509_get_serialNumber(self._x509), small_serial)</font>
<font color="red">1164.             if set_result:</font>
<font color="black">1165.                 # TODO Not tested</font>
<font color="red">1166.                 _raise_current_error()</font>
<font color="black">1167.         else:</font>
<font color="red">1168.             asn1_serial = _lib.BN_to_ASN1_INTEGER(bignum_serial[0], _ffi.NULL)</font>
<font color="red">1169.             _lib.BN_free(bignum_serial[0])</font>
<font color="red">1170.             if asn1_serial == _ffi.NULL:</font>
<font color="black">1171.                 # TODO Not tested</font>
<font color="red">1172.                 _raise_current_error()</font>
<font color="red">1173.             asn1_serial = _ffi.gc(asn1_serial, _lib.ASN1_INTEGER_free)</font>
<font color="red">1174.             set_result = _lib.X509_set_serialNumber(self._x509, asn1_serial)</font>
<font color="red">1175.             _openssl_assert(set_result == 1)</font>
<font color="black">1176. </font>
<font color="green">1177.     def get_serial_number(self):</font>
<font color="black">1178.         &quot;&quot;&quot;</font>
<font color="black">1179.         Return the serial number of this certificate.</font>
<font color="black">1180. </font>
<font color="black">1181.         :return: The serial number.</font>
<font color="black">1182.         :rtype: int</font>
<font color="black">1183.         &quot;&quot;&quot;</font>
<font color="red">1184.         asn1_serial = _lib.X509_get_serialNumber(self._x509)</font>
<font color="red">1185.         bignum_serial = _lib.ASN1_INTEGER_to_BN(asn1_serial, _ffi.NULL)</font>
<font color="red">1186.         try:</font>
<font color="red">1187.             hex_serial = _lib.BN_bn2hex(bignum_serial)</font>
<font color="red">1188.             try:</font>
<font color="red">1189.                 hexstring_serial = _ffi.string(hex_serial)</font>
<font color="red">1190.                 serial = int(hexstring_serial, 16)</font>
<font color="red">1191.                 return serial</font>
<font color="black">1192.             finally:</font>
<font color="red">1193.                 _lib.OPENSSL_free(hex_serial)</font>
<font color="black">1194.         finally:</font>
<font color="red">1195.             _lib.BN_free(bignum_serial)</font>
<font color="black">1196. </font>
<font color="green">1197.     def gmtime_adj_notAfter(self, amount):</font>
<font color="black">1198.         &quot;&quot;&quot;</font>
<font color="black">1199.         Adjust the time stamp on which the certificate stops being valid.</font>
<font color="black">1200. </font>
<font color="black">1201.         :param int amount: The number of seconds by which to adjust the</font>
<font color="black">1202.             timestamp.</font>
<font color="black">1203.         :return: ``None``</font>
<font color="black">1204.         &quot;&quot;&quot;</font>
<font color="red">1205.         if not isinstance(amount, int):</font>
<font color="red">1206.             raise TypeError(&quot;amount must be an integer&quot;)</font>
<font color="black">1207. </font>
<font color="red">1208.         notAfter = _lib.X509_get_notAfter(self._x509)</font>
<font color="red">1209.         _lib.X509_gmtime_adj(notAfter, amount)</font>
<font color="black">1210. </font>
<font color="green">1211.     def gmtime_adj_notBefore(self, amount):</font>
<font color="black">1212.         &quot;&quot;&quot;</font>
<font color="black">1213.         Adjust the timestamp on which the certificate starts being valid.</font>
<font color="black">1214. </font>
<font color="black">1215.         :param amount: The number of seconds by which to adjust the timestamp.</font>
<font color="black">1216.         :return: ``None``</font>
<font color="black">1217.         &quot;&quot;&quot;</font>
<font color="red">1218.         if not isinstance(amount, int):</font>
<font color="red">1219.             raise TypeError(&quot;amount must be an integer&quot;)</font>
<font color="black">1220. </font>
<font color="red">1221.         notBefore = _lib.X509_get_notBefore(self._x509)</font>
<font color="red">1222.         _lib.X509_gmtime_adj(notBefore, amount)</font>
<font color="black">1223. </font>
<font color="green">1224.     def has_expired(self):</font>
<font color="black">1225.         &quot;&quot;&quot;</font>
<font color="black">1226.         Check whether the certificate has expired.</font>
<font color="black">1227. </font>
<font color="black">1228.         :return: ``True`` if the certificate has expired, ``False`` otherwise.</font>
<font color="black">1229.         :rtype: bool</font>
<font color="black">1230.         &quot;&quot;&quot;</font>
<font color="red">1231.         time_string = _native(self.get_notAfter())</font>
<font color="red">1232.         not_after = datetime.datetime.strptime(time_string, &quot;%Y%m%d%H%M%SZ&quot;)</font>
<font color="black">1233. </font>
<font color="red">1234.         return not_after &lt; datetime.datetime.utcnow()</font>
<font color="black">1235. </font>
<font color="green">1236.     def _get_boundary_time(self, which):</font>
<font color="red">1237.         return _get_asn1_time(which(self._x509))</font>
<font color="black">1238. </font>
<font color="green">1239.     def get_notBefore(self):</font>
<font color="black">1240.         &quot;&quot;&quot;</font>
<font color="black">1241.         Get the timestamp at which the certificate starts being valid.</font>
<font color="black">1242. </font>
<font color="black">1243.         The timestamp is formatted as an ASN.1 GENERALIZEDTIME::</font>
<font color="black">1244. </font>
<font color="black">1245.             YYYYMMDDhhmmssZ</font>
<font color="black">1246.             YYYYMMDDhhmmss+hhmm</font>
<font color="black">1247.             YYYYMMDDhhmmss-hhmm</font>
<font color="black">1248. </font>
<font color="black">1249.         :return: A timestamp string, or ``None`` if there is none.</font>
<font color="black">1250.         :rtype: bytes or NoneType</font>
<font color="black">1251.         &quot;&quot;&quot;</font>
<font color="red">1252.         return self._get_boundary_time(_lib.X509_get_notBefore)</font>
<font color="black">1253. </font>
<font color="green">1254.     def _set_boundary_time(self, which, when):</font>
<font color="red">1255.         return _set_asn1_time(which(self._x509), when)</font>
<font color="black">1256. </font>
<font color="green">1257.     def set_notBefore(self, when):</font>
<font color="black">1258.         &quot;&quot;&quot;</font>
<font color="black">1259.         Set the timestamp at which the certificate starts being valid.</font>
<font color="black">1260. </font>
<font color="black">1261.         The timestamp is formatted as an ASN.1 GENERALIZEDTIME::</font>
<font color="black">1262. </font>
<font color="black">1263.             YYYYMMDDhhmmssZ</font>
<font color="black">1264.             YYYYMMDDhhmmss+hhmm</font>
<font color="black">1265.             YYYYMMDDhhmmss-hhmm</font>
<font color="black">1266. </font>
<font color="black">1267.         :param bytes when: A timestamp string.</font>
<font color="black">1268.         :return: ``None``</font>
<font color="black">1269.         &quot;&quot;&quot;</font>
<font color="red">1270.         return self._set_boundary_time(_lib.X509_get_notBefore, when)</font>
<font color="black">1271. </font>
<font color="green">1272.     def get_notAfter(self):</font>
<font color="black">1273.         &quot;&quot;&quot;</font>
<font color="black">1274.         Get the timestamp at which the certificate stops being valid.</font>
<font color="black">1275. </font>
<font color="black">1276.         The timestamp is formatted as an ASN.1 GENERALIZEDTIME::</font>
<font color="black">1277. </font>
<font color="black">1278.             YYYYMMDDhhmmssZ</font>
<font color="black">1279.             YYYYMMDDhhmmss+hhmm</font>
<font color="black">1280.             YYYYMMDDhhmmss-hhmm</font>
<font color="black">1281. </font>
<font color="black">1282.         :return: A timestamp string, or ``None`` if there is none.</font>
<font color="black">1283.         :rtype: bytes or NoneType</font>
<font color="black">1284.         &quot;&quot;&quot;</font>
<font color="red">1285.         return self._get_boundary_time(_lib.X509_get_notAfter)</font>
<font color="black">1286. </font>
<font color="green">1287.     def set_notAfter(self, when):</font>
<font color="black">1288.         &quot;&quot;&quot;</font>
<font color="black">1289.         Set the timestamp at which the certificate stops being valid.</font>
<font color="black">1290. </font>
<font color="black">1291.         The timestamp is formatted as an ASN.1 GENERALIZEDTIME::</font>
<font color="black">1292. </font>
<font color="black">1293.             YYYYMMDDhhmmssZ</font>
<font color="black">1294.             YYYYMMDDhhmmss+hhmm</font>
<font color="black">1295.             YYYYMMDDhhmmss-hhmm</font>
<font color="black">1296. </font>
<font color="black">1297.         :param bytes when: A timestamp string.</font>
<font color="black">1298.         :return: ``None``</font>
<font color="black">1299.         &quot;&quot;&quot;</font>
<font color="red">1300.         return self._set_boundary_time(_lib.X509_get_notAfter, when)</font>
<font color="black">1301. </font>
<font color="green">1302.     def _get_name(self, which):</font>
<font color="red">1303.         name = X509Name.__new__(X509Name)</font>
<font color="red">1304.         name._name = which(self._x509)</font>
<font color="red">1305.         _openssl_assert(name._name != _ffi.NULL)</font>
<font color="black">1306. </font>
<font color="black">1307.         # The name is owned by the X509 structure.  As long as the X509Name</font>
<font color="black">1308.         # Python object is alive, keep the X509 Python object alive.</font>
<font color="red">1309.         name._owner = self</font>
<font color="black">1310. </font>
<font color="red">1311.         return name</font>
<font color="black">1312. </font>
<font color="green">1313.     def _set_name(self, which, name):</font>
<font color="red">1314.         if not isinstance(name, X509Name):</font>
<font color="red">1315.             raise TypeError(&quot;name must be an X509Name&quot;)</font>
<font color="red">1316.         set_result = which(self._x509, name._name)</font>
<font color="red">1317.         _openssl_assert(set_result == 1)</font>
<font color="black">1318. </font>
<font color="green">1319.     def get_issuer(self):</font>
<font color="black">1320.         &quot;&quot;&quot;</font>
<font color="black">1321.         Return the issuer of this certificate.</font>
<font color="black">1322. </font>
<font color="black">1323.         This creates a new :class:`X509Name` that wraps the underlying issuer</font>
<font color="black">1324.         name field on the certificate. Modifying it will modify the underlying</font>
<font color="black">1325.         certificate, and will have the effect of modifying any other</font>
<font color="black">1326.         :class:`X509Name` that refers to this issuer.</font>
<font color="black">1327. </font>
<font color="black">1328.         :return: The issuer of this certificate.</font>
<font color="black">1329.         :rtype: :class:`X509Name`</font>
<font color="black">1330.         &quot;&quot;&quot;</font>
<font color="red">1331.         return self._get_name(_lib.X509_get_issuer_name)</font>
<font color="black">1332. </font>
<font color="green">1333.     def set_issuer(self, issuer):</font>
<font color="black">1334.         &quot;&quot;&quot;</font>
<font color="black">1335.         Set the issuer of this certificate.</font>
<font color="black">1336. </font>
<font color="black">1337.         :param issuer: The issuer.</font>
<font color="black">1338.         :type issuer: :py:class:`X509Name`</font>
<font color="black">1339. </font>
<font color="black">1340.         :return: ``None``</font>
<font color="black">1341.         &quot;&quot;&quot;</font>
<font color="red">1342.         return self._set_name(_lib.X509_set_issuer_name, issuer)</font>
<font color="black">1343. </font>
<font color="green">1344.     def get_subject(self):</font>
<font color="black">1345.         &quot;&quot;&quot;</font>
<font color="black">1346.         Return the subject of this certificate.</font>
<font color="black">1347. </font>
<font color="black">1348.         This creates a new :class:`X509Name` that wraps the underlying subject</font>
<font color="black">1349.         name field on the certificate. Modifying it will modify the underlying</font>
<font color="black">1350.         certificate, and will have the effect of modifying any other</font>
<font color="black">1351.         :class:`X509Name` that refers to this subject.</font>
<font color="black">1352. </font>
<font color="black">1353.         :return: The subject of this certificate.</font>
<font color="black">1354.         :rtype: :class:`X509Name`</font>
<font color="black">1355.         &quot;&quot;&quot;</font>
<font color="red">1356.         return self._get_name(_lib.X509_get_subject_name)</font>
<font color="black">1357. </font>
<font color="green">1358.     def set_subject(self, subject):</font>
<font color="black">1359.         &quot;&quot;&quot;</font>
<font color="black">1360.         Set the subject of this certificate.</font>
<font color="black">1361. </font>
<font color="black">1362.         :param subject: The subject.</font>
<font color="black">1363.         :type subject: :py:class:`X509Name`</font>
<font color="black">1364. </font>
<font color="black">1365.         :return: ``None``</font>
<font color="black">1366.         &quot;&quot;&quot;</font>
<font color="red">1367.         return self._set_name(_lib.X509_set_subject_name, subject)</font>
<font color="black">1368. </font>
<font color="green">1369.     def get_extension_count(self):</font>
<font color="black">1370.         &quot;&quot;&quot;</font>
<font color="black">1371.         Get the number of extensions on this certificate.</font>
<font color="black">1372. </font>
<font color="black">1373.         :return: The number of extensions.</font>
<font color="black">1374.         :rtype: :py:class:`int`</font>
<font color="black">1375. </font>
<font color="black">1376.         .. versionadded:: 0.12</font>
<font color="black">1377.         &quot;&quot;&quot;</font>
<font color="red">1378.         return _lib.X509_get_ext_count(self._x509)</font>
<font color="black">1379. </font>
<font color="green">1380.     def add_extensions(self, extensions):</font>
<font color="black">1381.         &quot;&quot;&quot;</font>
<font color="black">1382.         Add extensions to the certificate.</font>
<font color="black">1383. </font>
<font color="black">1384.         :param extensions: The extensions to add.</font>
<font color="black">1385.         :type extensions: An iterable of :py:class:`X509Extension` objects.</font>
<font color="black">1386.         :return: ``None``</font>
<font color="black">1387.         &quot;&quot;&quot;</font>
<font color="red">1388.         for ext in extensions:</font>
<font color="red">1389.             if not isinstance(ext, X509Extension):</font>
<font color="red">1390.                 raise ValueError(&quot;One of the elements is not an X509Extension&quot;)</font>
<font color="black">1391. </font>
<font color="red">1392.             add_result = _lib.X509_add_ext(self._x509, ext._extension, -1)</font>
<font color="red">1393.             if not add_result:</font>
<font color="red">1394.                 _raise_current_error()</font>
<font color="black">1395. </font>
<font color="green">1396.     def get_extension(self, index):</font>
<font color="black">1397.         &quot;&quot;&quot;</font>
<font color="black">1398.         Get a specific extension of the certificate by index.</font>
<font color="black">1399. </font>
<font color="black">1400.         Extensions on a certificate are kept in order. The index</font>
<font color="black">1401.         parameter selects which extension will be returned.</font>
<font color="black">1402. </font>
<font color="black">1403.         :param int index: The index of the extension to retrieve.</font>
<font color="black">1404.         :return: The extension at the specified index.</font>
<font color="black">1405.         :rtype: :py:class:`X509Extension`</font>
<font color="black">1406.         :raises IndexError: If the extension index was out of bounds.</font>
<font color="black">1407. </font>
<font color="black">1408.         .. versionadded:: 0.12</font>
<font color="black">1409.         &quot;&quot;&quot;</font>
<font color="red">1410.         ext = X509Extension.__new__(X509Extension)</font>
<font color="red">1411.         ext._extension = _lib.X509_get_ext(self._x509, index)</font>
<font color="red">1412.         if ext._extension == _ffi.NULL:</font>
<font color="red">1413.             raise IndexError(&quot;extension index out of bounds&quot;)</font>
<font color="black">1414. </font>
<font color="red">1415.         extension = _lib.X509_EXTENSION_dup(ext._extension)</font>
<font color="red">1416.         ext._extension = _ffi.gc(extension, _lib.X509_EXTENSION_free)</font>
<font color="red">1417.         return ext</font>
<font color="black">1418. </font>
<font color="black">1419. </font>
<font color="green">1420. X509Type = X509</font>
<font color="black">1421. </font>
<font color="black">1422. </font>
<font color="green">1423. class X509StoreFlags(object):</font>
<font color="black">1424.     &quot;&quot;&quot;</font>
<font color="black">1425.     Flags for X509 verification, used to change the behavior of</font>
<font color="black">1426.     :class:`X509Store`.</font>
<font color="black">1427. </font>
<font color="black">1428.     See `OpenSSL Verification Flags`_ for details.</font>
<font color="black">1429. </font>
<font color="black">1430.     .. _OpenSSL Verification Flags:</font>
<font color="black">1431.         https://www.openssl.org/docs/manmaster/crypto/X509_VERIFY_PARAM_set_flags.html</font>
<font color="green">1432.     &quot;&quot;&quot;</font>
<font color="green">1433.     CRL_CHECK = _lib.X509_V_FLAG_CRL_CHECK</font>
<font color="green">1434.     CRL_CHECK_ALL = _lib.X509_V_FLAG_CRL_CHECK_ALL</font>
<font color="green">1435.     IGNORE_CRITICAL = _lib.X509_V_FLAG_IGNORE_CRITICAL</font>
<font color="green">1436.     X509_STRICT = _lib.X509_V_FLAG_X509_STRICT</font>
<font color="green">1437.     ALLOW_PROXY_CERTS = _lib.X509_V_FLAG_ALLOW_PROXY_CERTS</font>
<font color="green">1438.     POLICY_CHECK = _lib.X509_V_FLAG_POLICY_CHECK</font>
<font color="green">1439.     EXPLICIT_POLICY = _lib.X509_V_FLAG_EXPLICIT_POLICY</font>
<font color="green">1440.     INHIBIT_MAP = _lib.X509_V_FLAG_INHIBIT_MAP</font>
<font color="green">1441.     NOTIFY_POLICY = _lib.X509_V_FLAG_NOTIFY_POLICY</font>
<font color="green">1442.     CHECK_SS_SIGNATURE = _lib.X509_V_FLAG_CHECK_SS_SIGNATURE</font>
<font color="green">1443.     CB_ISSUER_CHECK = _lib.X509_V_FLAG_CB_ISSUER_CHECK</font>
<font color="black">1444. </font>
<font color="black">1445. </font>
<font color="green">1446. class X509Store(object):</font>
<font color="black">1447.     &quot;&quot;&quot;</font>
<font color="black">1448.     An X.509 store.</font>
<font color="black">1449. </font>
<font color="black">1450.     An X.509 store is used to describe a context in which to verify a</font>
<font color="black">1451.     certificate. A description of a context may include a set of certificates</font>
<font color="black">1452.     to trust, a set of certificate revocation lists, verification flags and</font>
<font color="black">1453.     more.</font>
<font color="black">1454. </font>
<font color="black">1455.     An X.509 store, being only a description, cannot be used by itself to</font>
<font color="black">1456.     verify a certificate. To carry out the actual verification process, see</font>
<font color="black">1457.     :class:`X509StoreContext`.</font>
<font color="green">1458.     &quot;&quot;&quot;</font>
<font color="black">1459. </font>
<font color="green">1460.     def __init__(self):</font>
<font color="red">1461.         store = _lib.X509_STORE_new()</font>
<font color="red">1462.         self._store = _ffi.gc(store, _lib.X509_STORE_free)</font>
<font color="black">1463. </font>
<font color="green">1464.     def add_cert(self, cert):</font>
<font color="black">1465.         &quot;&quot;&quot;</font>
<font color="black">1466.         Adds a trusted certificate to this store.</font>
<font color="black">1467. </font>
<font color="black">1468.         Adding a certificate with this method adds this certificate as a</font>
<font color="black">1469.         *trusted* certificate.</font>
<font color="black">1470. </font>
<font color="black">1471.         :param X509 cert: The certificate to add to this store.</font>
<font color="black">1472.         :raises TypeError: If the certificate is not an :class:`X509`.</font>
<font color="black">1473.         :raises Error: If OpenSSL was unhappy with your certificate.</font>
<font color="black">1474.         :return: ``None`` if the certificate was added successfully.</font>
<font color="black">1475.         &quot;&quot;&quot;</font>
<font color="red">1476.         if not isinstance(cert, X509):</font>
<font color="red">1477.             raise TypeError()</font>
<font color="black">1478. </font>
<font color="red">1479.         _openssl_assert(_lib.X509_STORE_add_cert(self._store, cert._x509) != 0)</font>
<font color="black">1480. </font>
<font color="green">1481.     def add_crl(self, crl):</font>
<font color="black">1482.         &quot;&quot;&quot;</font>
<font color="black">1483.         Add a certificate revocation list to this store.</font>
<font color="black">1484. </font>
<font color="black">1485.         The certificate revocation lists added to a store will only be used if</font>
<font color="black">1486.         the associated flags are configured to check certificate revocation</font>
<font color="black">1487.         lists.</font>
<font color="black">1488. </font>
<font color="black">1489.         .. versionadded:: 16.1.0</font>
<font color="black">1490. </font>
<font color="black">1491.         :param CRL crl: The certificate revocation list to add to this store.</font>
<font color="black">1492.         :return: ``None`` if the certificate revocation list was added</font>
<font color="black">1493.             successfully.</font>
<font color="black">1494.         &quot;&quot;&quot;</font>
<font color="red">1495.         _openssl_assert(_lib.X509_STORE_add_crl(self._store, crl._crl) != 0)</font>
<font color="black">1496. </font>
<font color="green">1497.     def set_flags(self, flags):</font>
<font color="black">1498.         &quot;&quot;&quot;</font>
<font color="black">1499.         Set verification flags to this store.</font>
<font color="black">1500. </font>
<font color="black">1501.         Verification flags can be combined by oring them together.</font>
<font color="black">1502. </font>
<font color="black">1503.         .. note::</font>
<font color="black">1504. </font>
<font color="black">1505.           Setting a verification flag sometimes requires clients to add</font>
<font color="black">1506.           additional information to the store, otherwise a suitable error will</font>
<font color="black">1507.           be raised.</font>
<font color="black">1508. </font>
<font color="black">1509.           For example, in setting flags to enable CRL checking a</font>
<font color="black">1510.           suitable CRL must be added to the store otherwise an error will be</font>
<font color="black">1511.           raised.</font>
<font color="black">1512. </font>
<font color="black">1513.         .. versionadded:: 16.1.0</font>
<font color="black">1514. </font>
<font color="black">1515.         :param int flags: The verification flags to set on this store.</font>
<font color="black">1516.             See :class:`X509StoreFlags` for available constants.</font>
<font color="black">1517.         :return: ``None`` if the verification flags were successfully set.</font>
<font color="black">1518.         &quot;&quot;&quot;</font>
<font color="red">1519.         _openssl_assert(_lib.X509_STORE_set_flags(self._store, flags) != 0)</font>
<font color="black">1520. </font>
<font color="black">1521. </font>
<font color="green">1522. X509StoreType = X509Store</font>
<font color="black">1523. </font>
<font color="black">1524. </font>
<font color="green">1525. class X509StoreContextError(Exception):</font>
<font color="black">1526.     &quot;&quot;&quot;</font>
<font color="black">1527.     An exception raised when an error occurred while verifying a certificate</font>
<font color="black">1528.     using `OpenSSL.X509StoreContext.verify_certificate`.</font>
<font color="black">1529. </font>
<font color="black">1530.     :ivar certificate: The certificate which caused verificate failure.</font>
<font color="black">1531.     :type certificate: :class:`X509`</font>
<font color="green">1532.     &quot;&quot;&quot;</font>
<font color="black">1533. </font>
<font color="green">1534.     def __init__(self, message, certificate):</font>
<font color="red">1535.         super(X509StoreContextError, self).__init__(message)</font>
<font color="red">1536.         self.certificate = certificate</font>
<font color="black">1537. </font>
<font color="black">1538. </font>
<font color="green">1539. class X509StoreContext(object):</font>
<font color="black">1540.     &quot;&quot;&quot;</font>
<font color="black">1541.     An X.509 store context.</font>
<font color="black">1542. </font>
<font color="black">1543.     An X.509 store context is used to carry out the actual verification process</font>
<font color="black">1544.     of a certificate in a described context. For describing such a context, see</font>
<font color="black">1545.     :class:`X509Store`.</font>
<font color="black">1546. </font>
<font color="black">1547.     :ivar _store_ctx: The underlying X509_STORE_CTX structure used by this</font>
<font color="black">1548.         instance.  It is dynamically allocated and automatically garbage</font>
<font color="black">1549.         collected.</font>
<font color="black">1550.     :ivar _store: See the ``store`` ``__init__`` parameter.</font>
<font color="black">1551.     :ivar _cert: See the ``certificate`` ``__init__`` parameter.</font>
<font color="black">1552.     :param X509Store store: The certificates which will be trusted for the</font>
<font color="black">1553.         purposes of any verifications.</font>
<font color="black">1554.     :param X509 certificate: The certificate to be verified.</font>
<font color="green">1555.     &quot;&quot;&quot;</font>
<font color="black">1556. </font>
<font color="green">1557.     def __init__(self, store, certificate):</font>
<font color="red">1558.         store_ctx = _lib.X509_STORE_CTX_new()</font>
<font color="red">1559.         self._store_ctx = _ffi.gc(store_ctx, _lib.X509_STORE_CTX_free)</font>
<font color="red">1560.         self._store = store</font>
<font color="red">1561.         self._cert = certificate</font>
<font color="black">1562.         # Make the store context available for use after instantiating this</font>
<font color="black">1563.         # class by initializing it now. Per testing, subsequent calls to</font>
<font color="black">1564.         # :meth:`_init` have no adverse affect.</font>
<font color="red">1565.         self._init()</font>
<font color="black">1566. </font>
<font color="green">1567.     def _init(self):</font>
<font color="black">1568.         &quot;&quot;&quot;</font>
<font color="black">1569.         Set up the store context for a subsequent verification operation.</font>
<font color="black">1570.         &quot;&quot;&quot;</font>
<font color="red">1571.         ret = _lib.X509_STORE_CTX_init(</font>
<font color="red">1572.             self._store_ctx, self._store._store, self._cert._x509, _ffi.NULL</font>
<font color="black">1573.         )</font>
<font color="red">1574.         if ret &lt;= 0:</font>
<font color="red">1575.             _raise_current_error()</font>
<font color="black">1576. </font>
<font color="green">1577.     def _cleanup(self):</font>
<font color="black">1578.         &quot;&quot;&quot;</font>
<font color="black">1579.         Internally cleans up the store context.</font>
<font color="black">1580. </font>
<font color="black">1581.         The store context can then be reused with a new call to :meth:`_init`.</font>
<font color="black">1582.         &quot;&quot;&quot;</font>
<font color="red">1583.         _lib.X509_STORE_CTX_cleanup(self._store_ctx)</font>
<font color="black">1584. </font>
<font color="green">1585.     def _exception_from_context(self):</font>
<font color="black">1586.         &quot;&quot;&quot;</font>
<font color="black">1587.         Convert an OpenSSL native context error failure into a Python</font>
<font color="black">1588.         exception.</font>
<font color="black">1589. </font>
<font color="black">1590.         When a call to native OpenSSL X509_verify_cert fails, additional</font>
<font color="black">1591.         information about the failure can be obtained from the store context.</font>
<font color="black">1592.         &quot;&quot;&quot;</font>
<font color="black">1593.         errors = [</font>
<font color="red">1594.             _lib.X509_STORE_CTX_get_error(self._store_ctx),</font>
<font color="red">1595.             _lib.X509_STORE_CTX_get_error_depth(self._store_ctx),</font>
<font color="red">1596.             _native(_ffi.string(_lib.X509_verify_cert_error_string(</font>
<font color="red">1597.                 _lib.X509_STORE_CTX_get_error(self._store_ctx)))),</font>
<font color="black">1598.         ]</font>
<font color="black">1599.         # A context error should always be associated with a certificate, so we</font>
<font color="black">1600.         # expect this call to never return :class:`None`.</font>
<font color="red">1601.         _x509 = _lib.X509_STORE_CTX_get_current_cert(self._store_ctx)</font>
<font color="red">1602.         _cert = _lib.X509_dup(_x509)</font>
<font color="red">1603.         pycert = X509.__new__(X509)</font>
<font color="red">1604.         pycert._x509 = _ffi.gc(_cert, _lib.X509_free)</font>
<font color="red">1605.         return X509StoreContextError(errors, pycert)</font>
<font color="black">1606. </font>
<font color="green">1607.     def set_store(self, store):</font>
<font color="black">1608.         &quot;&quot;&quot;</font>
<font color="black">1609.         Set the context's X.509 store.</font>
<font color="black">1610. </font>
<font color="black">1611.         .. versionadded:: 0.15</font>
<font color="black">1612. </font>
<font color="black">1613.         :param X509Store store: The store description which will be used for</font>
<font color="black">1614.             the purposes of any *future* verifications.</font>
<font color="black">1615.         &quot;&quot;&quot;</font>
<font color="red">1616.         self._store = store</font>
<font color="black">1617. </font>
<font color="green">1618.     def verify_certificate(self):</font>
<font color="black">1619.         &quot;&quot;&quot;</font>
<font color="black">1620.         Verify a certificate in a context.</font>
<font color="black">1621. </font>
<font color="black">1622.         .. versionadded:: 0.15</font>
<font color="black">1623. </font>
<font color="black">1624.         :raises X509StoreContextError: If an error occurred when validating a</font>
<font color="black">1625.           certificate in the context. Sets ``certificate`` attribute to</font>
<font color="black">1626.           indicate which certificate caused the error.</font>
<font color="black">1627.         &quot;&quot;&quot;</font>
<font color="black">1628.         # Always re-initialize the store context in case</font>
<font color="black">1629.         # :meth:`verify_certificate` is called multiple times.</font>
<font color="red">1630.         self._init()</font>
<font color="red">1631.         ret = _lib.X509_verify_cert(self._store_ctx)</font>
<font color="red">1632.         self._cleanup()</font>
<font color="red">1633.         if ret &lt;= 0:</font>
<font color="red">1634.             raise self._exception_from_context()</font>
<font color="black">1635. </font>
<font color="black">1636. </font>
<font color="green">1637. def load_certificate(type, buffer):</font>
<font color="black">1638.     &quot;&quot;&quot;</font>
<font color="black">1639.     Load a certificate from a buffer</font>
<font color="black">1640. </font>
<font color="black">1641.     :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)</font>
<font color="black">1642. </font>
<font color="black">1643.     :param bytes buffer: The buffer the certificate is stored in</font>
<font color="black">1644. </font>
<font color="black">1645.     :return: The X509 object</font>
<font color="black">1646.     &quot;&quot;&quot;</font>
<font color="red">1647.     if isinstance(buffer, _text_type):</font>
<font color="red">1648.         buffer = buffer.encode(&quot;ascii&quot;)</font>
<font color="black">1649. </font>
<font color="red">1650.     bio = _new_mem_buf(buffer)</font>
<font color="black">1651. </font>
<font color="red">1652.     if type == FILETYPE_PEM:</font>
<font color="red">1653.         x509 = _lib.PEM_read_bio_X509(bio, _ffi.NULL, _ffi.NULL, _ffi.NULL)</font>
<font color="red">1654.     elif type == FILETYPE_ASN1:</font>
<font color="red">1655.         x509 = _lib.d2i_X509_bio(bio, _ffi.NULL)</font>
<font color="black">1656.     else:</font>
<font color="red">1657.         raise ValueError(</font>
<font color="red">1658.             &quot;type argument must be FILETYPE_PEM or FILETYPE_ASN1&quot;)</font>
<font color="black">1659. </font>
<font color="red">1660.     if x509 == _ffi.NULL:</font>
<font color="red">1661.         _raise_current_error()</font>
<font color="black">1662. </font>
<font color="red">1663.     cert = X509.__new__(X509)</font>
<font color="red">1664.     cert._x509 = _ffi.gc(x509, _lib.X509_free)</font>
<font color="red">1665.     return cert</font>
<font color="black">1666. </font>
<font color="black">1667. </font>
<font color="green">1668. def dump_certificate(type, cert):</font>
<font color="black">1669.     &quot;&quot;&quot;</font>
<font color="black">1670.     Dump a certificate to a buffer</font>
<font color="black">1671. </font>
<font color="black">1672.     :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1, or</font>
<font color="black">1673.         FILETYPE_TEXT)</font>
<font color="black">1674.     :param cert: The certificate to dump</font>
<font color="black">1675.     :return: The buffer with the dumped certificate in</font>
<font color="black">1676.     &quot;&quot;&quot;</font>
<font color="red">1677.     bio = _new_mem_buf()</font>
<font color="black">1678. </font>
<font color="red">1679.     if type == FILETYPE_PEM:</font>
<font color="red">1680.         result_code = _lib.PEM_write_bio_X509(bio, cert._x509)</font>
<font color="red">1681.     elif type == FILETYPE_ASN1:</font>
<font color="red">1682.         result_code = _lib.i2d_X509_bio(bio, cert._x509)</font>
<font color="red">1683.     elif type == FILETYPE_TEXT:</font>
<font color="red">1684.         result_code = _lib.X509_print_ex(bio, cert._x509, 0, 0)</font>
<font color="black">1685.     else:</font>
<font color="red">1686.         raise ValueError(</font>
<font color="red">1687.             &quot;type argument must be FILETYPE_PEM, FILETYPE_ASN1, or &quot;</font>
<font color="black">1688.             &quot;FILETYPE_TEXT&quot;)</font>
<font color="black">1689. </font>
<font color="red">1690.     assert result_code == 1</font>
<font color="red">1691.     return _bio_to_string(bio)</font>
<font color="black">1692. </font>
<font color="black">1693. </font>
<font color="green">1694. def dump_publickey(type, pkey):</font>
<font color="black">1695.     &quot;&quot;&quot;</font>
<font color="black">1696.     Dump a public key to a buffer.</font>
<font color="black">1697. </font>
<font color="black">1698.     :param type: The file type (one of :data:`FILETYPE_PEM` or</font>
<font color="black">1699.         :data:`FILETYPE_ASN1`).</font>
<font color="black">1700.     :param PKey pkey: The public key to dump</font>
<font color="black">1701.     :return: The buffer with the dumped key in it.</font>
<font color="black">1702.     :rtype: bytes</font>
<font color="black">1703.     &quot;&quot;&quot;</font>
<font color="red">1704.     bio = _new_mem_buf()</font>
<font color="red">1705.     if type == FILETYPE_PEM:</font>
<font color="red">1706.         write_bio = _lib.PEM_write_bio_PUBKEY</font>
<font color="red">1707.     elif type == FILETYPE_ASN1:</font>
<font color="red">1708.         write_bio = _lib.i2d_PUBKEY_bio</font>
<font color="black">1709.     else:</font>
<font color="red">1710.         raise ValueError(&quot;type argument must be FILETYPE_PEM or FILETYPE_ASN1&quot;)</font>
<font color="black">1711. </font>
<font color="red">1712.     result_code = write_bio(bio, pkey._pkey)</font>
<font color="red">1713.     if result_code != 1:  # pragma: no cover</font>
<font color="red">1714.         _raise_current_error()</font>
<font color="black">1715. </font>
<font color="red">1716.     return _bio_to_string(bio)</font>
<font color="black">1717. </font>
<font color="black">1718. </font>
<font color="green">1719. def dump_privatekey(type, pkey, cipher=None, passphrase=None):</font>
<font color="black">1720.     &quot;&quot;&quot;</font>
<font color="black">1721.     Dump the private key *pkey* into a buffer string encoded with the type</font>
<font color="black">1722.     *type*.  Optionally (if *type* is :const:`FILETYPE_PEM`) encrypting it</font>
<font color="black">1723.     using *cipher* and *passphrase*.</font>
<font color="black">1724. </font>
<font color="black">1725.     :param type: The file type (one of :const:`FILETYPE_PEM`,</font>
<font color="black">1726.         :const:`FILETYPE_ASN1`, or :const:`FILETYPE_TEXT`)</font>
<font color="black">1727.     :param PKey pkey: The PKey to dump</font>
<font color="black">1728.     :param cipher: (optional) if encrypted PEM format, the cipher to use</font>
<font color="black">1729.     :param passphrase: (optional) if encrypted PEM format, this can be either</font>
<font color="black">1730.         the passphrase to use, or a callback for providing the passphrase.</font>
<font color="black">1731. </font>
<font color="black">1732.     :return: The buffer with the dumped key in</font>
<font color="black">1733.     :rtype: bytes</font>
<font color="black">1734.     &quot;&quot;&quot;</font>
<font color="red">1735.     bio = _new_mem_buf()</font>
<font color="black">1736. </font>
<font color="red">1737.     if cipher is not None:</font>
<font color="red">1738.         if passphrase is None:</font>
<font color="red">1739.             raise TypeError(</font>
<font color="red">1740.                 &quot;if a value is given for cipher &quot;</font>
<font color="black">1741.                 &quot;one must also be given for passphrase&quot;)</font>
<font color="red">1742.         cipher_obj = _lib.EVP_get_cipherbyname(_byte_string(cipher))</font>
<font color="red">1743.         if cipher_obj == _ffi.NULL:</font>
<font color="red">1744.             raise ValueError(&quot;Invalid cipher name&quot;)</font>
<font color="black">1745.     else:</font>
<font color="red">1746.         cipher_obj = _ffi.NULL</font>
<font color="black">1747. </font>
<font color="red">1748.     helper = _PassphraseHelper(type, passphrase)</font>
<font color="red">1749.     if type == FILETYPE_PEM:</font>
<font color="red">1750.         result_code = _lib.PEM_write_bio_PrivateKey(</font>
<font color="red">1751.             bio, pkey._pkey, cipher_obj, _ffi.NULL, 0,</font>
<font color="red">1752.             helper.callback, helper.callback_args)</font>
<font color="red">1753.         helper.raise_if_problem()</font>
<font color="red">1754.     elif type == FILETYPE_ASN1:</font>
<font color="red">1755.         result_code = _lib.i2d_PrivateKey_bio(bio, pkey._pkey)</font>
<font color="red">1756.     elif type == FILETYPE_TEXT:</font>
<font color="red">1757.         rsa = _ffi.gc(</font>
<font color="red">1758.             _lib.EVP_PKEY_get1_RSA(pkey._pkey),</font>
<font color="red">1759.             _lib.RSA_free</font>
<font color="black">1760.         )</font>
<font color="red">1761.         result_code = _lib.RSA_print(bio, rsa, 0)</font>
<font color="black">1762.     else:</font>
<font color="red">1763.         raise ValueError(</font>
<font color="red">1764.             &quot;type argument must be FILETYPE_PEM, FILETYPE_ASN1, or &quot;</font>
<font color="black">1765.             &quot;FILETYPE_TEXT&quot;)</font>
<font color="black">1766. </font>
<font color="red">1767.     _openssl_assert(result_code != 0)</font>
<font color="black">1768. </font>
<font color="red">1769.     return _bio_to_string(bio)</font>
<font color="black">1770. </font>
<font color="black">1771. </font>
<font color="green">1772. class Revoked(object):</font>
<font color="black">1773.     &quot;&quot;&quot;</font>
<font color="black">1774.     A certificate revocation.</font>
<font color="green">1775.     &quot;&quot;&quot;</font>
<font color="black">1776.     # http://www.openssl.org/docs/apps/x509v3_config.html#CRL_distribution_points_</font>
<font color="black">1777.     # which differs from crl_reasons of crypto/x509v3/v3_enum.c that matches</font>
<font color="black">1778.     # OCSP_crl_reason_str.  We use the latter, just like the command line</font>
<font color="black">1779.     # program.</font>
<font color="black">1780.     _crl_reasons = [</font>
<font color="green">1781.         b&quot;unspecified&quot;,</font>
<font color="green">1782.         b&quot;keyCompromise&quot;,</font>
<font color="green">1783.         b&quot;CACompromise&quot;,</font>
<font color="green">1784.         b&quot;affiliationChanged&quot;,</font>
<font color="green">1785.         b&quot;superseded&quot;,</font>
<font color="green">1786.         b&quot;cessationOfOperation&quot;,</font>
<font color="green">1787.         b&quot;certificateHold&quot;,</font>
<font color="black">1788.         # b&quot;removeFromCRL&quot;,</font>
<font color="black">1789.     ]</font>
<font color="black">1790. </font>
<font color="green">1791.     def __init__(self):</font>
<font color="red">1792.         revoked = _lib.X509_REVOKED_new()</font>
<font color="red">1793.         self._revoked = _ffi.gc(revoked, _lib.X509_REVOKED_free)</font>
<font color="black">1794. </font>
<font color="green">1795.     def set_serial(self, hex_str):</font>
<font color="black">1796.         &quot;&quot;&quot;</font>
<font color="black">1797.         Set the serial number.</font>
<font color="black">1798. </font>
<font color="black">1799.         The serial number is formatted as a hexadecimal number encoded in</font>
<font color="black">1800.         ASCII.</font>
<font color="black">1801. </font>
<font color="black">1802.         :param bytes hex_str: The new serial number.</font>
<font color="black">1803. </font>
<font color="black">1804.         :return: ``None``</font>
<font color="black">1805.         &quot;&quot;&quot;</font>
<font color="red">1806.         bignum_serial = _ffi.gc(_lib.BN_new(), _lib.BN_free)</font>
<font color="red">1807.         bignum_ptr = _ffi.new(&quot;BIGNUM**&quot;)</font>
<font color="red">1808.         bignum_ptr[0] = bignum_serial</font>
<font color="red">1809.         bn_result = _lib.BN_hex2bn(bignum_ptr, hex_str)</font>
<font color="red">1810.         if not bn_result:</font>
<font color="red">1811.             raise ValueError(&quot;bad hex string&quot;)</font>
<font color="black">1812. </font>
<font color="red">1813.         asn1_serial = _ffi.gc(</font>
<font color="red">1814.             _lib.BN_to_ASN1_INTEGER(bignum_serial, _ffi.NULL),</font>
<font color="red">1815.             _lib.ASN1_INTEGER_free)</font>
<font color="red">1816.         _lib.X509_REVOKED_set_serialNumber(self._revoked, asn1_serial)</font>
<font color="black">1817. </font>
<font color="green">1818.     def get_serial(self):</font>
<font color="black">1819.         &quot;&quot;&quot;</font>
<font color="black">1820.         Get the serial number.</font>
<font color="black">1821. </font>
<font color="black">1822.         The serial number is formatted as a hexadecimal number encoded in</font>
<font color="black">1823.         ASCII.</font>
<font color="black">1824. </font>
<font color="black">1825.         :return: The serial number.</font>
<font color="black">1826.         :rtype: bytes</font>
<font color="black">1827.         &quot;&quot;&quot;</font>
<font color="red">1828.         bio = _new_mem_buf()</font>
<font color="black">1829. </font>
<font color="red">1830.         asn1_int = _lib.X509_REVOKED_get0_serialNumber(self._revoked)</font>
<font color="red">1831.         _openssl_assert(asn1_int != _ffi.NULL)</font>
<font color="red">1832.         result = _lib.i2a_ASN1_INTEGER(bio, asn1_int)</font>
<font color="red">1833.         _openssl_assert(result &gt;= 0)</font>
<font color="red">1834.         return _bio_to_string(bio)</font>
<font color="black">1835. </font>
<font color="green">1836.     def _delete_reason(self):</font>
<font color="red">1837.         for i in range(_lib.X509_REVOKED_get_ext_count(self._revoked)):</font>
<font color="red">1838.             ext = _lib.X509_REVOKED_get_ext(self._revoked, i)</font>
<font color="red">1839.             obj = _lib.X509_EXTENSION_get_object(ext)</font>
<font color="red">1840.             if _lib.OBJ_obj2nid(obj) == _lib.NID_crl_reason:</font>
<font color="red">1841.                 _lib.X509_EXTENSION_free(ext)</font>
<font color="red">1842.                 _lib.X509_REVOKED_delete_ext(self._revoked, i)</font>
<font color="red">1843.                 break</font>
<font color="black">1844. </font>
<font color="green">1845.     def set_reason(self, reason):</font>
<font color="black">1846.         &quot;&quot;&quot;</font>
<font color="black">1847.         Set the reason of this revocation.</font>
<font color="black">1848. </font>
<font color="black">1849.         If :data:`reason` is ``None``, delete the reason instead.</font>
<font color="black">1850. </font>
<font color="black">1851.         :param reason: The reason string.</font>
<font color="black">1852.         :type reason: :class:`bytes` or :class:`NoneType`</font>
<font color="black">1853. </font>
<font color="black">1854.         :return: ``None``</font>
<font color="black">1855. </font>
<font color="black">1856.         .. seealso::</font>
<font color="black">1857. </font>
<font color="black">1858.             :meth:`all_reasons`, which gives you a list of all supported</font>
<font color="black">1859.             reasons which you might pass to this method.</font>
<font color="black">1860.         &quot;&quot;&quot;</font>
<font color="red">1861.         if reason is None:</font>
<font color="red">1862.             self._delete_reason()</font>
<font color="red">1863.         elif not isinstance(reason, bytes):</font>
<font color="red">1864.             raise TypeError(&quot;reason must be None or a byte string&quot;)</font>
<font color="black">1865.         else:</font>
<font color="red">1866.             reason = reason.lower().replace(b' ', b'')</font>
<font color="red">1867.             reason_code = [r.lower() for r in self._crl_reasons].index(reason)</font>
<font color="black">1868. </font>
<font color="red">1869.             new_reason_ext = _lib.ASN1_ENUMERATED_new()</font>
<font color="red">1870.             _openssl_assert(new_reason_ext != _ffi.NULL)</font>
<font color="red">1871.             new_reason_ext = _ffi.gc(new_reason_ext, _lib.ASN1_ENUMERATED_free)</font>
<font color="black">1872. </font>
<font color="red">1873.             set_result = _lib.ASN1_ENUMERATED_set(new_reason_ext, reason_code)</font>
<font color="red">1874.             _openssl_assert(set_result != _ffi.NULL)</font>
<font color="black">1875. </font>
<font color="red">1876.             self._delete_reason()</font>
<font color="red">1877.             add_result = _lib.X509_REVOKED_add1_ext_i2d(</font>
<font color="red">1878.                 self._revoked, _lib.NID_crl_reason, new_reason_ext, 0, 0)</font>
<font color="red">1879.             _openssl_assert(add_result == 1)</font>
<font color="black">1880. </font>
<font color="green">1881.     def get_reason(self):</font>
<font color="black">1882.         &quot;&quot;&quot;</font>
<font color="black">1883.         Get the reason of this revocation.</font>
<font color="black">1884. </font>
<font color="black">1885.         :return: The reason, or ``None`` if there is none.</font>
<font color="black">1886.         :rtype: bytes or NoneType</font>
<font color="black">1887. </font>
<font color="black">1888.         .. seealso::</font>
<font color="black">1889. </font>
<font color="black">1890.             :meth:`all_reasons`, which gives you a list of all supported</font>
<font color="black">1891.             reasons this method might return.</font>
<font color="black">1892.         &quot;&quot;&quot;</font>
<font color="red">1893.         for i in range(_lib.X509_REVOKED_get_ext_count(self._revoked)):</font>
<font color="red">1894.             ext = _lib.X509_REVOKED_get_ext(self._revoked, i)</font>
<font color="red">1895.             obj = _lib.X509_EXTENSION_get_object(ext)</font>
<font color="red">1896.             if _lib.OBJ_obj2nid(obj) == _lib.NID_crl_reason:</font>
<font color="red">1897.                 bio = _new_mem_buf()</font>
<font color="black">1898. </font>
<font color="red">1899.                 print_result = _lib.X509V3_EXT_print(bio, ext, 0, 0)</font>
<font color="red">1900.                 if not print_result:</font>
<font color="red">1901.                     print_result = _lib.M_ASN1_OCTET_STRING_print(</font>
<font color="red">1902.                         bio, _lib.X509_EXTENSION_get_data(ext)</font>
<font color="black">1903.                     )</font>
<font color="red">1904.                     _openssl_assert(print_result != 0)</font>
<font color="black">1905. </font>
<font color="red">1906.                 return _bio_to_string(bio)</font>
<font color="black">1907. </font>
<font color="green">1908.     def all_reasons(self):</font>
<font color="black">1909.         &quot;&quot;&quot;</font>
<font color="black">1910.         Return a list of all the supported reason strings.</font>
<font color="black">1911. </font>
<font color="black">1912.         This list is a copy; modifying it does not change the supported reason</font>
<font color="black">1913.         strings.</font>
<font color="black">1914. </font>
<font color="black">1915.         :return: A list of reason strings.</font>
<font color="black">1916.         :rtype: :class:`list` of :class:`bytes`</font>
<font color="black">1917.         &quot;&quot;&quot;</font>
<font color="red">1918.         return self._crl_reasons[:]</font>
<font color="black">1919. </font>
<font color="green">1920.     def set_rev_date(self, when):</font>
<font color="black">1921.         &quot;&quot;&quot;</font>
<font color="black">1922.         Set the revocation timestamp.</font>
<font color="black">1923. </font>
<font color="black">1924.         :param bytes when: The timestamp of the revocation,</font>
<font color="black">1925.             as ASN.1 GENERALIZEDTIME.</font>
<font color="black">1926.         :return: ``None``</font>
<font color="black">1927.         &quot;&quot;&quot;</font>
<font color="red">1928.         dt = _lib.X509_REVOKED_get0_revocationDate(self._revoked)</font>
<font color="red">1929.         return _set_asn1_time(dt, when)</font>
<font color="black">1930. </font>
<font color="green">1931.     def get_rev_date(self):</font>
<font color="black">1932.         &quot;&quot;&quot;</font>
<font color="black">1933.         Get the revocation timestamp.</font>
<font color="black">1934. </font>
<font color="black">1935.         :return: The timestamp of the revocation, as ASN.1 GENERALIZEDTIME.</font>
<font color="black">1936.         :rtype: bytes</font>
<font color="black">1937.         &quot;&quot;&quot;</font>
<font color="red">1938.         dt = _lib.X509_REVOKED_get0_revocationDate(self._revoked)</font>
<font color="red">1939.         return _get_asn1_time(dt)</font>
<font color="black">1940. </font>
<font color="black">1941. </font>
<font color="green">1942. class CRL(object):</font>
<font color="black">1943.     &quot;&quot;&quot;</font>
<font color="black">1944.     A certificate revocation list.</font>
<font color="green">1945.     &quot;&quot;&quot;</font>
<font color="black">1946. </font>
<font color="green">1947.     def __init__(self):</font>
<font color="red">1948.         crl = _lib.X509_CRL_new()</font>
<font color="red">1949.         self._crl = _ffi.gc(crl, _lib.X509_CRL_free)</font>
<font color="black">1950. </font>
<font color="green">1951.     def get_revoked(self):</font>
<font color="black">1952.         &quot;&quot;&quot;</font>
<font color="black">1953.         Return the revocations in this certificate revocation list.</font>
<font color="black">1954. </font>
<font color="black">1955.         These revocations will be provided by value, not by reference.</font>
<font color="black">1956.         That means it's okay to mutate them: it won't affect this CRL.</font>
<font color="black">1957. </font>
<font color="black">1958.         :return: The revocations in this CRL.</font>
<font color="black">1959.         :rtype: :class:`tuple` of :class:`Revocation`</font>
<font color="black">1960.         &quot;&quot;&quot;</font>
<font color="red">1961.         results = []</font>
<font color="red">1962.         revoked_stack = _lib.X509_CRL_get_REVOKED(self._crl)</font>
<font color="red">1963.         for i in range(_lib.sk_X509_REVOKED_num(revoked_stack)):</font>
<font color="red">1964.             revoked = _lib.sk_X509_REVOKED_value(revoked_stack, i)</font>
<font color="red">1965.             revoked_copy = _lib.Cryptography_X509_REVOKED_dup(revoked)</font>
<font color="red">1966.             pyrev = Revoked.__new__(Revoked)</font>
<font color="red">1967.             pyrev._revoked = _ffi.gc(revoked_copy, _lib.X509_REVOKED_free)</font>
<font color="red">1968.             results.append(pyrev)</font>
<font color="red">1969.         if results:</font>
<font color="red">1970.             return tuple(results)</font>
<font color="black">1971. </font>
<font color="green">1972.     def add_revoked(self, revoked):</font>
<font color="black">1973.         &quot;&quot;&quot;</font>
<font color="black">1974.         Add a revoked (by value not reference) to the CRL structure</font>
<font color="black">1975. </font>
<font color="black">1976.         This revocation will be added by value, not by reference. That</font>
<font color="black">1977.         means it's okay to mutate it after adding: it won't affect</font>
<font color="black">1978.         this CRL.</font>
<font color="black">1979. </font>
<font color="black">1980.         :param Revoked revoked: The new revocation.</font>
<font color="black">1981.         :return: ``None``</font>
<font color="black">1982.         &quot;&quot;&quot;</font>
<font color="red">1983.         copy = _lib.Cryptography_X509_REVOKED_dup(revoked._revoked)</font>
<font color="red">1984.         _openssl_assert(copy != _ffi.NULL)</font>
<font color="black">1985. </font>
<font color="red">1986.         add_result = _lib.X509_CRL_add0_revoked(self._crl, copy)</font>
<font color="red">1987.         _openssl_assert(add_result != 0)</font>
<font color="black">1988. </font>
<font color="green">1989.     def get_issuer(self):</font>
<font color="black">1990.         &quot;&quot;&quot;</font>
<font color="black">1991.         Get the CRL's issuer.</font>
<font color="black">1992. </font>
<font color="black">1993.         .. versionadded:: 16.1.0</font>
<font color="black">1994. </font>
<font color="black">1995.         :rtype: X509Name</font>
<font color="black">1996.         &quot;&quot;&quot;</font>
<font color="red">1997.         _issuer = _lib.X509_NAME_dup(_lib.X509_CRL_get_issuer(self._crl))</font>
<font color="red">1998.         _openssl_assert(_issuer != _ffi.NULL)</font>
<font color="red">1999.         _issuer = _ffi.gc(_issuer, _lib.X509_NAME_free)</font>
<font color="red">2000.         issuer = X509Name.__new__(X509Name)</font>
<font color="red">2001.         issuer._name = _issuer</font>
<font color="red">2002.         return issuer</font>
<font color="black">2003. </font>
<font color="green">2004.     def set_version(self, version):</font>
<font color="black">2005.         &quot;&quot;&quot;</font>
<font color="black">2006.         Set the CRL version.</font>
<font color="black">2007. </font>
<font color="black">2008.         .. versionadded:: 16.1.0</font>
<font color="black">2009. </font>
<font color="black">2010.         :param int version: The version of the CRL.</font>
<font color="black">2011.         :return: ``None``</font>
<font color="black">2012.         &quot;&quot;&quot;</font>
<font color="red">2013.         _openssl_assert(_lib.X509_CRL_set_version(self._crl, version) != 0)</font>
<font color="black">2014. </font>
<font color="green">2015.     def _set_boundary_time(self, which, when):</font>
<font color="red">2016.         return _set_asn1_time(which(self._crl), when)</font>
<font color="black">2017. </font>
<font color="green">2018.     def set_lastUpdate(self, when):</font>
<font color="black">2019.         &quot;&quot;&quot;</font>
<font color="black">2020.         Set when the CRL was last updated.</font>
<font color="black">2021. </font>
<font color="black">2022.         The timestamp is formatted as an ASN.1 GENERALIZEDTIME::</font>
<font color="black">2023. </font>
<font color="black">2024.             YYYYMMDDhhmmssZ</font>
<font color="black">2025.             YYYYMMDDhhmmss+hhmm</font>
<font color="black">2026.             YYYYMMDDhhmmss-hhmm</font>
<font color="black">2027. </font>
<font color="black">2028.         .. versionadded:: 16.1.0</font>
<font color="black">2029. </font>
<font color="black">2030.         :param bytes when: A timestamp string.</font>
<font color="black">2031.         :return: ``None``</font>
<font color="black">2032.         &quot;&quot;&quot;</font>
<font color="red">2033.         return self._set_boundary_time(_lib.X509_CRL_get_lastUpdate, when)</font>
<font color="black">2034. </font>
<font color="green">2035.     def set_nextUpdate(self, when):</font>
<font color="black">2036.         &quot;&quot;&quot;</font>
<font color="black">2037.         Set when the CRL will next be udpated.</font>
<font color="black">2038. </font>
<font color="black">2039.         The timestamp is formatted as an ASN.1 GENERALIZEDTIME::</font>
<font color="black">2040. </font>
<font color="black">2041.             YYYYMMDDhhmmssZ</font>
<font color="black">2042.             YYYYMMDDhhmmss+hhmm</font>
<font color="black">2043.             YYYYMMDDhhmmss-hhmm</font>
<font color="black">2044. </font>
<font color="black">2045.         .. versionadded:: 16.1.0</font>
<font color="black">2046. </font>
<font color="black">2047.         :param bytes when: A timestamp string.</font>
<font color="black">2048.         :return: ``None``</font>
<font color="black">2049.         &quot;&quot;&quot;</font>
<font color="red">2050.         return self._set_boundary_time(_lib.X509_CRL_get_nextUpdate, when)</font>
<font color="black">2051. </font>
<font color="green">2052.     def sign(self, issuer_cert, issuer_key, digest):</font>
<font color="black">2053.         &quot;&quot;&quot;</font>
<font color="black">2054.         Sign the CRL.</font>
<font color="black">2055. </font>
<font color="black">2056.         Signing a CRL enables clients to associate the CRL itself with an</font>
<font color="black">2057.         issuer. Before a CRL is meaningful to other OpenSSL functions, it must</font>
<font color="black">2058.         be signed by an issuer.</font>
<font color="black">2059. </font>
<font color="black">2060.         This method implicitly sets the issuer's name based on the issuer</font>
<font color="black">2061.         certificate and private key used to sign the CRL.</font>
<font color="black">2062. </font>
<font color="black">2063.         .. versionadded:: 16.1.0</font>
<font color="black">2064. </font>
<font color="black">2065.         :param X509 issuer_cert: The issuer's certificate.</font>
<font color="black">2066.         :param PKey issuer_key: The issuer's private key.</font>
<font color="black">2067.         :param bytes digest: The digest method to sign the CRL with.</font>
<font color="black">2068.         &quot;&quot;&quot;</font>
<font color="red">2069.         digest_obj = _lib.EVP_get_digestbyname(digest)</font>
<font color="red">2070.         _openssl_assert(digest_obj != _ffi.NULL)</font>
<font color="red">2071.         _lib.X509_CRL_set_issuer_name(</font>
<font color="red">2072.             self._crl, _lib.X509_get_subject_name(issuer_cert._x509))</font>
<font color="red">2073.         _lib.X509_CRL_sort(self._crl)</font>
<font color="red">2074.         result = _lib.X509_CRL_sign(self._crl, issuer_key._pkey, digest_obj)</font>
<font color="red">2075.         _openssl_assert(result != 0)</font>
<font color="black">2076. </font>
<font color="green">2077.     def export(self, cert, key, type=FILETYPE_PEM, days=100,</font>
<font color="green">2078.                digest=_UNSPECIFIED):</font>
<font color="black">2079.         &quot;&quot;&quot;</font>
<font color="black">2080.         Export the CRL as a string.</font>
<font color="black">2081. </font>
<font color="black">2082.         :param X509 cert: The certificate used to sign the CRL.</font>
<font color="black">2083.         :param PKey key: The key used to sign the CRL.</font>
<font color="black">2084.         :param int type: The export format, either :data:`FILETYPE_PEM`,</font>
<font color="black">2085.             :data:`FILETYPE_ASN1`, or :data:`FILETYPE_TEXT`.</font>
<font color="black">2086.         :param int days: The number of days until the next update of this CRL.</font>
<font color="black">2087.         :param bytes digest: The name of the message digest to use (eg</font>
<font color="black">2088.             ``b&quot;sha2566&quot;``).</font>
<font color="black">2089.         :rtype: bytes</font>
<font color="black">2090.         &quot;&quot;&quot;</font>
<font color="black">2091. </font>
<font color="red">2092.         if not isinstance(cert, X509):</font>
<font color="red">2093.             raise TypeError(&quot;cert must be an X509 instance&quot;)</font>
<font color="red">2094.         if not isinstance(key, PKey):</font>
<font color="red">2095.             raise TypeError(&quot;key must be a PKey instance&quot;)</font>
<font color="red">2096.         if not isinstance(type, int):</font>
<font color="red">2097.             raise TypeError(&quot;type must be an integer&quot;)</font>
<font color="black">2098. </font>
<font color="red">2099.         if digest is _UNSPECIFIED:</font>
<font color="red">2100.             _warn(</font>
<font color="red">2101.                 &quot;The default message digest (md5) is deprecated.  &quot;</font>
<font color="black">2102.                 &quot;Pass the name of a message digest explicitly.&quot;,</font>
<font color="red">2103.                 category=DeprecationWarning,</font>
<font color="red">2104.                 stacklevel=2,</font>
<font color="black">2105.             )</font>
<font color="red">2106.             digest = b&quot;md5&quot;</font>
<font color="black">2107. </font>
<font color="red">2108.         digest_obj = _lib.EVP_get_digestbyname(digest)</font>
<font color="red">2109.         if digest_obj == _ffi.NULL:</font>
<font color="red">2110.             raise ValueError(&quot;No such digest method&quot;)</font>
<font color="black">2111. </font>
<font color="red">2112.         bio = _lib.BIO_new(_lib.BIO_s_mem())</font>
<font color="red">2113.         _openssl_assert(bio != _ffi.NULL)</font>
<font color="black">2114. </font>
<font color="black">2115.         # A scratch time object to give different values to different CRL</font>
<font color="black">2116.         # fields</font>
<font color="red">2117.         sometime = _lib.ASN1_TIME_new()</font>
<font color="red">2118.         _openssl_assert(sometime != _ffi.NULL)</font>
<font color="black">2119. </font>
<font color="red">2120.         _lib.X509_gmtime_adj(sometime, 0)</font>
<font color="red">2121.         _lib.X509_CRL_set_lastUpdate(self._crl, sometime)</font>
<font color="black">2122. </font>
<font color="red">2123.         _lib.X509_gmtime_adj(sometime, days * 24 * 60 * 60)</font>
<font color="red">2124.         _lib.X509_CRL_set_nextUpdate(self._crl, sometime)</font>
<font color="black">2125. </font>
<font color="red">2126.         _lib.X509_CRL_set_issuer_name(</font>
<font color="red">2127.             self._crl, _lib.X509_get_subject_name(cert._x509)</font>
<font color="black">2128.         )</font>
<font color="black">2129. </font>
<font color="red">2130.         sign_result = _lib.X509_CRL_sign(self._crl, key._pkey, digest_obj)</font>
<font color="red">2131.         if not sign_result:</font>
<font color="red">2132.             _raise_current_error()</font>
<font color="black">2133. </font>
<font color="red">2134.         return dump_crl(type, self)</font>
<font color="black">2135. </font>
<font color="black">2136. </font>
<font color="green">2137. CRLType = CRL</font>
<font color="black">2138. </font>
<font color="black">2139. </font>
<font color="green">2140. class PKCS7(object):</font>
<font color="green">2141.     def type_is_signed(self):</font>
<font color="black">2142.         &quot;&quot;&quot;</font>
<font color="black">2143.         Check if this NID_pkcs7_signed object</font>
<font color="black">2144. </font>
<font color="black">2145.         :return: True if the PKCS7 is of type signed</font>
<font color="black">2146.         &quot;&quot;&quot;</font>
<font color="red">2147.         return bool(_lib.PKCS7_type_is_signed(self._pkcs7))</font>
<font color="black">2148. </font>
<font color="green">2149.     def type_is_enveloped(self):</font>
<font color="black">2150.         &quot;&quot;&quot;</font>
<font color="black">2151.         Check if this NID_pkcs7_enveloped object</font>
<font color="black">2152. </font>
<font color="black">2153.         :returns: True if the PKCS7 is of type enveloped</font>
<font color="black">2154.         &quot;&quot;&quot;</font>
<font color="red">2155.         return bool(_lib.PKCS7_type_is_enveloped(self._pkcs7))</font>
<font color="black">2156. </font>
<font color="green">2157.     def type_is_signedAndEnveloped(self):</font>
<font color="black">2158.         &quot;&quot;&quot;</font>
<font color="black">2159.         Check if this NID_pkcs7_signedAndEnveloped object</font>
<font color="black">2160. </font>
<font color="black">2161.         :returns: True if the PKCS7 is of type signedAndEnveloped</font>
<font color="black">2162.         &quot;&quot;&quot;</font>
<font color="red">2163.         return bool(_lib.PKCS7_type_is_signedAndEnveloped(self._pkcs7))</font>
<font color="black">2164. </font>
<font color="green">2165.     def type_is_data(self):</font>
<font color="black">2166.         &quot;&quot;&quot;</font>
<font color="black">2167.         Check if this NID_pkcs7_data object</font>
<font color="black">2168. </font>
<font color="black">2169.         :return: True if the PKCS7 is of type data</font>
<font color="black">2170.         &quot;&quot;&quot;</font>
<font color="red">2171.         return bool(_lib.PKCS7_type_is_data(self._pkcs7))</font>
<font color="black">2172. </font>
<font color="green">2173.     def get_type_name(self):</font>
<font color="black">2174.         &quot;&quot;&quot;</font>
<font color="black">2175.         Returns the type name of the PKCS7 structure</font>
<font color="black">2176. </font>
<font color="black">2177.         :return: A string with the typename</font>
<font color="black">2178.         &quot;&quot;&quot;</font>
<font color="red">2179.         nid = _lib.OBJ_obj2nid(self._pkcs7.type)</font>
<font color="red">2180.         string_type = _lib.OBJ_nid2sn(nid)</font>
<font color="red">2181.         return _ffi.string(string_type)</font>
<font color="black">2182. </font>
<font color="green">2183. PKCS7Type = PKCS7</font>
<font color="black">2184. </font>
<font color="black">2185. </font>
<font color="green">2186. class PKCS12(object):</font>
<font color="black">2187.     &quot;&quot;&quot;</font>
<font color="black">2188.     A PKCS #12 archive.</font>
<font color="green">2189.     &quot;&quot;&quot;</font>
<font color="black">2190. </font>
<font color="green">2191.     def __init__(self):</font>
<font color="red">2192.         self._pkey = None</font>
<font color="red">2193.         self._cert = None</font>
<font color="red">2194.         self._cacerts = None</font>
<font color="red">2195.         self._friendlyname = None</font>
<font color="black">2196. </font>
<font color="green">2197.     def get_certificate(self):</font>
<font color="black">2198.         &quot;&quot;&quot;</font>
<font color="black">2199.         Get the certificate in the PKCS #12 structure.</font>
<font color="black">2200. </font>
<font color="black">2201.         :return: The certificate, or :py:const:`None` if there is none.</font>
<font color="black">2202.         :rtype: :py:class:`X509` or :py:const:`None`</font>
<font color="black">2203.         &quot;&quot;&quot;</font>
<font color="red">2204.         return self._cert</font>
<font color="black">2205. </font>
<font color="green">2206.     def set_certificate(self, cert):</font>
<font color="black">2207.         &quot;&quot;&quot;</font>
<font color="black">2208.         Set the certificate in the PKCS #12 structure.</font>
<font color="black">2209. </font>
<font color="black">2210.         :param cert: The new certificate, or :py:const:`None` to unset it.</font>
<font color="black">2211.         :type cert: :py:class:`X509` or :py:const:`None`</font>
<font color="black">2212. </font>
<font color="black">2213.         :return: ``None``</font>
<font color="black">2214.         &quot;&quot;&quot;</font>
<font color="red">2215.         if not isinstance(cert, X509):</font>
<font color="red">2216.             raise TypeError(&quot;cert must be an X509 instance&quot;)</font>
<font color="red">2217.         self._cert = cert</font>
<font color="black">2218. </font>
<font color="green">2219.     def get_privatekey(self):</font>
<font color="black">2220.         &quot;&quot;&quot;</font>
<font color="black">2221.         Get the private key in the PKCS #12 structure.</font>
<font color="black">2222. </font>
<font color="black">2223.         :return: The private key, or :py:const:`None` if there is none.</font>
<font color="black">2224.         :rtype: :py:class:`PKey`</font>
<font color="black">2225.         &quot;&quot;&quot;</font>
<font color="red">2226.         return self._pkey</font>
<font color="black">2227. </font>
<font color="green">2228.     def set_privatekey(self, pkey):</font>
<font color="black">2229.         &quot;&quot;&quot;</font>
<font color="black">2230.         Set the certificate portion of the PKCS #12 structure.</font>
<font color="black">2231. </font>
<font color="black">2232.         :param pkey: The new private key, or :py:const:`None` to unset it.</font>
<font color="black">2233.         :type pkey: :py:class:`PKey` or :py:const:`None`</font>
<font color="black">2234. </font>
<font color="black">2235.         :return: ``None``</font>
<font color="black">2236.         &quot;&quot;&quot;</font>
<font color="red">2237.         if not isinstance(pkey, PKey):</font>
<font color="red">2238.             raise TypeError(&quot;pkey must be a PKey instance&quot;)</font>
<font color="red">2239.         self._pkey = pkey</font>
<font color="black">2240. </font>
<font color="green">2241.     def get_ca_certificates(self):</font>
<font color="black">2242.         &quot;&quot;&quot;</font>
<font color="black">2243.         Get the CA certificates in the PKCS #12 structure.</font>
<font color="black">2244. </font>
<font color="black">2245.         :return: A tuple with the CA certificates in the chain, or</font>
<font color="black">2246.             :py:const:`None` if there are none.</font>
<font color="black">2247.         :rtype: :py:class:`tuple` of :py:class:`X509` or :py:const:`None`</font>
<font color="black">2248.         &quot;&quot;&quot;</font>
<font color="red">2249.         if self._cacerts is not None:</font>
<font color="red">2250.             return tuple(self._cacerts)</font>
<font color="black">2251. </font>
<font color="green">2252.     def set_ca_certificates(self, cacerts):</font>
<font color="black">2253.         &quot;&quot;&quot;</font>
<font color="black">2254.         Replace or set the CA certificates within the PKCS12 object.</font>
<font color="black">2255. </font>
<font color="black">2256.         :param cacerts: The new CA certificates, or :py:const:`None` to unset</font>
<font color="black">2257.             them.</font>
<font color="black">2258.         :type cacerts: An iterable of :py:class:`X509` or :py:const:`None`</font>
<font color="black">2259. </font>
<font color="black">2260.         :return: ``None``</font>
<font color="black">2261.         &quot;&quot;&quot;</font>
<font color="red">2262.         if cacerts is None:</font>
<font color="red">2263.             self._cacerts = None</font>
<font color="black">2264.         else:</font>
<font color="red">2265.             cacerts = list(cacerts)</font>
<font color="red">2266.             for cert in cacerts:</font>
<font color="red">2267.                 if not isinstance(cert, X509):</font>
<font color="red">2268.                     raise TypeError(</font>
<font color="red">2269.                         &quot;iterable must only contain X509 instances&quot;</font>
<font color="black">2270.                     )</font>
<font color="red">2271.             self._cacerts = cacerts</font>
<font color="black">2272. </font>
<font color="green">2273.     def set_friendlyname(self, name):</font>
<font color="black">2274.         &quot;&quot;&quot;</font>
<font color="black">2275.         Set the friendly name in the PKCS #12 structure.</font>
<font color="black">2276. </font>
<font color="black">2277.         :param name: The new friendly name, or :py:const:`None` to unset.</font>
<font color="black">2278.         :type name: :py:class:`bytes` or :py:const:`None`</font>
<font color="black">2279. </font>
<font color="black">2280.         :return: ``None``</font>
<font color="black">2281.         &quot;&quot;&quot;</font>
<font color="red">2282.         if name is None:</font>
<font color="red">2283.             self._friendlyname = None</font>
<font color="red">2284.         elif not isinstance(name, bytes):</font>
<font color="red">2285.             raise TypeError(</font>
<font color="red">2286.                 &quot;name must be a byte string or None (not %r)&quot; % (name,)</font>
<font color="black">2287.             )</font>
<font color="red">2288.         self._friendlyname = name</font>
<font color="black">2289. </font>
<font color="green">2290.     def get_friendlyname(self):</font>
<font color="black">2291.         &quot;&quot;&quot;</font>
<font color="black">2292.         Get the friendly name in the PKCS# 12 structure.</font>
<font color="black">2293. </font>
<font color="black">2294.         :returns: The friendly name,  or :py:const:`None` if there is none.</font>
<font color="black">2295.         :rtype: :py:class:`bytes` or :py:const:`None`</font>
<font color="black">2296.         &quot;&quot;&quot;</font>
<font color="red">2297.         return self._friendlyname</font>
<font color="black">2298. </font>
<font color="green">2299.     def export(self, passphrase=None, iter=2048, maciter=1):</font>
<font color="black">2300.         &quot;&quot;&quot;</font>
<font color="black">2301.         Dump a PKCS12 object as a string.</font>
<font color="black">2302. </font>
<font color="black">2303.         For more information, see the :c:func:`PKCS12_create` man page.</font>
<font color="black">2304. </font>
<font color="black">2305.         :param passphrase: The passphrase used to encrypt the structure. Unlike</font>
<font color="black">2306.             some other passphrase arguments, this *must* be a string, not a</font>
<font color="black">2307.             callback.</font>
<font color="black">2308.         :type passphrase: :py:data:`bytes`</font>
<font color="black">2309. </font>
<font color="black">2310.         :param iter: Number of times to repeat the encryption step.</font>
<font color="black">2311.         :type iter: :py:data:`int`</font>
<font color="black">2312. </font>
<font color="black">2313.         :param maciter: Number of times to repeat the MAC step.</font>
<font color="black">2314.         :type maciter: :py:data:`int`</font>
<font color="black">2315. </font>
<font color="black">2316.         :return: The string representation of the PKCS #12 structure.</font>
<font color="black">2317.         :rtype:</font>
<font color="black">2318.         &quot;&quot;&quot;</font>
<font color="red">2319.         passphrase = _text_to_bytes_and_warn(&quot;passphrase&quot;, passphrase)</font>
<font color="black">2320. </font>
<font color="red">2321.         if self._cacerts is None:</font>
<font color="red">2322.             cacerts = _ffi.NULL</font>
<font color="black">2323.         else:</font>
<font color="red">2324.             cacerts = _lib.sk_X509_new_null()</font>
<font color="red">2325.             cacerts = _ffi.gc(cacerts, _lib.sk_X509_free)</font>
<font color="red">2326.             for cert in self._cacerts:</font>
<font color="red">2327.                 _lib.sk_X509_push(cacerts, cert._x509)</font>
<font color="black">2328. </font>
<font color="red">2329.         if passphrase is None:</font>
<font color="red">2330.             passphrase = _ffi.NULL</font>
<font color="black">2331. </font>
<font color="red">2332.         friendlyname = self._friendlyname</font>
<font color="red">2333.         if friendlyname is None:</font>
<font color="red">2334.             friendlyname = _ffi.NULL</font>
<font color="black">2335. </font>
<font color="red">2336.         if self._pkey is None:</font>
<font color="red">2337.             pkey = _ffi.NULL</font>
<font color="black">2338.         else:</font>
<font color="red">2339.             pkey = self._pkey._pkey</font>
<font color="black">2340. </font>
<font color="red">2341.         if self._cert is None:</font>
<font color="red">2342.             cert = _ffi.NULL</font>
<font color="black">2343.         else:</font>
<font color="red">2344.             cert = self._cert._x509</font>
<font color="black">2345. </font>
<font color="red">2346.         pkcs12 = _lib.PKCS12_create(</font>
<font color="red">2347.             passphrase, friendlyname, pkey, cert, cacerts,</font>
<font color="red">2348.             _lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC,</font>
<font color="red">2349.             _lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC,</font>
<font color="red">2350.             iter, maciter, 0)</font>
<font color="red">2351.         if pkcs12 == _ffi.NULL:</font>
<font color="red">2352.             _raise_current_error()</font>
<font color="red">2353.         pkcs12 = _ffi.gc(pkcs12, _lib.PKCS12_free)</font>
<font color="black">2354. </font>
<font color="red">2355.         bio = _new_mem_buf()</font>
<font color="red">2356.         _lib.i2d_PKCS12_bio(bio, pkcs12)</font>
<font color="red">2357.         return _bio_to_string(bio)</font>
<font color="black">2358. </font>
<font color="black">2359. </font>
<font color="green">2360. PKCS12Type = PKCS12</font>
<font color="black">2361. </font>
<font color="black">2362. </font>
<font color="green">2363. class NetscapeSPKI(object):</font>
<font color="black">2364.     &quot;&quot;&quot;</font>
<font color="black">2365.     A Netscape SPKI object.</font>
<font color="green">2366.     &quot;&quot;&quot;</font>
<font color="black">2367. </font>
<font color="green">2368.     def __init__(self):</font>
<font color="red">2369.         spki = _lib.NETSCAPE_SPKI_new()</font>
<font color="red">2370.         self._spki = _ffi.gc(spki, _lib.NETSCAPE_SPKI_free)</font>
<font color="black">2371. </font>
<font color="green">2372.     def sign(self, pkey, digest):</font>
<font color="black">2373.         &quot;&quot;&quot;</font>
<font color="black">2374.         Sign the certificate request with this key and digest type.</font>
<font color="black">2375. </font>
<font color="black">2376.         :param pkey: The private key to sign with.</font>
<font color="black">2377.         :type pkey: :py:class:`PKey`</font>
<font color="black">2378. </font>
<font color="black">2379.         :param digest: The message digest to use.</font>
<font color="black">2380.         :type digest: :py:class:`bytes`</font>
<font color="black">2381. </font>
<font color="black">2382.         :return: ``None``</font>
<font color="black">2383.         &quot;&quot;&quot;</font>
<font color="red">2384.         if pkey._only_public:</font>
<font color="red">2385.             raise ValueError(&quot;Key has only public part&quot;)</font>
<font color="black">2386. </font>
<font color="red">2387.         if not pkey._initialized:</font>
<font color="red">2388.             raise ValueError(&quot;Key is uninitialized&quot;)</font>
<font color="black">2389. </font>
<font color="red">2390.         digest_obj = _lib.EVP_get_digestbyname(_byte_string(digest))</font>
<font color="red">2391.         if digest_obj == _ffi.NULL:</font>
<font color="red">2392.             raise ValueError(&quot;No such digest method&quot;)</font>
<font color="black">2393. </font>
<font color="red">2394.         sign_result = _lib.NETSCAPE_SPKI_sign(</font>
<font color="red">2395.             self._spki, pkey._pkey, digest_obj</font>
<font color="black">2396.         )</font>
<font color="red">2397.         _openssl_assert(sign_result &gt; 0)</font>
<font color="black">2398. </font>
<font color="green">2399.     def verify(self, key):</font>
<font color="black">2400.         &quot;&quot;&quot;</font>
<font color="black">2401.         Verifies a signature on a certificate request.</font>
<font color="black">2402. </font>
<font color="black">2403.         :param key: The public key that signature is supposedly from.</font>
<font color="black">2404.         :type pkey: :py:class:`PKey`</font>
<font color="black">2405. </font>
<font color="black">2406.         :return: :py:const:`True` if the signature is correct.</font>
<font color="black">2407.         :rtype: :py:class:`bool`</font>
<font color="black">2408. </font>
<font color="black">2409.         :raises Error: If the signature is invalid, or there was a problem</font>
<font color="black">2410.             verifying the signature.</font>
<font color="black">2411.         &quot;&quot;&quot;</font>
<font color="red">2412.         answer = _lib.NETSCAPE_SPKI_verify(self._spki, key._pkey)</font>
<font color="red">2413.         if answer &lt;= 0:</font>
<font color="red">2414.             _raise_current_error()</font>
<font color="red">2415.         return True</font>
<font color="black">2416. </font>
<font color="green">2417.     def b64_encode(self):</font>
<font color="black">2418.         &quot;&quot;&quot;</font>
<font color="black">2419.         Generate a base64 encoded representation of this SPKI object.</font>
<font color="black">2420. </font>
<font color="black">2421.         :return: The base64 encoded string.</font>
<font color="black">2422.         :rtype: :py:class:`bytes`</font>
<font color="black">2423.         &quot;&quot;&quot;</font>
<font color="red">2424.         encoded = _lib.NETSCAPE_SPKI_b64_encode(self._spki)</font>
<font color="red">2425.         result = _ffi.string(encoded)</font>
<font color="red">2426.         _lib.OPENSSL_free(encoded)</font>
<font color="red">2427.         return result</font>
<font color="black">2428. </font>
<font color="green">2429.     def get_pubkey(self):</font>
<font color="black">2430.         &quot;&quot;&quot;</font>
<font color="black">2431.         Get the public key of this certificate.</font>
<font color="black">2432. </font>
<font color="black">2433.         :return: The public key.</font>
<font color="black">2434.         :rtype: :py:class:`PKey`</font>
<font color="black">2435.         &quot;&quot;&quot;</font>
<font color="red">2436.         pkey = PKey.__new__(PKey)</font>
<font color="red">2437.         pkey._pkey = _lib.NETSCAPE_SPKI_get_pubkey(self._spki)</font>
<font color="red">2438.         _openssl_assert(pkey._pkey != _ffi.NULL)</font>
<font color="red">2439.         pkey._pkey = _ffi.gc(pkey._pkey, _lib.EVP_PKEY_free)</font>
<font color="red">2440.         pkey._only_public = True</font>
<font color="red">2441.         return pkey</font>
<font color="black">2442. </font>
<font color="green">2443.     def set_pubkey(self, pkey):</font>
<font color="black">2444.         &quot;&quot;&quot;</font>
<font color="black">2445.         Set the public key of the certificate</font>
<font color="black">2446. </font>
<font color="black">2447.         :param pkey: The public key</font>
<font color="black">2448.         :return: ``None``</font>
<font color="black">2449.         &quot;&quot;&quot;</font>
<font color="red">2450.         set_result = _lib.NETSCAPE_SPKI_set_pubkey(self._spki, pkey._pkey)</font>
<font color="red">2451.         _openssl_assert(set_result == 1)</font>
<font color="black">2452. </font>
<font color="black">2453. </font>
<font color="green">2454. NetscapeSPKIType = NetscapeSPKI</font>
<font color="black">2455. </font>
<font color="black">2456. </font>
<font color="green">2457. class _PassphraseHelper(object):</font>
<font color="green">2458.     def __init__(self, type, passphrase, more_args=False, truncate=False):</font>
<font color="red">2459.         if type != FILETYPE_PEM and passphrase is not None:</font>
<font color="red">2460.             raise ValueError(</font>
<font color="red">2461.                 &quot;only FILETYPE_PEM key format supports encryption&quot;</font>
<font color="black">2462.             )</font>
<font color="red">2463.         self._passphrase = passphrase</font>
<font color="red">2464.         self._more_args = more_args</font>
<font color="red">2465.         self._truncate = truncate</font>
<font color="red">2466.         self._problems = []</font>
<font color="black">2467. </font>
<font color="green">2468.     @property</font>
<font color="black">2469.     def callback(self):</font>
<font color="red">2470.         if self._passphrase is None:</font>
<font color="red">2471.             return _ffi.NULL</font>
<font color="red">2472.         elif isinstance(self._passphrase, bytes):</font>
<font color="red">2473.             return _ffi.NULL</font>
<font color="red">2474.         elif callable(self._passphrase):</font>
<font color="red">2475.             return _ffi.callback(&quot;pem_password_cb&quot;, self._read_passphrase)</font>
<font color="black">2476.         else:</font>
<font color="red">2477.             raise TypeError(&quot;Last argument must be string or callable&quot;)</font>
<font color="black">2478. </font>
<font color="green">2479.     @property</font>
<font color="black">2480.     def callback_args(self):</font>
<font color="red">2481.         if self._passphrase is None:</font>
<font color="red">2482.             return _ffi.NULL</font>
<font color="red">2483.         elif isinstance(self._passphrase, bytes):</font>
<font color="red">2484.             return self._passphrase</font>
<font color="red">2485.         elif callable(self._passphrase):</font>
<font color="red">2486.             return _ffi.NULL</font>
<font color="black">2487.         else:</font>
<font color="red">2488.             raise TypeError(&quot;Last argument must be string or callable&quot;)</font>
<font color="black">2489. </font>
<font color="green">2490.     def raise_if_problem(self, exceptionType=Error):</font>
<font color="red">2491.         try:</font>
<font color="red">2492.             _exception_from_error_queue(exceptionType)</font>
<font color="red">2493.         except exceptionType as e:</font>
<font color="red">2494.             from_queue = e</font>
<font color="red">2495.         if self._problems:</font>
<font color="red">2496.             raise self._problems[0]</font>
<font color="red">2497.         return from_queue</font>
<font color="black">2498. </font>
<font color="green">2499.     def _read_passphrase(self, buf, size, rwflag, userdata):</font>
<font color="red">2500.         try:</font>
<font color="red">2501.             if self._more_args:</font>
<font color="red">2502.                 result = self._passphrase(size, rwflag, userdata)</font>
<font color="black">2503.             else:</font>
<font color="red">2504.                 result = self._passphrase(rwflag)</font>
<font color="red">2505.             if not isinstance(result, bytes):</font>
<font color="red">2506.                 raise ValueError(&quot;String expected&quot;)</font>
<font color="red">2507.             if len(result) &gt; size:</font>
<font color="red">2508.                 if self._truncate:</font>
<font color="red">2509.                     result = result[:size]</font>
<font color="black">2510.                 else:</font>
<font color="red">2511.                     raise ValueError(</font>
<font color="red">2512.                         &quot;passphrase returned by callback is too long&quot;</font>
<font color="black">2513.                     )</font>
<font color="red">2514.             for i in range(len(result)):</font>
<font color="red">2515.                 buf[i] = result[i:i + 1]</font>
<font color="red">2516.             return len(result)</font>
<font color="red">2517.         except Exception as e:</font>
<font color="red">2518.             self._problems.append(e)</font>
<font color="red">2519.             return 0</font>
<font color="black">2520. </font>
<font color="black">2521. </font>
<font color="green">2522. def load_publickey(type, buffer):</font>
<font color="black">2523.     &quot;&quot;&quot;</font>
<font color="black">2524.     Load a public key from a buffer.</font>
<font color="black">2525. </font>
<font color="black">2526.     :param type: The file type (one of :data:`FILETYPE_PEM`,</font>
<font color="black">2527.         :data:`FILETYPE_ASN1`).</font>
<font color="black">2528.     :param buffer: The buffer the key is stored in.</font>
<font color="black">2529.     :type buffer: A Python string object, either unicode or bytestring.</font>
<font color="black">2530.     :return: The PKey object.</font>
<font color="black">2531.     :rtype: :class:`PKey`</font>
<font color="black">2532.     &quot;&quot;&quot;</font>
<font color="red">2533.     if isinstance(buffer, _text_type):</font>
<font color="red">2534.         buffer = buffer.encode(&quot;ascii&quot;)</font>
<font color="black">2535. </font>
<font color="red">2536.     bio = _new_mem_buf(buffer)</font>
<font color="black">2537. </font>
<font color="red">2538.     if type == FILETYPE_PEM:</font>
<font color="red">2539.         evp_pkey = _lib.PEM_read_bio_PUBKEY(</font>
<font color="red">2540.             bio, _ffi.NULL, _ffi.NULL, _ffi.NULL)</font>
<font color="red">2541.     elif type == FILETYPE_ASN1:</font>
<font color="red">2542.         evp_pkey = _lib.d2i_PUBKEY_bio(bio, _ffi.NULL)</font>
<font color="black">2543.     else:</font>
<font color="red">2544.         raise ValueError(&quot;type argument must be FILETYPE_PEM or FILETYPE_ASN1&quot;)</font>
<font color="black">2545. </font>
<font color="red">2546.     if evp_pkey == _ffi.NULL:</font>
<font color="red">2547.         _raise_current_error()</font>
<font color="black">2548. </font>
<font color="red">2549.     pkey = PKey.__new__(PKey)</font>
<font color="red">2550.     pkey._pkey = _ffi.gc(evp_pkey, _lib.EVP_PKEY_free)</font>
<font color="red">2551.     pkey._only_public = True</font>
<font color="red">2552.     return pkey</font>
<font color="black">2553. </font>
<font color="black">2554. </font>
<font color="green">2555. def load_privatekey(type, buffer, passphrase=None):</font>
<font color="black">2556.     &quot;&quot;&quot;</font>
<font color="black">2557.     Load a private key from a buffer</font>
<font color="black">2558. </font>
<font color="black">2559.     :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)</font>
<font color="black">2560.     :param buffer: The buffer the key is stored in</font>
<font color="black">2561.     :param passphrase: (optional) if encrypted PEM format, this can be</font>
<font color="black">2562.                        either the passphrase to use, or a callback for</font>
<font color="black">2563.                        providing the passphrase.</font>
<font color="black">2564. </font>
<font color="black">2565.     :return: The PKey object</font>
<font color="black">2566.     &quot;&quot;&quot;</font>
<font color="red">2567.     if isinstance(buffer, _text_type):</font>
<font color="red">2568.         buffer = buffer.encode(&quot;ascii&quot;)</font>
<font color="black">2569. </font>
<font color="red">2570.     bio = _new_mem_buf(buffer)</font>
<font color="black">2571. </font>
<font color="red">2572.     helper = _PassphraseHelper(type, passphrase)</font>
<font color="red">2573.     if type == FILETYPE_PEM:</font>
<font color="red">2574.         evp_pkey = _lib.PEM_read_bio_PrivateKey(</font>
<font color="red">2575.             bio, _ffi.NULL, helper.callback, helper.callback_args)</font>
<font color="red">2576.         helper.raise_if_problem()</font>
<font color="red">2577.     elif type == FILETYPE_ASN1:</font>
<font color="red">2578.         evp_pkey = _lib.d2i_PrivateKey_bio(bio, _ffi.NULL)</font>
<font color="black">2579.     else:</font>
<font color="red">2580.         raise ValueError(&quot;type argument must be FILETYPE_PEM or FILETYPE_ASN1&quot;)</font>
<font color="black">2581. </font>
<font color="red">2582.     if evp_pkey == _ffi.NULL:</font>
<font color="red">2583.         _raise_current_error()</font>
<font color="black">2584. </font>
<font color="red">2585.     pkey = PKey.__new__(PKey)</font>
<font color="red">2586.     pkey._pkey = _ffi.gc(evp_pkey, _lib.EVP_PKEY_free)</font>
<font color="red">2587.     return pkey</font>
<font color="black">2588. </font>
<font color="black">2589. </font>
<font color="green">2590. def dump_certificate_request(type, req):</font>
<font color="black">2591.     &quot;&quot;&quot;</font>
<font color="black">2592.     Dump a certificate request to a buffer</font>
<font color="black">2593. </font>
<font color="black">2594.     :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)</font>
<font color="black">2595.     :param req: The certificate request to dump</font>
<font color="black">2596.     :return: The buffer with the dumped certificate request in</font>
<font color="black">2597.     &quot;&quot;&quot;</font>
<font color="red">2598.     bio = _new_mem_buf()</font>
<font color="black">2599. </font>
<font color="red">2600.     if type == FILETYPE_PEM:</font>
<font color="red">2601.         result_code = _lib.PEM_write_bio_X509_REQ(bio, req._req)</font>
<font color="red">2602.     elif type == FILETYPE_ASN1:</font>
<font color="red">2603.         result_code = _lib.i2d_X509_REQ_bio(bio, req._req)</font>
<font color="red">2604.     elif type == FILETYPE_TEXT:</font>
<font color="red">2605.         result_code = _lib.X509_REQ_print_ex(bio, req._req, 0, 0)</font>
<font color="black">2606.     else:</font>
<font color="red">2607.         raise ValueError(</font>
<font color="red">2608.             &quot;type argument must be FILETYPE_PEM, FILETYPE_ASN1, or &quot;</font>
<font color="black">2609.             &quot;FILETYPE_TEXT&quot;</font>
<font color="black">2610.         )</font>
<font color="black">2611. </font>
<font color="red">2612.     _openssl_assert(result_code != 0)</font>
<font color="black">2613. </font>
<font color="red">2614.     return _bio_to_string(bio)</font>
<font color="black">2615. </font>
<font color="black">2616. </font>
<font color="green">2617. def load_certificate_request(type, buffer):</font>
<font color="black">2618.     &quot;&quot;&quot;</font>
<font color="black">2619.     Load a certificate request from a buffer</font>
<font color="black">2620. </font>
<font color="black">2621.     :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)</font>
<font color="black">2622.     :param buffer: The buffer the certificate request is stored in</font>
<font color="black">2623.     :return: The X509Req object</font>
<font color="black">2624.     &quot;&quot;&quot;</font>
<font color="red">2625.     if isinstance(buffer, _text_type):</font>
<font color="red">2626.         buffer = buffer.encode(&quot;ascii&quot;)</font>
<font color="black">2627. </font>
<font color="red">2628.     bio = _new_mem_buf(buffer)</font>
<font color="black">2629. </font>
<font color="red">2630.     if type == FILETYPE_PEM:</font>
<font color="red">2631.         req = _lib.PEM_read_bio_X509_REQ(bio, _ffi.NULL, _ffi.NULL, _ffi.NULL)</font>
<font color="red">2632.     elif type == FILETYPE_ASN1:</font>
<font color="red">2633.         req = _lib.d2i_X509_REQ_bio(bio, _ffi.NULL)</font>
<font color="black">2634.     else:</font>
<font color="red">2635.         raise ValueError(&quot;type argument must be FILETYPE_PEM or FILETYPE_ASN1&quot;)</font>
<font color="black">2636. </font>
<font color="red">2637.     _openssl_assert(req != _ffi.NULL)</font>
<font color="black">2638. </font>
<font color="red">2639.     x509req = X509Req.__new__(X509Req)</font>
<font color="red">2640.     x509req._req = _ffi.gc(req, _lib.X509_REQ_free)</font>
<font color="red">2641.     return x509req</font>
<font color="black">2642. </font>
<font color="black">2643. </font>
<font color="green">2644. def sign(pkey, data, digest):</font>
<font color="black">2645.     &quot;&quot;&quot;</font>
<font color="black">2646.     Sign data with a digest</font>
<font color="black">2647. </font>
<font color="black">2648.     :param pkey: Pkey to sign with</font>
<font color="black">2649.     :param data: data to be signed</font>
<font color="black">2650.     :param digest: message digest to use</font>
<font color="black">2651.     :return: signature</font>
<font color="black">2652.     &quot;&quot;&quot;</font>
<font color="red">2653.     data = _text_to_bytes_and_warn(&quot;data&quot;, data)</font>
<font color="black">2654. </font>
<font color="red">2655.     digest_obj = _lib.EVP_get_digestbyname(_byte_string(digest))</font>
<font color="red">2656.     if digest_obj == _ffi.NULL:</font>
<font color="red">2657.         raise ValueError(&quot;No such digest method&quot;)</font>
<font color="black">2658. </font>
<font color="red">2659.     md_ctx = _lib.Cryptography_EVP_MD_CTX_new()</font>
<font color="red">2660.     md_ctx = _ffi.gc(md_ctx, _lib.Cryptography_EVP_MD_CTX_free)</font>
<font color="black">2661. </font>
<font color="red">2662.     _lib.EVP_SignInit(md_ctx, digest_obj)</font>
<font color="red">2663.     _lib.EVP_SignUpdate(md_ctx, data, len(data))</font>
<font color="black">2664. </font>
<font color="red">2665.     pkey_length = (PKey.bits(pkey) + 7) // 8</font>
<font color="red">2666.     signature_buffer = _ffi.new(&quot;unsigned char[]&quot;, pkey_length)</font>
<font color="red">2667.     signature_length = _ffi.new(&quot;unsigned int*&quot;)</font>
<font color="red">2668.     final_result = _lib.EVP_SignFinal(</font>
<font color="red">2669.         md_ctx, signature_buffer, signature_length, pkey._pkey)</font>
<font color="red">2670.     _openssl_assert(final_result == 1)</font>
<font color="black">2671. </font>
<font color="red">2672.     return _ffi.buffer(signature_buffer, signature_length[0])[:]</font>
<font color="black">2673. </font>
<font color="black">2674. </font>
<font color="green">2675. def verify(cert, signature, data, digest):</font>
<font color="black">2676.     &quot;&quot;&quot;</font>
<font color="black">2677.     Verify a signature.</font>
<font color="black">2678. </font>
<font color="black">2679.     :param cert: signing certificate (X509 object)</font>
<font color="black">2680.     :param signature: signature returned by sign function</font>
<font color="black">2681.     :param data: data to be verified</font>
<font color="black">2682.     :param digest: message digest to use</font>
<font color="black">2683.     :return: ``None`` if the signature is correct, raise exception otherwise.</font>
<font color="black">2684.     &quot;&quot;&quot;</font>
<font color="red">2685.     data = _text_to_bytes_and_warn(&quot;data&quot;, data)</font>
<font color="black">2686. </font>
<font color="red">2687.     digest_obj = _lib.EVP_get_digestbyname(_byte_string(digest))</font>
<font color="red">2688.     if digest_obj == _ffi.NULL:</font>
<font color="red">2689.         raise ValueError(&quot;No such digest method&quot;)</font>
<font color="black">2690. </font>
<font color="red">2691.     pkey = _lib.X509_get_pubkey(cert._x509)</font>
<font color="red">2692.     _openssl_assert(pkey != _ffi.NULL)</font>
<font color="red">2693.     pkey = _ffi.gc(pkey, _lib.EVP_PKEY_free)</font>
<font color="black">2694. </font>
<font color="red">2695.     md_ctx = _lib.Cryptography_EVP_MD_CTX_new()</font>
<font color="red">2696.     md_ctx = _ffi.gc(md_ctx, _lib.Cryptography_EVP_MD_CTX_free)</font>
<font color="black">2697. </font>
<font color="red">2698.     _lib.EVP_VerifyInit(md_ctx, digest_obj)</font>
<font color="red">2699.     _lib.EVP_VerifyUpdate(md_ctx, data, len(data))</font>
<font color="red">2700.     verify_result = _lib.EVP_VerifyFinal(</font>
<font color="red">2701.         md_ctx, signature, len(signature), pkey</font>
<font color="black">2702.     )</font>
<font color="black">2703. </font>
<font color="red">2704.     if verify_result != 1:</font>
<font color="red">2705.         _raise_current_error()</font>
<font color="black">2706. </font>
<font color="black">2707. </font>
<font color="green">2708. def dump_crl(type, crl):</font>
<font color="black">2709.     &quot;&quot;&quot;</font>
<font color="black">2710.     Dump a certificate revocation list to a buffer.</font>
<font color="black">2711. </font>
<font color="black">2712.     :param type: The file type (one of ``FILETYPE_PEM``, ``FILETYPE_ASN1``, or</font>
<font color="black">2713.         ``FILETYPE_TEXT``).</font>
<font color="black">2714.     :param CRL crl: The CRL to dump.</font>
<font color="black">2715. </font>
<font color="black">2716.     :return: The buffer with the CRL.</font>
<font color="black">2717.     :rtype: bytes</font>
<font color="black">2718.     &quot;&quot;&quot;</font>
<font color="red">2719.     bio = _new_mem_buf()</font>
<font color="black">2720. </font>
<font color="red">2721.     if type == FILETYPE_PEM:</font>
<font color="red">2722.         ret = _lib.PEM_write_bio_X509_CRL(bio, crl._crl)</font>
<font color="red">2723.     elif type == FILETYPE_ASN1:</font>
<font color="red">2724.         ret = _lib.i2d_X509_CRL_bio(bio, crl._crl)</font>
<font color="red">2725.     elif type == FILETYPE_TEXT:</font>
<font color="red">2726.         ret = _lib.X509_CRL_print(bio, crl._crl)</font>
<font color="black">2727.     else:</font>
<font color="red">2728.         raise ValueError(</font>
<font color="red">2729.             &quot;type argument must be FILETYPE_PEM, FILETYPE_ASN1, or &quot;</font>
<font color="black">2730.             &quot;FILETYPE_TEXT&quot;)</font>
<font color="black">2731. </font>
<font color="red">2732.     assert ret == 1</font>
<font color="red">2733.     return _bio_to_string(bio)</font>
<font color="black">2734. </font>
<font color="black">2735. </font>
<font color="green">2736. def load_crl(type, buffer):</font>
<font color="black">2737.     &quot;&quot;&quot;</font>
<font color="black">2738.     Load a certificate revocation list from a buffer</font>
<font color="black">2739. </font>
<font color="black">2740.     :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)</font>
<font color="black">2741.     :param buffer: The buffer the CRL is stored in</font>
<font color="black">2742. </font>
<font color="black">2743.     :return: The PKey object</font>
<font color="black">2744.     &quot;&quot;&quot;</font>
<font color="red">2745.     if isinstance(buffer, _text_type):</font>
<font color="red">2746.         buffer = buffer.encode(&quot;ascii&quot;)</font>
<font color="black">2747. </font>
<font color="red">2748.     bio = _new_mem_buf(buffer)</font>
<font color="black">2749. </font>
<font color="red">2750.     if type == FILETYPE_PEM:</font>
<font color="red">2751.         crl = _lib.PEM_read_bio_X509_CRL(bio, _ffi.NULL, _ffi.NULL, _ffi.NULL)</font>
<font color="red">2752.     elif type == FILETYPE_ASN1:</font>
<font color="red">2753.         crl = _lib.d2i_X509_CRL_bio(bio, _ffi.NULL)</font>
<font color="black">2754.     else:</font>
<font color="red">2755.         raise ValueError(&quot;type argument must be FILETYPE_PEM or FILETYPE_ASN1&quot;)</font>
<font color="black">2756. </font>
<font color="red">2757.     if crl == _ffi.NULL:</font>
<font color="red">2758.         _raise_current_error()</font>
<font color="black">2759. </font>
<font color="red">2760.     result = CRL.__new__(CRL)</font>
<font color="red">2761.     result._crl = crl</font>
<font color="red">2762.     return result</font>
<font color="black">2763. </font>
<font color="black">2764. </font>
<font color="green">2765. def load_pkcs7_data(type, buffer):</font>
<font color="black">2766.     &quot;&quot;&quot;</font>
<font color="black">2767.     Load pkcs7 data from a buffer</font>
<font color="black">2768. </font>
<font color="black">2769.     :param type: The file type (one of FILETYPE_PEM or FILETYPE_ASN1)</font>
<font color="black">2770.     :param buffer: The buffer with the pkcs7 data.</font>
<font color="black">2771.     :return: The PKCS7 object</font>
<font color="black">2772.     &quot;&quot;&quot;</font>
<font color="red">2773.     if isinstance(buffer, _text_type):</font>
<font color="red">2774.         buffer = buffer.encode(&quot;ascii&quot;)</font>
<font color="black">2775. </font>
<font color="red">2776.     bio = _new_mem_buf(buffer)</font>
<font color="black">2777. </font>
<font color="red">2778.     if type == FILETYPE_PEM:</font>
<font color="red">2779.         pkcs7 = _lib.PEM_read_bio_PKCS7(bio, _ffi.NULL, _ffi.NULL, _ffi.NULL)</font>
<font color="red">2780.     elif type == FILETYPE_ASN1:</font>
<font color="red">2781.         pkcs7 = _lib.d2i_PKCS7_bio(bio, _ffi.NULL)</font>
<font color="black">2782.     else:</font>
<font color="red">2783.         raise ValueError(&quot;type argument must be FILETYPE_PEM or FILETYPE_ASN1&quot;)</font>
<font color="black">2784. </font>
<font color="red">2785.     if pkcs7 == _ffi.NULL:</font>
<font color="red">2786.         _raise_current_error()</font>
<font color="black">2787. </font>
<font color="red">2788.     pypkcs7 = PKCS7.__new__(PKCS7)</font>
<font color="red">2789.     pypkcs7._pkcs7 = _ffi.gc(pkcs7, _lib.PKCS7_free)</font>
<font color="red">2790.     return pypkcs7</font>
<font color="black">2791. </font>
<font color="black">2792. </font>
<font color="green">2793. def load_pkcs12(buffer, passphrase=None):</font>
<font color="black">2794.     &quot;&quot;&quot;</font>
<font color="black">2795.     Load a PKCS12 object from a buffer</font>
<font color="black">2796. </font>
<font color="black">2797.     :param buffer: The buffer the certificate is stored in</font>
<font color="black">2798.     :param passphrase: (Optional) The password to decrypt the PKCS12 lump</font>
<font color="black">2799.     :returns: The PKCS12 object</font>
<font color="black">2800.     &quot;&quot;&quot;</font>
<font color="red">2801.     passphrase = _text_to_bytes_and_warn(&quot;passphrase&quot;, passphrase)</font>
<font color="black">2802. </font>
<font color="red">2803.     if isinstance(buffer, _text_type):</font>
<font color="red">2804.         buffer = buffer.encode(&quot;ascii&quot;)</font>
<font color="black">2805. </font>
<font color="red">2806.     bio = _new_mem_buf(buffer)</font>
<font color="black">2807. </font>
<font color="black">2808.     # Use null passphrase if passphrase is None or empty string. With PKCS#12</font>
<font color="black">2809.     # password based encryption no password and a zero length password are two</font>
<font color="black">2810.     # different things, but OpenSSL implementation will try both to figure out</font>
<font color="black">2811.     # which one works.</font>
<font color="red">2812.     if not passphrase:</font>
<font color="red">2813.         passphrase = _ffi.NULL</font>
<font color="black">2814. </font>
<font color="red">2815.     p12 = _lib.d2i_PKCS12_bio(bio, _ffi.NULL)</font>
<font color="red">2816.     if p12 == _ffi.NULL:</font>
<font color="red">2817.         _raise_current_error()</font>
<font color="red">2818.     p12 = _ffi.gc(p12, _lib.PKCS12_free)</font>
<font color="black">2819. </font>
<font color="red">2820.     pkey = _ffi.new(&quot;EVP_PKEY**&quot;)</font>
<font color="red">2821.     cert = _ffi.new(&quot;X509**&quot;)</font>
<font color="red">2822.     cacerts = _ffi.new(&quot;Cryptography_STACK_OF_X509**&quot;)</font>
<font color="black">2823. </font>
<font color="red">2824.     parse_result = _lib.PKCS12_parse(p12, passphrase, pkey, cert, cacerts)</font>
<font color="red">2825.     if not parse_result:</font>
<font color="red">2826.         _raise_current_error()</font>
<font color="black">2827. </font>
<font color="red">2828.     cacerts = _ffi.gc(cacerts[0], _lib.sk_X509_free)</font>
<font color="black">2829. </font>
<font color="black">2830.     # openssl 1.0.0 sometimes leaves an X509_check_private_key error in the</font>
<font color="black">2831.     # queue for no particular reason.  This error isn't interesting to anyone</font>
<font color="black">2832.     # outside this function.  It's not even interesting to us.  Get rid of it.</font>
<font color="red">2833.     try:</font>
<font color="red">2834.         _raise_current_error()</font>
<font color="red">2835.     except Error:</font>
<font color="red">2836.         pass</font>
<font color="black">2837. </font>
<font color="red">2838.     if pkey[0] == _ffi.NULL:</font>
<font color="red">2839.         pykey = None</font>
<font color="black">2840.     else:</font>
<font color="red">2841.         pykey = PKey.__new__(PKey)</font>
<font color="red">2842.         pykey._pkey = _ffi.gc(pkey[0], _lib.EVP_PKEY_free)</font>
<font color="black">2843. </font>
<font color="red">2844.     if cert[0] == _ffi.NULL:</font>
<font color="red">2845.         pycert = None</font>
<font color="red">2846.         friendlyname = None</font>
<font color="black">2847.     else:</font>
<font color="red">2848.         pycert = X509.__new__(X509)</font>
<font color="red">2849.         pycert._x509 = _ffi.gc(cert[0], _lib.X509_free)</font>
<font color="black">2850. </font>
<font color="red">2851.         friendlyname_length = _ffi.new(&quot;int*&quot;)</font>
<font color="red">2852.         friendlyname_buffer = _lib.X509_alias_get0(</font>
<font color="red">2853.             cert[0], friendlyname_length</font>
<font color="black">2854.         )</font>
<font color="red">2855.         friendlyname = _ffi.buffer(</font>
<font color="red">2856.             friendlyname_buffer, friendlyname_length[0]</font>
<font color="black">2857.         )[:]</font>
<font color="red">2858.         if friendlyname_buffer == _ffi.NULL:</font>
<font color="red">2859.             friendlyname = None</font>
<font color="black">2860. </font>
<font color="red">2861.     pycacerts = []</font>
<font color="red">2862.     for i in range(_lib.sk_X509_num(cacerts)):</font>
<font color="red">2863.         pycacert = X509.__new__(X509)</font>
<font color="red">2864.         pycacert._x509 = _lib.sk_X509_value(cacerts, i)</font>
<font color="red">2865.         pycacerts.append(pycacert)</font>
<font color="red">2866.     if not pycacerts:</font>
<font color="red">2867.         pycacerts = None</font>
<font color="black">2868. </font>
<font color="red">2869.     pkcs12 = PKCS12.__new__(PKCS12)</font>
<font color="red">2870.     pkcs12._pkey = pykey</font>
<font color="red">2871.     pkcs12._cert = pycert</font>
<font color="red">2872.     pkcs12._cacerts = pycacerts</font>
<font color="red">2873.     pkcs12._friendlyname = friendlyname</font>
<font color="red">2874.     return pkcs12</font>
<font color="black">2875. </font>
<font color="black">2876. </font>
<font color="black">2877. # There are no direct unit tests for this initialization.  It is tested</font>
<font color="black">2878. # indirectly since it is necessary for functions like dump_privatekey when</font>
<font color="black">2879. # using encryption.</font>
<font color="black">2880. #</font>
<font color="black">2881. # Thus OpenSSL.test.test_crypto.FunctionTests.test_dump_privatekey_passphrase</font>
<font color="black">2882. # and some other similar tests may fail without this (though they may not if</font>
<font color="black">2883. # the Python runtime has already done some initialization of the underlying</font>
<font color="black">2884. # OpenSSL library (and is linked against the same one that cryptography is</font>
<font color="black">2885. # using)).</font>
<font color="green">2886. _lib.OpenSSL_add_all_algorithms()</font>
<font color="black">2887. </font>
<font color="black">2888. # This is similar but exercised mainly by exception_from_error_queue.  It calls</font>
<font color="black">2889. # both ERR_load_crypto_strings() and ERR_load_SSL_strings().</font>
<font color="green">2890. _lib.SSL_load_error_strings()</font>
<font color="black">2891. </font>
<font color="black">2892. </font>
<font color="black">2893. # Set the default string mask to match OpenSSL upstream (since 2005) and</font>
<font color="black">2894. # RFC5280 recommendations.</font>
<font color="green">2895. _lib.ASN1_STRING_set_default_mask_asc(b'utf8only')</font>
</pre>

