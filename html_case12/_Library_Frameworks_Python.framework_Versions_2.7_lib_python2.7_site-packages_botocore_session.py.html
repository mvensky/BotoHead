source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/session.py</b><br>


file stats: <b>383 lines, 275 executed: 71.8% covered</b>
<pre>
<font color="black">   1. # Copyright (c) 2012-2013 Mitch Garnaat http://garnaat.org/</font>
<font color="black">   2. # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   3. #</font>
<font color="black">   4. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   5. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   6. # the License is located at</font>
<font color="black">   7. #</font>
<font color="black">   8. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   9. #</font>
<font color="black">  10. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  11. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  12. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  13. # language governing permissions and limitations under the License.</font>
<font color="black">  14. &quot;&quot;&quot;</font>
<font color="black">  15. This module contains the main interface to the botocore package, the</font>
<font color="black">  16. Session object.</font>
<font color="green">  17. &quot;&quot;&quot;</font>
<font color="black">  18. </font>
<font color="green">  19. import copy</font>
<font color="green">  20. import logging</font>
<font color="green">  21. import os</font>
<font color="green">  22. import platform</font>
<font color="black">  23. </font>
<font color="green">  24. from botocore import __version__</font>
<font color="green">  25. import botocore.configloader</font>
<font color="green">  26. import botocore.credentials</font>
<font color="green">  27. import botocore.client</font>
<font color="green">  28. from botocore.exceptions import ConfigNotFound, ProfileNotFound</font>
<font color="green">  29. from botocore.exceptions import UnknownServiceError, PartialCredentialsError</font>
<font color="green">  30. from botocore.errorfactory import ClientExceptionsFactory</font>
<font color="green">  31. from botocore import handlers</font>
<font color="green">  32. from botocore.hooks import HierarchicalEmitter, first_non_none_response</font>
<font color="green">  33. from botocore.loaders import create_loader</font>
<font color="green">  34. from botocore.parsers import ResponseParserFactory</font>
<font color="green">  35. from botocore.regions import EndpointResolver</font>
<font color="green">  36. from botocore.model import ServiceModel</font>
<font color="green">  37. from botocore import paginate</font>
<font color="green">  38. from botocore import waiter</font>
<font color="green">  39. from botocore import retryhandler, translate</font>
<font color="black">  40. </font>
<font color="black">  41. </font>
<font color="green">  42. logger = logging.getLogger(__name__)</font>
<font color="black">  43. </font>
<font color="black">  44. </font>
<font color="green">  45. class Session(object):</font>
<font color="black">  46.     &quot;&quot;&quot;</font>
<font color="black">  47.     The Session object collects together useful functionality</font>
<font color="black">  48.     from `botocore` as well as important data such as configuration</font>
<font color="black">  49.     information and credentials into a single, easy-to-use object.</font>
<font color="black">  50. </font>
<font color="black">  51.     :ivar available_profiles: A list of profiles defined in the config</font>
<font color="black">  52.         file associated with this session.</font>
<font color="black">  53.     :ivar profile: The current profile.</font>
<font color="green">  54.     &quot;&quot;&quot;</font>
<font color="black">  55. </font>
<font color="black">  56.     #: A default dictionary that maps the logical names for session variables</font>
<font color="black">  57.     #: to the specific environment variables and configuration file names</font>
<font color="black">  58.     #: that contain the values for these variables.</font>
<font color="black">  59.     #: When creating a new Session object, you can pass in your own dictionary</font>
<font color="black">  60.     #: to remap the logical names or to add new logical names.  You can then</font>
<font color="black">  61.     #: get the current value for these variables by using the</font>
<font color="black">  62.     #: ``get_config_variable`` method of the :class:`botocore.session.Session`</font>
<font color="black">  63.     #: class.</font>
<font color="black">  64.     #: These form the keys of the dictionary.  The values in the dictionary</font>
<font color="black">  65.     #: are tuples of (&lt;config_name&gt;, &lt;environment variable&gt;, &lt;default value&gt;,</font>
<font color="black">  66.     #: &lt;conversion func&gt;).</font>
<font color="black">  67.     #: The conversion func is a function that takes the configuration value</font>
<font color="black">  68.     #: as an argument and returns the converted value.  If this value is</font>
<font color="black">  69.     #: None, then the configuration value is returned unmodified.  This</font>
<font color="black">  70.     #: conversion function can be used to type convert config values to</font>
<font color="black">  71.     #: values other than the default values of strings.</font>
<font color="black">  72.     #: The ``profile`` and ``config_file`` variables should always have a</font>
<font color="black">  73.     #: None value for the first entry in the tuple because it doesn't make</font>
<font color="black">  74.     #: sense to look inside the config file for the location of the config</font>
<font color="black">  75.     #: file or for the default profile to use.</font>
<font color="black">  76.     #: The ``config_name`` is the name to look for in the configuration file,</font>
<font color="black">  77.     #: the ``env var`` is the OS environment variable (``os.environ``) to</font>
<font color="black">  78.     #: use, and ``default_value`` is the value to use if no value is otherwise</font>
<font color="black">  79.     #: found.</font>
<font color="green">  80.     SESSION_VARIABLES = {</font>
<font color="black">  81.         # logical:  config_file, env_var,        default_value, conversion_func</font>
<font color="green">  82.         'profile': (None, ['AWS_DEFAULT_PROFILE', 'AWS_PROFILE'], None, None),</font>
<font color="green">  83.         'region': ('region', 'AWS_DEFAULT_REGION', None, None),</font>
<font color="green">  84.         'data_path': ('data_path', 'AWS_DATA_PATH', None, None),</font>
<font color="green">  85.         'config_file': (None, 'AWS_CONFIG_FILE', '~/.aws/config', None),</font>
<font color="green">  86.         'ca_bundle': ('ca_bundle', 'AWS_CA_BUNDLE', None, None),</font>
<font color="green">  87.         'api_versions': ('api_versions', None, {}, None),</font>
<font color="black">  88. </font>
<font color="black">  89.         # This is the shared credentials file amongst sdks.</font>
<font color="black">  90.         'credentials_file': (None, 'AWS_SHARED_CREDENTIALS_FILE',</font>
<font color="green">  91.                              '~/.aws/credentials', None),</font>
<font color="black">  92. </font>
<font color="black">  93.         # These variables only exist in the config file.</font>
<font color="black">  94. </font>
<font color="black">  95.         # This is the number of seconds until we time out a request to</font>
<font color="black">  96.         # the instance metadata service.</font>
<font color="black">  97.         'metadata_service_timeout': (</font>
<font color="green">  98.             'metadata_service_timeout',</font>
<font color="green">  99.             'AWS_METADATA_SERVICE_TIMEOUT', 1, int),</font>
<font color="black"> 100.         # This is the number of request attempts we make until we give</font>
<font color="black"> 101.         # up trying to retrieve data from the instance metadata service.</font>
<font color="black"> 102.         'metadata_service_num_attempts': (</font>
<font color="green"> 103.             'metadata_service_num_attempts',</font>
<font color="green"> 104.             'AWS_METADATA_SERVICE_NUM_ATTEMPTS', 1, int),</font>
<font color="green"> 105.         'parameter_validation': ('parameter_validation', None, True, None),</font>
<font color="black"> 106.     }</font>
<font color="black"> 107. </font>
<font color="black"> 108.     #: The default format string to use when configuring the botocore logger.</font>
<font color="green"> 109.     LOG_FORMAT = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'</font>
<font color="black"> 110. </font>
<font color="green"> 111.     def __init__(self, session_vars=None, event_hooks=None,</font>
<font color="green"> 112.                  include_builtin_handlers=True, profile=None):</font>
<font color="black"> 113.         &quot;&quot;&quot;</font>
<font color="black"> 114.         Create a new Session object.</font>
<font color="black"> 115. </font>
<font color="black"> 116.         :type session_vars: dict</font>
<font color="black"> 117.         :param session_vars: A dictionary that is used to override some or all</font>
<font color="black"> 118.             of the environment variables associated with this session.  The</font>
<font color="black"> 119.             key/value pairs defined in this dictionary will override the</font>
<font color="black"> 120.             corresponding variables defined in ``SESSION_VARIABLES``.</font>
<font color="black"> 121. </font>
<font color="black"> 122.         :type event_hooks: BaseEventHooks</font>
<font color="black"> 123.         :param event_hooks: The event hooks object to use. If one is not</font>
<font color="black"> 124.             provided, an event hooks object will be automatically created</font>
<font color="black"> 125.             for you.</font>
<font color="black"> 126. </font>
<font color="black"> 127.         :type include_builtin_handlers: bool</font>
<font color="black"> 128.         :param include_builtin_handlers: Indicates whether or not to</font>
<font color="black"> 129.             automatically register builtin handlers.</font>
<font color="black"> 130. </font>
<font color="black"> 131.         :type profile: str</font>
<font color="black"> 132.         :param profile: The name of the profile to use for this</font>
<font color="black"> 133.             session.  Note that the profile can only be set when</font>
<font color="black"> 134.             the session is created.</font>
<font color="black"> 135. </font>
<font color="black"> 136.         &quot;&quot;&quot;</font>
<font color="green"> 137.         self.session_var_map = copy.copy(self.SESSION_VARIABLES)</font>
<font color="green"> 138.         if session_vars:</font>
<font color="red"> 139.             self.session_var_map.update(session_vars)</font>
<font color="green"> 140.         if event_hooks is None:</font>
<font color="green"> 141.             self._events = HierarchicalEmitter()</font>
<font color="black"> 142.         else:</font>
<font color="red"> 143.             self._events = event_hooks</font>
<font color="green"> 144.         if include_builtin_handlers:</font>
<font color="green"> 145.             self._register_builtin_handlers(self._events)</font>
<font color="green"> 146.         self.user_agent_name = 'Botocore'</font>
<font color="green"> 147.         self.user_agent_version = __version__</font>
<font color="green"> 148.         self.user_agent_extra = ''</font>
<font color="black"> 149.         # The _profile attribute is just used to cache the value</font>
<font color="black"> 150.         # of the current profile to avoid going through the normal</font>
<font color="black"> 151.         # config lookup process each access time.</font>
<font color="green"> 152.         self._profile = None</font>
<font color="green"> 153.         self._config = None</font>
<font color="green"> 154.         self._credentials = None</font>
<font color="green"> 155.         self._profile_map = None</font>
<font color="black"> 156.         # This is a dict that stores per session specific config variable</font>
<font color="black"> 157.         # overrides via set_config_variable().</font>
<font color="green"> 158.         self._session_instance_vars = {}</font>
<font color="green"> 159.         if profile is not None:</font>
<font color="red"> 160.             self._session_instance_vars['profile'] = profile</font>
<font color="green"> 161.         self._client_config = None</font>
<font color="green"> 162.         self._components = ComponentLocator()</font>
<font color="green"> 163.         self._register_components()</font>
<font color="black"> 164. </font>
<font color="green"> 165.     def _register_components(self):</font>
<font color="green"> 166.         self._register_credential_provider()</font>
<font color="green"> 167.         self._register_data_loader()</font>
<font color="green"> 168.         self._register_endpoint_resolver()</font>
<font color="green"> 169.         self._register_event_emitter()</font>
<font color="green"> 170.         self._register_response_parser_factory()</font>
<font color="green"> 171.         self._register_exceptions_factory()</font>
<font color="black"> 172. </font>
<font color="green"> 173.     def _register_event_emitter(self):</font>
<font color="green"> 174.         self._components.register_component('event_emitter', self._events)</font>
<font color="black"> 175. </font>
<font color="green"> 176.     def _register_credential_provider(self):</font>
<font color="green"> 177.         self._components.lazy_register_component(</font>
<font color="green"> 178.             'credential_provider',</font>
<font color="green"> 179.             lambda:  botocore.credentials.create_credential_resolver(self))</font>
<font color="black"> 180. </font>
<font color="green"> 181.     def _register_data_loader(self):</font>
<font color="green"> 182.         self._components.lazy_register_component(</font>
<font color="green"> 183.             'data_loader',</font>
<font color="green"> 184.             lambda:  create_loader(self.get_config_variable('data_path')))</font>
<font color="black"> 185. </font>
<font color="green"> 186.     def _register_endpoint_resolver(self):</font>
<font color="green"> 187.         def create_default_resolver():</font>
<font color="green"> 188.             loader = self.get_component('data_loader')</font>
<font color="green"> 189.             endpoints = loader.load_data('endpoints')</font>
<font color="green"> 190.             return EndpointResolver(endpoints)</font>
<font color="green"> 191.         self._components.lazy_register_component(</font>
<font color="green"> 192.             'endpoint_resolver', create_default_resolver)</font>
<font color="black"> 193. </font>
<font color="green"> 194.     def _register_response_parser_factory(self):</font>
<font color="green"> 195.         self._components.register_component('response_parser_factory',</font>
<font color="green"> 196.                                             ResponseParserFactory())</font>
<font color="black"> 197. </font>
<font color="green"> 198.     def _register_exceptions_factory(self):</font>
<font color="green"> 199.         self._components.register_component(</font>
<font color="green"> 200.             'exceptions_factory', ClientExceptionsFactory())</font>
<font color="black"> 201. </font>
<font color="green"> 202.     def _register_builtin_handlers(self, events):</font>
<font color="green"> 203.         for spec in handlers.BUILTIN_HANDLERS:</font>
<font color="green"> 204.             if len(spec) == 2:</font>
<font color="green"> 205.                 event_name, handler = spec</font>
<font color="green"> 206.                 self.register(event_name, handler)</font>
<font color="black"> 207.             else:</font>
<font color="green"> 208.                 event_name, handler, register_type = spec</font>
<font color="green"> 209.                 if register_type is handlers.REGISTER_FIRST:</font>
<font color="green"> 210.                     self._events.register_first(event_name, handler)</font>
<font color="green"> 211.                 elif register_type is handlers.REGISTER_LAST:</font>
<font color="green"> 212.                     self._events.register_last(event_name, handler)</font>
<font color="black"> 213. </font>
<font color="green"> 214.     @property</font>
<font color="black"> 215.     def available_profiles(self):</font>
<font color="red"> 216.         return list(self._build_profile_map().keys())</font>
<font color="black"> 217. </font>
<font color="green"> 218.     def _build_profile_map(self):</font>
<font color="black"> 219.         # This will build the profile map if it has not been created,</font>
<font color="black"> 220.         # otherwise it will return the cached value.  The profile map</font>
<font color="black"> 221.         # is a list of profile names, to the config values for the profile.</font>
<font color="green"> 222.         if self._profile_map is None:</font>
<font color="green"> 223.             self._profile_map = self.full_config['profiles']</font>
<font color="green"> 224.         return self._profile_map</font>
<font color="black"> 225. </font>
<font color="green"> 226.     @property</font>
<font color="black"> 227.     def profile(self):</font>
<font color="red"> 228.         if self._profile is None:</font>
<font color="red"> 229.             profile = self.get_config_variable('profile')</font>
<font color="red"> 230.             self._profile = profile</font>
<font color="red"> 231.         return self._profile</font>
<font color="black"> 232. </font>
<font color="black"> 233.     def get_config_variable(self, logical_name,</font>
<font color="green"> 234.                             methods=('instance', 'env', 'config')):</font>
<font color="black"> 235.         &quot;&quot;&quot;</font>
<font color="black"> 236.         Retrieve the value associated with the specified logical_name</font>
<font color="black"> 237.         from the environment or the config file.  Values found in the</font>
<font color="black"> 238.         environment variable take precedence of values found in the</font>
<font color="black"> 239.         config file.  If no value can be found, a None will be returned.</font>
<font color="black"> 240. </font>
<font color="black"> 241.         :type logical_name: str</font>
<font color="black"> 242.         :param logical_name: The logical name of the session variable</font>
<font color="black"> 243.             you want to retrieve.  This name will be mapped to the</font>
<font color="black"> 244.             appropriate environment variable name for this session as</font>
<font color="black"> 245.             well as the appropriate config file entry.</font>
<font color="black"> 246. </font>
<font color="black"> 247.         :type method: tuple</font>
<font color="black"> 248.         :param method: Defines which methods will be used to find</font>
<font color="black"> 249.             the variable value.  By default, all available methods</font>
<font color="black"> 250.             are tried but you can limit which methods are used</font>
<font color="black"> 251.             by supplying a different value to this parameter.</font>
<font color="black"> 252.             Valid choices are: instance|env|config</font>
<font color="black"> 253. </font>
<font color="black"> 254.         :returns: value of variable or None if not defined.</font>
<font color="black"> 255. </font>
<font color="black"> 256.         &quot;&quot;&quot;</font>
<font color="black"> 257.         # Handle all the short circuit special cases first.</font>
<font color="green"> 258.         if logical_name not in self.session_var_map:</font>
<font color="red"> 259.             return</font>
<font color="black"> 260.         # Do the actual lookups.  We need to handle</font>
<font color="black"> 261.         # 'instance', 'env', and 'config' locations, in that order.</font>
<font color="green"> 262.         value = None</font>
<font color="green"> 263.         var_config = self.session_var_map[logical_name]</font>
<font color="green"> 264.         if self._found_in_instance_vars(methods, logical_name):</font>
<font color="red"> 265.             value = self._session_instance_vars[logical_name]</font>
<font color="red"> 266.             logger.debug(</font>
<font color="red"> 267.                 &quot;Loading variable %s from instance vars with value %r.&quot;,</font>
<font color="red"> 268.                 logical_name,</font>
<font color="red"> 269.                 value,</font>
<font color="black"> 270.             )</font>
<font color="red"> 271.             return value</font>
<font color="green"> 272.         elif self._found_in_env(methods, var_config):</font>
<font color="green"> 273.             value = self._retrieve_from_env(var_config[1], os.environ)</font>
<font color="green"> 274.             logger.debug(</font>
<font color="green"> 275.                 &quot;Loading variable %s from environment with value %r.&quot;,</font>
<font color="green"> 276.                 logical_name,</font>
<font color="green"> 277.                 value,</font>
<font color="black"> 278.             )</font>
<font color="green"> 279.         elif self._found_in_config_file(methods, var_config):</font>
<font color="green"> 280.             value = self.get_scoped_config()[var_config[0]]</font>
<font color="green"> 281.             logger.debug(</font>
<font color="green"> 282.                 &quot;Loading variable %s from config file with value %r.&quot;,</font>
<font color="green"> 283.                 logical_name,</font>
<font color="green"> 284.                 value,</font>
<font color="black"> 285.             )</font>
<font color="green"> 286.         if value is None:</font>
<font color="green"> 287.             logger.debug(&quot;Loading variable %s from defaults.&quot;, logical_name)</font>
<font color="green"> 288.             value = var_config[2]</font>
<font color="green"> 289.         if var_config[3] is not None:</font>
<font color="green"> 290.             value = var_config[3](value)</font>
<font color="green"> 291.         return value</font>
<font color="black"> 292. </font>
<font color="green"> 293.     def _found_in_instance_vars(self, methods, logical_name):</font>
<font color="green"> 294.         if 'instance' in methods:</font>
<font color="green"> 295.             return logical_name in self._session_instance_vars</font>
<font color="red"> 296.         return False</font>
<font color="black"> 297. </font>
<font color="green"> 298.     def _found_in_env(self, methods, var_config):</font>
<font color="black"> 299.         return (</font>
<font color="green"> 300.             'env' in methods and</font>
<font color="green"> 301.             var_config[1] is not None and</font>
<font color="green"> 302.             self._retrieve_from_env(var_config[1], os.environ) is not None)</font>
<font color="black"> 303. </font>
<font color="green"> 304.     def _found_in_config_file(self, methods, var_config):</font>
<font color="green"> 305.         if 'config' in methods and var_config[0] is not None:</font>
<font color="green"> 306.             return var_config[0] in self.get_scoped_config()</font>
<font color="green"> 307.         return False</font>
<font color="black"> 308. </font>
<font color="green"> 309.     def _retrieve_from_env(self, names, environ):</font>
<font color="black"> 310.         # We need to handle the case where names is either</font>
<font color="black"> 311.         # a single value or a list of variables.</font>
<font color="green"> 312.         if not isinstance(names, list):</font>
<font color="green"> 313.             names = [names]</font>
<font color="green"> 314.         for name in names:</font>
<font color="green"> 315.             if name in environ:</font>
<font color="green"> 316.                 return environ[name]</font>
<font color="green"> 317.         return None</font>
<font color="black"> 318. </font>
<font color="green"> 319.     def set_config_variable(self, logical_name, value):</font>
<font color="black"> 320.         &quot;&quot;&quot;Set a configuration variable to a specific value.</font>
<font color="black"> 321. </font>
<font color="black"> 322.         By using this method, you can override the normal lookup</font>
<font color="black"> 323.         process used in ``get_config_variable`` by explicitly setting</font>
<font color="black"> 324.         a value.  Subsequent calls to ``get_config_variable`` will</font>
<font color="black"> 325.         use the ``value``.  This gives you per-session specific</font>
<font color="black"> 326.         configuration values.</font>
<font color="black"> 327. </font>
<font color="black"> 328.         ::</font>
<font color="black"> 329.             &gt;&gt;&gt; # Assume logical name 'foo' maps to env var 'FOO'</font>
<font color="black"> 330.             &gt;&gt;&gt; os.environ['FOO'] = 'myvalue'</font>
<font color="black"> 331.             &gt;&gt;&gt; s.get_config_variable('foo')</font>
<font color="black"> 332.             'myvalue'</font>
<font color="black"> 333.             &gt;&gt;&gt; s.set_config_variable('foo', 'othervalue')</font>
<font color="black"> 334.             &gt;&gt;&gt; s.get_config_variable('foo')</font>
<font color="black"> 335.             'othervalue'</font>
<font color="black"> 336. </font>
<font color="black"> 337.         :type logical_name: str</font>
<font color="black"> 338.         :param logical_name: The logical name of the session variable</font>
<font color="black"> 339.             you want to set.  These are the keys in ``SESSION_VARIABLES``.</font>
<font color="black"> 340.         :param value: The value to associate with the config variable.</font>
<font color="black"> 341. </font>
<font color="black"> 342.         &quot;&quot;&quot;</font>
<font color="red"> 343.         logger.debug(</font>
<font color="red"> 344.             &quot;Setting config variable for %s to %r&quot;,</font>
<font color="red"> 345.             logical_name,</font>
<font color="red"> 346.             value,</font>
<font color="black"> 347.         )</font>
<font color="red"> 348.         self._session_instance_vars[logical_name] = value</font>
<font color="black"> 349. </font>
<font color="green"> 350.     def get_scoped_config(self):</font>
<font color="black"> 351.         &quot;&quot;&quot;</font>
<font color="black"> 352.         Returns the config values from the config file scoped to the current</font>
<font color="black"> 353.         profile.</font>
<font color="black"> 354. </font>
<font color="black"> 355.         The configuration data is loaded **only** from the config file.</font>
<font color="black"> 356.         It does not resolve variables based on different locations</font>
<font color="black"> 357.         (e.g. first from the session instance, then from environment</font>
<font color="black"> 358.         variables, then from the config file).  If you want this lookup</font>
<font color="black"> 359.         behavior, use the ``get_config_variable`` method instead.</font>
<font color="black"> 360. </font>
<font color="black"> 361.         Note that this configuration is specific to a single profile (the</font>
<font color="black"> 362.         ``profile`` session variable).</font>
<font color="black"> 363. </font>
<font color="black"> 364.         If the ``profile`` session variable is set and the profile does</font>
<font color="black"> 365.         not exist in the config file, a ``ProfileNotFound`` exception</font>
<font color="black"> 366.         will be raised.</font>
<font color="black"> 367. </font>
<font color="black"> 368.         :raises: ConfigNotFound, ConfigParseError, ProfileNotFound</font>
<font color="black"> 369.         :rtype: dict</font>
<font color="black"> 370. </font>
<font color="black"> 371.         &quot;&quot;&quot;</font>
<font color="green"> 372.         profile_name = self.get_config_variable('profile')</font>
<font color="green"> 373.         profile_map = self._build_profile_map()</font>
<font color="black"> 374.         # If a profile is not explicitly set return the default</font>
<font color="black"> 375.         # profile config or an empty config dict if we don't have</font>
<font color="black"> 376.         # a default profile.</font>
<font color="green"> 377.         if profile_name is None:</font>
<font color="red"> 378.             return profile_map.get('default', {})</font>
<font color="green"> 379.         elif profile_name not in profile_map:</font>
<font color="black"> 380.             # Otherwise if they specified a profile, it has to</font>
<font color="black"> 381.             # exist (even if it's the default profile) otherwise</font>
<font color="black"> 382.             # we complain.</font>
<font color="red"> 383.             raise ProfileNotFound(profile=profile_name)</font>
<font color="black"> 384.         else:</font>
<font color="green"> 385.             return profile_map[profile_name]</font>
<font color="black"> 386. </font>
<font color="green"> 387.     @property</font>
<font color="black"> 388.     def full_config(self):</font>
<font color="black"> 389.         &quot;&quot;&quot;Return the parsed config file.</font>
<font color="black"> 390. </font>
<font color="black"> 391.         The ``get_config`` method returns the config associated with the</font>
<font color="black"> 392.         specified profile.  This property returns the contents of the</font>
<font color="black"> 393.         **entire** config file.</font>
<font color="black"> 394. </font>
<font color="black"> 395.         :rtype: dict</font>
<font color="black"> 396.         &quot;&quot;&quot;</font>
<font color="green"> 397.         if self._config is None:</font>
<font color="green"> 398.             try:</font>
<font color="green"> 399.                 config_file = self.get_config_variable('config_file')</font>
<font color="green"> 400.                 self._config = botocore.configloader.load_config(config_file)</font>
<font color="red"> 401.             except ConfigNotFound:</font>
<font color="red"> 402.                 self._config = {'profiles': {}}</font>
<font color="green"> 403.             try:</font>
<font color="black"> 404.                 # Now we need to inject the profiles from the</font>
<font color="black"> 405.                 # credentials file.  We don't actually need the values</font>
<font color="black"> 406.                 # in the creds file, only the profile names so that we</font>
<font color="black"> 407.                 # can validate the user is not referring to a nonexistent</font>
<font color="black"> 408.                 # profile.</font>
<font color="green"> 409.                 cred_file = self.get_config_variable('credentials_file')</font>
<font color="green"> 410.                 cred_profiles = botocore.configloader.raw_config_parse(</font>
<font color="green"> 411.                     cred_file)</font>
<font color="green"> 412.                 for profile in cred_profiles:</font>
<font color="green"> 413.                     cred_vars = cred_profiles[profile]</font>
<font color="green"> 414.                     if profile not in self._config['profiles']:</font>
<font color="red"> 415.                         self._config['profiles'][profile] = cred_vars</font>
<font color="black"> 416.                     else:</font>
<font color="green"> 417.                         self._config['profiles'][profile].update(cred_vars)</font>
<font color="red"> 418.             except ConfigNotFound:</font>
<font color="red"> 419.                 pass</font>
<font color="green"> 420.         return self._config</font>
<font color="black"> 421. </font>
<font color="green"> 422.     def get_default_client_config(self):</font>
<font color="black"> 423.         &quot;&quot;&quot;Retrieves the default config for creating clients</font>
<font color="black"> 424. </font>
<font color="black"> 425.         :rtype: botocore.client.Config</font>
<font color="black"> 426.         :returns: The default client config object when creating clients. If</font>
<font color="black"> 427.             the value is ``None`` then there is no default config object</font>
<font color="black"> 428.             attached to the session.</font>
<font color="black"> 429.         &quot;&quot;&quot;</font>
<font color="green"> 430.         return self._client_config</font>
<font color="black"> 431. </font>
<font color="green"> 432.     def set_default_client_config(self, client_config):</font>
<font color="black"> 433.         &quot;&quot;&quot;Sets the default config for creating clients</font>
<font color="black"> 434. </font>
<font color="black"> 435.         :type client_config: botocore.client.Config</font>
<font color="black"> 436.         :param client_config: The default client config object when creating</font>
<font color="black"> 437.             clients. If the value is ``None`` then there is no default config</font>
<font color="black"> 438.             object attached to the session.</font>
<font color="black"> 439.         &quot;&quot;&quot;</font>
<font color="red"> 440.         self._client_config = client_config</font>
<font color="black"> 441. </font>
<font color="green"> 442.     def set_credentials(self, access_key, secret_key, token=None):</font>
<font color="black"> 443.         &quot;&quot;&quot;</font>
<font color="black"> 444.         Manually create credentials for this session.  If you would</font>
<font color="black"> 445.         prefer to use botocore without a config file, environment variables,</font>
<font color="black"> 446.         or IAM roles, you can pass explicit credentials into this</font>
<font color="black"> 447.         method to establish credentials for this session.</font>
<font color="black"> 448. </font>
<font color="black"> 449.         :type access_key: str</font>
<font color="black"> 450.         :param access_key: The access key part of the credentials.</font>
<font color="black"> 451. </font>
<font color="black"> 452.         :type secret_key: str</font>
<font color="black"> 453.         :param secret_key: The secret key part of the credentials.</font>
<font color="black"> 454. </font>
<font color="black"> 455.         :type token: str</font>
<font color="black"> 456.         :param token: An option session token used by STS session</font>
<font color="black"> 457.             credentials.</font>
<font color="black"> 458.         &quot;&quot;&quot;</font>
<font color="red"> 459.         self._credentials = botocore.credentials.Credentials(access_key,</font>
<font color="red"> 460.                                                              secret_key,</font>
<font color="red"> 461.                                                              token)</font>
<font color="black"> 462. </font>
<font color="green"> 463.     def get_credentials(self):</font>
<font color="black"> 464.         &quot;&quot;&quot;</font>
<font color="black"> 465.         Return the :class:`botocore.credential.Credential` object</font>
<font color="black"> 466.         associated with this session.  If the credentials have not</font>
<font color="black"> 467.         yet been loaded, this will attempt to load them.  If they</font>
<font color="black"> 468.         have already been loaded, this will return the cached</font>
<font color="black"> 469.         credentials.</font>
<font color="black"> 470. </font>
<font color="black"> 471.         &quot;&quot;&quot;</font>
<font color="green"> 472.         if self._credentials is None:</font>
<font color="green"> 473.             self._credentials = self._components.get_component(</font>
<font color="green"> 474.                 'credential_provider').load_credentials()</font>
<font color="green"> 475.         return self._credentials</font>
<font color="black"> 476. </font>
<font color="green"> 477.     def user_agent(self):</font>
<font color="black"> 478.         &quot;&quot;&quot;</font>
<font color="black"> 479.         Return a string suitable for use as a User-Agent header.</font>
<font color="black"> 480.         The string will be of the form:</font>
<font color="black"> 481. </font>
<font color="black"> 482.         &lt;agent_name&gt;/&lt;agent_version&gt; Python/&lt;py_ver&gt; &lt;plat_name&gt;/&lt;plat_ver&gt; &lt;exec_env&gt;</font>
<font color="black"> 483. </font>
<font color="black"> 484.         Where:</font>
<font color="black"> 485. </font>
<font color="black"> 486.          - agent_name is the value of the `user_agent_name` attribute</font>
<font color="black"> 487.            of the session object (`Boto` by default).</font>
<font color="black"> 488.          - agent_version is the value of the `user_agent_version`</font>
<font color="black"> 489.            attribute of the session object (the botocore version by default).</font>
<font color="black"> 490.            by default.</font>
<font color="black"> 491.          - py_ver is the version of the Python interpreter beng used.</font>
<font color="black"> 492.          - plat_name is the name of the platform (e.g. Darwin)</font>
<font color="black"> 493.          - plat_ver is the version of the platform</font>
<font color="black"> 494.          - exec_env is exec-env/$AWS_EXECUTION_ENV</font>
<font color="black"> 495. </font>
<font color="black"> 496.         If ``user_agent_extra`` is not empty, then this value will be</font>
<font color="black"> 497.         appended to the end of the user agent string.</font>
<font color="black"> 498. </font>
<font color="black"> 499.         &quot;&quot;&quot;</font>
<font color="green"> 500.         base = '%s/%s Python/%s %s/%s' % (self.user_agent_name,</font>
<font color="green"> 501.                                           self.user_agent_version,</font>
<font color="green"> 502.                                           platform.python_version(),</font>
<font color="green"> 503.                                           platform.system(),</font>
<font color="green"> 504.                                           platform.release())</font>
<font color="green"> 505.         if os.environ.get('AWS_EXECUTION_ENV') is not None:</font>
<font color="red"> 506.             base += ' exec-env/%s' % os.environ.get('AWS_EXECUTION_ENV')</font>
<font color="green"> 507.         if self.user_agent_extra:</font>
<font color="green"> 508.             base += ' %s' % self.user_agent_extra</font>
<font color="black"> 509. </font>
<font color="green"> 510.         return base</font>
<font color="black"> 511. </font>
<font color="green"> 512.     def get_data(self, data_path):</font>
<font color="black"> 513.         &quot;&quot;&quot;</font>
<font color="black"> 514.         Retrieve the data associated with `data_path`.</font>
<font color="black"> 515. </font>
<font color="black"> 516.         :type data_path: str</font>
<font color="black"> 517.         :param data_path: The path to the data you wish to retrieve.</font>
<font color="black"> 518.         &quot;&quot;&quot;</font>
<font color="red"> 519.         return self.get_component('data_loader').load_data(data_path)</font>
<font color="black"> 520. </font>
<font color="green"> 521.     def get_service_model(self, service_name, api_version=None):</font>
<font color="black"> 522.         &quot;&quot;&quot;Get the service model object.</font>
<font color="black"> 523. </font>
<font color="black"> 524.         :type service_name: string</font>
<font color="black"> 525.         :param service_name: The service name</font>
<font color="black"> 526. </font>
<font color="black"> 527.         :type api_version: string</font>
<font color="black"> 528.         :param api_version: The API version of the service.  If none is</font>
<font color="black"> 529.             provided, then the latest API version will be used.</font>
<font color="black"> 530. </font>
<font color="black"> 531.         :rtype: L{botocore.model.ServiceModel}</font>
<font color="black"> 532.         :return: The botocore service model for the service.</font>
<font color="black"> 533. </font>
<font color="black"> 534.         &quot;&quot;&quot;</font>
<font color="red"> 535.         service_description = self.get_service_data(service_name, api_version)</font>
<font color="red"> 536.         return ServiceModel(service_description, service_name=service_name)</font>
<font color="black"> 537. </font>
<font color="green"> 538.     def get_waiter_model(self, service_name, api_version=None):</font>
<font color="red"> 539.         loader = self.get_component('data_loader')</font>
<font color="red"> 540.         waiter_config = loader.load_service_model(</font>
<font color="red"> 541.             service_name, 'waiters-2', api_version)</font>
<font color="red"> 542.         return waiter.WaiterModel(waiter_config)</font>
<font color="black"> 543. </font>
<font color="green"> 544.     def get_paginator_model(self, service_name, api_version=None):</font>
<font color="red"> 545.         loader = self.get_component('data_loader')</font>
<font color="red"> 546.         paginator_config = loader.load_service_model(</font>
<font color="red"> 547.             service_name, 'paginators-1', api_version)</font>
<font color="red"> 548.         return paginate.PaginatorModel(paginator_config)</font>
<font color="black"> 549. </font>
<font color="green"> 550.     def get_service_data(self, service_name, api_version=None):</font>
<font color="black"> 551.         &quot;&quot;&quot;</font>
<font color="black"> 552.         Retrieve the fully merged data associated with a service.</font>
<font color="black"> 553.         &quot;&quot;&quot;</font>
<font color="red"> 554.         data_path = service_name</font>
<font color="red"> 555.         service_data = self.get_component('data_loader').load_service_model(</font>
<font color="red"> 556.             data_path,</font>
<font color="red"> 557.             type_name='service-2',</font>
<font color="red"> 558.             api_version=api_version</font>
<font color="black"> 559.         )</font>
<font color="red"> 560.         self._events.emit('service-data-loaded.%s' % service_name,</font>
<font color="red"> 561.                           service_data=service_data,</font>
<font color="red"> 562.                           service_name=service_name, session=self)</font>
<font color="red"> 563.         return service_data</font>
<font color="black"> 564. </font>
<font color="green"> 565.     def get_available_services(self):</font>
<font color="black"> 566.         &quot;&quot;&quot;</font>
<font color="black"> 567.         Return a list of names of available services.</font>
<font color="black"> 568.         &quot;&quot;&quot;</font>
<font color="red"> 569.         return self.get_component('data_loader')\</font>
<font color="red"> 570.             .list_available_services(type_name='service-2')</font>
<font color="black"> 571. </font>
<font color="green"> 572.     def set_debug_logger(self, logger_name='botocore'):</font>
<font color="black"> 573.         &quot;&quot;&quot;</font>
<font color="black"> 574.         Convenience function to quickly configure full debug output</font>
<font color="black"> 575.         to go to the console.</font>
<font color="black"> 576.         &quot;&quot;&quot;</font>
<font color="red"> 577.         self.set_stream_logger(logger_name, logging.DEBUG)</font>
<font color="black"> 578. </font>
<font color="green"> 579.     def set_stream_logger(self, logger_name, log_level, stream=None,</font>
<font color="green"> 580.                           format_string=None):</font>
<font color="black"> 581.         &quot;&quot;&quot;</font>
<font color="black"> 582.         Convenience method to configure a stream logger.</font>
<font color="black"> 583. </font>
<font color="black"> 584.         :type logger_name: str</font>
<font color="black"> 585.         :param logger_name: The name of the logger to configure</font>
<font color="black"> 586. </font>
<font color="black"> 587.         :type log_level: str</font>
<font color="black"> 588.         :param log_level: The log level to set for the logger.  This</font>
<font color="black"> 589.             is any param supported by the ``.setLevel()`` method of</font>
<font color="black"> 590.             a ``Log`` object.</font>
<font color="black"> 591. </font>
<font color="black"> 592.         :type stream: file</font>
<font color="black"> 593.         :param stream: A file like object to log to.  If none is provided</font>
<font color="black"> 594.             then sys.stderr will be used.</font>
<font color="black"> 595. </font>
<font color="black"> 596.         :type format_string: str</font>
<font color="black"> 597.         :param format_string: The format string to use for the log</font>
<font color="black"> 598.             formatter.  If none is provided this will default to</font>
<font color="black"> 599.             ``self.LOG_FORMAT``.</font>
<font color="black"> 600. </font>
<font color="black"> 601.         &quot;&quot;&quot;</font>
<font color="red"> 602.         log = logging.getLogger(logger_name)</font>
<font color="red"> 603.         log.setLevel(logging.DEBUG)</font>
<font color="black"> 604. </font>
<font color="red"> 605.         ch = logging.StreamHandler(stream)</font>
<font color="red"> 606.         ch.setLevel(log_level)</font>
<font color="black"> 607. </font>
<font color="black"> 608.         # create formatter</font>
<font color="red"> 609.         if format_string is None:</font>
<font color="red"> 610.             format_string = self.LOG_FORMAT</font>
<font color="red"> 611.         formatter = logging.Formatter(format_string)</font>
<font color="black"> 612. </font>
<font color="black"> 613.         # add formatter to ch</font>
<font color="red"> 614.         ch.setFormatter(formatter)</font>
<font color="black"> 615. </font>
<font color="black"> 616.         # add ch to logger</font>
<font color="red"> 617.         log.addHandler(ch)</font>
<font color="black"> 618. </font>
<font color="green"> 619.     def set_file_logger(self, log_level, path, logger_name='botocore'):</font>
<font color="black"> 620.         &quot;&quot;&quot;</font>
<font color="black"> 621.         Convenience function to quickly configure any level of logging</font>
<font color="black"> 622.         to a file.</font>
<font color="black"> 623. </font>
<font color="black"> 624.         :type log_level: int</font>
<font color="black"> 625.         :param log_level: A log level as specified in the `logging` module</font>
<font color="black"> 626. </font>
<font color="black"> 627.         :type path: string</font>
<font color="black"> 628.         :param path: Path to the log file.  The file will be created</font>
<font color="black"> 629.             if it doesn't already exist.</font>
<font color="black"> 630.         &quot;&quot;&quot;</font>
<font color="red"> 631.         log = logging.getLogger(logger_name)</font>
<font color="red"> 632.         log.setLevel(logging.DEBUG)</font>
<font color="black"> 633. </font>
<font color="black"> 634.         # create console handler and set level to debug</font>
<font color="red"> 635.         ch = logging.FileHandler(path)</font>
<font color="red"> 636.         ch.setLevel(log_level)</font>
<font color="black"> 637. </font>
<font color="black"> 638.         # create formatter</font>
<font color="red"> 639.         formatter = logging.Formatter(self.LOG_FORMAT)</font>
<font color="black"> 640. </font>
<font color="black"> 641.         # add formatter to ch</font>
<font color="red"> 642.         ch.setFormatter(formatter)</font>
<font color="black"> 643. </font>
<font color="black"> 644.         # add ch to logger</font>
<font color="red"> 645.         log.addHandler(ch)</font>
<font color="black"> 646. </font>
<font color="green"> 647.     def register(self, event_name, handler, unique_id=None,</font>
<font color="green"> 648.                  unique_id_uses_count=False):</font>
<font color="black"> 649.         &quot;&quot;&quot;Register a handler with an event.</font>
<font color="black"> 650. </font>
<font color="black"> 651.         :type event_name: str</font>
<font color="black"> 652.         :param event_name: The name of the event.</font>
<font color="black"> 653. </font>
<font color="black"> 654.         :type handler: callable</font>
<font color="black"> 655.         :param handler: The callback to invoke when the event</font>
<font color="black"> 656.             is emitted.  This object must be callable, and must</font>
<font color="black"> 657.             accept ``**kwargs``.  If either of these preconditions are</font>
<font color="black"> 658.             not met, a ``ValueError`` will be raised.</font>
<font color="black"> 659. </font>
<font color="black"> 660.         :type unique_id: str</font>
<font color="black"> 661.         :param unique_id: An optional identifier to associate with the</font>
<font color="black"> 662.             registration.  A unique_id can only be used once for</font>
<font color="black"> 663.             the entire session registration (unless it is unregistered).</font>
<font color="black"> 664.             This can be used to prevent an event handler from being</font>
<font color="black"> 665.             registered twice.</font>
<font color="black"> 666. </font>
<font color="black"> 667.         :param unique_id_uses_count: boolean</font>
<font color="black"> 668.         :param unique_id_uses_count: Specifies if the event should maintain</font>
<font color="black"> 669.             a count when a ``unique_id`` is registered and unregisted. The</font>
<font color="black"> 670.             event can only be completely unregistered once every register call</font>
<font color="black"> 671.             using the unique id has been matched by an ``unregister`` call.</font>
<font color="black"> 672.             If ``unique_id`` is specified, subsequent ``register``</font>
<font color="black"> 673.             calls must use the same value for  ``unique_id_uses_count``</font>
<font color="black"> 674.             as the ``register`` call that first registered the event.</font>
<font color="black"> 675. </font>
<font color="black"> 676.         :raises ValueError: If the call to ``register`` uses ``unique_id``</font>
<font color="black"> 677.             but the value for ``unique_id_uses_count`` differs from the</font>
<font color="black"> 678.             ``unique_id_uses_count`` value declared by the very first</font>
<font color="black"> 679.             ``register`` call for that ``unique_id``.</font>
<font color="black"> 680.         &quot;&quot;&quot;</font>
<font color="green"> 681.         self._events.register(event_name, handler, unique_id,</font>
<font color="green"> 682.                               unique_id_uses_count=unique_id_uses_count)</font>
<font color="black"> 683. </font>
<font color="green"> 684.     def unregister(self, event_name, handler=None, unique_id=None,</font>
<font color="green"> 685.                    unique_id_uses_count=False):</font>
<font color="black"> 686.         &quot;&quot;&quot;Unregister a handler with an event.</font>
<font color="black"> 687. </font>
<font color="black"> 688.         :type event_name: str</font>
<font color="black"> 689.         :param event_name: The name of the event.</font>
<font color="black"> 690. </font>
<font color="black"> 691.         :type handler: callable</font>
<font color="black"> 692.         :param handler: The callback to unregister.</font>
<font color="black"> 693. </font>
<font color="black"> 694.         :type unique_id: str</font>
<font color="black"> 695.         :param unique_id: A unique identifier identifying the callback</font>
<font color="black"> 696.             to unregister.  You can provide either the handler or the</font>
<font color="black"> 697.             unique_id, you do not have to provide both.</font>
<font color="black"> 698. </font>
<font color="black"> 699.         :param unique_id_uses_count: boolean</font>
<font color="black"> 700.         :param unique_id_uses_count: Specifies if the event should maintain</font>
<font color="black"> 701.             a count when a ``unique_id`` is registered and unregisted. The</font>
<font color="black"> 702.             event can only be completely unregistered once every ``register``</font>
<font color="black"> 703.             call using the ``unique_id`` has been matched by an ``unregister``</font>
<font color="black"> 704.             call. If the ``unique_id`` is specified, subsequent</font>
<font color="black"> 705.             ``unregister`` calls must use the same value for</font>
<font color="black"> 706.             ``unique_id_uses_count`` as the ``register`` call that first</font>
<font color="black"> 707.             registered the event.</font>
<font color="black"> 708. </font>
<font color="black"> 709.         :raises ValueError: If the call to ``unregister`` uses ``unique_id``</font>
<font color="black"> 710.             but the value for ``unique_id_uses_count`` differs from the</font>
<font color="black"> 711.             ``unique_id_uses_count`` value declared by the very first</font>
<font color="black"> 712.             ``register`` call for that ``unique_id``.</font>
<font color="black"> 713.         &quot;&quot;&quot;</font>
<font color="red"> 714.         self._events.unregister(event_name, handler=handler,</font>
<font color="red"> 715.                                 unique_id=unique_id,</font>
<font color="red"> 716.                                 unique_id_uses_count=unique_id_uses_count)</font>
<font color="black"> 717. </font>
<font color="green"> 718.     def emit(self, event_name, **kwargs):</font>
<font color="red"> 719.         return self._events.emit(event_name, **kwargs)</font>
<font color="black"> 720. </font>
<font color="green"> 721.     def emit_first_non_none_response(self, event_name, **kwargs):</font>
<font color="red"> 722.         responses = self._events.emit(event_name, **kwargs)</font>
<font color="red"> 723.         return first_non_none_response(responses)</font>
<font color="black"> 724. </font>
<font color="green"> 725.     def get_component(self, name):</font>
<font color="green"> 726.         return self._components.get_component(name)</font>
<font color="black"> 727. </font>
<font color="green"> 728.     def register_component(self, name, component):</font>
<font color="red"> 729.         self._components.register_component(name, component)</font>
<font color="black"> 730. </font>
<font color="green"> 731.     def lazy_register_component(self, name, component):</font>
<font color="red"> 732.         self._components.lazy_register_component(name, component)</font>
<font color="black"> 733. </font>
<font color="green"> 734.     def create_client(self, service_name, region_name=None, api_version=None,</font>
<font color="green"> 735.                       use_ssl=True, verify=None, endpoint_url=None,</font>
<font color="green"> 736.                       aws_access_key_id=None, aws_secret_access_key=None,</font>
<font color="green"> 737.                       aws_session_token=None, config=None):</font>
<font color="black"> 738.         &quot;&quot;&quot;Create a botocore client.</font>
<font color="black"> 739. </font>
<font color="black"> 740.         :type service_name: string</font>
<font color="black"> 741.         :param service_name: The name of the service for which a client will</font>
<font color="black"> 742.             be created.  You can use the ``Sesssion.get_available_services()``</font>
<font color="black"> 743.             method to get a list of all available service names.</font>
<font color="black"> 744. </font>
<font color="black"> 745.         :type region_name: string</font>
<font color="black"> 746.         :param region_name: The name of the region associated with the client.</font>
<font color="black"> 747.             A client is associated with a single region.</font>
<font color="black"> 748. </font>
<font color="black"> 749.         :type api_version: string</font>
<font color="black"> 750.         :param api_version: The API version to use.  By default, botocore will</font>
<font color="black"> 751.             use the latest API version when creating a client.  You only need</font>
<font color="black"> 752.             to specify this parameter if you want to use a previous API version</font>
<font color="black"> 753.             of the client.</font>
<font color="black"> 754. </font>
<font color="black"> 755.         :type use_ssl: boolean</font>
<font color="black"> 756.         :param use_ssl: Whether or not to use SSL.  By default, SSL is used.</font>
<font color="black"> 757.             Note that not all services support non-ssl connections.</font>
<font color="black"> 758. </font>
<font color="black"> 759.         :type verify: boolean/string</font>
<font color="black"> 760.         :param verify: Whether or not to verify SSL certificates.</font>
<font color="black"> 761.             By default SSL certificates are verified.  You can provide the</font>
<font color="black"> 762.             following values:</font>
<font color="black"> 763. </font>
<font color="black"> 764.             * False - do not validate SSL certificates.  SSL will still be</font>
<font color="black"> 765.               used (unless use_ssl is False), but SSL certificates</font>
<font color="black"> 766.               will not be verified.</font>
<font color="black"> 767.             * path/to/cert/bundle.pem - A filename of the CA cert bundle to</font>
<font color="black"> 768.               uses.  You can specify this argument if you want to use a</font>
<font color="black"> 769.               different CA cert bundle than the one used by botocore.</font>
<font color="black"> 770. </font>
<font color="black"> 771.         :type endpoint_url: string</font>
<font color="black"> 772.         :param endpoint_url: The complete URL to use for the constructed</font>
<font color="black"> 773.             client.  Normally, botocore will automatically construct the</font>
<font color="black"> 774.             appropriate URL to use when communicating with a service.  You can</font>
<font color="black"> 775.             specify a complete URL (including the &quot;http/https&quot; scheme) to</font>
<font color="black"> 776.             override this behavior.  If this value is provided, then</font>
<font color="black"> 777.             ``use_ssl`` is ignored.</font>
<font color="black"> 778. </font>
<font color="black"> 779.         :type aws_access_key_id: string</font>
<font color="black"> 780.         :param aws_access_key_id: The access key to use when creating</font>
<font color="black"> 781.             the client.  This is entirely optional, and if not provided,</font>
<font color="black"> 782.             the credentials configured for the session will automatically</font>
<font color="black"> 783.             be used.  You only need to provide this argument if you want</font>
<font color="black"> 784.             to override the credentials used for this specific client.</font>
<font color="black"> 785. </font>
<font color="black"> 786.         :type aws_secret_access_key: string</font>
<font color="black"> 787.         :param aws_secret_access_key: The secret key to use when creating</font>
<font color="black"> 788.             the client.  Same semantics as aws_access_key_id above.</font>
<font color="black"> 789. </font>
<font color="black"> 790.         :type aws_session_token: string</font>
<font color="black"> 791.         :param aws_session_token: The session token to use when creating</font>
<font color="black"> 792.             the client.  Same semantics as aws_access_key_id above.</font>
<font color="black"> 793. </font>
<font color="black"> 794.         :type config: botocore.client.Config</font>
<font color="black"> 795.         :param config: Advanced client configuration options. If a value</font>
<font color="black"> 796.             is specified in the client config, its value will take precedence</font>
<font color="black"> 797.             over environment variables and configuration values, but not over</font>
<font color="black"> 798.             a value passed explicitly to the method. If a default config</font>
<font color="black"> 799.             object is set on the session, the config object used when creating</font>
<font color="black"> 800.             the client will be the result of calling ``merge()`` on the</font>
<font color="black"> 801.             default config with the config provided to this call.</font>
<font color="black"> 802. </font>
<font color="black"> 803.         :rtype: botocore.client.BaseClient</font>
<font color="black"> 804.         :return: A botocore client instance</font>
<font color="black"> 805. </font>
<font color="black"> 806.         &quot;&quot;&quot;</font>
<font color="green"> 807.         default_client_config = self.get_default_client_config()</font>
<font color="black"> 808.         # If a config is provided and a default config is set, then</font>
<font color="black"> 809.         # use the config resulting from merging the two.</font>
<font color="green"> 810.         if config is not None and default_client_config is not None:</font>
<font color="red"> 811.             config = default_client_config.merge(config)</font>
<font color="black"> 812.         # If a config was not provided then use the default</font>
<font color="black"> 813.         # client config from the session</font>
<font color="green"> 814.         elif default_client_config is not None:</font>
<font color="red"> 815.             config = default_client_config</font>
<font color="black"> 816. </font>
<font color="black"> 817.         # Figure out the user-provided region based on the various</font>
<font color="black"> 818.         # configuration options.</font>
<font color="green"> 819.         if region_name is None:</font>
<font color="green"> 820.             if config and config.region_name is not None:</font>
<font color="red"> 821.                 region_name = config.region_name</font>
<font color="black"> 822.             else:</font>
<font color="green"> 823.                 region_name = self.get_config_variable('region')</font>
<font color="black"> 824. </font>
<font color="black"> 825.         # Figure out the verify value base on the various</font>
<font color="black"> 826.         # configuration options.</font>
<font color="green"> 827.         if verify is None:</font>
<font color="green"> 828.             verify = self.get_config_variable('ca_bundle')</font>
<font color="black"> 829. </font>
<font color="green"> 830.         if api_version is None:</font>
<font color="green"> 831.             api_version = self.get_config_variable('api_versions').get(</font>
<font color="green"> 832.                 service_name, None)</font>
<font color="black"> 833. </font>
<font color="green"> 834.         loader = self.get_component('data_loader')</font>
<font color="green"> 835.         event_emitter = self.get_component('event_emitter')</font>
<font color="green"> 836.         response_parser_factory = self.get_component(</font>
<font color="green"> 837.             'response_parser_factory')</font>
<font color="green"> 838.         if aws_access_key_id is not None and aws_secret_access_key is not None:</font>
<font color="red"> 839.             credentials = botocore.credentials.Credentials(</font>
<font color="red"> 840.                 access_key=aws_access_key_id,</font>
<font color="red"> 841.                 secret_key=aws_secret_access_key,</font>
<font color="red"> 842.                 token=aws_session_token)</font>
<font color="green"> 843.         elif self._missing_cred_vars(aws_access_key_id,</font>
<font color="green"> 844.                                      aws_secret_access_key):</font>
<font color="red"> 845.             raise PartialCredentialsError(</font>
<font color="red"> 846.                 provider='explicit',</font>
<font color="red"> 847.                 cred_var=self._missing_cred_vars(aws_access_key_id,</font>
<font color="red"> 848.                                                  aws_secret_access_key))</font>
<font color="black"> 849.         else:</font>
<font color="green"> 850.             credentials = self.get_credentials()</font>
<font color="green"> 851.         endpoint_resolver = self.get_component('endpoint_resolver')</font>
<font color="green"> 852.         exceptions_factory = self.get_component('exceptions_factory')</font>
<font color="green"> 853.         client_creator = botocore.client.ClientCreator(</font>
<font color="green"> 854.             loader, endpoint_resolver, self.user_agent(), event_emitter,</font>
<font color="green"> 855.             retryhandler, translate, response_parser_factory,</font>
<font color="green"> 856.             exceptions_factory)</font>
<font color="green"> 857.         client = client_creator.create_client(</font>
<font color="green"> 858.             service_name=service_name, region_name=region_name,</font>
<font color="green"> 859.             is_secure=use_ssl, endpoint_url=endpoint_url, verify=verify,</font>
<font color="green"> 860.             credentials=credentials, scoped_config=self.get_scoped_config(),</font>
<font color="green"> 861.             client_config=config, api_version=api_version)</font>
<font color="green"> 862.         return client</font>
<font color="black"> 863. </font>
<font color="green"> 864.     def _missing_cred_vars(self, access_key, secret_key):</font>
<font color="green"> 865.         if access_key is not None and secret_key is None:</font>
<font color="red"> 866.             return 'aws_secret_access_key'</font>
<font color="green"> 867.         if secret_key is not None and access_key is None:</font>
<font color="red"> 868.             return 'aws_access_key_id'</font>
<font color="green"> 869.         return None</font>
<font color="black"> 870. </font>
<font color="green"> 871.     def get_available_partitions(self):</font>
<font color="black"> 872.         &quot;&quot;&quot;Lists the available partitions found on disk</font>
<font color="black"> 873. </font>
<font color="black"> 874.         :rtype: list</font>
<font color="black"> 875.         :return: Returns a list of partition names (e.g., [&quot;aws&quot;, &quot;aws-cn&quot;])</font>
<font color="black"> 876.         &quot;&quot;&quot;</font>
<font color="red"> 877.         resolver = self.get_component('endpoint_resolver')</font>
<font color="red"> 878.         return resolver.get_available_partitions()</font>
<font color="black"> 879. </font>
<font color="green"> 880.     def get_available_regions(self, service_name, partition_name='aws',</font>
<font color="green"> 881.                               allow_non_regional=False):</font>
<font color="black"> 882.         &quot;&quot;&quot;Lists the region and endpoint names of a particular partition.</font>
<font color="black"> 883. </font>
<font color="black"> 884.         :type service_name: string</font>
<font color="black"> 885.         :param service_name: Name of a service to list endpoint for (e.g., s3).</font>
<font color="black"> 886.             This parameter accepts a service name (e.g., &quot;elb&quot;) or endpoint</font>
<font color="black"> 887.             prefix (e.g., &quot;elasticloadbalancing&quot;).</font>
<font color="black"> 888. </font>
<font color="black"> 889.         :type partition_name: string</font>
<font color="black"> 890.         :param partition_name: Name of the partition to limit endpoints to.</font>
<font color="black"> 891.             (e.g., aws for the public AWS endpoints, aws-cn for AWS China</font>
<font color="black"> 892.             endpoints, aws-us-gov for AWS GovCloud (US) Endpoints, etc.</font>
<font color="black"> 893. </font>
<font color="black"> 894.         :type allow_non_regional: bool</font>
<font color="black"> 895.         :param allow_non_regional: Set to True to include endpoints that are</font>
<font color="black"> 896.              not regional endpoints (e.g., s3-external-1,</font>
<font color="black"> 897.              fips-us-gov-west-1, etc).</font>
<font color="black"> 898.         :return: Returns a list of endpoint names (e.g., [&quot;us-east-1&quot;]).</font>
<font color="black"> 899.         &quot;&quot;&quot;</font>
<font color="red"> 900.         resolver = self.get_component('endpoint_resolver')</font>
<font color="red"> 901.         results = []</font>
<font color="red"> 902.         try:</font>
<font color="red"> 903.             service_data = self.get_service_data(service_name)</font>
<font color="red"> 904.             endpoint_prefix = service_data['metadata'].get(</font>
<font color="red"> 905.                 'endpointPrefix', service_name)</font>
<font color="red"> 906.             results = resolver.get_available_endpoints(</font>
<font color="red"> 907.                 endpoint_prefix, partition_name, allow_non_regional)</font>
<font color="red"> 908.         except UnknownServiceError:</font>
<font color="red"> 909.             pass</font>
<font color="red"> 910.         return results</font>
<font color="black"> 911. </font>
<font color="black"> 912. </font>
<font color="green"> 913. class ComponentLocator(object):</font>
<font color="green"> 914.     &quot;&quot;&quot;Service locator for session components.&quot;&quot;&quot;</font>
<font color="green"> 915.     def __init__(self):</font>
<font color="green"> 916.         self._components = {}</font>
<font color="green"> 917.         self._deferred = {}</font>
<font color="black"> 918. </font>
<font color="green"> 919.     def get_component(self, name):</font>
<font color="green"> 920.         if name in self._deferred:</font>
<font color="green"> 921.             factory = self._deferred[name]</font>
<font color="green"> 922.             self._components[name] = factory()</font>
<font color="black"> 923.             # Only delete the component from the deferred dict after</font>
<font color="black"> 924.             # successfully creating the object from the factory as well as</font>
<font color="black"> 925.             # injecting the instantiated value into the _components dict.</font>
<font color="green"> 926.             del self._deferred[name]</font>
<font color="green"> 927.         try:</font>
<font color="green"> 928.             return self._components[name]</font>
<font color="red"> 929.         except KeyError:</font>
<font color="red"> 930.             raise ValueError(&quot;Unknown component: %s&quot; % name)</font>
<font color="black"> 931. </font>
<font color="green"> 932.     def register_component(self, name, component):</font>
<font color="green"> 933.         self._components[name] = component</font>
<font color="green"> 934.         try:</font>
<font color="green"> 935.             del self._deferred[name]</font>
<font color="green"> 936.         except KeyError:</font>
<font color="green"> 937.             pass</font>
<font color="black"> 938. </font>
<font color="green"> 939.     def lazy_register_component(self, name, no_arg_factory):</font>
<font color="green"> 940.         self._deferred[name] = no_arg_factory</font>
<font color="green"> 941.         try:</font>
<font color="green"> 942.             del self._components[name]</font>
<font color="green"> 943.         except KeyError:</font>
<font color="green"> 944.             pass</font>
<font color="black"> 945. </font>
<font color="black"> 946. </font>
<font color="green"> 947. def get_session(env_vars=None):</font>
<font color="black"> 948.     &quot;&quot;&quot;</font>
<font color="black"> 949.     Return a new session object.</font>
<font color="black"> 950.     &quot;&quot;&quot;</font>
<font color="green"> 951.     return Session(env_vars)</font>
</pre>

