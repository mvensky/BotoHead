source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/packages/urllib3/connectionpool.py</b><br>


file stats: <b>334 lines, 190 executed: 56.9% covered</b>
<pre>
<font color="green">   1. import errno</font>
<font color="green">   2. import logging</font>
<font color="green">   3. import sys</font>
<font color="green">   4. import warnings</font>
<font color="black">   5. </font>
<font color="green">   6. from socket import error as SocketError, timeout as SocketTimeout</font>
<font color="green">   7. import socket</font>
<font color="black">   8. </font>
<font color="green">   9. try:  # Python 3</font>
<font color="green">  10.     from queue import LifoQueue, Empty, Full</font>
<font color="green">  11. except ImportError:</font>
<font color="green">  12.     from Queue import LifoQueue, Empty, Full</font>
<font color="green">  13.     import Queue as _  # Platform-specific: Windows</font>
<font color="black">  14. </font>
<font color="black">  15. </font>
<font color="green">  16. from .exceptions import (</font>
<font color="black">  17.     ClosedPoolError,</font>
<font color="black">  18.     ProtocolError,</font>
<font color="black">  19.     EmptyPoolError,</font>
<font color="black">  20.     HostChangedError,</font>
<font color="black">  21.     LocationValueError,</font>
<font color="black">  22.     MaxRetryError,</font>
<font color="black">  23.     ProxyError,</font>
<font color="black">  24.     ReadTimeoutError,</font>
<font color="black">  25.     SSLError,</font>
<font color="black">  26.     TimeoutError,</font>
<font color="black">  27.     InsecureRequestWarning,</font>
<font color="black">  28. )</font>
<font color="green">  29. from .packages.ssl_match_hostname import CertificateError</font>
<font color="green">  30. from .packages import six</font>
<font color="green">  31. from .connection import (</font>
<font color="black">  32.     port_by_scheme,</font>
<font color="black">  33.     DummyConnection,</font>
<font color="black">  34.     HTTPConnection, HTTPSConnection, VerifiedHTTPSConnection,</font>
<font color="black">  35.     HTTPException, BaseSSLError, ConnectionError</font>
<font color="black">  36. )</font>
<font color="green">  37. from .request import RequestMethods</font>
<font color="green">  38. from .response import HTTPResponse</font>
<font color="black">  39. </font>
<font color="green">  40. from .util.connection import is_connection_dropped</font>
<font color="green">  41. from .util.retry import Retry</font>
<font color="green">  42. from .util.timeout import Timeout</font>
<font color="green">  43. from .util.url import get_host</font>
<font color="black">  44. </font>
<font color="black">  45. </font>
<font color="green">  46. xrange = six.moves.xrange</font>
<font color="black">  47. </font>
<font color="green">  48. log = logging.getLogger(__name__)</font>
<font color="black">  49. </font>
<font color="green">  50. _Default = object()</font>
<font color="black">  51. </font>
<font color="black">  52. </font>
<font color="black">  53. ## Pool objects</font>
<font color="green">  54. class ConnectionPool(object):</font>
<font color="black">  55.     &quot;&quot;&quot;</font>
<font color="black">  56.     Base class for all connection pools, such as</font>
<font color="black">  57.     :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.</font>
<font color="green">  58.     &quot;&quot;&quot;</font>
<font color="black">  59. </font>
<font color="green">  60.     scheme = None</font>
<font color="green">  61.     QueueCls = LifoQueue</font>
<font color="black">  62. </font>
<font color="green">  63.     def __init__(self, host, port=None):</font>
<font color="green">  64.         if not host:</font>
<font color="red">  65.             raise LocationValueError(&quot;No host specified.&quot;)</font>
<font color="black">  66. </font>
<font color="black">  67.         # httplib doesn't like it when we include brackets in ipv6 addresses</font>
<font color="green">  68.         self.host = host.strip('[]')</font>
<font color="green">  69.         self.port = port</font>
<font color="black">  70. </font>
<font color="green">  71.     def __str__(self):</font>
<font color="red">  72.         return '%s(host=%r, port=%r)' % (type(self).__name__,</font>
<font color="red">  73.                                          self.host, self.port)</font>
<font color="black">  74. </font>
<font color="green">  75.     def __enter__(self):</font>
<font color="red">  76.         return self</font>
<font color="black">  77. </font>
<font color="green">  78.     def __exit__(self, exc_type, exc_val, exc_tb):</font>
<font color="red">  79.         self.close()</font>
<font color="black">  80.         # Return False to re-raise any potential exceptions</font>
<font color="red">  81.         return False</font>
<font color="black">  82. </font>
<font color="green">  83.     def close():</font>
<font color="black">  84.         &quot;&quot;&quot;</font>
<font color="black">  85.         Close all pooled connections and disable the pool.</font>
<font color="black">  86.         &quot;&quot;&quot;</font>
<font color="red">  87.         pass</font>
<font color="black">  88. </font>
<font color="black">  89. </font>
<font color="black">  90. # This is taken from http://hg.python.org/cpython/file/7aaba721ebc0/Lib/socket.py#l252</font>
<font color="green">  91. _blocking_errnos = set([errno.EAGAIN, errno.EWOULDBLOCK])</font>
<font color="black">  92. </font>
<font color="black">  93. </font>
<font color="green">  94. class HTTPConnectionPool(ConnectionPool, RequestMethods):</font>
<font color="black">  95.     &quot;&quot;&quot;</font>
<font color="black">  96.     Thread-safe connection pool for one host.</font>
<font color="black">  97. </font>
<font color="black">  98.     :param host:</font>
<font color="black">  99.         Host used for this HTTP Connection (e.g. &quot;localhost&quot;), passed into</font>
<font color="black"> 100.         :class:`httplib.HTTPConnection`.</font>
<font color="black"> 101. </font>
<font color="black"> 102.     :param port:</font>
<font color="black"> 103.         Port used for this HTTP Connection (None is equivalent to 80), passed</font>
<font color="black"> 104.         into :class:`httplib.HTTPConnection`.</font>
<font color="black"> 105. </font>
<font color="black"> 106.     :param strict:</font>
<font color="black"> 107.         Causes BadStatusLine to be raised if the status line can't be parsed</font>
<font color="black"> 108.         as a valid HTTP/1.0 or 1.1 status line, passed into</font>
<font color="black"> 109.         :class:`httplib.HTTPConnection`.</font>
<font color="black"> 110. </font>
<font color="black"> 111.         .. note::</font>
<font color="black"> 112.            Only works in Python 2. This parameter is ignored in Python 3.</font>
<font color="black"> 113. </font>
<font color="black"> 114.     :param timeout:</font>
<font color="black"> 115.         Socket timeout in seconds for each individual connection. This can</font>
<font color="black"> 116.         be a float or integer, which sets the timeout for the HTTP request,</font>
<font color="black"> 117.         or an instance of :class:`urllib3.util.Timeout` which gives you more</font>
<font color="black"> 118.         fine-grained control over request timeouts. After the constructor has</font>
<font color="black"> 119.         been parsed, this is always a `urllib3.util.Timeout` object.</font>
<font color="black"> 120. </font>
<font color="black"> 121.     :param maxsize:</font>
<font color="black"> 122.         Number of connections to save that can be reused. More than 1 is useful</font>
<font color="black"> 123.         in multithreaded situations. If ``block`` is set to false, more</font>
<font color="black"> 124.         connections will be created but they will not be saved once they've</font>
<font color="black"> 125.         been used.</font>
<font color="black"> 126. </font>
<font color="black"> 127.     :param block:</font>
<font color="black"> 128.         If set to True, no more than ``maxsize`` connections will be used at</font>
<font color="black"> 129.         a time. When no free connections are available, the call will block</font>
<font color="black"> 130.         until a connection has been released. This is a useful side effect for</font>
<font color="black"> 131.         particular multithreaded situations where one does not want to use more</font>
<font color="black"> 132.         than maxsize connections per host to prevent flooding.</font>
<font color="black"> 133. </font>
<font color="black"> 134.     :param headers:</font>
<font color="black"> 135.         Headers to include with all requests, unless other headers are given</font>
<font color="black"> 136.         explicitly.</font>
<font color="black"> 137. </font>
<font color="black"> 138.     :param retries:</font>
<font color="black"> 139.         Retry configuration to use by default with requests in this pool.</font>
<font color="black"> 140. </font>
<font color="black"> 141.     :param _proxy:</font>
<font color="black"> 142.         Parsed proxy URL, should not be used directly, instead, see</font>
<font color="black"> 143.         :class:`urllib3.connectionpool.ProxyManager`&quot;</font>
<font color="black"> 144. </font>
<font color="black"> 145.     :param _proxy_headers:</font>
<font color="black"> 146.         A dictionary with proxy headers, should not be used directly,</font>
<font color="black"> 147.         instead, see :class:`urllib3.connectionpool.ProxyManager`&quot;</font>
<font color="black"> 148. </font>
<font color="black"> 149.     :param \**conn_kw:</font>
<font color="black"> 150.         Additional parameters are used to create fresh :class:`urllib3.connection.HTTPConnection`,</font>
<font color="black"> 151.         :class:`urllib3.connection.HTTPSConnection` instances.</font>
<font color="green"> 152.     &quot;&quot;&quot;</font>
<font color="black"> 153. </font>
<font color="green"> 154.     scheme = 'http'</font>
<font color="green"> 155.     ConnectionCls = HTTPConnection</font>
<font color="black"> 156. </font>
<font color="green"> 157.     def __init__(self, host, port=None, strict=False,</font>
<font color="green"> 158.                  timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False,</font>
<font color="green"> 159.                  headers=None, retries=None,</font>
<font color="green"> 160.                  _proxy=None, _proxy_headers=None,</font>
<font color="black"> 161.                  **conn_kw):</font>
<font color="green"> 162.         ConnectionPool.__init__(self, host, port)</font>
<font color="green"> 163.         RequestMethods.__init__(self, headers)</font>
<font color="black"> 164. </font>
<font color="green"> 165.         self.strict = strict</font>
<font color="black"> 166. </font>
<font color="green"> 167.         if not isinstance(timeout, Timeout):</font>
<font color="green"> 168.             timeout = Timeout.from_float(timeout)</font>
<font color="black"> 169. </font>
<font color="green"> 170.         if retries is None:</font>
<font color="green"> 171.             retries = Retry.DEFAULT</font>
<font color="black"> 172. </font>
<font color="green"> 173.         self.timeout = timeout</font>
<font color="green"> 174.         self.retries = retries</font>
<font color="black"> 175. </font>
<font color="green"> 176.         self.pool = self.QueueCls(maxsize)</font>
<font color="green"> 177.         self.block = block</font>
<font color="black"> 178. </font>
<font color="green"> 179.         self.proxy = _proxy</font>
<font color="green"> 180.         self.proxy_headers = _proxy_headers or {}</font>
<font color="black"> 181. </font>
<font color="black"> 182.         # Fill the queue up so that doing get() on it will block properly</font>
<font color="green"> 183.         for _ in xrange(maxsize):</font>
<font color="green"> 184.             self.pool.put(None)</font>
<font color="black"> 185. </font>
<font color="black"> 186.         # These are mostly for testing and debugging purposes.</font>
<font color="green"> 187.         self.num_connections = 0</font>
<font color="green"> 188.         self.num_requests = 0</font>
<font color="green"> 189.         self.conn_kw = conn_kw</font>
<font color="black"> 190. </font>
<font color="green"> 191.         if self.proxy:</font>
<font color="black"> 192.             # Enable Nagle's algorithm for proxies, to avoid packet fragmentation.</font>
<font color="black"> 193.             # We cannot know if the user has added default socket options, so we cannot replace the</font>
<font color="black"> 194.             # list.</font>
<font color="red"> 195.             self.conn_kw.setdefault('socket_options', [])</font>
<font color="black"> 196. </font>
<font color="green"> 197.     def _new_conn(self):</font>
<font color="black"> 198.         &quot;&quot;&quot;</font>
<font color="black"> 199.         Return a fresh :class:`HTTPConnection`.</font>
<font color="black"> 200.         &quot;&quot;&quot;</font>
<font color="red"> 201.         self.num_connections += 1</font>
<font color="red"> 202.         log.info(&quot;Starting new HTTP connection (%d): %s&quot; %</font>
<font color="red"> 203.                  (self.num_connections, self.host))</font>
<font color="black"> 204. </font>
<font color="red"> 205.         conn = self.ConnectionCls(host=self.host, port=self.port,</font>
<font color="red"> 206.                                   timeout=self.timeout.connect_timeout,</font>
<font color="red"> 207.                                   strict=self.strict, **self.conn_kw)</font>
<font color="red"> 208.         return conn</font>
<font color="black"> 209. </font>
<font color="green"> 210.     def _get_conn(self, timeout=None):</font>
<font color="black"> 211.         &quot;&quot;&quot;</font>
<font color="black"> 212.         Get a connection. Will return a pooled connection if one is available.</font>
<font color="black"> 213. </font>
<font color="black"> 214.         If no connections are available and :prop:`.block` is ``False``, then a</font>
<font color="black"> 215.         fresh connection is returned.</font>
<font color="black"> 216. </font>
<font color="black"> 217.         :param timeout:</font>
<font color="black"> 218.             Seconds to wait before giving up and raising</font>
<font color="black"> 219.             :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and</font>
<font color="black"> 220.             :prop:`.block` is ``True``.</font>
<font color="black"> 221.         &quot;&quot;&quot;</font>
<font color="green"> 222.         conn = None</font>
<font color="green"> 223.         try:</font>
<font color="green"> 224.             conn = self.pool.get(block=self.block, timeout=timeout)</font>
<font color="black"> 225. </font>
<font color="red"> 226.         except AttributeError:  # self.pool is None</font>
<font color="red"> 227.             raise ClosedPoolError(self, &quot;Pool is closed.&quot;)</font>
<font color="black"> 228. </font>
<font color="red"> 229.         except Empty:</font>
<font color="red"> 230.             if self.block:</font>
<font color="red"> 231.                 raise EmptyPoolError(self,</font>
<font color="red"> 232.                                      &quot;Pool reached maximum size and no more &quot;</font>
<font color="black"> 233.                                      &quot;connections are allowed.&quot;)</font>
<font color="red"> 234.             pass  # Oh well, we'll create a new connection then</font>
<font color="black"> 235. </font>
<font color="black"> 236.         # If this is a persistent connection, check if it got disconnected</font>
<font color="green"> 237.         if conn and is_connection_dropped(conn):</font>
<font color="green"> 238.             log.info(&quot;Resetting dropped connection: %s&quot; % self.host)</font>
<font color="green"> 239.             conn.close()</font>
<font color="green"> 240.             if getattr(conn, 'auto_open', 1) == 0:</font>
<font color="black"> 241.                 # This is a proxied connection that has been mutated by</font>
<font color="black"> 242.                 # httplib._tunnel() and cannot be reused (since it would</font>
<font color="black"> 243.                 # attempt to bypass the proxy)</font>
<font color="red"> 244.                 conn = None</font>
<font color="black"> 245. </font>
<font color="green"> 246.         return conn or self._new_conn()</font>
<font color="black"> 247. </font>
<font color="green"> 248.     def _put_conn(self, conn):</font>
<font color="black"> 249.         &quot;&quot;&quot;</font>
<font color="black"> 250.         Put a connection back into the pool.</font>
<font color="black"> 251. </font>
<font color="black"> 252.         :param conn:</font>
<font color="black"> 253.             Connection object for the current host and port as returned by</font>
<font color="black"> 254.             :meth:`._new_conn` or :meth:`._get_conn`.</font>
<font color="black"> 255. </font>
<font color="black"> 256.         If the pool is already full, the connection is closed and discarded</font>
<font color="black"> 257.         because we exceeded maxsize. If connections are discarded frequently,</font>
<font color="black"> 258.         then maxsize should be increased.</font>
<font color="black"> 259. </font>
<font color="black"> 260.         If the pool is closed, then the connection will be closed and discarded.</font>
<font color="black"> 261.         &quot;&quot;&quot;</font>
<font color="green"> 262.         try:</font>
<font color="green"> 263.             self.pool.put(conn, block=False)</font>
<font color="green"> 264.             return  # Everything is dandy, done.</font>
<font color="red"> 265.         except AttributeError:</font>
<font color="black"> 266.             # self.pool is None.</font>
<font color="red"> 267.             pass</font>
<font color="red"> 268.         except Full:</font>
<font color="black"> 269.             # This should never happen if self.block == True</font>
<font color="red"> 270.             log.warning(</font>
<font color="red"> 271.                 &quot;Connection pool is full, discarding connection: %s&quot; %</font>
<font color="red"> 272.                 self.host)</font>
<font color="black"> 273. </font>
<font color="black"> 274.         # Connection never got put back into the pool, close it.</font>
<font color="red"> 275.         if conn:</font>
<font color="red"> 276.             conn.close()</font>
<font color="black"> 277. </font>
<font color="green"> 278.     def _validate_conn(self, conn):</font>
<font color="black"> 279.         &quot;&quot;&quot;</font>
<font color="black"> 280.         Called right before a request is made, after the socket is created.</font>
<font color="black"> 281.         &quot;&quot;&quot;</font>
<font color="green"> 282.         pass</font>
<font color="black"> 283. </font>
<font color="green"> 284.     def _prepare_proxy(self, conn):</font>
<font color="black"> 285.         # Nothing to do for HTTP connections.</font>
<font color="red"> 286.         pass</font>
<font color="black"> 287. </font>
<font color="green"> 288.     def _get_timeout(self, timeout):</font>
<font color="black"> 289.         &quot;&quot;&quot; Helper that always returns a :class:`urllib3.util.Timeout` &quot;&quot;&quot;</font>
<font color="green"> 290.         if timeout is _Default:</font>
<font color="red"> 291.             return self.timeout.clone()</font>
<font color="black"> 292. </font>
<font color="green"> 293.         if isinstance(timeout, Timeout):</font>
<font color="green"> 294.             return timeout.clone()</font>
<font color="black"> 295.         else:</font>
<font color="black"> 296.             # User passed us an int/float. This is for backwards compatibility,</font>
<font color="black"> 297.             # can be removed later</font>
<font color="red"> 298.             return Timeout.from_float(timeout)</font>
<font color="black"> 299. </font>
<font color="green"> 300.     def _raise_timeout(self, err, url, timeout_value):</font>
<font color="black"> 301.         &quot;&quot;&quot;Is the error actually a timeout? Will raise a ReadTimeout or pass&quot;&quot;&quot;</font>
<font color="black"> 302. </font>
<font color="red"> 303.         if isinstance(err, SocketTimeout):</font>
<font color="red"> 304.             raise ReadTimeoutError(self, url, &quot;Read timed out. (read timeout=%s)&quot; % timeout_value)</font>
<font color="black"> 305. </font>
<font color="black"> 306.         # See the above comment about EAGAIN in Python 3. In Python 2 we have</font>
<font color="black"> 307.         # to specifically catch it and throw the timeout error</font>
<font color="red"> 308.         if hasattr(err, 'errno') and err.errno in _blocking_errnos:</font>
<font color="red"> 309.             raise ReadTimeoutError(self, url, &quot;Read timed out. (read timeout=%s)&quot; % timeout_value)</font>
<font color="black"> 310. </font>
<font color="black"> 311.         # Catch possible read timeouts thrown as SSL errors. If not the</font>
<font color="black"> 312.         # case, rethrow the original. We need to do this because of:</font>
<font color="black"> 313.         # http://bugs.python.org/issue10272</font>
<font color="red"> 314.         if 'timed out' in str(err) or 'did not complete (read)' in str(err):  # Python 2.6</font>
<font color="red"> 315.             raise ReadTimeoutError(self, url, &quot;Read timed out. (read timeout=%s)&quot; % timeout_value)</font>
<font color="black"> 316. </font>
<font color="green"> 317.     def _make_request(self, conn, method, url, timeout=_Default,</font>
<font color="black"> 318.                       **httplib_request_kw):</font>
<font color="black"> 319.         &quot;&quot;&quot;</font>
<font color="black"> 320.         Perform a request on a given urllib connection object taken from our</font>
<font color="black"> 321.         pool.</font>
<font color="black"> 322. </font>
<font color="black"> 323.         :param conn:</font>
<font color="black"> 324.             a connection from one of our connection pools</font>
<font color="black"> 325. </font>
<font color="black"> 326.         :param timeout:</font>
<font color="black"> 327.             Socket timeout in seconds for the request. This can be a</font>
<font color="black"> 328.             float or integer, which will set the same timeout value for</font>
<font color="black"> 329.             the socket connect and the socket read, or an instance of</font>
<font color="black"> 330.             :class:`urllib3.util.Timeout`, which gives you more fine-grained</font>
<font color="black"> 331.             control over your timeouts.</font>
<font color="black"> 332.         &quot;&quot;&quot;</font>
<font color="green"> 333.         self.num_requests += 1</font>
<font color="black"> 334. </font>
<font color="green"> 335.         timeout_obj = self._get_timeout(timeout)</font>
<font color="green"> 336.         timeout_obj.start_connect()</font>
<font color="green"> 337.         conn.timeout = timeout_obj.connect_timeout</font>
<font color="black"> 338. </font>
<font color="black"> 339.         # Trigger any extra validation we need to do.</font>
<font color="green"> 340.         try:</font>
<font color="green"> 341.             self._validate_conn(conn)</font>
<font color="red"> 342.         except (SocketTimeout, BaseSSLError) as e:</font>
<font color="black"> 343.             # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.</font>
<font color="red"> 344.             self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)</font>
<font color="red"> 345.             raise</font>
<font color="black"> 346. </font>
<font color="black"> 347.         # conn.request() calls httplib.*.request, not the method in</font>
<font color="black"> 348.         # urllib3.request. It also calls makefile (recv) on the socket.</font>
<font color="green"> 349.         conn.request(method, url, **httplib_request_kw)</font>
<font color="black"> 350. </font>
<font color="black"> 351.         # Reset the timeout for the recv() on the socket</font>
<font color="green"> 352.         read_timeout = timeout_obj.read_timeout</font>
<font color="black"> 353. </font>
<font color="black"> 354.         # App Engine doesn't have a sock attr</font>
<font color="green"> 355.         if getattr(conn, 'sock', None):</font>
<font color="black"> 356.             # In Python 3 socket.py will catch EAGAIN and return None when you</font>
<font color="black"> 357.             # try and read into the file pointer created by http.client, which</font>
<font color="black"> 358.             # instead raises a BadStatusLine exception. Instead of catching</font>
<font color="black"> 359.             # the exception and assuming all BadStatusLine exceptions are read</font>
<font color="black"> 360.             # timeouts, check for a zero timeout before making the request.</font>
<font color="green"> 361.             if read_timeout == 0:</font>
<font color="red"> 362.                 raise ReadTimeoutError(</font>
<font color="red"> 363.                     self, url, &quot;Read timed out. (read timeout=%s)&quot; % read_timeout)</font>
<font color="green"> 364.             if read_timeout is Timeout.DEFAULT_TIMEOUT:</font>
<font color="red"> 365.                 conn.sock.settimeout(socket.getdefaulttimeout())</font>
<font color="black"> 366.             else:  # None or a value</font>
<font color="green"> 367.                 conn.sock.settimeout(read_timeout)</font>
<font color="black"> 368. </font>
<font color="black"> 369.         # Receive the response from the server</font>
<font color="green"> 370.         try:</font>
<font color="green"> 371.             try:  # Python 2.7, use buffering of HTTP responses</font>
<font color="green"> 372.                 httplib_response = conn.getresponse(buffering=True)</font>
<font color="red"> 373.             except TypeError:  # Python 2.6 and older</font>
<font color="red"> 374.                 httplib_response = conn.getresponse()</font>
<font color="red"> 375.         except (SocketTimeout, BaseSSLError, SocketError) as e:</font>
<font color="red"> 376.             self._raise_timeout(err=e, url=url, timeout_value=read_timeout)</font>
<font color="red"> 377.             raise</font>
<font color="black"> 378. </font>
<font color="black"> 379.         # AppEngine doesn't have a version attr.</font>
<font color="green"> 380.         http_version = getattr(conn, '_http_vsn_str', 'HTTP/?')</font>
<font color="green"> 381.         log.debug(&quot;\&quot;%s %s %s\&quot; %s %s&quot; % (method, url, http_version,</font>
<font color="green"> 382.                                           httplib_response.status,</font>
<font color="green"> 383.                                           httplib_response.length))</font>
<font color="green"> 384.         return httplib_response</font>
<font color="black"> 385. </font>
<font color="green"> 386.     def close(self):</font>
<font color="black"> 387.         &quot;&quot;&quot;</font>
<font color="black"> 388.         Close all pooled connections and disable the pool.</font>
<font color="black"> 389.         &quot;&quot;&quot;</font>
<font color="black"> 390.         # Disable access to the pool</font>
<font color="red"> 391.         old_pool, self.pool = self.pool, None</font>
<font color="black"> 392. </font>
<font color="red"> 393.         try:</font>
<font color="red"> 394.             while True:</font>
<font color="red"> 395.                 conn = old_pool.get(block=False)</font>
<font color="red"> 396.                 if conn:</font>
<font color="red"> 397.                     conn.close()</font>
<font color="black"> 398. </font>
<font color="red"> 399.         except Empty:</font>
<font color="red"> 400.             pass  # Done.</font>
<font color="black"> 401. </font>
<font color="green"> 402.     def is_same_host(self, url):</font>
<font color="black"> 403.         &quot;&quot;&quot;</font>
<font color="black"> 404.         Check if the given ``url`` is a member of the same host as this</font>
<font color="black"> 405.         connection pool.</font>
<font color="black"> 406.         &quot;&quot;&quot;</font>
<font color="red"> 407.         if url.startswith('/'):</font>
<font color="red"> 408.             return True</font>
<font color="black"> 409. </font>
<font color="black"> 410.         # TODO: Add optional support for socket.gethostbyname checking.</font>
<font color="red"> 411.         scheme, host, port = get_host(url)</font>
<font color="black"> 412. </font>
<font color="black"> 413.         # Use explicit default port for comparison when none is given</font>
<font color="red"> 414.         if self.port and not port:</font>
<font color="red"> 415.             port = port_by_scheme.get(scheme)</font>
<font color="red"> 416.         elif not self.port and port == port_by_scheme.get(scheme):</font>
<font color="red"> 417.             port = None</font>
<font color="black"> 418. </font>
<font color="red"> 419.         return (scheme, host, port) == (self.scheme, self.host, self.port)</font>
<font color="black"> 420. </font>
<font color="green"> 421.     def urlopen(self, method, url, body=None, headers=None, retries=None,</font>
<font color="green"> 422.                 redirect=True, assert_same_host=True, timeout=_Default,</font>
<font color="green"> 423.                 pool_timeout=None, release_conn=None, **response_kw):</font>
<font color="black"> 424.         &quot;&quot;&quot;</font>
<font color="black"> 425.         Get a connection from the pool and perform an HTTP request. This is the</font>
<font color="black"> 426.         lowest level call for making a request, so you'll need to specify all</font>
<font color="black"> 427.         the raw details.</font>
<font color="black"> 428. </font>
<font color="black"> 429.         .. note::</font>
<font color="black"> 430. </font>
<font color="black"> 431.            More commonly, it's appropriate to use a convenience method provided</font>
<font color="black"> 432.            by :class:`.RequestMethods`, such as :meth:`request`.</font>
<font color="black"> 433. </font>
<font color="black"> 434.         .. note::</font>
<font color="black"> 435. </font>
<font color="black"> 436.            `release_conn` will only behave as expected if</font>
<font color="black"> 437.            `preload_content=False` because we want to make</font>
<font color="black"> 438.            `preload_content=False` the default behaviour someday soon without</font>
<font color="black"> 439.            breaking backwards compatibility.</font>
<font color="black"> 440. </font>
<font color="black"> 441.         :param method:</font>
<font color="black"> 442.             HTTP request method (such as GET, POST, PUT, etc.)</font>
<font color="black"> 443. </font>
<font color="black"> 444.         :param body:</font>
<font color="black"> 445.             Data to send in the request body (useful for creating</font>
<font color="black"> 446.             POST requests, see HTTPConnectionPool.post_url for</font>
<font color="black"> 447.             more convenience).</font>
<font color="black"> 448. </font>
<font color="black"> 449.         :param headers:</font>
<font color="black"> 450.             Dictionary of custom headers to send, such as User-Agent,</font>
<font color="black"> 451.             If-None-Match, etc. If None, pool headers are used. If provided,</font>
<font color="black"> 452.             these headers completely replace any pool-specific headers.</font>
<font color="black"> 453. </font>
<font color="black"> 454.         :param retries:</font>
<font color="black"> 455.             Configure the number of retries to allow before raising a</font>
<font color="black"> 456.             :class:`~urllib3.exceptions.MaxRetryError` exception.</font>
<font color="black"> 457. </font>
<font color="black"> 458.             Pass ``None`` to retry until you receive a response. Pass a</font>
<font color="black"> 459.             :class:`~urllib3.util.retry.Retry` object for fine-grained control</font>
<font color="black"> 460.             over different types of retries.</font>
<font color="black"> 461.             Pass an integer number to retry connection errors that many times,</font>
<font color="black"> 462.             but no other types of errors. Pass zero to never retry.</font>
<font color="black"> 463. </font>
<font color="black"> 464.             If ``False``, then retries are disabled and any exception is raised</font>
<font color="black"> 465.             immediately. Also, instead of raising a MaxRetryError on redirects,</font>
<font color="black"> 466.             the redirect response will be returned.</font>
<font color="black"> 467. </font>
<font color="black"> 468.         :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.</font>
<font color="black"> 469. </font>
<font color="black"> 470.         :param redirect:</font>
<font color="black"> 471.             If True, automatically handle redirects (status codes 301, 302,</font>
<font color="black"> 472.             303, 307, 308). Each redirect counts as a retry. Disabling retries</font>
<font color="black"> 473.             will disable redirect, too.</font>
<font color="black"> 474. </font>
<font color="black"> 475.         :param assert_same_host:</font>
<font color="black"> 476.             If ``True``, will make sure that the host of the pool requests is</font>
<font color="black"> 477.             consistent else will raise HostChangedError. When False, you can</font>
<font color="black"> 478.             use the pool on an HTTP proxy and request foreign hosts.</font>
<font color="black"> 479. </font>
<font color="black"> 480.         :param timeout:</font>
<font color="black"> 481.             If specified, overrides the default timeout for this one</font>
<font color="black"> 482.             request. It may be a float (in seconds) or an instance of</font>
<font color="black"> 483.             :class:`urllib3.util.Timeout`.</font>
<font color="black"> 484. </font>
<font color="black"> 485.         :param pool_timeout:</font>
<font color="black"> 486.             If set and the pool is set to block=True, then this method will</font>
<font color="black"> 487.             block for ``pool_timeout`` seconds and raise EmptyPoolError if no</font>
<font color="black"> 488.             connection is available within the time period.</font>
<font color="black"> 489. </font>
<font color="black"> 490.         :param release_conn:</font>
<font color="black"> 491.             If False, then the urlopen call will not release the connection</font>
<font color="black"> 492.             back into the pool once a response is received (but will release if</font>
<font color="black"> 493.             you read the entire contents of the response such as when</font>
<font color="black"> 494.             `preload_content=True`). This is useful if you're not preloading</font>
<font color="black"> 495.             the response's content immediately. You will need to call</font>
<font color="black"> 496.             ``r.release_conn()`` on the response ``r`` to return the connection</font>
<font color="black"> 497.             back into the pool. If None, it takes the value of</font>
<font color="black"> 498.             ``response_kw.get('preload_content', True)``.</font>
<font color="black"> 499. </font>
<font color="black"> 500.         :param \**response_kw:</font>
<font color="black"> 501.             Additional parameters are passed to</font>
<font color="black"> 502.             :meth:`urllib3.response.HTTPResponse.from_httplib`</font>
<font color="black"> 503.         &quot;&quot;&quot;</font>
<font color="green"> 504.         if headers is None:</font>
<font color="red"> 505.             headers = self.headers</font>
<font color="black"> 506. </font>
<font color="green"> 507.         if not isinstance(retries, Retry):</font>
<font color="red"> 508.             retries = Retry.from_int(retries, redirect=redirect, default=self.retries)</font>
<font color="black"> 509. </font>
<font color="green"> 510.         if release_conn is None:</font>
<font color="green"> 511.             release_conn = response_kw.get('preload_content', True)</font>
<font color="black"> 512. </font>
<font color="black"> 513.         # Check host</font>
<font color="green"> 514.         if assert_same_host and not self.is_same_host(url):</font>
<font color="red"> 515.             raise HostChangedError(self, url, retries)</font>
<font color="black"> 516. </font>
<font color="green"> 517.         conn = None</font>
<font color="black"> 518. </font>
<font color="black"> 519.         # Merge the proxy headers. Only do this in HTTP. We have to copy the</font>
<font color="black"> 520.         # headers dict so we can safely change it without those changes being</font>
<font color="black"> 521.         # reflected in anyone else's copy.</font>
<font color="green"> 522.         if self.scheme == 'http':</font>
<font color="red"> 523.             headers = headers.copy()</font>
<font color="red"> 524.             headers.update(self.proxy_headers)</font>
<font color="black"> 525. </font>
<font color="black"> 526.         # Must keep the exception bound to a separate variable or else Python 3</font>
<font color="black"> 527.         # complains about UnboundLocalError.</font>
<font color="green"> 528.         err = None</font>
<font color="black"> 529. </font>
<font color="green"> 530.         try:</font>
<font color="black"> 531.             # Request a connection from the queue.</font>
<font color="green"> 532.             timeout_obj = self._get_timeout(timeout)</font>
<font color="green"> 533.             conn = self._get_conn(timeout=pool_timeout)</font>
<font color="black"> 534. </font>
<font color="green"> 535.             conn.timeout = timeout_obj.connect_timeout</font>
<font color="black"> 536. </font>
<font color="green"> 537.             is_new_proxy_conn = self.proxy is not None and not getattr(conn, 'sock', None)</font>
<font color="green"> 538.             if is_new_proxy_conn:</font>
<font color="red"> 539.                 self._prepare_proxy(conn)</font>
<font color="black"> 540. </font>
<font color="black"> 541.             # Make the request on the httplib connection object.</font>
<font color="green"> 542.             httplib_response = self._make_request(conn, method, url,</font>
<font color="green"> 543.                                                   timeout=timeout_obj,</font>
<font color="green"> 544.                                                   body=body, headers=headers)</font>
<font color="black"> 545. </font>
<font color="black"> 546.             # If we're going to release the connection in ``finally:``, then</font>
<font color="black"> 547.             # the request doesn't need to know about the connection. Otherwise</font>
<font color="black"> 548.             # it will also try to release it and we'll have a double-release</font>
<font color="black"> 549.             # mess.</font>
<font color="green"> 550.             response_conn = not release_conn and conn</font>
<font color="black"> 551. </font>
<font color="black"> 552.             # Import httplib's response into our own wrapper object</font>
<font color="green"> 553.             response = HTTPResponse.from_httplib(httplib_response,</font>
<font color="green"> 554.                                                  pool=self,</font>
<font color="green"> 555.                                                  connection=response_conn,</font>
<font color="green"> 556.                                                  **response_kw)</font>
<font color="black"> 557. </font>
<font color="black"> 558.             # else:</font>
<font color="black"> 559.             #     The connection will be put back into the pool when</font>
<font color="black"> 560.             #     ``response.release_conn()`` is called (implicitly by</font>
<font color="black"> 561.             #     ``response.read()``)</font>
<font color="black"> 562. </font>
<font color="red"> 563.         except Empty:</font>
<font color="black"> 564.             # Timed out by queue.</font>
<font color="red"> 565.             raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)</font>
<font color="black"> 566. </font>
<font color="red"> 567.         except (BaseSSLError, CertificateError) as e:</font>
<font color="black"> 568.             # Close the connection. If a connection is reused on which there</font>
<font color="black"> 569.             # was a Certificate error, the next request will certainly raise</font>
<font color="black"> 570.             # another Certificate error.</font>
<font color="red"> 571.             if conn:</font>
<font color="red"> 572.                 conn.close()</font>
<font color="red"> 573.                 conn = None</font>
<font color="red"> 574.             raise SSLError(e)</font>
<font color="black"> 575. </font>
<font color="red"> 576.         except SSLError:</font>
<font color="black"> 577.             # Treat SSLError separately from BaseSSLError to preserve</font>
<font color="black"> 578.             # traceback.</font>
<font color="red"> 579.             if conn:</font>
<font color="red"> 580.                 conn.close()</font>
<font color="red"> 581.                 conn = None</font>
<font color="red"> 582.             raise</font>
<font color="black"> 583. </font>
<font color="red"> 584.         except (TimeoutError, HTTPException, SocketError, ConnectionError) as e:</font>
<font color="red"> 585.             if conn:</font>
<font color="black"> 586.                 # Discard the connection for these exceptions. It will be</font>
<font color="black"> 587.                 # be replaced during the next _get_conn() call.</font>
<font color="red"> 588.                 conn.close()</font>
<font color="red"> 589.                 conn = None</font>
<font color="black"> 590. </font>
<font color="red"> 591.             if isinstance(e, SocketError) and self.proxy:</font>
<font color="red"> 592.                 e = ProxyError('Cannot connect to proxy.', e)</font>
<font color="red"> 593.             elif isinstance(e, (SocketError, HTTPException)):</font>
<font color="red"> 594.                 e = ProtocolError('Connection aborted.', e)</font>
<font color="black"> 595. </font>
<font color="red"> 596.             retries = retries.increment(method, url, error=e, _pool=self,</font>
<font color="red"> 597.                                         _stacktrace=sys.exc_info()[2])</font>
<font color="red"> 598.             retries.sleep()</font>
<font color="black"> 599. </font>
<font color="black"> 600.             # Keep track of the error for the retry warning.</font>
<font color="red"> 601.             err = e</font>
<font color="black"> 602. </font>
<font color="black"> 603.         finally:</font>
<font color="green"> 604.             if release_conn:</font>
<font color="black"> 605.                 # Put the connection back to be reused. If the connection is</font>
<font color="black"> 606.                 # expired then it will be None, which will get replaced with a</font>
<font color="black"> 607.                 # fresh connection during _get_conn.</font>
<font color="red"> 608.                 self._put_conn(conn)</font>
<font color="black"> 609. </font>
<font color="green"> 610.         if not conn:</font>
<font color="black"> 611.             # Try again</font>
<font color="red"> 612.             log.warning(&quot;Retrying (%r) after connection &quot;</font>
<font color="red"> 613.                         &quot;broken by '%r': %s&quot; % (retries, err, url))</font>
<font color="red"> 614.             return self.urlopen(method, url, body, headers, retries,</font>
<font color="red"> 615.                                 redirect, assert_same_host,</font>
<font color="red"> 616.                                 timeout=timeout, pool_timeout=pool_timeout,</font>
<font color="red"> 617.                                 release_conn=release_conn, **response_kw)</font>
<font color="black"> 618. </font>
<font color="black"> 619.         # Handle redirect?</font>
<font color="green"> 620.         redirect_location = redirect and response.get_redirect_location()</font>
<font color="green"> 621.         if redirect_location:</font>
<font color="red"> 622.             if response.status == 303:</font>
<font color="red"> 623.                 method = 'GET'</font>
<font color="black"> 624. </font>
<font color="red"> 625.             try:</font>
<font color="red"> 626.                 retries = retries.increment(method, url, response=response, _pool=self)</font>
<font color="red"> 627.             except MaxRetryError:</font>
<font color="red"> 628.                 if retries.raise_on_redirect:</font>
<font color="red"> 629.                     raise</font>
<font color="red"> 630.                 return response</font>
<font color="black"> 631. </font>
<font color="red"> 632.             log.info(&quot;Redirecting %s -&gt; %s&quot; % (url, redirect_location))</font>
<font color="red"> 633.             return self.urlopen(method, redirect_location, body, headers,</font>
<font color="red"> 634.                     retries=retries, redirect=redirect,</font>
<font color="red"> 635.                     assert_same_host=assert_same_host,</font>
<font color="red"> 636.                     timeout=timeout, pool_timeout=pool_timeout,</font>
<font color="red"> 637.                     release_conn=release_conn, **response_kw)</font>
<font color="black"> 638. </font>
<font color="black"> 639.         # Check if we should retry the HTTP response.</font>
<font color="green"> 640.         if retries.is_forced_retry(method, status_code=response.status):</font>
<font color="red"> 641.             retries = retries.increment(method, url, response=response, _pool=self)</font>
<font color="red"> 642.             retries.sleep()</font>
<font color="red"> 643.             log.info(&quot;Forced retry: %s&quot; % url)</font>
<font color="red"> 644.             return self.urlopen(method, url, body, headers,</font>
<font color="red"> 645.                     retries=retries, redirect=redirect,</font>
<font color="red"> 646.                     assert_same_host=assert_same_host,</font>
<font color="red"> 647.                     timeout=timeout, pool_timeout=pool_timeout,</font>
<font color="red"> 648.                     release_conn=release_conn, **response_kw)</font>
<font color="black"> 649. </font>
<font color="green"> 650.         return response</font>
<font color="black"> 651. </font>
<font color="black"> 652. </font>
<font color="green"> 653. class HTTPSConnectionPool(HTTPConnectionPool):</font>
<font color="black"> 654.     &quot;&quot;&quot;</font>
<font color="black"> 655.     Same as :class:`.HTTPConnectionPool`, but HTTPS.</font>
<font color="black"> 656. </font>
<font color="black"> 657.     When Python is compiled with the :mod:`ssl` module, then</font>
<font color="black"> 658.     :class:`.VerifiedHTTPSConnection` is used, which *can* verify certificates,</font>
<font color="black"> 659.     instead of :class:`.HTTPSConnection`.</font>
<font color="black"> 660. </font>
<font color="black"> 661.     :class:`.VerifiedHTTPSConnection` uses one of ``assert_fingerprint``,</font>
<font color="black"> 662.     ``assert_hostname`` and ``host`` in this order to verify connections.</font>
<font color="black"> 663.     If ``assert_hostname`` is False, no verification is done.</font>
<font color="black"> 664. </font>
<font color="black"> 665.     The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs`` and</font>
<font color="black"> 666.     ``ssl_version`` are only used if :mod:`ssl` is available and are fed into</font>
<font color="black"> 667.     :meth:`urllib3.util.ssl_wrap_socket` to upgrade the connection socket</font>
<font color="black"> 668.     into an SSL socket.</font>
<font color="green"> 669.     &quot;&quot;&quot;</font>
<font color="black"> 670. </font>
<font color="green"> 671.     scheme = 'https'</font>
<font color="green"> 672.     ConnectionCls = HTTPSConnection</font>
<font color="black"> 673. </font>
<font color="green"> 674.     def __init__(self, host, port=None,</font>
<font color="green"> 675.                  strict=False, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1,</font>
<font color="green"> 676.                  block=False, headers=None, retries=None,</font>
<font color="green"> 677.                  _proxy=None, _proxy_headers=None,</font>
<font color="green"> 678.                  key_file=None, cert_file=None, cert_reqs=None,</font>
<font color="green"> 679.                  ca_certs=None, ssl_version=None,</font>
<font color="green"> 680.                  assert_hostname=None, assert_fingerprint=None,</font>
<font color="black"> 681.                  **conn_kw):</font>
<font color="black"> 682. </font>
<font color="green"> 683.         HTTPConnectionPool.__init__(self, host, port, strict, timeout, maxsize,</font>
<font color="green"> 684.                                     block, headers, retries, _proxy, _proxy_headers,</font>
<font color="green"> 685.                                     **conn_kw)</font>
<font color="green"> 686.         self.key_file = key_file</font>
<font color="green"> 687.         self.cert_file = cert_file</font>
<font color="green"> 688.         self.cert_reqs = cert_reqs</font>
<font color="green"> 689.         self.ca_certs = ca_certs</font>
<font color="green"> 690.         self.ssl_version = ssl_version</font>
<font color="green"> 691.         self.assert_hostname = assert_hostname</font>
<font color="green"> 692.         self.assert_fingerprint = assert_fingerprint</font>
<font color="black"> 693. </font>
<font color="green"> 694.     def _prepare_conn(self, conn):</font>
<font color="black"> 695.         &quot;&quot;&quot;</font>
<font color="black"> 696.         Prepare the ``connection`` for :meth:`urllib3.util.ssl_wrap_socket`</font>
<font color="black"> 697.         and establish the tunnel if proxy is used.</font>
<font color="black"> 698.         &quot;&quot;&quot;</font>
<font color="black"> 699. </font>
<font color="green"> 700.         if isinstance(conn, VerifiedHTTPSConnection):</font>
<font color="green"> 701.             conn.set_cert(key_file=self.key_file,</font>
<font color="green"> 702.                           cert_file=self.cert_file,</font>
<font color="green"> 703.                           cert_reqs=self.cert_reqs,</font>
<font color="green"> 704.                           ca_certs=self.ca_certs,</font>
<font color="green"> 705.                           assert_hostname=self.assert_hostname,</font>
<font color="green"> 706.                           assert_fingerprint=self.assert_fingerprint)</font>
<font color="green"> 707.             conn.ssl_version = self.ssl_version</font>
<font color="black"> 708. </font>
<font color="green"> 709.         return conn</font>
<font color="black"> 710. </font>
<font color="green"> 711.     def _prepare_proxy(self, conn):</font>
<font color="black"> 712.         &quot;&quot;&quot;</font>
<font color="black"> 713.         Establish tunnel connection early, because otherwise httplib</font>
<font color="black"> 714.         would improperly set Host: header to proxy's IP:port.</font>
<font color="black"> 715.         &quot;&quot;&quot;</font>
<font color="black"> 716.         # Python 2.7+</font>
<font color="red"> 717.         try:</font>
<font color="red"> 718.             set_tunnel = conn.set_tunnel</font>
<font color="red"> 719.         except AttributeError:  # Platform-specific: Python 2.6</font>
<font color="red"> 720.             set_tunnel = conn._set_tunnel</font>
<font color="black"> 721. </font>
<font color="red"> 722.         if sys.version_info &lt;= (2, 6, 4) and not self.proxy_headers:   # Python 2.6.4 and older</font>
<font color="red"> 723.             set_tunnel(self.host, self.port)</font>
<font color="black"> 724.         else:</font>
<font color="red"> 725.             set_tunnel(self.host, self.port, self.proxy_headers)</font>
<font color="black"> 726. </font>
<font color="red"> 727.         conn.connect()</font>
<font color="black"> 728. </font>
<font color="green"> 729.     def _new_conn(self):</font>
<font color="black"> 730.         &quot;&quot;&quot;</font>
<font color="black"> 731.         Return a fresh :class:`httplib.HTTPSConnection`.</font>
<font color="black"> 732.         &quot;&quot;&quot;</font>
<font color="green"> 733.         self.num_connections += 1</font>
<font color="green"> 734.         log.info(&quot;Starting new HTTPS connection (%d): %s&quot;</font>
<font color="green"> 735.                  % (self.num_connections, self.host))</font>
<font color="black"> 736. </font>
<font color="green"> 737.         if not self.ConnectionCls or self.ConnectionCls is DummyConnection:</font>
<font color="red"> 738.             raise SSLError(&quot;Can't connect to HTTPS URL because the SSL &quot;</font>
<font color="black"> 739.                            &quot;module is not available.&quot;)</font>
<font color="black"> 740. </font>
<font color="green"> 741.         actual_host = self.host</font>
<font color="green"> 742.         actual_port = self.port</font>
<font color="green"> 743.         if self.proxy is not None:</font>
<font color="red"> 744.             actual_host = self.proxy.host</font>
<font color="red"> 745.             actual_port = self.proxy.port</font>
<font color="black"> 746. </font>
<font color="green"> 747.         conn = self.ConnectionCls(host=actual_host, port=actual_port,</font>
<font color="green"> 748.                                   timeout=self.timeout.connect_timeout,</font>
<font color="green"> 749.                                   strict=self.strict, **self.conn_kw)</font>
<font color="black"> 750. </font>
<font color="green"> 751.         return self._prepare_conn(conn)</font>
<font color="black"> 752. </font>
<font color="green"> 753.     def _validate_conn(self, conn):</font>
<font color="black"> 754.         &quot;&quot;&quot;</font>
<font color="black"> 755.         Called right before a request is made, after the socket is created.</font>
<font color="black"> 756.         &quot;&quot;&quot;</font>
<font color="green"> 757.         super(HTTPSConnectionPool, self)._validate_conn(conn)</font>
<font color="black"> 758. </font>
<font color="black"> 759.         # Force connect early to allow us to validate the connection.</font>
<font color="green"> 760.         if not getattr(conn, 'sock', None):  # AppEngine might not have  `.sock`</font>
<font color="green"> 761.             conn.connect()</font>
<font color="black"> 762. </font>
<font color="green"> 763.         if not conn.is_verified:</font>
<font color="red"> 764.             warnings.warn((</font>
<font color="red"> 765.                 'Unverified HTTPS request is being made. '</font>
<font color="black"> 766.                 'Adding certificate verification is strongly advised. See: '</font>
<font color="black"> 767.                 'https://urllib3.readthedocs.org/en/latest/security.html'),</font>
<font color="red"> 768.                 InsecureRequestWarning)</font>
<font color="black"> 769. </font>
<font color="black"> 770. </font>
<font color="green"> 771. def connection_from_url(url, **kw):</font>
<font color="black"> 772.     &quot;&quot;&quot;</font>
<font color="black"> 773.     Given a url, return an :class:`.ConnectionPool` instance of its host.</font>
<font color="black"> 774. </font>
<font color="black"> 775.     This is a shortcut for not having to parse out the scheme, host, and port</font>
<font color="black"> 776.     of the url before creating an :class:`.ConnectionPool` instance.</font>
<font color="black"> 777. </font>
<font color="black"> 778.     :param url:</font>
<font color="black"> 779.         Absolute URL string that must include the scheme. Port is optional.</font>
<font color="black"> 780. </font>
<font color="black"> 781.     :param \**kw:</font>
<font color="black"> 782.         Passes additional parameters to the constructor of the appropriate</font>
<font color="black"> 783.         :class:`.ConnectionPool`. Useful for specifying things like</font>
<font color="black"> 784.         timeout, maxsize, headers, etc.</font>
<font color="black"> 785. </font>
<font color="black"> 786.     Example::</font>
<font color="black"> 787. </font>
<font color="black"> 788.         &gt;&gt;&gt; conn = connection_from_url('http://google.com/')</font>
<font color="black"> 789.         &gt;&gt;&gt; r = conn.request('GET', '/')</font>
<font color="black"> 790.     &quot;&quot;&quot;</font>
<font color="red"> 791.     scheme, host, port = get_host(url)</font>
<font color="red"> 792.     if scheme == 'https':</font>
<font color="red"> 793.         return HTTPSConnectionPool(host, port=port, **kw)</font>
<font color="black"> 794.     else:</font>
<font color="red"> 795.         return HTTPConnectionPool(host, port=port, **kw)</font>
</pre>

