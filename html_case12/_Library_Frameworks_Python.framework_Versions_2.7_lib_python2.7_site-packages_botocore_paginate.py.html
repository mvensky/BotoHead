source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/paginate.py</b><br>


file stats: <b>405 lines, 63 executed: 15.6% covered</b>
<pre>
<font color="black">   1. # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="black">  13. </font>
<font color="green">  14. from itertools import tee</font>
<font color="black">  15. </font>
<font color="green">  16. from botocore.compat import six</font>
<font color="black">  17. </font>
<font color="green">  18. import jmespath</font>
<font color="green">  19. import json</font>
<font color="green">  20. import base64</font>
<font color="green">  21. import logging</font>
<font color="green">  22. from botocore.exceptions import PaginationError</font>
<font color="green">  23. from botocore.compat import zip</font>
<font color="green">  24. from botocore.utils import set_value_from_jmespath, merge_dicts</font>
<font color="black">  25. </font>
<font color="black">  26. </font>
<font color="green">  27. log = logging.getLogger(__name__)</font>
<font color="black">  28. </font>
<font color="black">  29. </font>
<font color="green">  30. class TokenEncoder(object):</font>
<font color="black">  31.     &quot;&quot;&quot;Encodes dictionaries into opaque strings.</font>
<font color="black">  32. </font>
<font color="black">  33.     This for the most part json dumps + base64 encoding, but also supports</font>
<font color="black">  34.     having bytes in the dictionary in addition to the types that json can</font>
<font color="black">  35.     handle by default.</font>
<font color="black">  36. </font>
<font color="black">  37.     This is intended for use in encoding pagination tokens, which in some</font>
<font color="black">  38.     cases can be complex structures and / or contain bytes.</font>
<font color="green">  39.     &quot;&quot;&quot;</font>
<font color="black">  40. </font>
<font color="green">  41.     def encode(self, token):</font>
<font color="black">  42.         &quot;&quot;&quot;Encodes a dictionary to an opaque string.</font>
<font color="black">  43. </font>
<font color="black">  44.         :type token: dict</font>
<font color="black">  45.         :param token: A dictionary containing pagination information,</font>
<font color="black">  46.             particularly the service pagination token(s) but also other boto</font>
<font color="black">  47.             metadata.</font>
<font color="black">  48. </font>
<font color="black">  49.         :rtype: str</font>
<font color="black">  50.         :returns: An opaque string</font>
<font color="black">  51.         &quot;&quot;&quot;</font>
<font color="red">  52.         try:</font>
<font color="black">  53.             # Try just using json dumps first to avoid having to traverse</font>
<font color="black">  54.             # and encode the dict. In 99.9999% of cases this will work.</font>
<font color="red">  55.             json_string = json.dumps(token)</font>
<font color="red">  56.         except (TypeError, UnicodeDecodeError):</font>
<font color="black">  57.             # If normal dumping failed, go through and base64 encode all bytes.</font>
<font color="red">  58.             encoded_token, encoded_keys = self._encode(token, [])</font>
<font color="black">  59. </font>
<font color="black">  60.             # Save the list of all the encoded key paths. We can safely</font>
<font color="black">  61.             # assume that no service will ever use this key.</font>
<font color="red">  62.             encoded_token['boto_encoded_keys'] = encoded_keys</font>
<font color="black">  63. </font>
<font color="black">  64.             # Now that the bytes are all encoded, dump the json.</font>
<font color="red">  65.             json_string = json.dumps(encoded_token)</font>
<font color="black">  66. </font>
<font color="black">  67.         # base64 encode the json string to produce an opaque token string.</font>
<font color="red">  68.         return base64.b64encode(json_string.encode('utf-8')).decode('utf-8')</font>
<font color="black">  69. </font>
<font color="green">  70.     def _encode(self, data, path):</font>
<font color="black">  71.         &quot;&quot;&quot;Encode bytes in given data, keeping track of the path traversed.&quot;&quot;&quot;</font>
<font color="red">  72.         if isinstance(data, dict):</font>
<font color="red">  73.             return self._encode_dict(data, path)</font>
<font color="red">  74.         elif isinstance(data, list):</font>
<font color="red">  75.             return self._encode_list(data, path)</font>
<font color="red">  76.         elif isinstance(data, six.binary_type):</font>
<font color="red">  77.             return self._encode_bytes(data, path)</font>
<font color="black">  78.         else:</font>
<font color="red">  79.             return data, []</font>
<font color="black">  80. </font>
<font color="green">  81.     def _encode_list(self, data, path):</font>
<font color="black">  82.         &quot;&quot;&quot;Encode any bytes in a list, noting the index of what is encoded.&quot;&quot;&quot;</font>
<font color="red">  83.         new_data = []</font>
<font color="red">  84.         encoded = []</font>
<font color="red">  85.         for i, value in enumerate(data):</font>
<font color="red">  86.             new_path = path + [i]</font>
<font color="red">  87.             new_value, new_encoded = self._encode(value, new_path)</font>
<font color="red">  88.             new_data.append(new_value)</font>
<font color="red">  89.             encoded.extend(new_encoded)</font>
<font color="red">  90.         return new_data, encoded</font>
<font color="black">  91. </font>
<font color="green">  92.     def _encode_dict(self, data, path):</font>
<font color="black">  93.         &quot;&quot;&quot;Encode any bytes in a dict, noting the index of what is encoded.&quot;&quot;&quot;</font>
<font color="red">  94.         new_data = {}</font>
<font color="red">  95.         encoded = []</font>
<font color="red">  96.         for key, value in data.items():</font>
<font color="red">  97.             new_path = path + [key]</font>
<font color="red">  98.             new_value, new_encoded = self._encode(value, new_path)</font>
<font color="red">  99.             new_data[key] = new_value</font>
<font color="red"> 100.             encoded.extend(new_encoded)</font>
<font color="red"> 101.         return new_data, encoded</font>
<font color="black"> 102. </font>
<font color="green"> 103.     def _encode_bytes(self, data, path):</font>
<font color="black"> 104.         &quot;&quot;&quot;Base64 encode a byte string.&quot;&quot;&quot;</font>
<font color="red"> 105.         return base64.b64encode(data).decode('utf-8'), [path]</font>
<font color="black"> 106. </font>
<font color="black"> 107. </font>
<font color="green"> 108. class TokenDecoder(object):</font>
<font color="black"> 109.     &quot;&quot;&quot;Decodes token strings back into dictionaries.</font>
<font color="black"> 110. </font>
<font color="black"> 111.     This performs the inverse operation to the TokenEncoder, accepting</font>
<font color="black"> 112.     opaque strings and decoding them into a useable form.</font>
<font color="green"> 113.     &quot;&quot;&quot;</font>
<font color="black"> 114. </font>
<font color="green"> 115.     def decode(self, token):</font>
<font color="black"> 116.         &quot;&quot;&quot;Decodes an opaque string to a dictionary.</font>
<font color="black"> 117. </font>
<font color="black"> 118.         :type token: str</font>
<font color="black"> 119.         :param token: A token string given by the botocore pagination</font>
<font color="black"> 120.             interface.</font>
<font color="black"> 121. </font>
<font color="black"> 122.         :rtype: dict</font>
<font color="black"> 123.         :returns: A dictionary containing pagination information,</font>
<font color="black"> 124.             particularly the service pagination token(s) but also other boto</font>
<font color="black"> 125.             metadata.</font>
<font color="black"> 126.         &quot;&quot;&quot;</font>
<font color="red"> 127.         json_string = base64.b64decode(token.encode('utf-8')).decode('utf-8')</font>
<font color="red"> 128.         decoded_token = json.loads(json_string)</font>
<font color="black"> 129. </font>
<font color="black"> 130.         # Remove the encoding metadata as it is read since it will no longer</font>
<font color="black"> 131.         # be needed.</font>
<font color="red"> 132.         encoded_keys = decoded_token.pop('boto_encoded_keys', None)</font>
<font color="red"> 133.         if encoded_keys is None:</font>
<font color="red"> 134.             return decoded_token</font>
<font color="black"> 135.         else:</font>
<font color="red"> 136.             return self._decode(decoded_token, encoded_keys)</font>
<font color="black"> 137. </font>
<font color="green"> 138.     def _decode(self, token, encoded_keys):</font>
<font color="black"> 139.         &quot;&quot;&quot;Find each encoded value and decode it.&quot;&quot;&quot;</font>
<font color="red"> 140.         for key in encoded_keys:</font>
<font color="red"> 141.             encoded = self._path_get(token, key)</font>
<font color="red"> 142.             decoded = base64.b64decode(encoded.encode('utf-8'))</font>
<font color="red"> 143.             self._path_set(token, key, decoded)</font>
<font color="red"> 144.         return token</font>
<font color="black"> 145. </font>
<font color="green"> 146.     def _path_get(self, data, path):</font>
<font color="black"> 147.         &quot;&quot;&quot;Return the nested data at the given path.</font>
<font color="black"> 148. </font>
<font color="black"> 149.         For instance:</font>
<font color="black"> 150.             data = {'foo': ['bar', 'baz']}</font>
<font color="black"> 151.             path = ['foo', 0]</font>
<font color="black"> 152.             ==&gt; 'bar'</font>
<font color="black"> 153.         &quot;&quot;&quot;</font>
<font color="black"> 154.         # jmespath isn't used here because it would be difficult to actually</font>
<font color="black"> 155.         # create the jmespath query when taking all of the unknowns of key</font>
<font color="black"> 156.         # structure into account. Gross though this is, it is simple and not</font>
<font color="black"> 157.         # very error prone.</font>
<font color="red"> 158.         d = data</font>
<font color="red"> 159.         for step in path:</font>
<font color="red"> 160.             d = d[step]</font>
<font color="red"> 161.         return d</font>
<font color="black"> 162. </font>
<font color="green"> 163.     def _path_set(self, data, path, value):</font>
<font color="black"> 164.         &quot;&quot;&quot;Set the value of a key in the given data.</font>
<font color="black"> 165. </font>
<font color="black"> 166.         Example:</font>
<font color="black"> 167.             data = {'foo': ['bar', 'baz']}</font>
<font color="black"> 168.             path = ['foo', 1]</font>
<font color="black"> 169.             value = 'bin'</font>
<font color="black"> 170.             ==&gt; data = {'foo': ['bar', 'bin']}</font>
<font color="black"> 171.         &quot;&quot;&quot;</font>
<font color="red"> 172.         container = self._path_get(data, path[:-1])</font>
<font color="red"> 173.         container[path[-1]] = value</font>
<font color="black"> 174. </font>
<font color="black"> 175. </font>
<font color="green"> 176. class PaginatorModel(object):</font>
<font color="green"> 177.     def __init__(self, paginator_config):</font>
<font color="red"> 178.         self._paginator_config = paginator_config['pagination']</font>
<font color="black"> 179. </font>
<font color="green"> 180.     def get_paginator(self, operation_name):</font>
<font color="red"> 181.         try:</font>
<font color="red"> 182.             single_paginator_config = self._paginator_config[operation_name]</font>
<font color="red"> 183.         except KeyError:</font>
<font color="red"> 184.             raise ValueError(&quot;Paginator for operation does not exist: %s&quot;</font>
<font color="red"> 185.                              % operation_name)</font>
<font color="red"> 186.         return single_paginator_config</font>
<font color="black"> 187. </font>
<font color="black"> 188. </font>
<font color="green"> 189. class PageIterator(object):</font>
<font color="green"> 190.     def __init__(self, method, input_token, output_token, more_results,</font>
<font color="black"> 191.                  result_keys, non_aggregate_keys, limit_key, max_items,</font>
<font color="black"> 192.                  starting_token, page_size, op_kwargs):</font>
<font color="red"> 193.         self._method = method</font>
<font color="red"> 194.         self._input_token = input_token</font>
<font color="red"> 195.         self._output_token = output_token</font>
<font color="red"> 196.         self._more_results = more_results</font>
<font color="red"> 197.         self._result_keys = result_keys</font>
<font color="red"> 198.         self._max_items = max_items</font>
<font color="red"> 199.         self._limit_key = limit_key</font>
<font color="red"> 200.         self._starting_token = starting_token</font>
<font color="red"> 201.         self._page_size = page_size</font>
<font color="red"> 202.         self._op_kwargs = op_kwargs</font>
<font color="red"> 203.         self._resume_token = None</font>
<font color="red"> 204.         self._non_aggregate_key_exprs = non_aggregate_keys</font>
<font color="red"> 205.         self._non_aggregate_part = {}</font>
<font color="red"> 206.         self._token_encoder = TokenEncoder()</font>
<font color="red"> 207.         self._token_decoder = TokenDecoder()</font>
<font color="black"> 208. </font>
<font color="green"> 209.     @property</font>
<font color="black"> 210.     def result_keys(self):</font>
<font color="red"> 211.         return self._result_keys</font>
<font color="black"> 212. </font>
<font color="green"> 213.     @property</font>
<font color="black"> 214.     def resume_token(self):</font>
<font color="black"> 215.         &quot;&quot;&quot;Token to specify to resume pagination.&quot;&quot;&quot;</font>
<font color="red"> 216.         return self._resume_token</font>
<font color="black"> 217. </font>
<font color="green"> 218.     @resume_token.setter</font>
<font color="black"> 219.     def resume_token(self, value):</font>
<font color="red"> 220.         if not isinstance(value, dict):</font>
<font color="red"> 221.             raise ValueError(&quot;Bad starting token: %s&quot; % value)</font>
<font color="black"> 222. </font>
<font color="red"> 223.         if 'boto_truncate_amount' in value:</font>
<font color="red"> 224.             token_keys = sorted(self._input_token + ['boto_truncate_amount'])</font>
<font color="black"> 225.         else:</font>
<font color="red"> 226.             token_keys = sorted(self._input_token)</font>
<font color="red"> 227.         dict_keys = sorted(value.keys())</font>
<font color="black"> 228. </font>
<font color="red"> 229.         if token_keys == dict_keys:</font>
<font color="red"> 230.             self._resume_token = self._token_encoder.encode(value)</font>
<font color="black"> 231.         else:</font>
<font color="red"> 232.             raise ValueError(&quot;Bad starting token: %s&quot; % value)</font>
<font color="black"> 233. </font>
<font color="green"> 234.     @property</font>
<font color="black"> 235.     def non_aggregate_part(self):</font>
<font color="red"> 236.         return self._non_aggregate_part</font>
<font color="black"> 237. </font>
<font color="green"> 238.     def __iter__(self):</font>
<font color="red"> 239.         current_kwargs = self._op_kwargs</font>
<font color="red"> 240.         previous_next_token = None</font>
<font color="red"> 241.         next_token = dict((key, None) for key in self._input_token)</font>
<font color="red"> 242.         if self._starting_token is not None:</font>
<font color="black"> 243.             # If the starting token exists, populate the next_token with the</font>
<font color="black"> 244.             # values inside it. This ensures that we have the service's</font>
<font color="black"> 245.             # pagination token on hand if we need to truncate after the</font>
<font color="black"> 246.             # first response.</font>
<font color="red"> 247.             next_token = self._parse_starting_token()[0]</font>
<font color="black"> 248.         # The number of items from result_key we've seen so far.</font>
<font color="red"> 249.         total_items = 0</font>
<font color="red"> 250.         first_request = True</font>
<font color="red"> 251.         primary_result_key = self.result_keys[0]</font>
<font color="red"> 252.         starting_truncation = 0</font>
<font color="red"> 253.         self._inject_starting_params(current_kwargs)</font>
<font color="red"> 254.         while True:</font>
<font color="red"> 255.             response = self._make_request(current_kwargs)</font>
<font color="red"> 256.             parsed = self._extract_parsed_response(response)</font>
<font color="red"> 257.             if first_request:</font>
<font color="black"> 258.                 # The first request is handled differently.  We could</font>
<font color="black"> 259.                 # possibly have a resume/starting token that tells us where</font>
<font color="black"> 260.                 # to index into the retrieved page.</font>
<font color="red"> 261.                 if self._starting_token is not None:</font>
<font color="red"> 262.                     starting_truncation = self._handle_first_request(</font>
<font color="red"> 263.                         parsed, primary_result_key, starting_truncation)</font>
<font color="red"> 264.                 first_request = False</font>
<font color="red"> 265.                 self._record_non_aggregate_key_values(parsed)</font>
<font color="black"> 266.             else:</font>
<font color="black"> 267.                 # If this isn't the first request, we have already sliced into</font>
<font color="black"> 268.                 # the first request and had to make additional requests after.</font>
<font color="black"> 269.                 # We no longer need to add this to truncation.</font>
<font color="red"> 270.                 starting_truncation = 0</font>
<font color="red"> 271.             current_response = primary_result_key.search(parsed)</font>
<font color="red"> 272.             if current_response is None:</font>
<font color="red"> 273.                 current_response = []</font>
<font color="red"> 274.             num_current_response = len(current_response)</font>
<font color="red"> 275.             truncate_amount = 0</font>
<font color="red"> 276.             if self._max_items is not None:</font>
<font color="red"> 277.                 truncate_amount = (total_items + num_current_response) \</font>
<font color="red"> 278.                                   - self._max_items</font>
<font color="red"> 279.             if truncate_amount &gt; 0:</font>
<font color="red"> 280.                 self._truncate_response(parsed, primary_result_key,</font>
<font color="red"> 281.                                         truncate_amount, starting_truncation,</font>
<font color="red"> 282.                                         next_token)</font>
<font color="red"> 283.                 yield response</font>
<font color="red"> 284.                 break</font>
<font color="black"> 285.             else:</font>
<font color="red"> 286.                 yield response</font>
<font color="red"> 287.                 total_items += num_current_response</font>
<font color="red"> 288.                 next_token = self._get_next_token(parsed)</font>
<font color="red"> 289.                 if all(t is None for t in next_token.values()):</font>
<font color="red"> 290.                     break</font>
<font color="red"> 291.                 if self._max_items is not None and \</font>
<font color="red"> 292.                         total_items == self._max_items:</font>
<font color="black"> 293.                     # We're on a page boundary so we can set the current</font>
<font color="black"> 294.                     # next token to be the resume token.</font>
<font color="red"> 295.                     self.resume_token = next_token</font>
<font color="red"> 296.                     break</font>
<font color="red"> 297.                 if previous_next_token is not None and \</font>
<font color="red"> 298.                         previous_next_token == next_token:</font>
<font color="red"> 299.                     message = (&quot;The same next token was received &quot;</font>
<font color="red"> 300.                                &quot;twice: %s&quot; % next_token)</font>
<font color="red"> 301.                     raise PaginationError(message=message)</font>
<font color="red"> 302.                 self._inject_token_into_kwargs(current_kwargs, next_token)</font>
<font color="red"> 303.                 previous_next_token = next_token</font>
<font color="black"> 304. </font>
<font color="green"> 305.     def search(self, expression):</font>
<font color="black"> 306.         &quot;&quot;&quot;Applies a JMESPath expression to a paginator</font>
<font color="black"> 307. </font>
<font color="black"> 308.         Each page of results is searched using the provided JMESPath</font>
<font color="black"> 309.         expression. If the result is not a list, it is yielded</font>
<font color="black"> 310.         directly. If the result is a list, each element in the result</font>
<font color="black"> 311.         is yielded individually (essentially implementing a flatmap in</font>
<font color="black"> 312.         which the JMESPath search is the mapping function).</font>
<font color="black"> 313. </font>
<font color="black"> 314.         :type expression: str</font>
<font color="black"> 315.         :param expression: JMESPath expression to apply to each page.</font>
<font color="black"> 316. </font>
<font color="black"> 317.         :return: Returns an iterator that yields the individual</font>
<font color="black"> 318.             elements of applying a JMESPath expression to each page of</font>
<font color="black"> 319.             results.</font>
<font color="black"> 320.         &quot;&quot;&quot;</font>
<font color="red"> 321.         compiled = jmespath.compile(expression)</font>
<font color="red"> 322.         for page in self:</font>
<font color="red"> 323.             results = compiled.search(page)</font>
<font color="red"> 324.             if isinstance(results, list):</font>
<font color="red"> 325.                 for element in results:</font>
<font color="red"> 326.                     yield element</font>
<font color="black"> 327.             else:</font>
<font color="black"> 328.                 # Yield result directly if it is not a list.</font>
<font color="red"> 329.                 yield results</font>
<font color="black"> 330. </font>
<font color="green"> 331.     def _make_request(self, current_kwargs):</font>
<font color="red"> 332.         return self._method(**current_kwargs)</font>
<font color="black"> 333. </font>
<font color="green"> 334.     def _extract_parsed_response(self, response):</font>
<font color="red"> 335.         return response</font>
<font color="black"> 336. </font>
<font color="green"> 337.     def _record_non_aggregate_key_values(self, response):</font>
<font color="red"> 338.         non_aggregate_keys = {}</font>
<font color="red"> 339.         for expression in self._non_aggregate_key_exprs:</font>
<font color="red"> 340.             result = expression.search(response)</font>
<font color="red"> 341.             set_value_from_jmespath(non_aggregate_keys,</font>
<font color="red"> 342.                                     expression.expression,</font>
<font color="red"> 343.                                     result)</font>
<font color="red"> 344.         self._non_aggregate_part = non_aggregate_keys</font>
<font color="black"> 345. </font>
<font color="green"> 346.     def _inject_starting_params(self, op_kwargs):</font>
<font color="black"> 347.         # If the user has specified a starting token we need to</font>
<font color="black"> 348.         # inject that into the operation's kwargs.</font>
<font color="red"> 349.         if self._starting_token is not None:</font>
<font color="black"> 350.             # Don't need to do anything special if there is no starting</font>
<font color="black"> 351.             # token specified.</font>
<font color="red"> 352.             next_token = self._parse_starting_token()[0]</font>
<font color="red"> 353.             self._inject_token_into_kwargs(op_kwargs, next_token)</font>
<font color="red"> 354.         if self._page_size is not None:</font>
<font color="black"> 355.             # Pass the page size as the parameter name for limiting</font>
<font color="black"> 356.             # page size, also known as the limit_key.</font>
<font color="red"> 357.             op_kwargs[self._limit_key] = self._page_size</font>
<font color="black"> 358. </font>
<font color="green"> 359.     def _inject_token_into_kwargs(self, op_kwargs, next_token):</font>
<font color="red"> 360.         for name, token in next_token.items():</font>
<font color="red"> 361.             if (token is not None) and (token != 'None'):</font>
<font color="red"> 362.                 op_kwargs[name] = token</font>
<font color="red"> 363.             elif name in op_kwargs:</font>
<font color="red"> 364.                 del op_kwargs[name]</font>
<font color="black"> 365. </font>
<font color="green"> 366.     def _handle_first_request(self, parsed, primary_result_key,</font>
<font color="black"> 367.                               starting_truncation):</font>
<font color="black"> 368.         # If the payload is an array or string, we need to slice into it</font>
<font color="black"> 369.         # and only return the truncated amount.</font>
<font color="red"> 370.         starting_truncation = self._parse_starting_token()[1]</font>
<font color="red"> 371.         all_data = primary_result_key.search(parsed)</font>
<font color="red"> 372.         if isinstance(all_data, (list, six.string_types)):</font>
<font color="red"> 373.             data = all_data[starting_truncation:]</font>
<font color="black"> 374.         else:</font>
<font color="red"> 375.             data = None</font>
<font color="red"> 376.         set_value_from_jmespath(</font>
<font color="red"> 377.             parsed,</font>
<font color="red"> 378.             primary_result_key.expression,</font>
<font color="red"> 379.             data</font>
<font color="black"> 380.         )</font>
<font color="black"> 381.         # We also need to truncate any secondary result keys</font>
<font color="black"> 382.         # because they were not truncated in the previous last</font>
<font color="black"> 383.         # response.</font>
<font color="red"> 384.         for token in self.result_keys:</font>
<font color="red"> 385.             if token == primary_result_key:</font>
<font color="red"> 386.                 continue</font>
<font color="red"> 387.             sample = token.search(parsed)</font>
<font color="red"> 388.             if isinstance(sample, list):</font>
<font color="red"> 389.                 empty_value = []</font>
<font color="red"> 390.             elif isinstance(sample, six.string_types):</font>
<font color="red"> 391.                 empty_value = ''</font>
<font color="red"> 392.             elif isinstance(sample, (int, float)):</font>
<font color="red"> 393.                 empty_value = 0</font>
<font color="black"> 394.             else:</font>
<font color="red"> 395.                 empty_value = None</font>
<font color="red"> 396.             set_value_from_jmespath(parsed, token.expression, empty_value)</font>
<font color="red"> 397.         return starting_truncation</font>
<font color="black"> 398. </font>
<font color="green"> 399.     def _truncate_response(self, parsed, primary_result_key, truncate_amount,</font>
<font color="black"> 400.                            starting_truncation, next_token):</font>
<font color="red"> 401.         original = primary_result_key.search(parsed)</font>
<font color="red"> 402.         if original is None:</font>
<font color="red"> 403.             original = []</font>
<font color="red"> 404.         amount_to_keep = len(original) - truncate_amount</font>
<font color="red"> 405.         truncated = original[:amount_to_keep]</font>
<font color="red"> 406.         set_value_from_jmespath(</font>
<font color="red"> 407.             parsed,</font>
<font color="red"> 408.             primary_result_key.expression,</font>
<font color="red"> 409.             truncated</font>
<font color="black"> 410.         )</font>
<font color="black"> 411.         # The issue here is that even though we know how much we've truncated</font>
<font color="black"> 412.         # we need to account for this globally including any starting</font>
<font color="black"> 413.         # left truncation. For example:</font>
<font color="black"> 414.         # Raw response: [0,1,2,3]</font>
<font color="black"> 415.         # Starting index: 1</font>
<font color="black"> 416.         # Max items: 1</font>
<font color="black"> 417.         # Starting left truncation: [1, 2, 3]</font>
<font color="black"> 418.         # End right truncation for max items: [1]</font>
<font color="black"> 419.         # However, even though we only kept 1, this is post</font>
<font color="black"> 420.         # left truncation so the next starting index should be 2, not 1</font>
<font color="black"> 421.         # (left_truncation + amount_to_keep).</font>
<font color="black"> 422.         next_token['boto_truncate_amount'] = \</font>
<font color="red"> 423.             amount_to_keep + starting_truncation</font>
<font color="red"> 424.         self.resume_token = next_token</font>
<font color="black"> 425. </font>
<font color="green"> 426.     def _get_next_token(self, parsed):</font>
<font color="red"> 427.         if self._more_results is not None:</font>
<font color="red"> 428.             if not self._more_results.search(parsed):</font>
<font color="red"> 429.                 return {}</font>
<font color="red"> 430.         next_tokens = {}</font>
<font color="red"> 431.         for output_token, input_key in \</font>
<font color="red"> 432.                 zip(self._output_token, self._input_token):</font>
<font color="red"> 433.             next_token = output_token.search(parsed)</font>
<font color="black"> 434.             # We do not want to include any empty strings as actual tokens.</font>
<font color="black"> 435.             # Treat them as None.</font>
<font color="red"> 436.             if next_token:</font>
<font color="red"> 437.                 next_tokens[input_key] = next_token</font>
<font color="black"> 438.             else:</font>
<font color="red"> 439.                 next_tokens[input_key] = None</font>
<font color="red"> 440.         return next_tokens</font>
<font color="black"> 441. </font>
<font color="green"> 442.     def result_key_iters(self):</font>
<font color="red"> 443.         teed_results = tee(self, len(self.result_keys))</font>
<font color="red"> 444.         return [ResultKeyIterator(i, result_key) for i, result_key</font>
<font color="red"> 445.                 in zip(teed_results, self.result_keys)]</font>
<font color="black"> 446. </font>
<font color="green"> 447.     def build_full_result(self):</font>
<font color="red"> 448.         complete_result = {}</font>
<font color="red"> 449.         for response in self:</font>
<font color="red"> 450.             page = response</font>
<font color="black"> 451.             # We want to try to catch operation object pagination</font>
<font color="black"> 452.             # and format correctly for those. They come in the form</font>
<font color="black"> 453.             # of a tuple of two elements: (http_response, parsed_responsed).</font>
<font color="black"> 454.             # We want the parsed_response as that is what the page iterator</font>
<font color="black"> 455.             # uses. We can remove it though once operation objects are removed.</font>
<font color="red"> 456.             if isinstance(response, tuple) and len(response) == 2:</font>
<font color="red"> 457.                 page = response[1]</font>
<font color="black"> 458.             # We're incrementally building the full response page</font>
<font color="black"> 459.             # by page.  For each page in the response we need to</font>
<font color="black"> 460.             # inject the necessary components from the page</font>
<font color="black"> 461.             # into the complete_result.</font>
<font color="red"> 462.             for result_expression in self.result_keys:</font>
<font color="black"> 463.                 # In order to incrementally update a result key</font>
<font color="black"> 464.                 # we need to search the existing value from complete_result,</font>
<font color="black"> 465.                 # then we need to search the _current_ page for the</font>
<font color="black"> 466.                 # current result key value.  Then we append the current</font>
<font color="black"> 467.                 # value onto the existing value, and re-set that value</font>
<font color="black"> 468.                 # as the new value.</font>
<font color="red"> 469.                 result_value = result_expression.search(page)</font>
<font color="red"> 470.                 if result_value is None:</font>
<font color="red"> 471.                     continue</font>
<font color="red"> 472.                 existing_value = result_expression.search(complete_result)</font>
<font color="red"> 473.                 if existing_value is None:</font>
<font color="black"> 474.                     # Set the initial result</font>
<font color="red"> 475.                     set_value_from_jmespath(</font>
<font color="red"> 476.                         complete_result, result_expression.expression,</font>
<font color="red"> 477.                         result_value)</font>
<font color="red"> 478.                     continue</font>
<font color="black"> 479.                 # Now both result_value and existing_value contain something</font>
<font color="red"> 480.                 if isinstance(result_value, list):</font>
<font color="red"> 481.                     existing_value.extend(result_value)</font>
<font color="red"> 482.                 elif isinstance(result_value, (int, float, six.string_types)):</font>
<font color="black"> 483.                     # Modify the existing result with the sum or concatenation</font>
<font color="red"> 484.                     set_value_from_jmespath(</font>
<font color="red"> 485.                         complete_result, result_expression.expression,</font>
<font color="red"> 486.                         existing_value + result_value)</font>
<font color="red"> 487.         merge_dicts(complete_result, self.non_aggregate_part)</font>
<font color="red"> 488.         if self.resume_token is not None:</font>
<font color="red"> 489.             complete_result['NextToken'] = self.resume_token</font>
<font color="red"> 490.         return complete_result</font>
<font color="black"> 491. </font>
<font color="green"> 492.     def _parse_starting_token(self):</font>
<font color="red"> 493.         if self._starting_token is None:</font>
<font color="red"> 494.             return None</font>
<font color="black"> 495. </font>
<font color="black"> 496.         # The starting token is a dict passed as a base64 encoded string.</font>
<font color="red"> 497.         next_token = self._starting_token</font>
<font color="red"> 498.         try:</font>
<font color="red"> 499.             next_token = self._token_decoder.decode(next_token)</font>
<font color="red"> 500.             index = 0</font>
<font color="red"> 501.             if 'boto_truncate_amount' in next_token:</font>
<font color="red"> 502.                 index = next_token.get('boto_truncate_amount')</font>
<font color="red"> 503.                 del next_token['boto_truncate_amount']</font>
<font color="red"> 504.         except (ValueError, TypeError):</font>
<font color="red"> 505.             next_token, index = self._parse_starting_token_deprecated()</font>
<font color="red"> 506.         return next_token, index</font>
<font color="black"> 507. </font>
<font color="green"> 508.     def _parse_starting_token_deprecated(self):</font>
<font color="black"> 509.         &quot;&quot;&quot;</font>
<font color="black"> 510.         This handles parsing of old style starting tokens, and attempts to</font>
<font color="black"> 511.         coerce them into the new style.</font>
<font color="black"> 512.         &quot;&quot;&quot;</font>
<font color="red"> 513.         log.debug(&quot;Attempting to fall back to old starting token parser. For &quot;</font>
<font color="red"> 514.                   &quot;token: %s&quot; % self._starting_token)</font>
<font color="red"> 515.         if self._starting_token is None:</font>
<font color="red"> 516.             return None</font>
<font color="black"> 517. </font>
<font color="red"> 518.         parts = self._starting_token.split('___')</font>
<font color="red"> 519.         next_token = []</font>
<font color="red"> 520.         index = 0</font>
<font color="red"> 521.         if len(parts) == len(self._input_token) + 1:</font>
<font color="red"> 522.             try:</font>
<font color="red"> 523.                 index = int(parts.pop())</font>
<font color="red"> 524.             except ValueError:</font>
<font color="red"> 525.                 raise ValueError(&quot;Bad starting token: %s&quot; %</font>
<font color="red"> 526.                                  self._starting_token)</font>
<font color="red"> 527.         for part in parts:</font>
<font color="red"> 528.             if part == 'None':</font>
<font color="red"> 529.                 next_token.append(None)</font>
<font color="black"> 530.             else:</font>
<font color="red"> 531.                 next_token.append(part)</font>
<font color="red"> 532.         return self._convert_deprecated_starting_token(next_token), index</font>
<font color="black"> 533. </font>
<font color="green"> 534.     def _convert_deprecated_starting_token(self, deprecated_token):</font>
<font color="black"> 535.         &quot;&quot;&quot;</font>
<font color="black"> 536.         This attempts to convert a deprecated starting token into the new</font>
<font color="black"> 537.         style.</font>
<font color="black"> 538.         &quot;&quot;&quot;</font>
<font color="red"> 539.         len_deprecated_token = len(deprecated_token)</font>
<font color="red"> 540.         len_input_token = len(self._input_token)</font>
<font color="red"> 541.         if len_deprecated_token &gt; len_input_token:</font>
<font color="red"> 542.             raise ValueError(&quot;Bad starting token: %s&quot; % self._starting_token)</font>
<font color="red"> 543.         elif len_deprecated_token &lt; len_input_token:</font>
<font color="red"> 544.             log.debug(&quot;Old format starting token does not contain all input &quot;</font>
<font color="black"> 545.                       &quot;tokens. Setting the rest, in order, as None.&quot;)</font>
<font color="red"> 546.             for i in range(len_input_token - len_deprecated_token):</font>
<font color="red"> 547.                 deprecated_token.append(None)</font>
<font color="red"> 548.         return dict(zip(self._input_token, deprecated_token))</font>
<font color="black"> 549. </font>
<font color="black"> 550. </font>
<font color="green"> 551. class Paginator(object):</font>
<font color="green"> 552.     PAGE_ITERATOR_CLS = PageIterator</font>
<font color="black"> 553. </font>
<font color="green"> 554.     def __init__(self, method, pagination_config, model):</font>
<font color="red"> 555.         self._model = model</font>
<font color="red"> 556.         self._method = method</font>
<font color="red"> 557.         self._pagination_cfg = pagination_config</font>
<font color="red"> 558.         self._output_token = self._get_output_tokens(self._pagination_cfg)</font>
<font color="red"> 559.         self._input_token = self._get_input_tokens(self._pagination_cfg)</font>
<font color="red"> 560.         self._more_results = self._get_more_results_token(self._pagination_cfg)</font>
<font color="red"> 561.         self._non_aggregate_keys = self._get_non_aggregate_keys(</font>
<font color="red"> 562.             self._pagination_cfg)</font>
<font color="red"> 563.         self._result_keys = self._get_result_keys(self._pagination_cfg)</font>
<font color="red"> 564.         self._limit_key = self._get_limit_key(self._pagination_cfg)</font>
<font color="black"> 565. </font>
<font color="green"> 566.     @property</font>
<font color="black"> 567.     def result_keys(self):</font>
<font color="red"> 568.         return self._result_keys</font>
<font color="black"> 569. </font>
<font color="green"> 570.     def _get_non_aggregate_keys(self, config):</font>
<font color="red"> 571.         keys = []</font>
<font color="red"> 572.         for key in config.get('non_aggregate_keys', []):</font>
<font color="red"> 573.             keys.append(jmespath.compile(key))</font>
<font color="red"> 574.         return keys</font>
<font color="black"> 575. </font>
<font color="green"> 576.     def _get_output_tokens(self, config):</font>
<font color="red"> 577.         output = []</font>
<font color="red"> 578.         output_token = config['output_token']</font>
<font color="red"> 579.         if not isinstance(output_token, list):</font>
<font color="red"> 580.             output_token = [output_token]</font>
<font color="red"> 581.         for config in output_token:</font>
<font color="red"> 582.             output.append(jmespath.compile(config))</font>
<font color="red"> 583.         return output</font>
<font color="black"> 584. </font>
<font color="green"> 585.     def _get_input_tokens(self, config):</font>
<font color="red"> 586.         input_token = self._pagination_cfg['input_token']</font>
<font color="red"> 587.         if not isinstance(input_token, list):</font>
<font color="red"> 588.             input_token = [input_token]</font>
<font color="red"> 589.         return input_token</font>
<font color="black"> 590. </font>
<font color="green"> 591.     def _get_more_results_token(self, config):</font>
<font color="red"> 592.         more_results = config.get('more_results')</font>
<font color="red"> 593.         if more_results is not None:</font>
<font color="red"> 594.             return jmespath.compile(more_results)</font>
<font color="black"> 595. </font>
<font color="green"> 596.     def _get_result_keys(self, config):</font>
<font color="red"> 597.         result_key = config.get('result_key')</font>
<font color="red"> 598.         if result_key is not None:</font>
<font color="red"> 599.             if not isinstance(result_key, list):</font>
<font color="red"> 600.                 result_key = [result_key]</font>
<font color="red"> 601.             result_key = [jmespath.compile(rk) for rk in result_key]</font>
<font color="red"> 602.             return result_key</font>
<font color="black"> 603. </font>
<font color="green"> 604.     def _get_limit_key(self, config):</font>
<font color="red"> 605.         return config.get('limit_key')</font>
<font color="black"> 606. </font>
<font color="green"> 607.     def paginate(self, **kwargs):</font>
<font color="black"> 608.         &quot;&quot;&quot;Create paginator object for an operation.</font>
<font color="black"> 609. </font>
<font color="black"> 610.         This returns an iterable object.  Iterating over</font>
<font color="black"> 611.         this object will yield a single page of a response</font>
<font color="black"> 612.         at a time.</font>
<font color="black"> 613. </font>
<font color="black"> 614.         &quot;&quot;&quot;</font>
<font color="red"> 615.         page_params = self._extract_paging_params(kwargs)</font>
<font color="red"> 616.         return self.PAGE_ITERATOR_CLS(</font>
<font color="red"> 617.             self._method, self._input_token,</font>
<font color="red"> 618.             self._output_token, self._more_results,</font>
<font color="red"> 619.             self._result_keys, self._non_aggregate_keys,</font>
<font color="red"> 620.             self._limit_key,</font>
<font color="red"> 621.             page_params['MaxItems'],</font>
<font color="red"> 622.             page_params['StartingToken'],</font>
<font color="red"> 623.             page_params['PageSize'],</font>
<font color="red"> 624.             kwargs)</font>
<font color="black"> 625. </font>
<font color="green"> 626.     def _extract_paging_params(self, kwargs):</font>
<font color="red"> 627.         pagination_config = kwargs.pop('PaginationConfig', {})</font>
<font color="red"> 628.         max_items = pagination_config.get('MaxItems', None)</font>
<font color="red"> 629.         if max_items is not None:</font>
<font color="red"> 630.             max_items = int(max_items)</font>
<font color="red"> 631.         page_size = pagination_config.get('PageSize', None)</font>
<font color="red"> 632.         if page_size is not None:</font>
<font color="red"> 633.             if self._limit_key is None:</font>
<font color="red"> 634.                 raise PaginationError(</font>
<font color="red"> 635.                     message=&quot;PageSize parameter is not supported for the &quot;</font>
<font color="black"> 636.                             &quot;pagination interface for this operation.&quot;)</font>
<font color="red"> 637.             input_members = self._model.input_shape.members</font>
<font color="red"> 638.             limit_key_shape = input_members.get(self._limit_key)</font>
<font color="red"> 639.             if limit_key_shape.type_name == 'string':</font>
<font color="red"> 640.                 if not isinstance(page_size, six.string_types):</font>
<font color="red"> 641.                     page_size = str(page_size)</font>
<font color="black"> 642.             else:</font>
<font color="red"> 643.                 page_size = int(page_size)</font>
<font color="red"> 644.         return {</font>
<font color="red"> 645.             'MaxItems': max_items,</font>
<font color="red"> 646.             'StartingToken': pagination_config.get('StartingToken', None),</font>
<font color="red"> 647.             'PageSize': page_size,</font>
<font color="black"> 648.         }</font>
<font color="black"> 649. </font>
<font color="black"> 650. </font>
<font color="green"> 651. class ResultKeyIterator(object):</font>
<font color="black"> 652.     &quot;&quot;&quot;Iterates over the results of paginated responses.</font>
<font color="black"> 653. </font>
<font color="black"> 654.     Each iterator is associated with a single result key.</font>
<font color="black"> 655.     Iterating over this object will give you each element in</font>
<font color="black"> 656.     the result key list.</font>
<font color="black"> 657. </font>
<font color="black"> 658.     :param pages_iterator: An iterator that will give you</font>
<font color="black"> 659.         pages of results (a ``PageIterator`` class).</font>
<font color="black"> 660.     :param result_key: The JMESPath expression representing</font>
<font color="black"> 661.         the result key.</font>
<font color="black"> 662. </font>
<font color="green"> 663.     &quot;&quot;&quot;</font>
<font color="black"> 664. </font>
<font color="green"> 665.     def __init__(self, pages_iterator, result_key):</font>
<font color="red"> 666.         self._pages_iterator = pages_iterator</font>
<font color="red"> 667.         self.result_key = result_key</font>
<font color="black"> 668. </font>
<font color="green"> 669.     def __iter__(self):</font>
<font color="red"> 670.         for page in self._pages_iterator:</font>
<font color="red"> 671.             results = self.result_key.search(page)</font>
<font color="red"> 672.             if results is None:</font>
<font color="red"> 673.                 results = []</font>
<font color="red"> 674.             for result in results:</font>
<font color="red"> 675.                 yield result</font>
</pre>

