source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/configloader.py</b><br>


file stats: <b>86 lines, 44 executed: 51.2% covered</b>
<pre>
<font color="black">   1. # Copyright (c) 2012-2013 Mitch Garnaat http://garnaat.org/</font>
<font color="black">   2. # Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   3. #</font>
<font color="black">   4. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   5. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   6. # the License is located at</font>
<font color="black">   7. #</font>
<font color="black">   8. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   9. #</font>
<font color="black">  10. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  11. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  12. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  13. # language governing permissions and limitations under the License.</font>
<font color="green">  14. import os</font>
<font color="green">  15. import shlex</font>
<font color="green">  16. import copy</font>
<font color="green">  17. import sys</font>
<font color="black">  18. </font>
<font color="green">  19. from botocore.compat import six</font>
<font color="black">  20. </font>
<font color="green">  21. import botocore.exceptions</font>
<font color="black">  22. </font>
<font color="black">  23. </font>
<font color="green">  24. def multi_file_load_config(*filenames):</font>
<font color="black">  25.     &quot;&quot;&quot;Load and combine multiple INI configs with profiles.</font>
<font color="black">  26. </font>
<font color="black">  27.     This function will take a list of filesnames and return</font>
<font color="black">  28.     a single dictionary that represents the merging of the loaded</font>
<font color="black">  29.     config files.</font>
<font color="black">  30. </font>
<font color="black">  31.     If any of the provided filenames does not exist, then that file</font>
<font color="black">  32.     is ignored.  It is therefore ok to provide a list of filenames,</font>
<font color="black">  33.     some of which may not exist.</font>
<font color="black">  34. </font>
<font color="black">  35.     Configuration files are **not** deep merged, only the top level</font>
<font color="black">  36.     keys are merged.  The filenames should be passed in order of</font>
<font color="black">  37.     precedence.  The first config file has precedence over the</font>
<font color="black">  38.     second config file, which has precedence over the third config file,</font>
<font color="black">  39.     etc.  The only exception to this is that the &quot;profiles&quot; key is</font>
<font color="black">  40.     merged to combine profiles from multiple config files into a</font>
<font color="black">  41.     single profiles mapping.  However, if a profile is defined in</font>
<font color="black">  42.     multiple config files, then the config file with the highest</font>
<font color="black">  43.     precedence is used.  Profile values themselves are not merged.</font>
<font color="black">  44.     For example::</font>
<font color="black">  45. </font>
<font color="black">  46.         FileA              FileB                FileC</font>
<font color="black">  47.         [foo]             [foo]                 [bar]</font>
<font color="black">  48.         a=1               a=2                   a=3</font>
<font color="black">  49.                           b=2</font>
<font color="black">  50. </font>
<font color="black">  51.         [bar]             [baz]                [profile a]</font>
<font color="black">  52.         a=2               a=3                  region=e</font>
<font color="black">  53. </font>
<font color="black">  54.         [profile a]       [profile b]          [profile c]</font>
<font color="black">  55.         region=c          region=d             region=f</font>
<font color="black">  56. </font>
<font color="black">  57.     The final result of ``multi_file_load_config(FileA, FileB, FileC)``</font>
<font color="black">  58.     would be::</font>
<font color="black">  59. </font>
<font color="black">  60.         {&quot;foo&quot;: {&quot;a&quot;: 1}, &quot;bar&quot;: {&quot;a&quot;: 2}, &quot;baz&quot;: {&quot;a&quot;: 3},</font>
<font color="black">  61.         &quot;profiles&quot;: {&quot;a&quot;: {&quot;region&quot;: &quot;c&quot;}}, {&quot;b&quot;: {&quot;region&quot;: d&quot;}},</font>
<font color="black">  62.                     {&quot;c&quot;: {&quot;region&quot;: &quot;f&quot;}}}</font>
<font color="black">  63. </font>
<font color="black">  64.     Note that the &quot;foo&quot; key comes from A, even though it's defined in both</font>
<font color="black">  65.     FileA and FileB.  Because &quot;foo&quot; was defined in FileA first, then the values</font>
<font color="black">  66.     for &quot;foo&quot; from FileA are used and the values for &quot;foo&quot; from FileB are</font>
<font color="black">  67.     ignored.  Also note where the profiles originate from.  Profile &quot;a&quot;</font>
<font color="black">  68.     comes FileA, profile &quot;b&quot; comes from FileB, and profile &quot;c&quot; comes</font>
<font color="black">  69.     from FileC.</font>
<font color="black">  70. </font>
<font color="black">  71.     &quot;&quot;&quot;</font>
<font color="red">  72.     configs = []</font>
<font color="red">  73.     profiles = []</font>
<font color="red">  74.     for filename in filenames:</font>
<font color="red">  75.         try:</font>
<font color="red">  76.             loaded = load_config(filename)</font>
<font color="red">  77.         except botocore.exceptions.ConfigNotFound:</font>
<font color="red">  78.             continue</font>
<font color="red">  79.         profiles.append(loaded.pop('profiles'))</font>
<font color="red">  80.         configs.append(loaded)</font>
<font color="red">  81.     merged_config = _merge_list_of_dicts(configs)</font>
<font color="red">  82.     merged_profiles = _merge_list_of_dicts(profiles)</font>
<font color="red">  83.     merged_config['profiles'] = merged_profiles</font>
<font color="red">  84.     return merged_config</font>
<font color="black">  85. </font>
<font color="black">  86. </font>
<font color="green">  87. def _merge_list_of_dicts(list_of_dicts):</font>
<font color="red">  88.     merged_dicts = {}</font>
<font color="red">  89.     for single_dict in list_of_dicts:</font>
<font color="red">  90.         for key, value in single_dict.items():</font>
<font color="red">  91.             if key not in merged_dicts:</font>
<font color="red">  92.                 merged_dicts[key] = value</font>
<font color="red">  93.     return merged_dicts</font>
<font color="black">  94. </font>
<font color="black">  95. </font>
<font color="green">  96. def load_config(config_filename):</font>
<font color="black">  97.     &quot;&quot;&quot;Parse a INI config with profiles.</font>
<font color="black">  98. </font>
<font color="black">  99.     This will parse an INI config file and map top level profiles</font>
<font color="black"> 100.     into a top level &quot;profile&quot; key.</font>
<font color="black"> 101. </font>
<font color="black"> 102.     If you want to parse an INI file and map all section names to</font>
<font color="black"> 103.     top level keys, use ``raw_config_parse`` instead.</font>
<font color="black"> 104. </font>
<font color="black"> 105.     &quot;&quot;&quot;</font>
<font color="green"> 106.     parsed = raw_config_parse(config_filename)</font>
<font color="green"> 107.     return build_profile_map(parsed)</font>
<font color="black"> 108. </font>
<font color="black"> 109. </font>
<font color="green"> 110. def raw_config_parse(config_filename, parse_subsections=True):</font>
<font color="black"> 111.     &quot;&quot;&quot;Returns the parsed INI config contents.</font>
<font color="black"> 112. </font>
<font color="black"> 113.     Each section name is a top level key.</font>
<font color="black"> 114. </font>
<font color="black"> 115.     :param config_filename: The name of the INI file to parse</font>
<font color="black"> 116. </font>
<font color="black"> 117.     :param parse_subsections: If True, parse indented blocks as</font>
<font color="black"> 118.        subsections that represent their own configuration dictionary.</font>
<font color="black"> 119.        For example, if the config file had the contents::</font>
<font color="black"> 120. </font>
<font color="black"> 121.            s3 =</font>
<font color="black"> 122.               signature_version = s3v4</font>
<font color="black"> 123.               addressing_style = path</font>
<font color="black"> 124. </font>
<font color="black"> 125.         The resulting ``raw_config_parse`` would be::</font>
<font color="black"> 126. </font>
<font color="black"> 127.             {'s3': {'signature_version': 's3v4', 'addressing_style': 'path'}}</font>
<font color="black"> 128. </font>
<font color="black"> 129.        If False, do not try to parse subsections and return the indented</font>
<font color="black"> 130.        block as its literal value::</font>
<font color="black"> 131. </font>
<font color="black"> 132.             {'s3': '\nsignature_version = s3v4\naddressing_style = path'}</font>
<font color="black"> 133. </font>
<font color="black"> 134.     :returns: A dict with keys for each profile found in the config</font>
<font color="black"> 135.         file and the value of each key being a dict containing name</font>
<font color="black"> 136.         value pairs found in that profile.</font>
<font color="black"> 137. </font>
<font color="black"> 138.     :raises: ConfigNotFound, ConfigParseError</font>
<font color="black"> 139.     &quot;&quot;&quot;</font>
<font color="green"> 140.     config = {}</font>
<font color="green"> 141.     path = config_filename</font>
<font color="green"> 142.     if path is not None:</font>
<font color="green"> 143.         path = os.path.expandvars(path)</font>
<font color="green"> 144.         path = os.path.expanduser(path)</font>
<font color="green"> 145.         if not os.path.isfile(path):</font>
<font color="red"> 146.             raise botocore.exceptions.ConfigNotFound(path=_unicode_path(path))</font>
<font color="green"> 147.         cp = six.moves.configparser.RawConfigParser()</font>
<font color="green"> 148.         try:</font>
<font color="green"> 149.             cp.read([path])</font>
<font color="red"> 150.         except six.moves.configparser.Error:</font>
<font color="red"> 151.             raise botocore.exceptions.ConfigParseError(</font>
<font color="red"> 152.                 path=_unicode_path(path))</font>
<font color="black"> 153.         else:</font>
<font color="green"> 154.             for section in cp.sections():</font>
<font color="green"> 155.                 config[section] = {}</font>
<font color="green"> 156.                 for option in cp.options(section):</font>
<font color="green"> 157.                     config_value = cp.get(section, option)</font>
<font color="green"> 158.                     if parse_subsections and config_value.startswith('\n'):</font>
<font color="black"> 159.                         # Then we need to parse the inner contents as</font>
<font color="black"> 160.                         # hierarchical.  We support a single level</font>
<font color="black"> 161.                         # of nesting for now.</font>
<font color="red"> 162.                         try:</font>
<font color="red"> 163.                             config_value = _parse_nested(config_value)</font>
<font color="red"> 164.                         except ValueError:</font>
<font color="red"> 165.                             raise botocore.exceptions.ConfigParseError(</font>
<font color="red"> 166.                                 path=_unicode_path(path))</font>
<font color="green"> 167.                     config[section][option] = config_value</font>
<font color="green"> 168.     return config</font>
<font color="black"> 169. </font>
<font color="black"> 170. </font>
<font color="green"> 171. def _unicode_path(path):</font>
<font color="red"> 172.     if isinstance(path, six.text_type):</font>
<font color="red"> 173.         return path</font>
<font color="red"> 174.     return path.decode(sys.getfilesystemencoding(), 'replace')</font>
<font color="black"> 175. </font>
<font color="black"> 176. </font>
<font color="green"> 177. def _parse_nested(config_value):</font>
<font color="black"> 178.     # Given a value like this:</font>
<font color="black"> 179.     # \n</font>
<font color="black"> 180.     # foo = bar</font>
<font color="black"> 181.     # bar = baz</font>
<font color="black"> 182.     # We need to parse this into</font>
<font color="black"> 183.     # {'foo': 'bar', 'bar': 'baz}</font>
<font color="red"> 184.     parsed = {}</font>
<font color="red"> 185.     for line in config_value.splitlines():</font>
<font color="red"> 186.         line = line.strip()</font>
<font color="red"> 187.         if not line:</font>
<font color="red"> 188.             continue</font>
<font color="black"> 189.         # The caller will catch ValueError</font>
<font color="black"> 190.         # and raise an appropriate error</font>
<font color="black"> 191.         # if this fails.</font>
<font color="red"> 192.         key, value = line.split('=', 1)</font>
<font color="red"> 193.         parsed[key.strip()] = value.strip()</font>
<font color="red"> 194.     return parsed</font>
<font color="black"> 195. </font>
<font color="black"> 196. </font>
<font color="green"> 197. def build_profile_map(parsed_ini_config):</font>
<font color="black"> 198.     &quot;&quot;&quot;Convert the parsed INI config into a profile map.</font>
<font color="black"> 199. </font>
<font color="black"> 200.     The config file format requires that every profile except the</font>
<font color="black"> 201.     default to be prepended with &quot;profile&quot;, e.g.::</font>
<font color="black"> 202. </font>
<font color="black"> 203.         [profile test]</font>
<font color="black"> 204.         aws_... = foo</font>
<font color="black"> 205.         aws_... = bar</font>
<font color="black"> 206. </font>
<font color="black"> 207.         [profile bar]</font>
<font color="black"> 208.         aws_... = foo</font>
<font color="black"> 209.         aws_... = bar</font>
<font color="black"> 210. </font>
<font color="black"> 211.         # This is *not* a profile</font>
<font color="black"> 212.         [preview]</font>
<font color="black"> 213.         otherstuff = 1</font>
<font color="black"> 214. </font>
<font color="black"> 215.         # Neither is this</font>
<font color="black"> 216.         [foobar]</font>
<font color="black"> 217.         morestuff = 2</font>
<font color="black"> 218. </font>
<font color="black"> 219.     The build_profile_map will take a parsed INI config file where each top</font>
<font color="black"> 220.     level key represents a section name, and convert into a format where all</font>
<font color="black"> 221.     the profiles are under a single top level &quot;profiles&quot; key, and each key in</font>
<font color="black"> 222.     the sub dictionary is a profile name.  For example, the above config file</font>
<font color="black"> 223.     would be converted from::</font>
<font color="black"> 224. </font>
<font color="black"> 225.         {&quot;profile test&quot;: {&quot;aws_...&quot;: &quot;foo&quot;, &quot;aws...&quot;: &quot;bar&quot;},</font>
<font color="black"> 226.          &quot;profile bar&quot;: {&quot;aws...&quot;: &quot;foo&quot;, &quot;aws...&quot;: &quot;bar&quot;},</font>
<font color="black"> 227.          &quot;preview&quot;: {&quot;otherstuff&quot;: ...},</font>
<font color="black"> 228.          &quot;foobar&quot;: {&quot;morestuff&quot;: ...},</font>
<font color="black"> 229.          }</font>
<font color="black"> 230. </font>
<font color="black"> 231.     into::</font>
<font color="black"> 232. </font>
<font color="black"> 233.         {&quot;profiles&quot;: {&quot;test&quot;: {&quot;aws_...&quot;: &quot;foo&quot;, &quot;aws...&quot;: &quot;bar&quot;},</font>
<font color="black"> 234.                       &quot;bar&quot;: {&quot;aws...&quot;: &quot;foo&quot;, &quot;aws...&quot;: &quot;bar&quot;},</font>
<font color="black"> 235.          &quot;preview&quot;: {&quot;otherstuff&quot;: ...},</font>
<font color="black"> 236.          &quot;foobar&quot;: {&quot;morestuff&quot;: ...},</font>
<font color="black"> 237.         }</font>
<font color="black"> 238. </font>
<font color="black"> 239.     If there are no profiles in the provided parsed INI contents, then</font>
<font color="black"> 240.     an empty dict will be the value associated with the ``profiles`` key.</font>
<font color="black"> 241. </font>
<font color="black"> 242.     .. note::</font>
<font color="black"> 243. </font>
<font color="black"> 244.         This will not mutate the passed in parsed_ini_config.  Instead it will</font>
<font color="black"> 245.         make a deepcopy and return that value.</font>
<font color="black"> 246. </font>
<font color="black"> 247.     &quot;&quot;&quot;</font>
<font color="green"> 248.     parsed_config = copy.deepcopy(parsed_ini_config)</font>
<font color="green"> 249.     profiles = {}</font>
<font color="green"> 250.     final_config = {}</font>
<font color="green"> 251.     for key, values in parsed_config.items():</font>
<font color="green"> 252.         if key.startswith(&quot;profile&quot;):</font>
<font color="green"> 253.             try:</font>
<font color="green"> 254.                 parts = shlex.split(key)</font>
<font color="red"> 255.             except ValueError:</font>
<font color="red"> 256.                 continue</font>
<font color="green"> 257.             if len(parts) == 2:</font>
<font color="green"> 258.                 profiles[parts[1]] = values</font>
<font color="green"> 259.         elif key == 'default':</font>
<font color="black"> 260.             # default section is special and is considered a profile</font>
<font color="black"> 261.             # name but we don't require you use 'profile &quot;default&quot;'</font>
<font color="black"> 262.             # as a section.</font>
<font color="green"> 263.             profiles[key] = values</font>
<font color="black"> 264.         else:</font>
<font color="red"> 265.             final_config[key] = values</font>
<font color="green"> 266.     final_config['profiles'] = profiles</font>
<font color="green"> 267.     return final_config</font>
</pre>

