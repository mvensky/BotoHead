source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/jmespath/visitor.py</b><br>


file stats: <b>202 lines, 53 executed: 26.2% covered</b>
<pre>
<font color="green">   1. import operator</font>
<font color="black">   2. </font>
<font color="green">   3. from jmespath import functions</font>
<font color="black">   4. </font>
<font color="black">   5. </font>
<font color="green">   6. def _equals(x, y):</font>
<font color="red">   7.     if _is_special_integer_case(x, y):</font>
<font color="red">   8.         return False</font>
<font color="black">   9.     else:</font>
<font color="red">  10.         return x == y</font>
<font color="black">  11. </font>
<font color="black">  12. </font>
<font color="green">  13. def _is_special_integer_case(x, y):</font>
<font color="black">  14.     # We need to special case comparing 0 or 1 to</font>
<font color="black">  15.     # True/False.  While normally comparing any</font>
<font color="black">  16.     # integer other than 0/1 to True/False will always</font>
<font color="black">  17.     # return False.  However 0/1 have this:</font>
<font color="black">  18.     # &gt;&gt;&gt; 0 == True</font>
<font color="black">  19.     # False</font>
<font color="black">  20.     # &gt;&gt;&gt; 0 == False</font>
<font color="black">  21.     # True</font>
<font color="black">  22.     # &gt;&gt;&gt; 1 == True</font>
<font color="black">  23.     # True</font>
<font color="black">  24.     # &gt;&gt;&gt; 1 == False</font>
<font color="black">  25.     # False</font>
<font color="black">  26.     #</font>
<font color="black">  27.     # Also need to consider that:</font>
<font color="black">  28.     # &gt;&gt;&gt; 0 in [True, False]</font>
<font color="black">  29.     # True</font>
<font color="red">  30.     if x is 0 or x is 1:</font>
<font color="red">  31.         return y is True or y is False</font>
<font color="red">  32.     elif y is 0 or y is 1:</font>
<font color="red">  33.         return x is True or x is False</font>
<font color="black">  34. </font>
<font color="black">  35. </font>
<font color="green">  36. class Options(object):</font>
<font color="green">  37.     &quot;&quot;&quot;Options to control how a JMESPath function is evaluated.&quot;&quot;&quot;</font>
<font color="green">  38.     def __init__(self, dict_cls):</font>
<font color="black">  39.         #: The class to use when creating a dict.  The interpreter</font>
<font color="black">  40.         #  may create dictionaries during the evalution of a JMESPath</font>
<font color="black">  41.         #  expression.  For example, a multi-select hash will</font>
<font color="black">  42.         #  create a dictionary.  By default we use a dict() type.</font>
<font color="black">  43.         #  You can set this value to change what dict type is used.</font>
<font color="black">  44.         #  The most common reason you would change this is if you</font>
<font color="black">  45.         #  want to set a collections.OrderedDict so that you can</font>
<font color="black">  46.         #  have predictible key ordering.</font>
<font color="red">  47.         self.dict_cls = dict_cls</font>
<font color="black">  48. </font>
<font color="black">  49. </font>
<font color="green">  50. class _Expression(object):</font>
<font color="green">  51.     def __init__(self, expression):</font>
<font color="red">  52.         self.expression = expression</font>
<font color="black">  53. </font>
<font color="black">  54. </font>
<font color="green">  55. class Visitor(object):</font>
<font color="green">  56.     def __init__(self):</font>
<font color="red">  57.         self._method_cache = {}</font>
<font color="black">  58. </font>
<font color="green">  59.     def visit(self, node, *args, **kwargs):</font>
<font color="red">  60.         node_type = node['type']</font>
<font color="red">  61.         method = self._method_cache.get(node_type)</font>
<font color="red">  62.         if method is None:</font>
<font color="red">  63.             method = getattr(</font>
<font color="red">  64.                 self, 'visit_%s' % node['type'], self.default_visit)</font>
<font color="red">  65.             self._method_cache[node_type] = method</font>
<font color="red">  66.         return method(node, *args, **kwargs)</font>
<font color="black">  67. </font>
<font color="green">  68.     def default_visit(self, node, *args, **kwargs):</font>
<font color="red">  69.         raise NotImplementedError(&quot;default_visit&quot;)</font>
<font color="black">  70. </font>
<font color="black">  71. </font>
<font color="green">  72. class TreeInterpreter(Visitor):</font>
<font color="green">  73.     COMPARATOR_FUNC = {</font>
<font color="green">  74.         'le': operator.le,</font>
<font color="green">  75.         'ne': lambda x, y: not _equals(x, y),</font>
<font color="green">  76.         'lt': operator.lt,</font>
<font color="green">  77.         'lte': operator.le,</font>
<font color="green">  78.         'eq': _equals,</font>
<font color="green">  79.         'gt': operator.gt,</font>
<font color="green">  80.         'gte': operator.ge</font>
<font color="black">  81.     }</font>
<font color="green">  82.     MAP_TYPE = dict</font>
<font color="black">  83. </font>
<font color="green">  84.     def __init__(self, options=None):</font>
<font color="red">  85.         super(TreeInterpreter, self).__init__()</font>
<font color="red">  86.         self._options = options</font>
<font color="red">  87.         self._dict_cls = self.MAP_TYPE</font>
<font color="red">  88.         if options is not None and options.dict_cls is not None:</font>
<font color="red">  89.             self._dict_cls = self._options.dict_cls</font>
<font color="red">  90.         self._functions = functions.RuntimeFunctions()</font>
<font color="black">  91.         # Note that .interpreter is a property that uses</font>
<font color="black">  92.         # a weakref so that the cyclic reference can be</font>
<font color="black">  93.         # properly freed.</font>
<font color="red">  94.         self._functions.interpreter = self</font>
<font color="black">  95. </font>
<font color="green">  96.     def default_visit(self, node, *args, **kwargs):</font>
<font color="red">  97.         raise NotImplementedError(node['type'])</font>
<font color="black">  98. </font>
<font color="green">  99.     def visit_subexpression(self, node, value):</font>
<font color="red"> 100.         result = value</font>
<font color="red"> 101.         for node in node['children']:</font>
<font color="red"> 102.             result = self.visit(node, result)</font>
<font color="red"> 103.         return result</font>
<font color="black"> 104. </font>
<font color="green"> 105.     def visit_field(self, node, value):</font>
<font color="red"> 106.         try:</font>
<font color="red"> 107.             return value.get(node['value'])</font>
<font color="red"> 108.         except AttributeError:</font>
<font color="red"> 109.             return None</font>
<font color="black"> 110. </font>
<font color="green"> 111.     def visit_comparator(self, node, value):</font>
<font color="red"> 112.         comparator_func = self.COMPARATOR_FUNC[node['value']]</font>
<font color="red"> 113.         return comparator_func(</font>
<font color="red"> 114.             self.visit(node['children'][0], value),</font>
<font color="red"> 115.             self.visit(node['children'][1], value)</font>
<font color="black"> 116.         )</font>
<font color="black"> 117. </font>
<font color="green"> 118.     def visit_current(self, node, value):</font>
<font color="red"> 119.         return value</font>
<font color="black"> 120. </font>
<font color="green"> 121.     def visit_expref(self, node, value):</font>
<font color="red"> 122.         return _Expression(node['children'][0])</font>
<font color="black"> 123. </font>
<font color="green"> 124.     def visit_function_expression(self, node, value):</font>
<font color="red"> 125.         resolved_args = []</font>
<font color="red"> 126.         for child in node['children']:</font>
<font color="red"> 127.             current = self.visit(child, value)</font>
<font color="red"> 128.             resolved_args.append(current)</font>
<font color="red"> 129.         return self._functions.call_function(node['value'], resolved_args)</font>
<font color="black"> 130. </font>
<font color="green"> 131.     def visit_filter_projection(self, node, value):</font>
<font color="red"> 132.         base = self.visit(node['children'][0], value)</font>
<font color="red"> 133.         if not isinstance(base, list):</font>
<font color="red"> 134.             return None</font>
<font color="red"> 135.         comparator_node = node['children'][2]</font>
<font color="red"> 136.         collected = []</font>
<font color="red"> 137.         for element in base:</font>
<font color="red"> 138.             if self._is_true(self.visit(comparator_node, element)):</font>
<font color="red"> 139.                 current = self.visit(node['children'][1], element)</font>
<font color="red"> 140.                 if current is not None:</font>
<font color="red"> 141.                     collected.append(current)</font>
<font color="red"> 142.         return collected</font>
<font color="black"> 143. </font>
<font color="green"> 144.     def visit_flatten(self, node, value):</font>
<font color="red"> 145.         base = self.visit(node['children'][0], value)</font>
<font color="red"> 146.         if not isinstance(base, list):</font>
<font color="black"> 147.             # Can't flatten the object if it's not a list.</font>
<font color="red"> 148.             return None</font>
<font color="red"> 149.         merged_list = []</font>
<font color="red"> 150.         for element in base:</font>
<font color="red"> 151.             if isinstance(element, list):</font>
<font color="red"> 152.                 merged_list.extend(element)</font>
<font color="black"> 153.             else:</font>
<font color="red"> 154.                 merged_list.append(element)</font>
<font color="red"> 155.         return merged_list</font>
<font color="black"> 156. </font>
<font color="green"> 157.     def visit_identity(self, node, value):</font>
<font color="red"> 158.         return value</font>
<font color="black"> 159. </font>
<font color="green"> 160.     def visit_index(self, node, value):</font>
<font color="black"> 161.         # Even though we can index strings, we don't</font>
<font color="black"> 162.         # want to support that.</font>
<font color="red"> 163.         if not isinstance(value, list):</font>
<font color="red"> 164.             return None</font>
<font color="red"> 165.         try:</font>
<font color="red"> 166.             return value[node['value']]</font>
<font color="red"> 167.         except IndexError:</font>
<font color="red"> 168.             return None</font>
<font color="black"> 169. </font>
<font color="green"> 170.     def visit_index_expression(self, node, value):</font>
<font color="red"> 171.         result = value</font>
<font color="red"> 172.         for node in node['children']:</font>
<font color="red"> 173.             result = self.visit(node, result)</font>
<font color="red"> 174.         return result</font>
<font color="black"> 175. </font>
<font color="green"> 176.     def visit_slice(self, node, value):</font>
<font color="red"> 177.         if not isinstance(value, list):</font>
<font color="red"> 178.             return None</font>
<font color="red"> 179.         s = slice(*node['children'])</font>
<font color="red"> 180.         return value[s]</font>
<font color="black"> 181. </font>
<font color="green"> 182.     def visit_key_val_pair(self, node, value):</font>
<font color="red"> 183.         return self.visit(node['children'][0], value)</font>
<font color="black"> 184. </font>
<font color="green"> 185.     def visit_literal(self, node, value):</font>
<font color="red"> 186.         return node['value']</font>
<font color="black"> 187. </font>
<font color="green"> 188.     def visit_multi_select_dict(self, node, value):</font>
<font color="red"> 189.         if value is None:</font>
<font color="red"> 190.             return None</font>
<font color="red"> 191.         collected = self._dict_cls()</font>
<font color="red"> 192.         for child in node['children']:</font>
<font color="red"> 193.             collected[child['value']] = self.visit(child, value)</font>
<font color="red"> 194.         return collected</font>
<font color="black"> 195. </font>
<font color="green"> 196.     def visit_multi_select_list(self, node, value):</font>
<font color="red"> 197.         if value is None:</font>
<font color="red"> 198.             return None</font>
<font color="red"> 199.         collected = []</font>
<font color="red"> 200.         for child in node['children']:</font>
<font color="red"> 201.             collected.append(self.visit(child, value))</font>
<font color="red"> 202.         return collected</font>
<font color="black"> 203. </font>
<font color="green"> 204.     def visit_or_expression(self, node, value):</font>
<font color="red"> 205.         matched = self.visit(node['children'][0], value)</font>
<font color="red"> 206.         if self._is_false(matched):</font>
<font color="red"> 207.             matched = self.visit(node['children'][1], value)</font>
<font color="red"> 208.         return matched</font>
<font color="black"> 209. </font>
<font color="green"> 210.     def visit_and_expression(self, node, value):</font>
<font color="red"> 211.         matched = self.visit(node['children'][0], value)</font>
<font color="red"> 212.         if self._is_false(matched):</font>
<font color="red"> 213.             return matched</font>
<font color="red"> 214.         return self.visit(node['children'][1], value)</font>
<font color="black"> 215. </font>
<font color="green"> 216.     def visit_not_expression(self, node, value):</font>
<font color="red"> 217.         original_result = self.visit(node['children'][0], value)</font>
<font color="red"> 218.         if original_result is 0:</font>
<font color="black"> 219.             # Special case for 0, !0 should be false, not true.</font>
<font color="black"> 220.             # 0 is not a special cased integer in jmespath.</font>
<font color="red"> 221.             return False</font>
<font color="red"> 222.         return not original_result</font>
<font color="black"> 223. </font>
<font color="green"> 224.     def visit_pipe(self, node, value):</font>
<font color="red"> 225.         result = value</font>
<font color="red"> 226.         for node in node['children']:</font>
<font color="red"> 227.             result = self.visit(node, result)</font>
<font color="red"> 228.         return result</font>
<font color="black"> 229. </font>
<font color="green"> 230.     def visit_projection(self, node, value):</font>
<font color="red"> 231.         base = self.visit(node['children'][0], value)</font>
<font color="red"> 232.         if not isinstance(base, list):</font>
<font color="red"> 233.             return None</font>
<font color="red"> 234.         collected = []</font>
<font color="red"> 235.         for element in base:</font>
<font color="red"> 236.             current = self.visit(node['children'][1], element)</font>
<font color="red"> 237.             if current is not None:</font>
<font color="red"> 238.                 collected.append(current)</font>
<font color="red"> 239.         return collected</font>
<font color="black"> 240. </font>
<font color="green"> 241.     def visit_value_projection(self, node, value):</font>
<font color="red"> 242.         base = self.visit(node['children'][0], value)</font>
<font color="red"> 243.         try:</font>
<font color="red"> 244.             base = base.values()</font>
<font color="red"> 245.         except AttributeError:</font>
<font color="red"> 246.             return None</font>
<font color="red"> 247.         collected = []</font>
<font color="red"> 248.         for element in base:</font>
<font color="red"> 249.             current = self.visit(node['children'][1], element)</font>
<font color="red"> 250.             if current is not None:</font>
<font color="red"> 251.                 collected.append(current)</font>
<font color="red"> 252.         return collected</font>
<font color="black"> 253. </font>
<font color="green"> 254.     def _is_false(self, value):</font>
<font color="black"> 255.         # This looks weird, but we're explicitly using equality checks</font>
<font color="black"> 256.         # because the truth/false values are different between</font>
<font color="black"> 257.         # python and jmespath.</font>
<font color="red"> 258.         return (value == '' or value == [] or value == {} or value is None or</font>
<font color="red"> 259.                 value is False)</font>
<font color="black"> 260. </font>
<font color="green"> 261.     def _is_true(self, value):</font>
<font color="red"> 262.         return not self._is_false(value)</font>
<font color="black"> 263. </font>
<font color="black"> 264. </font>
<font color="green"> 265. class GraphvizVisitor(Visitor):</font>
<font color="green"> 266.     def __init__(self):</font>
<font color="red"> 267.         super(GraphvizVisitor, self).__init__()</font>
<font color="red"> 268.         self._lines = []</font>
<font color="red"> 269.         self._count = 1</font>
<font color="black"> 270. </font>
<font color="green"> 271.     def visit(self, node, *args, **kwargs):</font>
<font color="red"> 272.         self._lines.append('digraph AST {')</font>
<font color="red"> 273.         current = '%s%s' % (node['type'], self._count)</font>
<font color="red"> 274.         self._count += 1</font>
<font color="red"> 275.         self._visit(node, current)</font>
<font color="red"> 276.         self._lines.append('}')</font>
<font color="red"> 277.         return '\n'.join(self._lines)</font>
<font color="black"> 278. </font>
<font color="green"> 279.     def _visit(self, node, current):</font>
<font color="red"> 280.         self._lines.append('%s [label=&quot;%s(%s)&quot;]' % (</font>
<font color="red"> 281.             current, node['type'], node.get('value', '')))</font>
<font color="red"> 282.         for child in node.get('children', []):</font>
<font color="red"> 283.             child_name = '%s%s' % (child['type'], self._count)</font>
<font color="red"> 284.             self._count += 1</font>
<font color="red"> 285.             self._lines.append('  %s -&gt; %s' % (current, child_name))</font>
<font color="red"> 286.             self._visit(child, child_name)</font>
</pre>

