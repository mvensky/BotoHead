source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/boto3/resources/factory.py</b><br>


file stats: <b>262 lines, 32 executed: 12.2% covered</b>
<pre>
<font color="black">   1. # Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="black">  13. </font>
<font color="green">  14. import logging</font>
<font color="green">  15. from functools import partial</font>
<font color="black">  16. </font>
<font color="green">  17. from .action import ServiceAction</font>
<font color="green">  18. from .action import WaiterAction</font>
<font color="green">  19. from .base import ResourceMeta, ServiceResource</font>
<font color="green">  20. from .collection import CollectionFactory</font>
<font color="green">  21. from .model import ResourceModel</font>
<font color="green">  22. from .response import build_identifiers, ResourceHandler</font>
<font color="green">  23. from ..exceptions import ResourceLoadException</font>
<font color="green">  24. from ..docs import docstring</font>
<font color="black">  25. </font>
<font color="black">  26. </font>
<font color="green">  27. logger = logging.getLogger(__name__)</font>
<font color="black">  28. </font>
<font color="black">  29. </font>
<font color="green">  30. class ResourceFactory(object):</font>
<font color="black">  31.     &quot;&quot;&quot;</font>
<font color="black">  32.     A factory to create new :py:class:`~boto3.resources.base.ServiceResource`</font>
<font color="black">  33.     classes from a :py:class:`~boto3.resources.model.ResourceModel`. There are</font>
<font color="black">  34.     two types of lookups that can be done: one on the service itself (e.g. an</font>
<font color="black">  35.     SQS resource) and another on models contained within the service (e.g. an</font>
<font color="black">  36.     SQS Queue resource).</font>
<font color="green">  37.     &quot;&quot;&quot;</font>
<font color="green">  38.     def __init__(self, emitter):</font>
<font color="green">  39.         self._collection_factory = CollectionFactory()</font>
<font color="green">  40.         self._emitter = emitter</font>
<font color="black">  41. </font>
<font color="green">  42.     def load_from_definition(self, resource_name,</font>
<font color="black">  43.                              single_resource_json_definition, service_context):</font>
<font color="black">  44.         &quot;&quot;&quot;</font>
<font color="black">  45.         Loads a resource from a model, creating a new</font>
<font color="black">  46.         :py:class:`~boto3.resources.base.ServiceResource` subclass</font>
<font color="black">  47.         with the correct properties and methods, named based on the service</font>
<font color="black">  48.         and resource name, e.g. EC2.Instance.</font>
<font color="black">  49. </font>
<font color="black">  50.         :type resource_name: string</font>
<font color="black">  51.         :param resource_name: Name of the resource to look up. For services,</font>
<font color="black">  52.                               this should match the ``service_name``.</font>
<font color="black">  53. </font>
<font color="black">  54.         :type single_resource_json_definition: dict</font>
<font color="black">  55.         :param single_resource_json_definition:</font>
<font color="black">  56.             The loaded json of a single service resource or resource</font>
<font color="black">  57.             definition.</font>
<font color="black">  58. </font>
<font color="black">  59.         :type service_context: :py:class:`~boto3.utils.ServiceContext`</font>
<font color="black">  60.         :param service_context: Context about the AWS service</font>
<font color="black">  61. </font>
<font color="black">  62.         :rtype: Subclass of :py:class:`~boto3.resources.base.ServiceResource`</font>
<font color="black">  63.         :return: The service or resource class.</font>
<font color="black">  64.         &quot;&quot;&quot;</font>
<font color="red">  65.         logger.debug('Loading %s:%s', service_context.service_name,</font>
<font color="red">  66.                      resource_name)</font>
<font color="black">  67. </font>
<font color="black">  68.         # Using the loaded JSON create a ResourceModel object.</font>
<font color="red">  69.         resource_model = ResourceModel(</font>
<font color="red">  70.             resource_name, single_resource_json_definition,</font>
<font color="red">  71.             service_context.resource_json_definitions</font>
<font color="black">  72.         )</font>
<font color="black">  73. </font>
<font color="black">  74.         # Do some renaming of the shape if there was a naming collision</font>
<font color="black">  75.         # that needed to be accounted for.</font>
<font color="red">  76.         shape = None</font>
<font color="red">  77.         if resource_model.shape:</font>
<font color="red">  78.             shape = service_context.service_model.shape_for(</font>
<font color="red">  79.                 resource_model.shape)</font>
<font color="red">  80.         resource_model.load_rename_map(shape)</font>
<font color="black">  81. </font>
<font color="black">  82.         # Set some basic info</font>
<font color="red">  83.         meta = ResourceMeta(</font>
<font color="red">  84.             service_context.service_name, resource_model=resource_model)</font>
<font color="red">  85.         attrs = {</font>
<font color="red">  86.             'meta': meta,</font>
<font color="black">  87.         }</font>
<font color="black">  88. </font>
<font color="black">  89.         # Create and load all of attributes of the resource class based</font>
<font color="black">  90.         # on the models.</font>
<font color="black">  91. </font>
<font color="black">  92.         # Identifiers</font>
<font color="red">  93.         self._load_identifiers(</font>
<font color="red">  94.             attrs=attrs, meta=meta, resource_name=resource_name,</font>
<font color="red">  95.             resource_model=resource_model</font>
<font color="black">  96.         )</font>
<font color="black">  97. </font>
<font color="black">  98.         # Load/Reload actions</font>
<font color="red">  99.         self._load_actions(</font>
<font color="red"> 100.             attrs=attrs, resource_name=resource_name,</font>
<font color="red"> 101.             resource_model=resource_model, service_context=service_context</font>
<font color="black"> 102.         )</font>
<font color="black"> 103. </font>
<font color="black"> 104.         # Attributes that get auto-loaded</font>
<font color="red"> 105.         self._load_attributes(</font>
<font color="red"> 106.             attrs=attrs, meta=meta, resource_name=resource_name,</font>
<font color="red"> 107.             resource_model=resource_model,</font>
<font color="red"> 108.             service_context=service_context)</font>
<font color="black"> 109. </font>
<font color="black"> 110.         # Collections and their corresponding methods</font>
<font color="red"> 111.         self._load_collections(</font>
<font color="red"> 112.             attrs=attrs, resource_model=resource_model,</font>
<font color="red"> 113.             service_context=service_context)</font>
<font color="black"> 114. </font>
<font color="black"> 115.         # References and Subresources</font>
<font color="red"> 116.         self._load_has_relations(</font>
<font color="red"> 117.             attrs=attrs, resource_name=resource_name,</font>
<font color="red"> 118.             resource_model=resource_model, service_context=service_context</font>
<font color="black"> 119.         )</font>
<font color="black"> 120. </font>
<font color="black"> 121.         # Waiter resource actions</font>
<font color="red"> 122.         self._load_waiters(</font>
<font color="red"> 123.             attrs=attrs, resource_name=resource_name,</font>
<font color="red"> 124.             resource_model=resource_model, service_context=service_context</font>
<font color="black"> 125.         )</font>
<font color="black"> 126. </font>
<font color="black"> 127.         # Create the name based on the requested service and resource</font>
<font color="red"> 128.         cls_name = resource_name</font>
<font color="red"> 129.         if service_context.service_name == resource_name:</font>
<font color="red"> 130.             cls_name = 'ServiceResource'</font>
<font color="red"> 131.         cls_name = service_context.service_name + '.' + cls_name</font>
<font color="black"> 132. </font>
<font color="red"> 133.         base_classes = [ServiceResource]</font>
<font color="red"> 134.         if self._emitter is not None:</font>
<font color="red"> 135.             self._emitter.emit(</font>
<font color="red"> 136.                 'creating-resource-class.%s' % cls_name,</font>
<font color="red"> 137.                 class_attributes=attrs, base_classes=base_classes,</font>
<font color="red"> 138.                 service_context=service_context)</font>
<font color="red"> 139.         return type(str(cls_name), tuple(base_classes), attrs)</font>
<font color="black"> 140. </font>
<font color="green"> 141.     def _load_identifiers(self, attrs, meta, resource_model, resource_name):</font>
<font color="black"> 142.         &quot;&quot;&quot;</font>
<font color="black"> 143.         Populate required identifiers. These are arguments without which</font>
<font color="black"> 144.         the resource cannot be used. Identifiers become arguments for</font>
<font color="black"> 145.         operations on the resource.</font>
<font color="black"> 146.         &quot;&quot;&quot;</font>
<font color="red"> 147.         for identifier in resource_model.identifiers:</font>
<font color="red"> 148.             meta.identifiers.append(identifier.name)</font>
<font color="red"> 149.             attrs[identifier.name] = self._create_identifier(</font>
<font color="red"> 150.                 identifier, resource_name)</font>
<font color="black"> 151. </font>
<font color="green"> 152.     def _load_actions(self, attrs, resource_name, resource_model,</font>
<font color="black"> 153.                       service_context):</font>
<font color="black"> 154.         &quot;&quot;&quot;</font>
<font color="black"> 155.         Actions on the resource become methods, with the ``load`` method</font>
<font color="black"> 156.         being a special case which sets internal data for attributes, and</font>
<font color="black"> 157.         ``reload`` is an alias for ``load``.</font>
<font color="black"> 158.         &quot;&quot;&quot;</font>
<font color="red"> 159.         if resource_model.load:</font>
<font color="red"> 160.             attrs['load'] = self._create_action(</font>
<font color="red"> 161.                 action_model=resource_model.load, resource_name=resource_name,</font>
<font color="red"> 162.                 service_context=service_context, is_load=True)</font>
<font color="red"> 163.             attrs['reload'] = attrs['load']</font>
<font color="black"> 164. </font>
<font color="red"> 165.         for action in resource_model.actions:</font>
<font color="red"> 166.             attrs[action.name] = self._create_action(</font>
<font color="red"> 167.                 action_model=action, resource_name=resource_name,</font>
<font color="red"> 168.                 service_context=service_context)</font>
<font color="black"> 169. </font>
<font color="green"> 170.     def _load_attributes(self, attrs, meta, resource_name, resource_model,</font>
<font color="black"> 171.                          service_context):</font>
<font color="black"> 172.         &quot;&quot;&quot;</font>
<font color="black"> 173.         Load resource attributes based on the resource shape. The shape</font>
<font color="black"> 174.         name is referenced in the resource JSON, but the shape itself</font>
<font color="black"> 175.         is defined in the Botocore service JSON, hence the need for</font>
<font color="black"> 176.         access to the ``service_model``.</font>
<font color="black"> 177.         &quot;&quot;&quot;</font>
<font color="red"> 178.         if not resource_model.shape:</font>
<font color="red"> 179.             return</font>
<font color="black"> 180. </font>
<font color="red"> 181.         shape = service_context.service_model.shape_for(</font>
<font color="red"> 182.             resource_model.shape)</font>
<font color="black"> 183. </font>
<font color="red"> 184.         identifiers = dict(</font>
<font color="red"> 185.             (i.member_name, i)</font>
<font color="red"> 186.             for i in resource_model.identifiers if i.member_name)</font>
<font color="red"> 187.         attributes = resource_model.get_attributes(shape)</font>
<font color="red"> 188.         for name, (orig_name, member) in attributes.items():</font>
<font color="red"> 189.             if name in identifiers:</font>
<font color="red"> 190.                 prop = self._create_identifier_alias(</font>
<font color="red"> 191.                     resource_name=resource_name,</font>
<font color="red"> 192.                     identifier=identifiers[name],</font>
<font color="red"> 193.                     member_model=member,</font>
<font color="red"> 194.                     service_context=service_context</font>
<font color="black"> 195.                 )</font>
<font color="black"> 196.             else:</font>
<font color="red"> 197.                 prop = self._create_autoload_property(</font>
<font color="red"> 198.                     resource_name=resource_name,</font>
<font color="red"> 199.                     name=orig_name, snake_cased=name,</font>
<font color="red"> 200.                     member_model=member,</font>
<font color="red"> 201.                     service_context=service_context</font>
<font color="black"> 202.                 )</font>
<font color="red"> 203.             attrs[name] = prop</font>
<font color="black"> 204. </font>
<font color="green"> 205.     def _load_collections(self, attrs, resource_model, service_context):</font>
<font color="black"> 206.         &quot;&quot;&quot;</font>
<font color="black"> 207.         Load resource collections from the model. Each collection becomes</font>
<font color="black"> 208.         a :py:class:`~boto3.resources.collection.CollectionManager` instance</font>
<font color="black"> 209.         on the resource instance, which allows you to iterate and filter</font>
<font color="black"> 210.         through the collection's items.</font>
<font color="black"> 211.         &quot;&quot;&quot;</font>
<font color="red"> 212.         for collection_model in resource_model.collections:</font>
<font color="red"> 213.             attrs[collection_model.name] = self._create_collection(</font>
<font color="red"> 214.                 resource_name=resource_model.name,</font>
<font color="red"> 215.                 collection_model=collection_model,</font>
<font color="red"> 216.                 service_context=service_context</font>
<font color="black"> 217.             )</font>
<font color="black"> 218. </font>
<font color="green"> 219.     def _load_has_relations(self, attrs, resource_name, resource_model,</font>
<font color="black"> 220.                             service_context):</font>
<font color="black"> 221.         &quot;&quot;&quot;</font>
<font color="black"> 222.         Load related resources, which are defined via a ``has``</font>
<font color="black"> 223.         relationship but conceptually come in two forms:</font>
<font color="black"> 224. </font>
<font color="black"> 225.         1. A reference, which is a related resource instance and can be</font>
<font color="black"> 226.            ``None``, such as an EC2 instance's ``vpc``.</font>
<font color="black"> 227.         2. A subresource, which is a resource constructor that will always</font>
<font color="black"> 228.            return a resource instance which shares identifiers/data with</font>
<font color="black"> 229.            this resource, such as ``s3.Bucket('name').Object('key')``.</font>
<font color="black"> 230.         &quot;&quot;&quot;</font>
<font color="red"> 231.         for reference in resource_model.references:</font>
<font color="black"> 232.             # This is a dangling reference, i.e. we have all</font>
<font color="black"> 233.             # the data we need to create the resource, so</font>
<font color="black"> 234.             # this instance becomes an attribute on the class.</font>
<font color="red"> 235.             attrs[reference.name] = self._create_reference(</font>
<font color="red"> 236.                 reference_model=reference,</font>
<font color="red"> 237.                 resource_name=resource_name,</font>
<font color="red"> 238.                 service_context=service_context</font>
<font color="black"> 239.             )</font>
<font color="black"> 240. </font>
<font color="red"> 241.         for subresource in resource_model.subresources:</font>
<font color="black"> 242.             # This is a sub-resource class you can create</font>
<font color="black"> 243.             # by passing in an identifier, e.g. s3.Bucket(name).</font>
<font color="red"> 244.             attrs[subresource.name] = self._create_class_partial(</font>
<font color="red"> 245.                 subresource_model=subresource,</font>
<font color="red"> 246.                 resource_name=resource_name,</font>
<font color="red"> 247.                 service_context=service_context</font>
<font color="black"> 248.             )</font>
<font color="black"> 249. </font>
<font color="red"> 250.         self._create_available_subresources_command(</font>
<font color="red"> 251.             attrs, resource_model.subresources)</font>
<font color="black"> 252. </font>
<font color="green"> 253.     def _create_available_subresources_command(self, attrs, subresources):</font>
<font color="red"> 254.         _subresources = [subresource.name for subresource in subresources]</font>
<font color="red"> 255.         _subresources = sorted(_subresources)</font>
<font color="black"> 256. </font>
<font color="red"> 257.         def get_available_subresources(factory_self):</font>
<font color="black"> 258.             &quot;&quot;&quot;</font>
<font color="black"> 259.             Returns a list of all the available sub-resources for this</font>
<font color="black"> 260.             Resource.</font>
<font color="black"> 261. </font>
<font color="black"> 262.             :returns: A list containing the name of each sub-resource for this</font>
<font color="black"> 263.                 resource</font>
<font color="black"> 264.             :rtype: list of str</font>
<font color="black"> 265.             &quot;&quot;&quot;</font>
<font color="red"> 266.             return _subresources</font>
<font color="black"> 267. </font>
<font color="red"> 268.         attrs['get_available_subresources'] = get_available_subresources</font>
<font color="black"> 269. </font>
<font color="green"> 270.     def _load_waiters(self, attrs, resource_name, resource_model,</font>
<font color="black"> 271.                       service_context):</font>
<font color="black"> 272.         &quot;&quot;&quot;</font>
<font color="black"> 273.         Load resource waiters from the model. Each waiter allows you to</font>
<font color="black"> 274.         wait until a resource reaches a specific state by polling the state</font>
<font color="black"> 275.         of the resource.</font>
<font color="black"> 276.         &quot;&quot;&quot;</font>
<font color="red"> 277.         for waiter in resource_model.waiters:</font>
<font color="red"> 278.             attrs[waiter.name] = self._create_waiter(</font>
<font color="red"> 279.                 resource_waiter_model=waiter,</font>
<font color="red"> 280.                 resource_name=resource_name,</font>
<font color="red"> 281.                 service_context=service_context</font>
<font color="black"> 282.             )</font>
<font color="black"> 283. </font>
<font color="green"> 284.     def _create_identifier(factory_self, identifier, resource_name):</font>
<font color="black"> 285.         &quot;&quot;&quot;</font>
<font color="black"> 286.         Creates a read-only property for identifier attributes.</font>
<font color="black"> 287.         &quot;&quot;&quot;</font>
<font color="red"> 288.         def get_identifier(self):</font>
<font color="black"> 289.             # The default value is set to ``None`` instead of</font>
<font color="black"> 290.             # raising an AttributeError because when resources are</font>
<font color="black"> 291.             # instantiated a check is made such that none of the</font>
<font color="black"> 292.             # identifiers have a value ``None``. If any are ``None``,</font>
<font color="black"> 293.             # a more informative user error than a generic AttributeError</font>
<font color="black"> 294.             # is raised.</font>
<font color="red"> 295.             return getattr(self, '_' + identifier.name, None)</font>
<font color="black"> 296. </font>
<font color="red"> 297.         get_identifier.__name__ = str(identifier.name)</font>
<font color="red"> 298.         get_identifier.__doc__ = docstring.IdentifierDocstring(</font>
<font color="red"> 299.             resource_name=resource_name,</font>
<font color="red"> 300.             identifier_model=identifier,</font>
<font color="red"> 301.             include_signature=False</font>
<font color="black"> 302.         )</font>
<font color="black"> 303. </font>
<font color="red"> 304.         return property(get_identifier)</font>
<font color="black"> 305. </font>
<font color="green"> 306.     def _create_identifier_alias(factory_self, resource_name, identifier,</font>
<font color="black"> 307.                                  member_model, service_context):</font>
<font color="black"> 308.         &quot;&quot;&quot;</font>
<font color="black"> 309.         Creates a read-only property that aliases an identifier.</font>
<font color="black"> 310.         &quot;&quot;&quot;</font>
<font color="red"> 311.         def get_identifier(self):</font>
<font color="red"> 312.             return getattr(self, '_' + identifier.name, None)</font>
<font color="black"> 313. </font>
<font color="red"> 314.         get_identifier.__name__ = str(identifier.member_name)</font>
<font color="red"> 315.         get_identifier.__doc__ = docstring.AttributeDocstring(</font>
<font color="red"> 316.             service_name=service_context.service_name,</font>
<font color="red"> 317.             resource_name=resource_name,</font>
<font color="red"> 318.             attr_name=identifier.member_name,</font>
<font color="red"> 319.             event_emitter=factory_self._emitter,</font>
<font color="red"> 320.             attr_model=member_model,</font>
<font color="red"> 321.             include_signature=False</font>
<font color="black"> 322.         )</font>
<font color="black"> 323. </font>
<font color="red"> 324.         return property(get_identifier)</font>
<font color="black"> 325. </font>
<font color="green"> 326.     def _create_autoload_property(factory_self, resource_name, name,</font>
<font color="black"> 327.                                   snake_cased, member_model, service_context):</font>
<font color="black"> 328.         &quot;&quot;&quot;</font>
<font color="black"> 329.         Creates a new property on the resource to lazy-load its value</font>
<font color="black"> 330.         via the resource's ``load`` method (if it exists).</font>
<font color="black"> 331.         &quot;&quot;&quot;</font>
<font color="black"> 332.         # The property loader will check to see if this resource has already</font>
<font color="black"> 333.         # been loaded and return the cached value if possible. If not, then</font>
<font color="black"> 334.         # it first checks to see if it CAN be loaded (raise if not), then</font>
<font color="black"> 335.         # calls the load before returning the value.</font>
<font color="red"> 336.         def property_loader(self):</font>
<font color="red"> 337.             if self.meta.data is None:</font>
<font color="red"> 338.                 if hasattr(self, 'load'):</font>
<font color="red"> 339.                     self.load()</font>
<font color="black"> 340.                 else:</font>
<font color="red"> 341.                     raise ResourceLoadException(</font>
<font color="red"> 342.                         '{0} has no load method'.format(</font>
<font color="red"> 343.                             self.__class__.__name__))</font>
<font color="black"> 344. </font>
<font color="red"> 345.             return self.meta.data.get(name)</font>
<font color="black"> 346. </font>
<font color="red"> 347.         property_loader.__name__ = str(snake_cased)</font>
<font color="red"> 348.         property_loader.__doc__ = docstring.AttributeDocstring(</font>
<font color="red"> 349.             service_name=service_context.service_name,</font>
<font color="red"> 350.             resource_name=resource_name,</font>
<font color="red"> 351.             attr_name=snake_cased,</font>
<font color="red"> 352.             event_emitter=factory_self._emitter,</font>
<font color="red"> 353.             attr_model=member_model,</font>
<font color="red"> 354.             include_signature=False</font>
<font color="black"> 355.         )</font>
<font color="black"> 356. </font>
<font color="red"> 357.         return property(property_loader)</font>
<font color="black"> 358. </font>
<font color="green"> 359.     def _create_waiter(factory_self, resource_waiter_model, resource_name,</font>
<font color="black"> 360.                        service_context):</font>
<font color="black"> 361.         &quot;&quot;&quot;</font>
<font color="black"> 362.         Creates a new wait method for each resource where both a waiter and</font>
<font color="black"> 363.         resource model is defined.</font>
<font color="black"> 364.         &quot;&quot;&quot;</font>
<font color="red"> 365.         waiter = WaiterAction(resource_waiter_model,</font>
<font color="red"> 366.                               waiter_resource_name=resource_waiter_model.name)</font>
<font color="black"> 367. </font>
<font color="red"> 368.         def do_waiter(self, *args, **kwargs):</font>
<font color="red"> 369.             waiter(self, *args, **kwargs)</font>
<font color="black"> 370. </font>
<font color="red"> 371.         do_waiter.__name__ = str(resource_waiter_model.name)</font>
<font color="red"> 372.         do_waiter.__doc__ = docstring.ResourceWaiterDocstring(</font>
<font color="red"> 373.             resource_name=resource_name,</font>
<font color="red"> 374.             event_emitter=factory_self._emitter,</font>
<font color="red"> 375.             service_model=service_context.service_model,</font>
<font color="red"> 376.             resource_waiter_model=resource_waiter_model,</font>
<font color="red"> 377.             service_waiter_model=service_context.service_waiter_model,</font>
<font color="red"> 378.             include_signature=False</font>
<font color="black"> 379.         )</font>
<font color="red"> 380.         return do_waiter</font>
<font color="black"> 381. </font>
<font color="green"> 382.     def _create_collection(factory_self, resource_name, collection_model,</font>
<font color="black"> 383.                            service_context):</font>
<font color="black"> 384.         &quot;&quot;&quot;</font>
<font color="black"> 385.         Creates a new property on the resource to lazy-load a collection.</font>
<font color="black"> 386.         &quot;&quot;&quot;</font>
<font color="red"> 387.         cls = factory_self._collection_factory.load_from_definition(</font>
<font color="red"> 388.             resource_name=resource_name, collection_model=collection_model,</font>
<font color="red"> 389.             service_context=service_context,</font>
<font color="red"> 390.             event_emitter=factory_self._emitter)</font>
<font color="black"> 391. </font>
<font color="red"> 392.         def get_collection(self):</font>
<font color="red"> 393.             return cls(</font>
<font color="red"> 394.                 collection_model=collection_model, parent=self,</font>
<font color="red"> 395.                 factory=factory_self, service_context=service_context)</font>
<font color="black"> 396. </font>
<font color="red"> 397.         get_collection.__name__ = str(collection_model.name)</font>
<font color="red"> 398.         get_collection.__doc__ = docstring.CollectionDocstring(</font>
<font color="red"> 399.             collection_model=collection_model, include_signature=False)</font>
<font color="red"> 400.         return property(get_collection)</font>
<font color="black"> 401. </font>
<font color="green"> 402.     def _create_reference(factory_self, reference_model, resource_name,</font>
<font color="black"> 403.                           service_context):</font>
<font color="black"> 404.         &quot;&quot;&quot;</font>
<font color="black"> 405.         Creates a new property on the resource to lazy-load a reference.</font>
<font color="black"> 406.         &quot;&quot;&quot;</font>
<font color="black"> 407.         # References are essentially an action with no request</font>
<font color="black"> 408.         # or response, so we can re-use the response handlers to</font>
<font color="black"> 409.         # build up resources from identifiers and data members.</font>
<font color="red"> 410.         handler = ResourceHandler(</font>
<font color="red"> 411.             search_path=reference_model.resource.path, factory=factory_self,</font>
<font color="red"> 412.             resource_model=reference_model.resource,</font>
<font color="red"> 413.             service_context=service_context</font>
<font color="black"> 414.         )</font>
<font color="black"> 415. </font>
<font color="black"> 416.         # Are there any identifiers that need access to data members?</font>
<font color="black"> 417.         # This is important when building the resource below since</font>
<font color="black"> 418.         # it requires the data to be loaded.</font>
<font color="red"> 419.         needs_data = any(i.source == 'data' for i in</font>
<font color="red"> 420.                          reference_model.resource.identifiers)</font>
<font color="black"> 421. </font>
<font color="red"> 422.         def get_reference(self):</font>
<font color="black"> 423.             # We need to lazy-evaluate the reference to handle circular</font>
<font color="black"> 424.             # references between resources. We do this by loading the class</font>
<font color="black"> 425.             # when first accessed.</font>
<font color="black"> 426.             # This is using a *response handler* so we need to make sure</font>
<font color="black"> 427.             # our data is loaded (if possible) and pass that data into</font>
<font color="black"> 428.             # the handler as if it were a response. This allows references</font>
<font color="black"> 429.             # to have their data loaded properly.</font>
<font color="red"> 430.             if needs_data and self.meta.data is None and hasattr(self, 'load'):</font>
<font color="red"> 431.                 self.load()</font>
<font color="red"> 432.             return handler(self, {}, self.meta.data)</font>
<font color="black"> 433. </font>
<font color="red"> 434.         get_reference.__name__ = str(reference_model.name)</font>
<font color="red"> 435.         get_reference.__doc__ = docstring.ReferenceDocstring(</font>
<font color="red"> 436.             reference_model=reference_model,</font>
<font color="red"> 437.             include_signature=False</font>
<font color="black"> 438.         )</font>
<font color="red"> 439.         return property(get_reference)</font>
<font color="black"> 440. </font>
<font color="green"> 441.     def _create_class_partial(factory_self, subresource_model, resource_name,</font>
<font color="black"> 442.                               service_context):</font>
<font color="black"> 443.         &quot;&quot;&quot;</font>
<font color="black"> 444.         Creates a new method which acts as a functools.partial, passing</font>
<font color="black"> 445.         along the instance's low-level `client` to the new resource</font>
<font color="black"> 446.         class' constructor.</font>
<font color="black"> 447.         &quot;&quot;&quot;</font>
<font color="red"> 448.         name = subresource_model.resource.type</font>
<font color="black"> 449. </font>
<font color="red"> 450.         def create_resource(self, *args, **kwargs):</font>
<font color="black"> 451.             # We need a new method here because we want access to the</font>
<font color="black"> 452.             # instance's client.</font>
<font color="red"> 453.             positional_args = []</font>
<font color="black"> 454. </font>
<font color="black"> 455.             # We lazy-load the class to handle circular references.</font>
<font color="red"> 456.             json_def = service_context.resource_json_definitions.get(name, {})</font>
<font color="red"> 457.             resource_cls = factory_self.load_from_definition(</font>
<font color="red"> 458.                 resource_name=name,</font>
<font color="red"> 459.                 single_resource_json_definition=json_def,</font>
<font color="red"> 460.                 service_context=service_context</font>
<font color="black"> 461.             )</font>
<font color="black"> 462. </font>
<font color="black"> 463.             # Assumes that identifiers are in order, which lets you do</font>
<font color="black"> 464.             # e.g. ``sqs.Queue('foo').Message('bar')`` to create a new message</font>
<font color="black"> 465.             # linked with the ``foo`` queue and which has a ``bar`` receipt</font>
<font color="black"> 466.             # handle. If we did kwargs here then future positional arguments</font>
<font color="black"> 467.             # would lead to failure.</font>
<font color="red"> 468.             identifiers = subresource_model.resource.identifiers</font>
<font color="red"> 469.             if identifiers is not None:</font>
<font color="red"> 470.                 for identifier, value in build_identifiers(identifiers, self):</font>
<font color="red"> 471.                     positional_args.append(value)</font>
<font color="black"> 472. </font>
<font color="red"> 473.             return partial(resource_cls, *positional_args,</font>
<font color="red"> 474.                            client=self.meta.client)(*args, **kwargs)</font>
<font color="black"> 475. </font>
<font color="red"> 476.         create_resource.__name__ = str(name)</font>
<font color="red"> 477.         create_resource.__doc__ = docstring.SubResourceDocstring(</font>
<font color="red"> 478.             resource_name=resource_name,</font>
<font color="red"> 479.             sub_resource_model=subresource_model,</font>
<font color="red"> 480.             service_model=service_context.service_model,</font>
<font color="red"> 481.             include_signature=False</font>
<font color="black"> 482.         )</font>
<font color="red"> 483.         return create_resource</font>
<font color="black"> 484. </font>
<font color="black"> 485.     def _create_action(factory_self, action_model, resource_name,</font>
<font color="green"> 486.                        service_context, is_load=False):</font>
<font color="black"> 487.         &quot;&quot;&quot;</font>
<font color="black"> 488.         Creates a new method which makes a request to the underlying</font>
<font color="black"> 489.         AWS service.</font>
<font color="black"> 490.         &quot;&quot;&quot;</font>
<font color="black"> 491.         # Create the action in in this closure but before the ``do_action``</font>
<font color="black"> 492.         # method below is invoked, which allows instances of the resource</font>
<font color="black"> 493.         # to share the ServiceAction instance.</font>
<font color="red"> 494.         action = ServiceAction(</font>
<font color="red"> 495.             action_model, factory=factory_self,</font>
<font color="red"> 496.             service_context=service_context</font>
<font color="black"> 497.         )</font>
<font color="black"> 498. </font>
<font color="black"> 499.         # A resource's ``load`` method is special because it sets</font>
<font color="black"> 500.         # values on the resource instead of returning the response.</font>
<font color="red"> 501.         if is_load:</font>
<font color="black"> 502.             # We need a new method here because we want access to the</font>
<font color="black"> 503.             # instance via ``self``.</font>
<font color="red"> 504.             def do_action(self, *args, **kwargs):</font>
<font color="red"> 505.                 response = action(self, *args, **kwargs)</font>
<font color="red"> 506.                 self.meta.data = response</font>
<font color="black"> 507.             # Create the docstring for the load/reload mehtods.</font>
<font color="red"> 508.             lazy_docstring = docstring.LoadReloadDocstring(</font>
<font color="red"> 509.                 action_name=action_model.name,</font>
<font color="red"> 510.                 resource_name=resource_name,</font>
<font color="red"> 511.                 event_emitter=factory_self._emitter,</font>
<font color="red"> 512.                 load_model=action_model,</font>
<font color="red"> 513.                 service_model=service_context.service_model,</font>
<font color="red"> 514.                 include_signature=False</font>
<font color="black"> 515.             )</font>
<font color="black"> 516.         else:</font>
<font color="black"> 517.             # We need a new method here because we want access to the</font>
<font color="black"> 518.             # instance via ``self``.</font>
<font color="red"> 519.             def do_action(self, *args, **kwargs):</font>
<font color="red"> 520.                 response = action(self, *args, **kwargs)</font>
<font color="black"> 521. </font>
<font color="red"> 522.                 if hasattr(self, 'load'):</font>
<font color="black"> 523.                     # Clear cached data. It will be reloaded the next</font>
<font color="black"> 524.                     # time that an attribute is accessed.</font>
<font color="black"> 525.                     # TODO: Make this configurable in the future?</font>
<font color="red"> 526.                     self.meta.data = None</font>
<font color="black"> 527. </font>
<font color="red"> 528.                 return response</font>
<font color="red"> 529.             lazy_docstring = docstring.ActionDocstring(</font>
<font color="red"> 530.                 resource_name=resource_name,</font>
<font color="red"> 531.                 event_emitter=factory_self._emitter,</font>
<font color="red"> 532.                 action_model=action_model,</font>
<font color="red"> 533.                 service_model=service_context.service_model,</font>
<font color="red"> 534.                 include_signature=False</font>
<font color="black"> 535.             )</font>
<font color="black"> 536. </font>
<font color="red"> 537.         do_action.__name__ = str(action_model.name)</font>
<font color="red"> 538.         do_action.__doc__ = lazy_docstring</font>
<font color="red"> 539.         return do_action</font>
</pre>

