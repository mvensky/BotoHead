source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/concurrent/futures/_base.py</b><br>


file stats: <b>321 lines, 95 executed: 29.6% covered</b>
<pre>
<font color="black">   1. # Copyright 2009 Brian Quinlan. All Rights Reserved.</font>
<font color="black">   2. # Licensed to PSF under a Contributor Agreement.</font>
<font color="black">   3. </font>
<font color="green">   4. import collections</font>
<font color="green">   5. import logging</font>
<font color="green">   6. import threading</font>
<font color="green">   7. import itertools</font>
<font color="green">   8. import time</font>
<font color="black">   9. </font>
<font color="green">  10. __author__ = 'Brian Quinlan (brian@sweetapp.com)'</font>
<font color="black">  11. </font>
<font color="green">  12. FIRST_COMPLETED = 'FIRST_COMPLETED'</font>
<font color="green">  13. FIRST_EXCEPTION = 'FIRST_EXCEPTION'</font>
<font color="green">  14. ALL_COMPLETED = 'ALL_COMPLETED'</font>
<font color="green">  15. _AS_COMPLETED = '_AS_COMPLETED'</font>
<font color="black">  16. </font>
<font color="black">  17. # Possible future states (for internal use by the futures package).</font>
<font color="green">  18. PENDING = 'PENDING'</font>
<font color="green">  19. RUNNING = 'RUNNING'</font>
<font color="black">  20. # The future was cancelled by the user...</font>
<font color="green">  21. CANCELLED = 'CANCELLED'</font>
<font color="black">  22. # ...and _Waiter.add_cancelled() was called by a worker.</font>
<font color="green">  23. CANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'</font>
<font color="green">  24. FINISHED = 'FINISHED'</font>
<font color="black">  25. </font>
<font color="black">  26. _FUTURE_STATES = [</font>
<font color="green">  27.     PENDING,</font>
<font color="green">  28.     RUNNING,</font>
<font color="green">  29.     CANCELLED,</font>
<font color="green">  30.     CANCELLED_AND_NOTIFIED,</font>
<font color="green">  31.     FINISHED</font>
<font color="black">  32. ]</font>
<font color="black">  33. </font>
<font color="green">  34. _STATE_TO_DESCRIPTION_MAP = {</font>
<font color="green">  35.     PENDING: &quot;pending&quot;,</font>
<font color="green">  36.     RUNNING: &quot;running&quot;,</font>
<font color="green">  37.     CANCELLED: &quot;cancelled&quot;,</font>
<font color="green">  38.     CANCELLED_AND_NOTIFIED: &quot;cancelled&quot;,</font>
<font color="green">  39.     FINISHED: &quot;finished&quot;</font>
<font color="black">  40. }</font>
<font color="black">  41. </font>
<font color="black">  42. # Logger for internal use by the futures package.</font>
<font color="green">  43. LOGGER = logging.getLogger(&quot;concurrent.futures&quot;)</font>
<font color="black">  44. </font>
<font color="green">  45. class Error(Exception):</font>
<font color="green">  46.     &quot;&quot;&quot;Base class for all future-related exceptions.&quot;&quot;&quot;</font>
<font color="green">  47.     pass</font>
<font color="black">  48. </font>
<font color="green">  49. class CancelledError(Error):</font>
<font color="green">  50.     &quot;&quot;&quot;The Future was cancelled.&quot;&quot;&quot;</font>
<font color="green">  51.     pass</font>
<font color="black">  52. </font>
<font color="green">  53. class TimeoutError(Error):</font>
<font color="green">  54.     &quot;&quot;&quot;The operation exceeded the given deadline.&quot;&quot;&quot;</font>
<font color="green">  55.     pass</font>
<font color="black">  56. </font>
<font color="green">  57. class _Waiter(object):</font>
<font color="green">  58.     &quot;&quot;&quot;Provides the event that wait() and as_completed() block on.&quot;&quot;&quot;</font>
<font color="green">  59.     def __init__(self):</font>
<font color="red">  60.         self.event = threading.Event()</font>
<font color="red">  61.         self.finished_futures = []</font>
<font color="black">  62. </font>
<font color="green">  63.     def add_result(self, future):</font>
<font color="red">  64.         self.finished_futures.append(future)</font>
<font color="black">  65. </font>
<font color="green">  66.     def add_exception(self, future):</font>
<font color="red">  67.         self.finished_futures.append(future)</font>
<font color="black">  68. </font>
<font color="green">  69.     def add_cancelled(self, future):</font>
<font color="red">  70.         self.finished_futures.append(future)</font>
<font color="black">  71. </font>
<font color="green">  72. class _AsCompletedWaiter(_Waiter):</font>
<font color="green">  73.     &quot;&quot;&quot;Used by as_completed().&quot;&quot;&quot;</font>
<font color="black">  74. </font>
<font color="green">  75.     def __init__(self):</font>
<font color="red">  76.         super(_AsCompletedWaiter, self).__init__()</font>
<font color="red">  77.         self.lock = threading.Lock()</font>
<font color="black">  78. </font>
<font color="green">  79.     def add_result(self, future):</font>
<font color="red">  80.         with self.lock:</font>
<font color="red">  81.             super(_AsCompletedWaiter, self).add_result(future)</font>
<font color="red">  82.             self.event.set()</font>
<font color="black">  83. </font>
<font color="green">  84.     def add_exception(self, future):</font>
<font color="red">  85.         with self.lock:</font>
<font color="red">  86.             super(_AsCompletedWaiter, self).add_exception(future)</font>
<font color="red">  87.             self.event.set()</font>
<font color="black">  88. </font>
<font color="green">  89.     def add_cancelled(self, future):</font>
<font color="red">  90.         with self.lock:</font>
<font color="red">  91.             super(_AsCompletedWaiter, self).add_cancelled(future)</font>
<font color="red">  92.             self.event.set()</font>
<font color="black">  93. </font>
<font color="green">  94. class _FirstCompletedWaiter(_Waiter):</font>
<font color="green">  95.     &quot;&quot;&quot;Used by wait(return_when=FIRST_COMPLETED).&quot;&quot;&quot;</font>
<font color="black">  96. </font>
<font color="green">  97.     def add_result(self, future):</font>
<font color="red">  98.         super(_FirstCompletedWaiter, self).add_result(future)</font>
<font color="red">  99.         self.event.set()</font>
<font color="black"> 100. </font>
<font color="green"> 101.     def add_exception(self, future):</font>
<font color="red"> 102.         super(_FirstCompletedWaiter, self).add_exception(future)</font>
<font color="red"> 103.         self.event.set()</font>
<font color="black"> 104. </font>
<font color="green"> 105.     def add_cancelled(self, future):</font>
<font color="red"> 106.         super(_FirstCompletedWaiter, self).add_cancelled(future)</font>
<font color="red"> 107.         self.event.set()</font>
<font color="black"> 108. </font>
<font color="green"> 109. class _AllCompletedWaiter(_Waiter):</font>
<font color="green"> 110.     &quot;&quot;&quot;Used by wait(return_when=FIRST_EXCEPTION and ALL_COMPLETED).&quot;&quot;&quot;</font>
<font color="black"> 111. </font>
<font color="green"> 112.     def __init__(self, num_pending_calls, stop_on_exception):</font>
<font color="red"> 113.         self.num_pending_calls = num_pending_calls</font>
<font color="red"> 114.         self.stop_on_exception = stop_on_exception</font>
<font color="red"> 115.         self.lock = threading.Lock()</font>
<font color="red"> 116.         super(_AllCompletedWaiter, self).__init__()</font>
<font color="black"> 117. </font>
<font color="green"> 118.     def _decrement_pending_calls(self):</font>
<font color="red"> 119.         with self.lock:</font>
<font color="red"> 120.             self.num_pending_calls -= 1</font>
<font color="red"> 121.             if not self.num_pending_calls:</font>
<font color="red"> 122.                 self.event.set()</font>
<font color="black"> 123. </font>
<font color="green"> 124.     def add_result(self, future):</font>
<font color="red"> 125.         super(_AllCompletedWaiter, self).add_result(future)</font>
<font color="red"> 126.         self._decrement_pending_calls()</font>
<font color="black"> 127. </font>
<font color="green"> 128.     def add_exception(self, future):</font>
<font color="red"> 129.         super(_AllCompletedWaiter, self).add_exception(future)</font>
<font color="red"> 130.         if self.stop_on_exception:</font>
<font color="red"> 131.             self.event.set()</font>
<font color="black"> 132.         else:</font>
<font color="red"> 133.             self._decrement_pending_calls()</font>
<font color="black"> 134. </font>
<font color="green"> 135.     def add_cancelled(self, future):</font>
<font color="red"> 136.         super(_AllCompletedWaiter, self).add_cancelled(future)</font>
<font color="red"> 137.         self._decrement_pending_calls()</font>
<font color="black"> 138. </font>
<font color="green"> 139. class _AcquireFutures(object):</font>
<font color="green"> 140.     &quot;&quot;&quot;A context manager that does an ordered acquire of Future conditions.&quot;&quot;&quot;</font>
<font color="black"> 141. </font>
<font color="green"> 142.     def __init__(self, futures):</font>
<font color="red"> 143.         self.futures = sorted(futures, key=id)</font>
<font color="black"> 144. </font>
<font color="green"> 145.     def __enter__(self):</font>
<font color="red"> 146.         for future in self.futures:</font>
<font color="red"> 147.             future._condition.acquire()</font>
<font color="black"> 148. </font>
<font color="green"> 149.     def __exit__(self, *args):</font>
<font color="red"> 150.         for future in self.futures:</font>
<font color="red"> 151.             future._condition.release()</font>
<font color="black"> 152. </font>
<font color="green"> 153. def _create_and_install_waiters(fs, return_when):</font>
<font color="red"> 154.     if return_when == _AS_COMPLETED:</font>
<font color="red"> 155.         waiter = _AsCompletedWaiter()</font>
<font color="red"> 156.     elif return_when == FIRST_COMPLETED:</font>
<font color="red"> 157.         waiter = _FirstCompletedWaiter()</font>
<font color="black"> 158.     else:</font>
<font color="red"> 159.         pending_count = sum(</font>
<font color="red"> 160.                 f._state not in [CANCELLED_AND_NOTIFIED, FINISHED] for f in fs)</font>
<font color="black"> 161. </font>
<font color="red"> 162.         if return_when == FIRST_EXCEPTION:</font>
<font color="red"> 163.             waiter = _AllCompletedWaiter(pending_count, stop_on_exception=True)</font>
<font color="red"> 164.         elif return_when == ALL_COMPLETED:</font>
<font color="red"> 165.             waiter = _AllCompletedWaiter(pending_count, stop_on_exception=False)</font>
<font color="black"> 166.         else:</font>
<font color="red"> 167.             raise ValueError(&quot;Invalid return condition: %r&quot; % return_when)</font>
<font color="black"> 168. </font>
<font color="red"> 169.     for f in fs:</font>
<font color="red"> 170.         f._waiters.append(waiter)</font>
<font color="black"> 171. </font>
<font color="red"> 172.     return waiter</font>
<font color="black"> 173. </font>
<font color="green"> 174. def as_completed(fs, timeout=None):</font>
<font color="black"> 175.     &quot;&quot;&quot;An iterator over the given futures that yields each as it completes.</font>
<font color="black"> 176. </font>
<font color="black"> 177.     Args:</font>
<font color="black"> 178.         fs: The sequence of Futures (possibly created by different Executors) to</font>
<font color="black"> 179.             iterate over.</font>
<font color="black"> 180.         timeout: The maximum number of seconds to wait. If None, then there</font>
<font color="black"> 181.             is no limit on the wait time.</font>
<font color="black"> 182. </font>
<font color="black"> 183.     Returns:</font>
<font color="black"> 184.         An iterator that yields the given Futures as they complete (finished or</font>
<font color="black"> 185.         cancelled). If any given Futures are duplicated, they will be returned</font>
<font color="black"> 186.         once.</font>
<font color="black"> 187. </font>
<font color="black"> 188.     Raises:</font>
<font color="black"> 189.         TimeoutError: If the entire result iterator could not be generated</font>
<font color="black"> 190.             before the given timeout.</font>
<font color="black"> 191.     &quot;&quot;&quot;</font>
<font color="red"> 192.     if timeout is not None:</font>
<font color="red"> 193.         end_time = timeout + time.time()</font>
<font color="black"> 194. </font>
<font color="red"> 195.     fs = set(fs)</font>
<font color="red"> 196.     with _AcquireFutures(fs):</font>
<font color="red"> 197.         finished = set(</font>
<font color="red"> 198.                 f for f in fs</font>
<font color="red"> 199.                 if f._state in [CANCELLED_AND_NOTIFIED, FINISHED])</font>
<font color="red"> 200.         pending = fs - finished</font>
<font color="red"> 201.         waiter = _create_and_install_waiters(fs, _AS_COMPLETED)</font>
<font color="black"> 202. </font>
<font color="red"> 203.     try:</font>
<font color="red"> 204.         for future in finished:</font>
<font color="red"> 205.             yield future</font>
<font color="black"> 206. </font>
<font color="red"> 207.         while pending:</font>
<font color="red"> 208.             if timeout is None:</font>
<font color="red"> 209.                 wait_timeout = None</font>
<font color="black"> 210.             else:</font>
<font color="red"> 211.                 wait_timeout = end_time - time.time()</font>
<font color="red"> 212.                 if wait_timeout &lt; 0:</font>
<font color="red"> 213.                     raise TimeoutError(</font>
<font color="red"> 214.                             '%d (of %d) futures unfinished' % (</font>
<font color="red"> 215.                             len(pending), len(fs)))</font>
<font color="black"> 216. </font>
<font color="red"> 217.             waiter.event.wait(wait_timeout)</font>
<font color="black"> 218. </font>
<font color="red"> 219.             with waiter.lock:</font>
<font color="red"> 220.                 finished = waiter.finished_futures</font>
<font color="red"> 221.                 waiter.finished_futures = []</font>
<font color="red"> 222.                 waiter.event.clear()</font>
<font color="black"> 223. </font>
<font color="red"> 224.             for future in finished:</font>
<font color="red"> 225.                 yield future</font>
<font color="red"> 226.                 pending.remove(future)</font>
<font color="black"> 227. </font>
<font color="black"> 228.     finally:</font>
<font color="red"> 229.         for f in fs:</font>
<font color="red"> 230.             with f._condition:</font>
<font color="red"> 231.                 f._waiters.remove(waiter)</font>
<font color="black"> 232. </font>
<font color="green"> 233. DoneAndNotDoneFutures = collections.namedtuple(</font>
<font color="green"> 234.         'DoneAndNotDoneFutures', 'done not_done')</font>
<font color="green"> 235. def wait(fs, timeout=None, return_when=ALL_COMPLETED):</font>
<font color="black"> 236.     &quot;&quot;&quot;Wait for the futures in the given sequence to complete.</font>
<font color="black"> 237. </font>
<font color="black"> 238.     Args:</font>
<font color="black"> 239.         fs: The sequence of Futures (possibly created by different Executors) to</font>
<font color="black"> 240.             wait upon.</font>
<font color="black"> 241.         timeout: The maximum number of seconds to wait. If None, then there</font>
<font color="black"> 242.             is no limit on the wait time.</font>
<font color="black"> 243.         return_when: Indicates when this function should return. The options</font>
<font color="black"> 244.             are:</font>
<font color="black"> 245. </font>
<font color="black"> 246.             FIRST_COMPLETED - Return when any future finishes or is</font>
<font color="black"> 247.                               cancelled.</font>
<font color="black"> 248.             FIRST_EXCEPTION - Return when any future finishes by raising an</font>
<font color="black"> 249.                               exception. If no future raises an exception</font>
<font color="black"> 250.                               then it is equivalent to ALL_COMPLETED.</font>
<font color="black"> 251.             ALL_COMPLETED -   Return when all futures finish or are cancelled.</font>
<font color="black"> 252. </font>
<font color="black"> 253.     Returns:</font>
<font color="black"> 254.         A named 2-tuple of sets. The first set, named 'done', contains the</font>
<font color="black"> 255.         futures that completed (is finished or cancelled) before the wait</font>
<font color="black"> 256.         completed. The second set, named 'not_done', contains uncompleted</font>
<font color="black"> 257.         futures.</font>
<font color="black"> 258.     &quot;&quot;&quot;</font>
<font color="red"> 259.     with _AcquireFutures(fs):</font>
<font color="red"> 260.         done = set(f for f in fs</font>
<font color="red"> 261.                    if f._state in [CANCELLED_AND_NOTIFIED, FINISHED])</font>
<font color="red"> 262.         not_done = set(fs) - done</font>
<font color="black"> 263. </font>
<font color="red"> 264.         if (return_when == FIRST_COMPLETED) and done:</font>
<font color="red"> 265.             return DoneAndNotDoneFutures(done, not_done)</font>
<font color="red"> 266.         elif (return_when == FIRST_EXCEPTION) and done:</font>
<font color="red"> 267.             if any(f for f in done</font>
<font color="red"> 268.                    if not f.cancelled() and f.exception() is not None):</font>
<font color="red"> 269.                 return DoneAndNotDoneFutures(done, not_done)</font>
<font color="black"> 270. </font>
<font color="red"> 271.         if len(done) == len(fs):</font>
<font color="red"> 272.             return DoneAndNotDoneFutures(done, not_done)</font>
<font color="black"> 273. </font>
<font color="red"> 274.         waiter = _create_and_install_waiters(fs, return_when)</font>
<font color="black"> 275. </font>
<font color="red"> 276.     waiter.event.wait(timeout)</font>
<font color="red"> 277.     for f in fs:</font>
<font color="red"> 278.         with f._condition:</font>
<font color="red"> 279.             f._waiters.remove(waiter)</font>
<font color="black"> 280. </font>
<font color="red"> 281.     done.update(waiter.finished_futures)</font>
<font color="red"> 282.     return DoneAndNotDoneFutures(done, set(fs) - done)</font>
<font color="black"> 283. </font>
<font color="green"> 284. class Future(object):</font>
<font color="green"> 285.     &quot;&quot;&quot;Represents the result of an asynchronous computation.&quot;&quot;&quot;</font>
<font color="black"> 286. </font>
<font color="green"> 287.     def __init__(self):</font>
<font color="black"> 288.         &quot;&quot;&quot;Initializes the future. Should not be called by clients.&quot;&quot;&quot;</font>
<font color="red"> 289.         self._condition = threading.Condition()</font>
<font color="red"> 290.         self._state = PENDING</font>
<font color="red"> 291.         self._result = None</font>
<font color="red"> 292.         self._exception = None</font>
<font color="red"> 293.         self._traceback = None</font>
<font color="red"> 294.         self._waiters = []</font>
<font color="red"> 295.         self._done_callbacks = []</font>
<font color="black"> 296. </font>
<font color="green"> 297.     def _invoke_callbacks(self):</font>
<font color="red"> 298.         for callback in self._done_callbacks:</font>
<font color="red"> 299.             try:</font>
<font color="red"> 300.                 callback(self)</font>
<font color="red"> 301.             except Exception:</font>
<font color="red"> 302.                 LOGGER.exception('exception calling callback for %r', self)</font>
<font color="black"> 303. </font>
<font color="green"> 304.     def __repr__(self):</font>
<font color="red"> 305.         with self._condition:</font>
<font color="red"> 306.             if self._state == FINISHED:</font>
<font color="red"> 307.                 if self._exception:</font>
<font color="red"> 308.                     return '&lt;Future at %s state=%s raised %s&gt;' % (</font>
<font color="red"> 309.                         hex(id(self)),</font>
<font color="red"> 310.                         _STATE_TO_DESCRIPTION_MAP[self._state],</font>
<font color="red"> 311.                         self._exception.__class__.__name__)</font>
<font color="black"> 312.                 else:</font>
<font color="red"> 313.                     return '&lt;Future at %s state=%s returned %s&gt;' % (</font>
<font color="red"> 314.                         hex(id(self)),</font>
<font color="red"> 315.                         _STATE_TO_DESCRIPTION_MAP[self._state],</font>
<font color="red"> 316.                         self._result.__class__.__name__)</font>
<font color="red"> 317.             return '&lt;Future at %s state=%s&gt;' % (</font>
<font color="red"> 318.                     hex(id(self)),</font>
<font color="red"> 319.                    _STATE_TO_DESCRIPTION_MAP[self._state])</font>
<font color="black"> 320. </font>
<font color="green"> 321.     def cancel(self):</font>
<font color="black"> 322.         &quot;&quot;&quot;Cancel the future if possible.</font>
<font color="black"> 323. </font>
<font color="black"> 324.         Returns True if the future was cancelled, False otherwise. A future</font>
<font color="black"> 325.         cannot be cancelled if it is running or has already completed.</font>
<font color="black"> 326.         &quot;&quot;&quot;</font>
<font color="red"> 327.         with self._condition:</font>
<font color="red"> 328.             if self._state in [RUNNING, FINISHED]:</font>
<font color="red"> 329.                 return False</font>
<font color="black"> 330. </font>
<font color="red"> 331.             if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:</font>
<font color="red"> 332.                 return True</font>
<font color="black"> 333. </font>
<font color="red"> 334.             self._state = CANCELLED</font>
<font color="red"> 335.             self._condition.notify_all()</font>
<font color="black"> 336. </font>
<font color="red"> 337.         self._invoke_callbacks()</font>
<font color="red"> 338.         return True</font>
<font color="black"> 339. </font>
<font color="green"> 340.     def cancelled(self):</font>
<font color="black"> 341.         &quot;&quot;&quot;Return True if the future has cancelled.&quot;&quot;&quot;</font>
<font color="red"> 342.         with self._condition:</font>
<font color="red"> 343.             return self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]</font>
<font color="black"> 344. </font>
<font color="green"> 345.     def running(self):</font>
<font color="black"> 346.         &quot;&quot;&quot;Return True if the future is currently executing.&quot;&quot;&quot;</font>
<font color="red"> 347.         with self._condition:</font>
<font color="red"> 348.             return self._state == RUNNING</font>
<font color="black"> 349. </font>
<font color="green"> 350.     def done(self):</font>
<font color="black"> 351.         &quot;&quot;&quot;Return True of the future was cancelled or finished executing.&quot;&quot;&quot;</font>
<font color="red"> 352.         with self._condition:</font>
<font color="red"> 353.             return self._state in [CANCELLED, CANCELLED_AND_NOTIFIED, FINISHED]</font>
<font color="black"> 354. </font>
<font color="green"> 355.     def __get_result(self):</font>
<font color="red"> 356.         if self._exception:</font>
<font color="red"> 357.             raise type(self._exception), self._exception, self._traceback</font>
<font color="black"> 358.         else:</font>
<font color="red"> 359.             return self._result</font>
<font color="black"> 360. </font>
<font color="green"> 361.     def add_done_callback(self, fn):</font>
<font color="black"> 362.         &quot;&quot;&quot;Attaches a callable that will be called when the future finishes.</font>
<font color="black"> 363. </font>
<font color="black"> 364.         Args:</font>
<font color="black"> 365.             fn: A callable that will be called with this future as its only</font>
<font color="black"> 366.                 argument when the future completes or is cancelled. The callable</font>
<font color="black"> 367.                 will always be called by a thread in the same process in which</font>
<font color="black"> 368.                 it was added. If the future has already completed or been</font>
<font color="black"> 369.                 cancelled then the callable will be called immediately. These</font>
<font color="black"> 370.                 callables are called in the order that they were added.</font>
<font color="black"> 371.         &quot;&quot;&quot;</font>
<font color="red"> 372.         with self._condition:</font>
<font color="red"> 373.             if self._state not in [CANCELLED, CANCELLED_AND_NOTIFIED, FINISHED]:</font>
<font color="red"> 374.                 self._done_callbacks.append(fn)</font>
<font color="red"> 375.                 return</font>
<font color="red"> 376.         fn(self)</font>
<font color="black"> 377. </font>
<font color="green"> 378.     def result(self, timeout=None):</font>
<font color="black"> 379.         &quot;&quot;&quot;Return the result of the call that the future represents.</font>
<font color="black"> 380. </font>
<font color="black"> 381.         Args:</font>
<font color="black"> 382.             timeout: The number of seconds to wait for the result if the future</font>
<font color="black"> 383.                 isn't done. If None, then there is no limit on the wait time.</font>
<font color="black"> 384. </font>
<font color="black"> 385.         Returns:</font>
<font color="black"> 386.             The result of the call that the future represents.</font>
<font color="black"> 387. </font>
<font color="black"> 388.         Raises:</font>
<font color="black"> 389.             CancelledError: If the future was cancelled.</font>
<font color="black"> 390.             TimeoutError: If the future didn't finish executing before the given</font>
<font color="black"> 391.                 timeout.</font>
<font color="black"> 392.             Exception: If the call raised then that exception will be raised.</font>
<font color="black"> 393.         &quot;&quot;&quot;</font>
<font color="red"> 394.         with self._condition:</font>
<font color="red"> 395.             if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:</font>
<font color="red"> 396.                 raise CancelledError()</font>
<font color="red"> 397.             elif self._state == FINISHED:</font>
<font color="red"> 398.                 return self.__get_result()</font>
<font color="black"> 399. </font>
<font color="red"> 400.             self._condition.wait(timeout)</font>
<font color="black"> 401. </font>
<font color="red"> 402.             if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:</font>
<font color="red"> 403.                 raise CancelledError()</font>
<font color="red"> 404.             elif self._state == FINISHED:</font>
<font color="red"> 405.                 return self.__get_result()</font>
<font color="black"> 406.             else:</font>
<font color="red"> 407.                 raise TimeoutError()</font>
<font color="black"> 408. </font>
<font color="green"> 409.     def exception_info(self, timeout=None):</font>
<font color="black"> 410.         &quot;&quot;&quot;Return a tuple of (exception, traceback) raised by the call that the</font>
<font color="black"> 411.         future represents.</font>
<font color="black"> 412. </font>
<font color="black"> 413.         Args:</font>
<font color="black"> 414.             timeout: The number of seconds to wait for the exception if the</font>
<font color="black"> 415.                 future isn't done. If None, then there is no limit on the wait</font>
<font color="black"> 416.                 time.</font>
<font color="black"> 417. </font>
<font color="black"> 418.         Returns:</font>
<font color="black"> 419.             The exception raised by the call that the future represents or None</font>
<font color="black"> 420.             if the call completed without raising.</font>
<font color="black"> 421. </font>
<font color="black"> 422.         Raises:</font>
<font color="black"> 423.             CancelledError: If the future was cancelled.</font>
<font color="black"> 424.             TimeoutError: If the future didn't finish executing before the given</font>
<font color="black"> 425.                 timeout.</font>
<font color="black"> 426.         &quot;&quot;&quot;</font>
<font color="red"> 427.         with self._condition:</font>
<font color="red"> 428.             if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:</font>
<font color="red"> 429.                 raise CancelledError()</font>
<font color="red"> 430.             elif self._state == FINISHED:</font>
<font color="red"> 431.                 return self._exception, self._traceback</font>
<font color="black"> 432. </font>
<font color="red"> 433.             self._condition.wait(timeout)</font>
<font color="black"> 434. </font>
<font color="red"> 435.             if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:</font>
<font color="red"> 436.                 raise CancelledError()</font>
<font color="red"> 437.             elif self._state == FINISHED:</font>
<font color="red"> 438.                 return self._exception, self._traceback</font>
<font color="black"> 439.             else:</font>
<font color="red"> 440.                 raise TimeoutError()</font>
<font color="black"> 441. </font>
<font color="green"> 442.     def exception(self, timeout=None):</font>
<font color="black"> 443.         &quot;&quot;&quot;Return the exception raised by the call that the future represents.</font>
<font color="black"> 444. </font>
<font color="black"> 445.         Args:</font>
<font color="black"> 446.             timeout: The number of seconds to wait for the exception if the</font>
<font color="black"> 447.                 future isn't done. If None, then there is no limit on the wait</font>
<font color="black"> 448.                 time.</font>
<font color="black"> 449. </font>
<font color="black"> 450.         Returns:</font>
<font color="black"> 451.             The exception raised by the call that the future represents or None</font>
<font color="black"> 452.             if the call completed without raising.</font>
<font color="black"> 453. </font>
<font color="black"> 454.         Raises:</font>
<font color="black"> 455.             CancelledError: If the future was cancelled.</font>
<font color="black"> 456.             TimeoutError: If the future didn't finish executing before the given</font>
<font color="black"> 457.                 timeout.</font>
<font color="black"> 458.         &quot;&quot;&quot;</font>
<font color="red"> 459.         return self.exception_info(timeout)[0]</font>
<font color="black"> 460. </font>
<font color="black"> 461.     # The following methods should only be used by Executors and in tests.</font>
<font color="green"> 462.     def set_running_or_notify_cancel(self):</font>
<font color="black"> 463.         &quot;&quot;&quot;Mark the future as running or process any cancel notifications.</font>
<font color="black"> 464. </font>
<font color="black"> 465.         Should only be used by Executor implementations and unit tests.</font>
<font color="black"> 466. </font>
<font color="black"> 467.         If the future has been cancelled (cancel() was called and returned</font>
<font color="black"> 468.         True) then any threads waiting on the future completing (though calls</font>
<font color="black"> 469.         to as_completed() or wait()) are notified and False is returned.</font>
<font color="black"> 470. </font>
<font color="black"> 471.         If the future was not cancelled then it is put in the running state</font>
<font color="black"> 472.         (future calls to running() will return True) and True is returned.</font>
<font color="black"> 473. </font>
<font color="black"> 474.         This method should be called by Executor implementations before</font>
<font color="black"> 475.         executing the work associated with this future. If this method returns</font>
<font color="black"> 476.         False then the work should not be executed.</font>
<font color="black"> 477. </font>
<font color="black"> 478.         Returns:</font>
<font color="black"> 479.             False if the Future was cancelled, True otherwise.</font>
<font color="black"> 480. </font>
<font color="black"> 481.         Raises:</font>
<font color="black"> 482.             RuntimeError: if this method was already called or if set_result()</font>
<font color="black"> 483.                 or set_exception() was called.</font>
<font color="black"> 484.         &quot;&quot;&quot;</font>
<font color="red"> 485.         with self._condition:</font>
<font color="red"> 486.             if self._state == CANCELLED:</font>
<font color="red"> 487.                 self._state = CANCELLED_AND_NOTIFIED</font>
<font color="red"> 488.                 for waiter in self._waiters:</font>
<font color="red"> 489.                     waiter.add_cancelled(self)</font>
<font color="black"> 490.                 # self._condition.notify_all() is not necessary because</font>
<font color="black"> 491.                 # self.cancel() triggers a notification.</font>
<font color="red"> 492.                 return False</font>
<font color="red"> 493.             elif self._state == PENDING:</font>
<font color="red"> 494.                 self._state = RUNNING</font>
<font color="red"> 495.                 return True</font>
<font color="black"> 496.             else:</font>
<font color="red"> 497.                 LOGGER.critical('Future %s in unexpected state: %s',</font>
<font color="red"> 498.                                 id(self),</font>
<font color="red"> 499.                                 self._state)</font>
<font color="red"> 500.                 raise RuntimeError('Future in unexpected state')</font>
<font color="black"> 501. </font>
<font color="green"> 502.     def set_result(self, result):</font>
<font color="black"> 503.         &quot;&quot;&quot;Sets the return value of work associated with the future.</font>
<font color="black"> 504. </font>
<font color="black"> 505.         Should only be used by Executor implementations and unit tests.</font>
<font color="black"> 506.         &quot;&quot;&quot;</font>
<font color="red"> 507.         with self._condition:</font>
<font color="red"> 508.             self._result = result</font>
<font color="red"> 509.             self._state = FINISHED</font>
<font color="red"> 510.             for waiter in self._waiters:</font>
<font color="red"> 511.                 waiter.add_result(self)</font>
<font color="red"> 512.             self._condition.notify_all()</font>
<font color="red"> 513.         self._invoke_callbacks()</font>
<font color="black"> 514. </font>
<font color="green"> 515.     def set_exception_info(self, exception, traceback):</font>
<font color="black"> 516.         &quot;&quot;&quot;Sets the result of the future as being the given exception</font>
<font color="black"> 517.         and traceback.</font>
<font color="black"> 518. </font>
<font color="black"> 519.         Should only be used by Executor implementations and unit tests.</font>
<font color="black"> 520.         &quot;&quot;&quot;</font>
<font color="red"> 521.         with self._condition:</font>
<font color="red"> 522.             self._exception = exception</font>
<font color="red"> 523.             self._traceback = traceback</font>
<font color="red"> 524.             self._state = FINISHED</font>
<font color="red"> 525.             for waiter in self._waiters:</font>
<font color="red"> 526.                 waiter.add_exception(self)</font>
<font color="red"> 527.             self._condition.notify_all()</font>
<font color="red"> 528.         self._invoke_callbacks()</font>
<font color="black"> 529. </font>
<font color="green"> 530.     def set_exception(self, exception):</font>
<font color="black"> 531.         &quot;&quot;&quot;Sets the result of the future as being the given exception.</font>
<font color="black"> 532. </font>
<font color="black"> 533.         Should only be used by Executor implementations and unit tests.</font>
<font color="black"> 534.         &quot;&quot;&quot;</font>
<font color="red"> 535.         self.set_exception_info(exception, None)</font>
<font color="black"> 536. </font>
<font color="green"> 537. class Executor(object):</font>
<font color="green"> 538.     &quot;&quot;&quot;This is an abstract base class for concrete asynchronous executors.&quot;&quot;&quot;</font>
<font color="black"> 539. </font>
<font color="green"> 540.     def submit(self, fn, *args, **kwargs):</font>
<font color="black"> 541.         &quot;&quot;&quot;Submits a callable to be executed with the given arguments.</font>
<font color="black"> 542. </font>
<font color="black"> 543.         Schedules the callable to be executed as fn(*args, **kwargs) and returns</font>
<font color="black"> 544.         a Future instance representing the execution of the callable.</font>
<font color="black"> 545. </font>
<font color="black"> 546.         Returns:</font>
<font color="black"> 547.             A Future representing the given call.</font>
<font color="black"> 548.         &quot;&quot;&quot;</font>
<font color="red"> 549.         raise NotImplementedError()</font>
<font color="black"> 550. </font>
<font color="green"> 551.     def map(self, fn, *iterables, **kwargs):</font>
<font color="black"> 552.         &quot;&quot;&quot;Returns a iterator equivalent to map(fn, iter).</font>
<font color="black"> 553. </font>
<font color="black"> 554.         Args:</font>
<font color="black"> 555.             fn: A callable that will take as many arguments as there are</font>
<font color="black"> 556.                 passed iterables.</font>
<font color="black"> 557.             timeout: The maximum number of seconds to wait. If None, then there</font>
<font color="black"> 558.                 is no limit on the wait time.</font>
<font color="black"> 559. </font>
<font color="black"> 560.         Returns:</font>
<font color="black"> 561.             An iterator equivalent to: map(func, *iterables) but the calls may</font>
<font color="black"> 562.             be evaluated out-of-order.</font>
<font color="black"> 563. </font>
<font color="black"> 564.         Raises:</font>
<font color="black"> 565.             TimeoutError: If the entire result iterator could not be generated</font>
<font color="black"> 566.                 before the given timeout.</font>
<font color="black"> 567.             Exception: If fn(*args) raises for any values.</font>
<font color="black"> 568.         &quot;&quot;&quot;</font>
<font color="red"> 569.         timeout = kwargs.get('timeout')</font>
<font color="red"> 570.         if timeout is not None:</font>
<font color="red"> 571.             end_time = timeout + time.time()</font>
<font color="black"> 572. </font>
<font color="red"> 573.         fs = [self.submit(fn, *args) for args in itertools.izip(*iterables)]</font>
<font color="black"> 574. </font>
<font color="black"> 575.         # Yield must be hidden in closure so that the futures are submitted</font>
<font color="black"> 576.         # before the first iterator value is required.</font>
<font color="red"> 577.         def result_iterator():</font>
<font color="red"> 578.             try:</font>
<font color="red"> 579.                 for future in fs:</font>
<font color="red"> 580.                     if timeout is None:</font>
<font color="red"> 581.                         yield future.result()</font>
<font color="black"> 582.                     else:</font>
<font color="red"> 583.                         yield future.result(end_time - time.time())</font>
<font color="black"> 584.             finally:</font>
<font color="red"> 585.                 for future in fs:</font>
<font color="red"> 586.                     future.cancel()</font>
<font color="red"> 587.         return result_iterator()</font>
<font color="black"> 588. </font>
<font color="green"> 589.     def shutdown(self, wait=True):</font>
<font color="black"> 590.         &quot;&quot;&quot;Clean-up the resources associated with the Executor.</font>
<font color="black"> 591. </font>
<font color="black"> 592.         It is safe to call this method several times. Otherwise, no other</font>
<font color="black"> 593.         methods can be called after this one.</font>
<font color="black"> 594. </font>
<font color="black"> 595.         Args:</font>
<font color="black"> 596.             wait: If True then shutdown will not return until all running</font>
<font color="black"> 597.                 futures have finished executing and the resources used by the</font>
<font color="black"> 598.                 executor have been reclaimed.</font>
<font color="black"> 599.         &quot;&quot;&quot;</font>
<font color="red"> 600.         pass</font>
<font color="black"> 601. </font>
<font color="green"> 602.     def __enter__(self):</font>
<font color="red"> 603.         return self</font>
<font color="black"> 604. </font>
<font color="green"> 605.     def __exit__(self, exc_type, exc_val, exc_tb):</font>
<font color="red"> 606.         self.shutdown(wait=True)</font>
<font color="red"> 607.         return False</font>
</pre>

