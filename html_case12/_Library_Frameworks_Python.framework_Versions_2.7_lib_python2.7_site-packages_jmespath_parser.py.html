source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/jmespath/parser.py</b><br>


file stats: <b>388 lines, 97 executed: 25.0% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;Top down operator precedence parser.</font>
<font color="black">   2. </font>
<font color="black">   3. This is an implementation of Vaughan R. Pratt's</font>
<font color="black">   4. &quot;Top Down Operator Precedence&quot; parser.</font>
<font color="black">   5. (http://dl.acm.org/citation.cfm?doid=512927.512931).</font>
<font color="black">   6. </font>
<font color="black">   7. These are some additional resources that help explain the</font>
<font color="black">   8. general idea behind a Pratt parser:</font>
<font color="black">   9. </font>
<font color="black">  10. * http://effbot.org/zone/simple-top-down-parsing.htm</font>
<font color="black">  11. * http://javascript.crockford.com/tdop/tdop.html</font>
<font color="black">  12. </font>
<font color="black">  13. A few notes on the implementation.</font>
<font color="black">  14. </font>
<font color="black">  15. * All the nud/led tokens are on the Parser class itself, and are dispatched</font>
<font color="black">  16.   using getattr().  This keeps all the parsing logic contained to a single</font>
<font color="black">  17.   class.</font>
<font color="black">  18. * We use two passes through the data.  One to create a list of token,</font>
<font color="black">  19.   then one pass through the tokens to create the AST.  While the lexer actually</font>
<font color="black">  20.   yields tokens, we convert it to a list so we can easily implement two tokens</font>
<font color="black">  21.   of lookahead.  A previous implementation used a fixed circular buffer, but it</font>
<font color="black">  22.   was significantly slower.  Also, the average jmespath expression typically</font>
<font color="black">  23.   does not have a large amount of token so this is not an issue.  And</font>
<font color="black">  24.   interestingly enough, creating a token list first is actually faster than</font>
<font color="black">  25.   consuming from the token iterator one token at a time.</font>
<font color="black">  26. </font>
<font color="green">  27. &quot;&quot;&quot;</font>
<font color="green">  28. import random</font>
<font color="black">  29. </font>
<font color="green">  30. from jmespath import lexer</font>
<font color="green">  31. from jmespath.compat import with_repr_method</font>
<font color="green">  32. from jmespath import ast</font>
<font color="green">  33. from jmespath import exceptions</font>
<font color="green">  34. from jmespath import visitor</font>
<font color="black">  35. </font>
<font color="black">  36. </font>
<font color="green">  37. class Parser(object):</font>
<font color="green">  38.     BINDING_POWER = {</font>
<font color="green">  39.         'eof': 0,</font>
<font color="green">  40.         'unquoted_identifier': 0,</font>
<font color="green">  41.         'quoted_identifier': 0,</font>
<font color="green">  42.         'rbracket': 0,</font>
<font color="green">  43.         'rparen': 0,</font>
<font color="green">  44.         'comma': 0,</font>
<font color="green">  45.         'rbrace': 0,</font>
<font color="green">  46.         'number': 0,</font>
<font color="green">  47.         'current': 0,</font>
<font color="green">  48.         'expref': 0,</font>
<font color="green">  49.         'colon': 0,</font>
<font color="green">  50.         'pipe': 1,</font>
<font color="green">  51.         'or': 2,</font>
<font color="green">  52.         'and': 3,</font>
<font color="green">  53.         'eq': 5,</font>
<font color="green">  54.         'gt': 5,</font>
<font color="green">  55.         'lt': 5,</font>
<font color="green">  56.         'gte': 5,</font>
<font color="green">  57.         'lte': 5,</font>
<font color="green">  58.         'ne': 5,</font>
<font color="green">  59.         'flatten': 9,</font>
<font color="black">  60.         # Everything above stops a projection.</font>
<font color="green">  61.         'star': 20,</font>
<font color="green">  62.         'filter': 21,</font>
<font color="green">  63.         'dot': 40,</font>
<font color="green">  64.         'not': 45,</font>
<font color="green">  65.         'lbrace': 50,</font>
<font color="green">  66.         'lbracket': 55,</font>
<font color="green">  67.         'lparen': 60,</font>
<font color="black">  68.     }</font>
<font color="black">  69.     # The maximum binding power for a token that can stop</font>
<font color="black">  70.     # a projection.</font>
<font color="green">  71.     _PROJECTION_STOP = 10</font>
<font color="black">  72.     # The _MAX_SIZE most recent expressions are cached in</font>
<font color="black">  73.     # _CACHE dict.</font>
<font color="green">  74.     _CACHE = {}</font>
<font color="green">  75.     _MAX_SIZE = 128</font>
<font color="black">  76. </font>
<font color="green">  77.     def __init__(self, lookahead=2):</font>
<font color="red">  78.         self.tokenizer = None</font>
<font color="red">  79.         self._tokens = [None] * lookahead</font>
<font color="red">  80.         self._buffer_size = lookahead</font>
<font color="red">  81.         self._index = 0</font>
<font color="black">  82. </font>
<font color="green">  83.     def parse(self, expression):</font>
<font color="red">  84.         cached = self._CACHE.get(expression)</font>
<font color="red">  85.         if cached is not None:</font>
<font color="red">  86.             return cached</font>
<font color="red">  87.         parsed_result = self._do_parse(expression)</font>
<font color="red">  88.         self._CACHE[expression] = parsed_result</font>
<font color="red">  89.         if len(self._CACHE) &gt; self._MAX_SIZE:</font>
<font color="red">  90.             self._free_cache_entries()</font>
<font color="red">  91.         return parsed_result</font>
<font color="black">  92. </font>
<font color="green">  93.     def _do_parse(self, expression):</font>
<font color="red">  94.         try:</font>
<font color="red">  95.             return self._parse(expression)</font>
<font color="red">  96.         except exceptions.LexerError as e:</font>
<font color="red">  97.             e.expression = expression</font>
<font color="red">  98.             raise</font>
<font color="red">  99.         except exceptions.IncompleteExpressionError as e:</font>
<font color="red"> 100.             e.set_expression(expression)</font>
<font color="red"> 101.             raise</font>
<font color="red"> 102.         except exceptions.ParseError as e:</font>
<font color="red"> 103.             e.expression = expression</font>
<font color="red"> 104.             raise</font>
<font color="black"> 105. </font>
<font color="green"> 106.     def _parse(self, expression):</font>
<font color="red"> 107.         self.tokenizer = lexer.Lexer().tokenize(expression)</font>
<font color="red"> 108.         self._tokens = list(self.tokenizer)</font>
<font color="red"> 109.         self._index = 0</font>
<font color="red"> 110.         parsed = self._expression(binding_power=0)</font>
<font color="red"> 111.         if not self._current_token() == 'eof':</font>
<font color="red"> 112.             t = self._lookahead_token(0)</font>
<font color="red"> 113.             raise exceptions.ParseError(t['start'], t['value'], t['type'],</font>
<font color="red"> 114.                                         &quot;Unexpected token: %s&quot; % t['value'])</font>
<font color="red"> 115.         return ParsedResult(expression, parsed)</font>
<font color="black"> 116. </font>
<font color="green"> 117.     def _expression(self, binding_power=0):</font>
<font color="red"> 118.         left_token = self._lookahead_token(0)</font>
<font color="red"> 119.         self._advance()</font>
<font color="red"> 120.         nud_function = getattr(</font>
<font color="red"> 121.             self, '_token_nud_%s' % left_token['type'],</font>
<font color="red"> 122.             self._error_nud_token)</font>
<font color="red"> 123.         left = nud_function(left_token)</font>
<font color="red"> 124.         current_token = self._current_token()</font>
<font color="red"> 125.         while binding_power &lt; self.BINDING_POWER[current_token]:</font>
<font color="red"> 126.             led = getattr(self, '_token_led_%s' % current_token, None)</font>
<font color="red"> 127.             if led is None:</font>
<font color="red"> 128.                 error_token = self._lookahead_token(0)</font>
<font color="red"> 129.                 self._error_led_token(error_token)</font>
<font color="black"> 130.             else:</font>
<font color="red"> 131.                 self._advance()</font>
<font color="red"> 132.                 left = led(left)</font>
<font color="red"> 133.                 current_token = self._current_token()</font>
<font color="red"> 134.         return left</font>
<font color="black"> 135. </font>
<font color="green"> 136.     def _token_nud_string_literal(self, token):</font>
<font color="red"> 137.         return ast.literal(token['value'])</font>
<font color="black"> 138. </font>
<font color="green"> 139.     def _token_nud_literal(self, token):</font>
<font color="red"> 140.         return ast.literal(token['value'])</font>
<font color="black"> 141. </font>
<font color="green"> 142.     def _token_nud_unquoted_identifier(self, token):</font>
<font color="red"> 143.         return ast.field(token['value'])</font>
<font color="black"> 144. </font>
<font color="green"> 145.     def _token_nud_quoted_identifier(self, token):</font>
<font color="red"> 146.         field = ast.field(token['value'])</font>
<font color="black"> 147.         # You can't have a quoted identifier as a function</font>
<font color="black"> 148.         # name.</font>
<font color="red"> 149.         if self._current_token() == 'lparen':</font>
<font color="red"> 150.             t = self._lookahead_token(0)</font>
<font color="red"> 151.             raise exceptions.ParseError(</font>
<font color="red"> 152.                 0, t['value'], t['type'],</font>
<font color="red"> 153.                 'Quoted identifier not allowed for function names.')</font>
<font color="red"> 154.         return field</font>
<font color="black"> 155. </font>
<font color="green"> 156.     def _token_nud_star(self, token):</font>
<font color="red"> 157.         left = ast.identity()</font>
<font color="red"> 158.         if self._current_token() == 'rbracket':</font>
<font color="red"> 159.             right = ast.identity()</font>
<font color="black"> 160.         else:</font>
<font color="red"> 161.             right = self._parse_projection_rhs(self.BINDING_POWER['star'])</font>
<font color="red"> 162.         return ast.value_projection(left, right)</font>
<font color="black"> 163. </font>
<font color="green"> 164.     def _token_nud_filter(self, token):</font>
<font color="red"> 165.         return self._token_led_filter(ast.identity())</font>
<font color="black"> 166. </font>
<font color="green"> 167.     def _token_nud_lbrace(self, token):</font>
<font color="red"> 168.         return self._parse_multi_select_hash()</font>
<font color="black"> 169. </font>
<font color="green"> 170.     def _token_nud_lparen(self, token):</font>
<font color="red"> 171.         expression = self._expression()</font>
<font color="red"> 172.         self._match('rparen')</font>
<font color="red"> 173.         return expression</font>
<font color="black"> 174. </font>
<font color="green"> 175.     def _token_nud_flatten(self, token):</font>
<font color="red"> 176.         left = ast.flatten(ast.identity())</font>
<font color="red"> 177.         right = self._parse_projection_rhs(</font>
<font color="red"> 178.             self.BINDING_POWER['flatten'])</font>
<font color="red"> 179.         return ast.projection(left, right)</font>
<font color="black"> 180. </font>
<font color="green"> 181.     def _token_nud_not(self, token):</font>
<font color="red"> 182.         expr = self._expression(self.BINDING_POWER['not'])</font>
<font color="red"> 183.         return ast.not_expression(expr)</font>
<font color="black"> 184. </font>
<font color="green"> 185.     def _token_nud_lbracket(self, token):</font>
<font color="red"> 186.         if self._current_token() in ['number', 'colon']:</font>
<font color="red"> 187.             right = self._parse_index_expression()</font>
<font color="black"> 188.             # We could optimize this and remove the identity() node.</font>
<font color="black"> 189.             # We don't really need an index_expression node, we can</font>
<font color="black"> 190.             # just use emit an index node here if we're not dealing</font>
<font color="black"> 191.             # with a slice.</font>
<font color="red"> 192.             return self._project_if_slice(ast.identity(), right)</font>
<font color="red"> 193.         elif self._current_token() == 'star' and \</font>
<font color="red"> 194.                 self._lookahead(1) == 'rbracket':</font>
<font color="red"> 195.             self._advance()</font>
<font color="red"> 196.             self._advance()</font>
<font color="red"> 197.             right = self._parse_projection_rhs(self.BINDING_POWER['star'])</font>
<font color="red"> 198.             return ast.projection(ast.identity(), right)</font>
<font color="black"> 199.         else:</font>
<font color="red"> 200.             return self._parse_multi_select_list()</font>
<font color="black"> 201. </font>
<font color="green"> 202.     def _parse_index_expression(self):</font>
<font color="black"> 203.         # We're here:</font>
<font color="black"> 204.         # [&lt;current&gt;</font>
<font color="black"> 205.         #  ^</font>
<font color="black"> 206.         #  | current token</font>
<font color="red"> 207.         if (self._lookahead(0) == 'colon' or</font>
<font color="red"> 208.                 self._lookahead(1) == 'colon'):</font>
<font color="red"> 209.             return self._parse_slice_expression()</font>
<font color="black"> 210.         else:</font>
<font color="black"> 211.             # Parse the syntax [number]</font>
<font color="red"> 212.             node = ast.index(self._lookahead_token(0)['value'])</font>
<font color="red"> 213.             self._advance()</font>
<font color="red"> 214.             self._match('rbracket')</font>
<font color="red"> 215.             return node</font>
<font color="black"> 216. </font>
<font color="green"> 217.     def _parse_slice_expression(self):</font>
<font color="black"> 218.         # [start:end:step]</font>
<font color="black"> 219.         # Where start, end, and step are optional.</font>
<font color="black"> 220.         # The last colon is optional as well.</font>
<font color="red"> 221.         parts = [None, None, None]</font>
<font color="red"> 222.         index = 0</font>
<font color="red"> 223.         current_token = self._current_token()</font>
<font color="red"> 224.         while not current_token == 'rbracket' and index &lt; 3:</font>
<font color="red"> 225.             if current_token == 'colon':</font>
<font color="red"> 226.                 index += 1</font>
<font color="red"> 227.                 self._advance()</font>
<font color="red"> 228.             elif current_token == 'number':</font>
<font color="red"> 229.                 parts[index] = self._lookahead_token(0)['value']</font>
<font color="red"> 230.                 self._advance()</font>
<font color="black"> 231.             else:</font>
<font color="red"> 232.                 t = self._lookahead_token(0)</font>
<font color="red"> 233.                 lex_position = t['start']</font>
<font color="red"> 234.                 actual_value = t['value']</font>
<font color="red"> 235.                 actual_type = t['type']</font>
<font color="red"> 236.                 raise exceptions.ParseError(lex_position, actual_value,</font>
<font color="red"> 237.                                             actual_type, 'syntax error')</font>
<font color="red"> 238.             current_token = self._current_token()</font>
<font color="red"> 239.         self._match('rbracket')</font>
<font color="red"> 240.         return ast.slice(*parts)</font>
<font color="black"> 241. </font>
<font color="green"> 242.     def _token_nud_current(self, token):</font>
<font color="red"> 243.         return ast.current_node()</font>
<font color="black"> 244. </font>
<font color="green"> 245.     def _token_nud_expref(self, token):</font>
<font color="red"> 246.         expression = self._expression(self.BINDING_POWER['expref'])</font>
<font color="red"> 247.         return ast.expref(expression)</font>
<font color="black"> 248. </font>
<font color="green"> 249.     def _token_led_dot(self, left):</font>
<font color="red"> 250.         if not self._current_token() == 'star':</font>
<font color="red"> 251.             right = self._parse_dot_rhs(self.BINDING_POWER['dot'])</font>
<font color="red"> 252.             if left['type'] == 'subexpression':</font>
<font color="red"> 253.                 left['children'].append(right)</font>
<font color="red"> 254.                 return left</font>
<font color="black"> 255.             else:</font>
<font color="red"> 256.                 return ast.subexpression([left, right])</font>
<font color="black"> 257.         else:</font>
<font color="black"> 258.             # We're creating a projection.</font>
<font color="red"> 259.             self._advance()</font>
<font color="red"> 260.             right = self._parse_projection_rhs(</font>
<font color="red"> 261.                 self.BINDING_POWER['dot'])</font>
<font color="red"> 262.             return ast.value_projection(left, right)</font>
<font color="black"> 263. </font>
<font color="green"> 264.     def _token_led_pipe(self, left):</font>
<font color="red"> 265.         right = self._expression(self.BINDING_POWER['pipe'])</font>
<font color="red"> 266.         return ast.pipe(left, right)</font>
<font color="black"> 267. </font>
<font color="green"> 268.     def _token_led_or(self, left):</font>
<font color="red"> 269.         right = self._expression(self.BINDING_POWER['or'])</font>
<font color="red"> 270.         return ast.or_expression(left, right)</font>
<font color="black"> 271. </font>
<font color="green"> 272.     def _token_led_and(self, left):</font>
<font color="red"> 273.         right = self._expression(self.BINDING_POWER['and'])</font>
<font color="red"> 274.         return ast.and_expression(left, right)</font>
<font color="black"> 275. </font>
<font color="green"> 276.     def _token_led_lparen(self, left):</font>
<font color="red"> 277.         name = left['value']</font>
<font color="red"> 278.         args = []</font>
<font color="red"> 279.         while not self._current_token() == 'rparen':</font>
<font color="red"> 280.             expression = self._expression()</font>
<font color="red"> 281.             if self._current_token() == 'comma':</font>
<font color="red"> 282.                 self._match('comma')</font>
<font color="red"> 283.             args.append(expression)</font>
<font color="red"> 284.         self._match('rparen')</font>
<font color="red"> 285.         function_node = ast.function_expression(name, args)</font>
<font color="red"> 286.         return function_node</font>
<font color="black"> 287. </font>
<font color="green"> 288.     def _token_led_filter(self, left):</font>
<font color="black"> 289.         # Filters are projections.</font>
<font color="red"> 290.         condition = self._expression(0)</font>
<font color="red"> 291.         self._match('rbracket')</font>
<font color="red"> 292.         if self._current_token() == 'flatten':</font>
<font color="red"> 293.             right = ast.identity()</font>
<font color="black"> 294.         else:</font>
<font color="red"> 295.             right = self._parse_projection_rhs(self.BINDING_POWER['filter'])</font>
<font color="red"> 296.         return ast.filter_projection(left, right, condition)</font>
<font color="black"> 297. </font>
<font color="green"> 298.     def _token_led_eq(self, left):</font>
<font color="red"> 299.         return self._parse_comparator(left, 'eq')</font>
<font color="black"> 300. </font>
<font color="green"> 301.     def _token_led_ne(self, left):</font>
<font color="red"> 302.         return self._parse_comparator(left, 'ne')</font>
<font color="black"> 303. </font>
<font color="green"> 304.     def _token_led_gt(self, left):</font>
<font color="red"> 305.         return self._parse_comparator(left, 'gt')</font>
<font color="black"> 306. </font>
<font color="green"> 307.     def _token_led_gte(self, left):</font>
<font color="red"> 308.         return self._parse_comparator(left, 'gte')</font>
<font color="black"> 309. </font>
<font color="green"> 310.     def _token_led_lt(self, left):</font>
<font color="red"> 311.         return self._parse_comparator(left, 'lt')</font>
<font color="black"> 312. </font>
<font color="green"> 313.     def _token_led_lte(self, left):</font>
<font color="red"> 314.         return self._parse_comparator(left, 'lte')</font>
<font color="black"> 315. </font>
<font color="green"> 316.     def _token_led_flatten(self, left):</font>
<font color="red"> 317.         left = ast.flatten(left)</font>
<font color="red"> 318.         right = self._parse_projection_rhs(</font>
<font color="red"> 319.             self.BINDING_POWER['flatten'])</font>
<font color="red"> 320.         return ast.projection(left, right)</font>
<font color="black"> 321. </font>
<font color="green"> 322.     def _token_led_lbracket(self, left):</font>
<font color="red"> 323.         token = self._lookahead_token(0)</font>
<font color="red"> 324.         if token['type'] in ['number', 'colon']:</font>
<font color="red"> 325.             right = self._parse_index_expression()</font>
<font color="red"> 326.             if left['type'] == 'index_expression':</font>
<font color="black"> 327.                 # Optimization: if the left node is an index expr,</font>
<font color="black"> 328.                 # we can avoid creating another node and instead just add</font>
<font color="black"> 329.                 # the right node as a child of the left.</font>
<font color="red"> 330.                 left['children'].append(right)</font>
<font color="red"> 331.                 return left</font>
<font color="black"> 332.             else:</font>
<font color="red"> 333.                 return self._project_if_slice(left, right)</font>
<font color="black"> 334.         else:</font>
<font color="black"> 335.             # We have a projection</font>
<font color="red"> 336.             self._match('star')</font>
<font color="red"> 337.             self._match('rbracket')</font>
<font color="red"> 338.             right = self._parse_projection_rhs(self.BINDING_POWER['star'])</font>
<font color="red"> 339.             return ast.projection(left, right)</font>
<font color="black"> 340. </font>
<font color="green"> 341.     def _project_if_slice(self, left, right):</font>
<font color="red"> 342.         index_expr = ast.index_expression([left, right])</font>
<font color="red"> 343.         if right['type'] == 'slice':</font>
<font color="red"> 344.             return ast.projection(</font>
<font color="red"> 345.                 index_expr,</font>
<font color="red"> 346.                 self._parse_projection_rhs(self.BINDING_POWER['star']))</font>
<font color="black"> 347.         else:</font>
<font color="red"> 348.             return index_expr</font>
<font color="black"> 349. </font>
<font color="green"> 350.     def _parse_comparator(self, left, comparator):</font>
<font color="red"> 351.         right = self._expression(self.BINDING_POWER[comparator])</font>
<font color="red"> 352.         return ast.comparator(comparator, left, right)</font>
<font color="black"> 353. </font>
<font color="green"> 354.     def _parse_multi_select_list(self):</font>
<font color="red"> 355.         expressions = []</font>
<font color="red"> 356.         while True:</font>
<font color="red"> 357.             expression = self._expression()</font>
<font color="red"> 358.             expressions.append(expression)</font>
<font color="red"> 359.             if self._current_token() == 'rbracket':</font>
<font color="red"> 360.                 break</font>
<font color="black"> 361.             else:</font>
<font color="red"> 362.                 self._match('comma')</font>
<font color="red"> 363.         self._match('rbracket')</font>
<font color="red"> 364.         return ast.multi_select_list(expressions)</font>
<font color="black"> 365. </font>
<font color="green"> 366.     def _parse_multi_select_hash(self):</font>
<font color="red"> 367.         pairs = []</font>
<font color="red"> 368.         while True:</font>
<font color="red"> 369.             key_token = self._lookahead_token(0)</font>
<font color="black"> 370.             # Before getting the token value, verify it's</font>
<font color="black"> 371.             # an identifier.</font>
<font color="red"> 372.             self._match_multiple_tokens(</font>
<font color="red"> 373.                 token_types=['quoted_identifier', 'unquoted_identifier'])</font>
<font color="red"> 374.             key_name = key_token['value']</font>
<font color="red"> 375.             self._match('colon')</font>
<font color="red"> 376.             value = self._expression(0)</font>
<font color="red"> 377.             node = ast.key_val_pair(key_name=key_name, node=value)</font>
<font color="red"> 378.             pairs.append(node)</font>
<font color="red"> 379.             if self._current_token() == 'comma':</font>
<font color="red"> 380.                 self._match('comma')</font>
<font color="red"> 381.             elif self._current_token() == 'rbrace':</font>
<font color="red"> 382.                 self._match('rbrace')</font>
<font color="red"> 383.                 break</font>
<font color="red"> 384.         return ast.multi_select_dict(nodes=pairs)</font>
<font color="black"> 385. </font>
<font color="green"> 386.     def _parse_projection_rhs(self, binding_power):</font>
<font color="black"> 387.         # Parse the right hand side of the projection.</font>
<font color="red"> 388.         if self.BINDING_POWER[self._current_token()] &lt; self._PROJECTION_STOP:</font>
<font color="black"> 389.             # BP of 10 are all the tokens that stop a projection.</font>
<font color="red"> 390.             right = ast.identity()</font>
<font color="red"> 391.         elif self._current_token() == 'lbracket':</font>
<font color="red"> 392.             right = self._expression(binding_power)</font>
<font color="red"> 393.         elif self._current_token() == 'filter':</font>
<font color="red"> 394.             right = self._expression(binding_power)</font>
<font color="red"> 395.         elif self._current_token() == 'dot':</font>
<font color="red"> 396.             self._match('dot')</font>
<font color="red"> 397.             right = self._parse_dot_rhs(binding_power)</font>
<font color="black"> 398.         else:</font>
<font color="red"> 399.             t = self._lookahead_token(0)</font>
<font color="red"> 400.             lex_position = t['start']</font>
<font color="red"> 401.             actual_value = t['value']</font>
<font color="red"> 402.             actual_type = t['type']</font>
<font color="red"> 403.             raise exceptions.ParseError(lex_position, actual_value,</font>
<font color="red"> 404.                                         actual_type, 'syntax error')</font>
<font color="red"> 405.         return right</font>
<font color="black"> 406. </font>
<font color="green"> 407.     def _parse_dot_rhs(self, binding_power):</font>
<font color="black"> 408.         # From the grammar:</font>
<font color="black"> 409.         # expression '.' ( identifier /</font>
<font color="black"> 410.         #                  multi-select-list /</font>
<font color="black"> 411.         #                  multi-select-hash /</font>
<font color="black"> 412.         #                  function-expression /</font>
<font color="black"> 413.         #                  *</font>
<font color="black"> 414.         # In terms of tokens that means that after a '.',</font>
<font color="black"> 415.         # you can have:</font>
<font color="red"> 416.         lookahead = self._current_token()</font>
<font color="black"> 417.         # Common case &quot;foo.bar&quot;, so first check for an identifier.</font>
<font color="red"> 418.         if lookahead in ['quoted_identifier', 'unquoted_identifier', 'star']:</font>
<font color="red"> 419.             return self._expression(binding_power)</font>
<font color="red"> 420.         elif lookahead == 'lbracket':</font>
<font color="red"> 421.             self._match('lbracket')</font>
<font color="red"> 422.             return self._parse_multi_select_list()</font>
<font color="red"> 423.         elif lookahead == 'lbrace':</font>
<font color="red"> 424.             self._match('lbrace')</font>
<font color="red"> 425.             return self._parse_multi_select_hash()</font>
<font color="black"> 426.         else:</font>
<font color="red"> 427.             t = self._lookahead_token(0)</font>
<font color="red"> 428.             allowed = ['quoted_identifier', 'unquoted_identifier',</font>
<font color="red"> 429.                        'lbracket', 'lbrace']</font>
<font color="red"> 430.             lex_position = t['start']</font>
<font color="red"> 431.             actual_value = t['value']</font>
<font color="red"> 432.             actual_type = t['type']</font>
<font color="red"> 433.             raise exceptions.ParseError(</font>
<font color="red"> 434.                 lex_position, actual_value, actual_type,</font>
<font color="red"> 435.                 &quot;Expecting: %s, got: %s&quot; % (allowed,</font>
<font color="red"> 436.                                             actual_type))</font>
<font color="black"> 437. </font>
<font color="green"> 438.     def _assert_not_token(self, *token_types):</font>
<font color="red"> 439.         if self._current_token() in token_types:</font>
<font color="red"> 440.             t = self._lookahead_token(0)</font>
<font color="red"> 441.             lex_position = t['start']</font>
<font color="red"> 442.             actual_value = t['value']</font>
<font color="red"> 443.             actual_type = t['type']</font>
<font color="red"> 444.             raise exceptions.ParseError(</font>
<font color="red"> 445.                 lex_position, actual_value, actual_type,</font>
<font color="red"> 446.                 &quot;Token %s not allowed to be: %s&quot; % (actual_type, token_types))</font>
<font color="black"> 447. </font>
<font color="green"> 448.     def _error_nud_token(self, token):</font>
<font color="red"> 449.         if token['type'] == 'eof':</font>
<font color="red"> 450.             raise exceptions.IncompleteExpressionError(</font>
<font color="red"> 451.                 token['start'], token['value'], token['type'])</font>
<font color="red"> 452.         raise exceptions.ParseError(token['start'], token['value'],</font>
<font color="red"> 453.                                     token['type'], 'Invalid token.')</font>
<font color="black"> 454. </font>
<font color="green"> 455.     def _error_led_token(self, token):</font>
<font color="red"> 456.         raise exceptions.ParseError(token['start'], token['value'],</font>
<font color="red"> 457.                                     token['type'], 'Invalid token')</font>
<font color="black"> 458. </font>
<font color="green"> 459.     def _match(self, token_type=None):</font>
<font color="black"> 460.         # inline'd self._current_token()</font>
<font color="red"> 461.         if self._current_token() == token_type:</font>
<font color="black"> 462.             # inline'd self._advance()</font>
<font color="red"> 463.             self._advance()</font>
<font color="black"> 464.         else:</font>
<font color="red"> 465.             t = self._lookahead_token(0)</font>
<font color="red"> 466.             lex_position = t['start']</font>
<font color="red"> 467.             actual_value = t['value']</font>
<font color="red"> 468.             actual_type = t['type']</font>
<font color="red"> 469.             if actual_type == 'eof':</font>
<font color="red"> 470.                 raise exceptions.IncompleteExpressionError(</font>
<font color="red"> 471.                     lex_position, actual_value, actual_type)</font>
<font color="black"> 472.             else:</font>
<font color="red"> 473.                 message = 'Expecting: %s, got: %s' % (token_type,</font>
<font color="red"> 474.                                                       actual_type)</font>
<font color="red"> 475.             raise exceptions.ParseError(</font>
<font color="red"> 476.                 lex_position, actual_value, actual_type, message)</font>
<font color="black"> 477. </font>
<font color="green"> 478.     def _match_multiple_tokens(self, token_types):</font>
<font color="red"> 479.         if self._current_token() not in token_types:</font>
<font color="red"> 480.             t = self._lookahead_token(0)</font>
<font color="red"> 481.             lex_position = t['start']</font>
<font color="red"> 482.             actual_value = t['value']</font>
<font color="red"> 483.             actual_type = t['type']</font>
<font color="red"> 484.             if actual_type == 'eof':</font>
<font color="red"> 485.                 raise exceptions.IncompleteExpressionError(</font>
<font color="red"> 486.                     lex_position, actual_value, actual_type)</font>
<font color="black"> 487.             else:</font>
<font color="red"> 488.                 message = 'Expecting: %s, got: %s' % (token_types,</font>
<font color="red"> 489.                                                       actual_type)</font>
<font color="red"> 490.             raise exceptions.ParseError(</font>
<font color="red"> 491.                 lex_position, actual_value, actual_type, message)</font>
<font color="red"> 492.         self._advance()</font>
<font color="black"> 493. </font>
<font color="green"> 494.     def _advance(self):</font>
<font color="red"> 495.         self._index += 1</font>
<font color="black"> 496. </font>
<font color="green"> 497.     def _current_token(self):</font>
<font color="red"> 498.         return self._tokens[self._index]['type']</font>
<font color="black"> 499. </font>
<font color="green"> 500.     def _lookahead(self, number):</font>
<font color="red"> 501.         return self._tokens[self._index + number]['type']</font>
<font color="black"> 502. </font>
<font color="green"> 503.     def _lookahead_token(self, number):</font>
<font color="red"> 504.         return self._tokens[self._index + number]</font>
<font color="black"> 505. </font>
<font color="green"> 506.     def _free_cache_entries(self):</font>
<font color="red"> 507.         for key in random.sample(self._CACHE.keys(), int(self._MAX_SIZE / 2)):</font>
<font color="red"> 508.             del self._CACHE[key]</font>
<font color="black"> 509. </font>
<font color="green"> 510.     @classmethod</font>
<font color="black"> 511.     def purge(cls):</font>
<font color="black"> 512.         &quot;&quot;&quot;Clear the expression compilation cache.&quot;&quot;&quot;</font>
<font color="red"> 513.         cls._CACHE.clear()</font>
<font color="black"> 514. </font>
<font color="black"> 515. </font>
<font color="green"> 516. @with_repr_method</font>
<font color="green"> 517. class ParsedResult(object):</font>
<font color="green"> 518.     def __init__(self, expression, parsed):</font>
<font color="red"> 519.         self.expression = expression</font>
<font color="red"> 520.         self.parsed = parsed</font>
<font color="black"> 521. </font>
<font color="green"> 522.     def search(self, value, options=None):</font>
<font color="red"> 523.         interpreter = visitor.TreeInterpreter(options)</font>
<font color="red"> 524.         result = interpreter.visit(self.parsed, value)</font>
<font color="red"> 525.         return result</font>
<font color="black"> 526. </font>
<font color="green"> 527.     def _render_dot_file(self):</font>
<font color="black"> 528.         &quot;&quot;&quot;Render the parsed AST as a dot file.</font>
<font color="black"> 529. </font>
<font color="black"> 530.         Note that this is marked as an internal method because</font>
<font color="black"> 531.         the AST is an implementation detail and is subject</font>
<font color="black"> 532.         to change.  This method can be used to help troubleshoot</font>
<font color="black"> 533.         or for development purposes, but is not considered part</font>
<font color="black"> 534.         of the public supported API.  Use at your own risk.</font>
<font color="black"> 535. </font>
<font color="black"> 536.         &quot;&quot;&quot;</font>
<font color="red"> 537.         renderer = visitor.GraphvizVisitor()</font>
<font color="red"> 538.         contents = renderer.visit(self.parsed)</font>
<font color="red"> 539.         return contents</font>
<font color="black"> 540. </font>
<font color="green"> 541.     def __repr__(self):</font>
<font color="red"> 542.         return repr(self.parsed)</font>
</pre>

