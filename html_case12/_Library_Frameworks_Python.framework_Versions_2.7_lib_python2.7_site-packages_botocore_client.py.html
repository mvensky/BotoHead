source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/client.py</b><br>


file stats: <b>531 lines, 368 executed: 69.3% covered</b>
<pre>
<font color="black">   1. # Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="green">  13. import logging</font>
<font color="green">  14. import functools</font>
<font color="black">  15. </font>
<font color="green">  16. from botocore import waiter, xform_name</font>
<font color="green">  17. from botocore.auth import AUTH_TYPE_MAPS</font>
<font color="green">  18. from botocore.awsrequest import prepare_request_dict</font>
<font color="green">  19. from botocore.docs.docstring import ClientMethodDocstring</font>
<font color="green">  20. from botocore.docs.docstring import PaginatorDocstring</font>
<font color="green">  21. from botocore.exceptions import ClientError, DataNotFoundError</font>
<font color="green">  22. from botocore.exceptions import OperationNotPageableError</font>
<font color="green">  23. from botocore.exceptions import UnknownSignatureVersionError</font>
<font color="green">  24. from botocore.hooks import first_non_none_response</font>
<font color="green">  25. from botocore.model import ServiceModel</font>
<font color="green">  26. from botocore.paginate import Paginator</font>
<font color="green">  27. from botocore.utils import CachedProperty</font>
<font color="green">  28. from botocore.utils import get_service_module_name</font>
<font color="green">  29. from botocore.utils import switch_host_s3_accelerate</font>
<font color="green">  30. from botocore.utils import S3RegionRedirector</font>
<font color="green">  31. from botocore.utils import fix_s3_host</font>
<font color="green">  32. from botocore.utils import switch_to_virtual_host_style</font>
<font color="green">  33. from botocore.utils import S3_ACCELERATE_WHITELIST</font>
<font color="green">  34. from botocore.args import ClientArgsCreator</font>
<font color="green">  35. from botocore.compat import urlsplit</font>
<font color="green">  36. from botocore import UNSIGNED</font>
<font color="black">  37. # Keep this imported.  There's pre-existing code that uses</font>
<font color="black">  38. # &quot;from botocore.client import Config&quot;.</font>
<font color="green">  39. from botocore.config import Config</font>
<font color="green">  40. from botocore.history import get_global_history_recorder</font>
<font color="black">  41. </font>
<font color="black">  42. </font>
<font color="green">  43. logger = logging.getLogger(__name__)</font>
<font color="green">  44. history_recorder = get_global_history_recorder()</font>
<font color="black">  45. </font>
<font color="black">  46. </font>
<font color="green">  47. class ClientCreator(object):</font>
<font color="green">  48.     &quot;&quot;&quot;Creates client objects for a service.&quot;&quot;&quot;</font>
<font color="black">  49.     def __init__(self, loader, endpoint_resolver, user_agent, event_emitter,</font>
<font color="black">  50.                  retry_handler_factory, retry_config_translator,</font>
<font color="green">  51.                  response_parser_factory=None, exceptions_factory=None):</font>
<font color="green">  52.         self._loader = loader</font>
<font color="green">  53.         self._endpoint_resolver = endpoint_resolver</font>
<font color="green">  54.         self._user_agent = user_agent</font>
<font color="green">  55.         self._event_emitter = event_emitter</font>
<font color="green">  56.         self._retry_handler_factory = retry_handler_factory</font>
<font color="green">  57.         self._retry_config_translator = retry_config_translator</font>
<font color="green">  58.         self._response_parser_factory = response_parser_factory</font>
<font color="green">  59.         self._exceptions_factory = exceptions_factory</font>
<font color="black">  60. </font>
<font color="green">  61.     def create_client(self, service_name, region_name, is_secure=True,</font>
<font color="green">  62.                       endpoint_url=None, verify=None,</font>
<font color="green">  63.                       credentials=None, scoped_config=None,</font>
<font color="green">  64.                       api_version=None,</font>
<font color="green">  65.                       client_config=None):</font>
<font color="green">  66.         responses = self._event_emitter.emit(</font>
<font color="green">  67.             'choose-service-name', service_name=service_name)</font>
<font color="green">  68.         service_name = first_non_none_response(responses, default=service_name)</font>
<font color="green">  69.         service_model = self._load_service_model(service_name, api_version)</font>
<font color="green">  70.         cls = self._create_client_class(service_name, service_model)</font>
<font color="green">  71.         endpoint_bridge = ClientEndpointBridge(</font>
<font color="green">  72.             self._endpoint_resolver, scoped_config, client_config,</font>
<font color="green">  73.             service_signing_name=service_model.metadata.get('signingName'))</font>
<font color="green">  74.         client_args = self._get_client_args(</font>
<font color="green">  75.             service_model, region_name, is_secure, endpoint_url,</font>
<font color="green">  76.             verify, credentials, scoped_config, client_config, endpoint_bridge)</font>
<font color="green">  77.         service_client = cls(**client_args)</font>
<font color="green">  78.         self._register_retries(service_client)</font>
<font color="green">  79.         self._register_s3_events(</font>
<font color="green">  80.             service_client, endpoint_bridge, endpoint_url, client_config,</font>
<font color="green">  81.             scoped_config)</font>
<font color="green">  82.         return service_client</font>
<font color="black">  83. </font>
<font color="green">  84.     def create_client_class(self, service_name, api_version=None):</font>
<font color="red">  85.         service_model = self._load_service_model(service_name, api_version)</font>
<font color="red">  86.         return self._create_client_class(service_name, service_model)</font>
<font color="black">  87. </font>
<font color="green">  88.     def _create_client_class(self, service_name, service_model):</font>
<font color="green">  89.         class_attributes = self._create_methods(service_model)</font>
<font color="green">  90.         py_name_to_operation_name = self._create_name_mapping(service_model)</font>
<font color="green">  91.         class_attributes['_PY_TO_OP_NAME'] = py_name_to_operation_name</font>
<font color="green">  92.         bases = [BaseClient]</font>
<font color="green">  93.         self._event_emitter.emit('creating-client-class.%s' % service_name,</font>
<font color="green">  94.                                  class_attributes=class_attributes,</font>
<font color="green">  95.                                  base_classes=bases)</font>
<font color="green">  96.         class_name = get_service_module_name(service_model)</font>
<font color="green">  97.         cls = type(str(class_name), tuple(bases), class_attributes)</font>
<font color="green">  98.         return cls</font>
<font color="black">  99. </font>
<font color="green"> 100.     def _load_service_model(self, service_name, api_version=None):</font>
<font color="green"> 101.         json_model = self._loader.load_service_model(service_name, 'service-2',</font>
<font color="green"> 102.                                                      api_version=api_version)</font>
<font color="green"> 103.         service_model = ServiceModel(json_model, service_name=service_name)</font>
<font color="green"> 104.         return service_model</font>
<font color="black"> 105. </font>
<font color="green"> 106.     def _register_retries(self, client):</font>
<font color="green"> 107.         endpoint_prefix = client.meta.service_model.endpoint_prefix</font>
<font color="black"> 108. </font>
<font color="black"> 109.         # First, we load the entire retry config for all services,</font>
<font color="black"> 110.         # then pull out just the information we need.</font>
<font color="green"> 111.         original_config = self._loader.load_data('_retry')</font>
<font color="green"> 112.         if not original_config:</font>
<font color="red"> 113.             return</font>
<font color="black"> 114. </font>
<font color="green"> 115.         retry_config = self._retry_config_translator.build_retry_config(</font>
<font color="green"> 116.             endpoint_prefix, original_config.get('retry', {}),</font>
<font color="green"> 117.             original_config.get('definitions', {}),</font>
<font color="green"> 118.             client.meta.config.retries</font>
<font color="black"> 119.         )</font>
<font color="black"> 120. </font>
<font color="green"> 121.         logger.debug(&quot;Registering retry handlers for service: %s&quot;,</font>
<font color="green"> 122.                      client.meta.service_model.service_name)</font>
<font color="green"> 123.         handler = self._retry_handler_factory.create_retry_handler(</font>
<font color="green"> 124.             retry_config, endpoint_prefix)</font>
<font color="green"> 125.         unique_id = 'retry-config-%s' % endpoint_prefix</font>
<font color="green"> 126.         client.meta.events.register('needs-retry.%s' % endpoint_prefix,</font>
<font color="green"> 127.                                     handler, unique_id=unique_id)</font>
<font color="black"> 128. </font>
<font color="green"> 129.     def _register_s3_events(self, client, endpoint_bridge, endpoint_url,</font>
<font color="black"> 130.                             client_config, scoped_config):</font>
<font color="green"> 131.         if client.meta.service_model.service_name != 's3':</font>
<font color="red"> 132.             return</font>
<font color="green"> 133.         S3RegionRedirector(endpoint_bridge, client).register()</font>
<font color="green"> 134.         self._set_s3_addressing_style(</font>
<font color="green"> 135.             endpoint_url, client.meta.config.s3, client.meta.events,</font>
<font color="green"> 136.             client.meta.partition</font>
<font color="black"> 137.         )</font>
<font color="black"> 138.         # Enable accelerate if the configuration is set to to true or the</font>
<font color="black"> 139.         # endpoint being used matches one of the accelerate endpoints.</font>
<font color="green"> 140.         if self._is_s3_accelerate(endpoint_url, client.meta.config.s3):</font>
<font color="black"> 141.             # Also make sure that the hostname gets switched to</font>
<font color="black"> 142.             # s3-accelerate.amazonaws.com</font>
<font color="red"> 143.             client.meta.events.register_first(</font>
<font color="red"> 144.                 'before-sign.s3', switch_host_s3_accelerate)</font>
<font color="black"> 145. </font>
<font color="green"> 146.         self._set_s3_presign_signature_version(</font>
<font color="green"> 147.             client.meta, client_config, scoped_config)</font>
<font color="black"> 148. </font>
<font color="green"> 149.     def _set_s3_addressing_style(self, endpoint_url, s3_config, event_emitter,</font>
<font color="black"> 150.                                  partition):</font>
<font color="green"> 151.         if s3_config is None:</font>
<font color="green"> 152.             s3_config = {}</font>
<font color="black"> 153. </font>
<font color="green"> 154.         addressing_style = self._get_s3_addressing_style(</font>
<font color="green"> 155.             endpoint_url, s3_config)</font>
<font color="green"> 156.         handler = self._get_s3_addressing_handler(</font>
<font color="green"> 157.             endpoint_url, s3_config, addressing_style, partition)</font>
<font color="green"> 158.         if handler is not None:</font>
<font color="green"> 159.             event_emitter.register('before-sign.s3', handler)</font>
<font color="black"> 160. </font>
<font color="green"> 161.     def _get_s3_addressing_style(self, endpoint_url, s3_config):</font>
<font color="black"> 162.         # Use virtual host style addressing if accelerate is enabled or if</font>
<font color="black"> 163.         # the given endpoint url is an accelerate endpoint.</font>
<font color="green"> 164.         accelerate = s3_config.get('use_accelerate_endpoint', False)</font>
<font color="green"> 165.         if accelerate or self._is_s3_accelerate(endpoint_url, s3_config):</font>
<font color="red"> 166.             return 'virtual'</font>
<font color="black"> 167. </font>
<font color="black"> 168.         # If a particular addressing style is configured, use it.</font>
<font color="green"> 169.         configured_addressing_style = s3_config.get('addressing_style')</font>
<font color="green"> 170.         if configured_addressing_style:</font>
<font color="red"> 171.             return configured_addressing_style</font>
<font color="black"> 172. </font>
<font color="green"> 173.     def _get_s3_addressing_handler(self, endpoint_url, s3_config,</font>
<font color="black"> 174.                                    addressing_style, partition):</font>
<font color="black"> 175.         # If virtual host style was configured, use it regardless of whether</font>
<font color="black"> 176.         # or not the bucket looks dns compatible.</font>
<font color="green"> 177.         if addressing_style == 'virtual':</font>
<font color="red"> 178.             logger.debug(&quot;Using S3 virtual host style addressing.&quot;)</font>
<font color="red"> 179.             return switch_to_virtual_host_style</font>
<font color="black"> 180. </font>
<font color="black"> 181.         # If path style is configured, no additional steps are needed. If</font>
<font color="black"> 182.         # endpoint_url was specified, don't default to virtual. We could</font>
<font color="black"> 183.         # potentially default provided endpoint urls to virtual hosted</font>
<font color="black"> 184.         # style, but for now it is avoided.</font>
<font color="green"> 185.         if addressing_style == 'path' or endpoint_url is not None:</font>
<font color="red"> 186.             logger.debug(&quot;Using S3 path style addressing.&quot;)</font>
<font color="red"> 187.             return None</font>
<font color="black"> 188. </font>
<font color="green"> 189.         logger.debug(&quot;Defaulting to S3 virtual host style addressing with &quot;</font>
<font color="black"> 190.                      &quot;path style addressing fallback.&quot;)</font>
<font color="black"> 191. </font>
<font color="black"> 192.         # By default, try to use virtual style with path fallback.</font>
<font color="green"> 193.         return fix_s3_host</font>
<font color="black"> 194. </font>
<font color="green"> 195.     def _is_s3_accelerate(self, endpoint_url, s3_config):</font>
<font color="black"> 196.         # Accelerate has been explicitly configured.</font>
<font color="green"> 197.         if s3_config is not None and s3_config.get('use_accelerate_endpoint'):</font>
<font color="red"> 198.             return True</font>
<font color="black"> 199. </font>
<font color="black"> 200.         # Accelerate mode is turned on automatically if an endpoint url is</font>
<font color="black"> 201.         # provided that matches the accelerate scheme.</font>
<font color="green"> 202.         if endpoint_url is None:</font>
<font color="green"> 203.             return False</font>
<font color="black"> 204. </font>
<font color="black"> 205.         # Accelerate is only valid for Amazon endpoints.</font>
<font color="red"> 206.         netloc = urlsplit(endpoint_url).netloc</font>
<font color="red"> 207.         if not netloc.endswith('amazonaws.com'):</font>
<font color="red"> 208.             return False</font>
<font color="black"> 209. </font>
<font color="black"> 210.         # The first part of the url should always be s3-accelerate.</font>
<font color="red"> 211.         parts = netloc.split('.')</font>
<font color="red"> 212.         if parts[0] != 's3-accelerate':</font>
<font color="red"> 213.             return False</font>
<font color="black"> 214. </font>
<font color="black"> 215.         # Url parts between 's3-accelerate' and 'amazonaws.com' which</font>
<font color="black"> 216.         # represent different url features.</font>
<font color="red"> 217.         feature_parts = parts[1:-2]</font>
<font color="black"> 218. </font>
<font color="black"> 219.         # There should be no duplicate url parts.</font>
<font color="red"> 220.         if len(feature_parts) != len(set(feature_parts)):</font>
<font color="red"> 221.             return False</font>
<font color="black"> 222. </font>
<font color="black"> 223.         # Remaining parts must all be in the whitelist.</font>
<font color="red"> 224.         return all(p in S3_ACCELERATE_WHITELIST for p in feature_parts)</font>
<font color="black"> 225. </font>
<font color="green"> 226.     def _set_s3_presign_signature_version(self, client_meta,</font>
<font color="black"> 227.                                           client_config, scoped_config):</font>
<font color="black"> 228.         # This will return the manually configured signature version, or None</font>
<font color="black"> 229.         # if none was manually set. If a customer manually sets the signature</font>
<font color="black"> 230.         # version, we always want to use what they set.</font>
<font color="green"> 231.         provided_signature_version = _get_configured_signature_version(</font>
<font color="green"> 232.             's3', client_config, scoped_config)</font>
<font color="green"> 233.         if provided_signature_version is not None:</font>
<font color="red"> 234.             return</font>
<font color="black"> 235. </font>
<font color="black"> 236.         # Check to see if the region is a region that we know about. If we</font>
<font color="black"> 237.         # don't know about a region, then we can safely assume it's a new</font>
<font color="black"> 238.         # region that is sigv4 only, since all new S3 regions only allow sigv4.</font>
<font color="green"> 239.         regions = self._endpoint_resolver.get_available_endpoints(</font>
<font color="green"> 240.             's3', client_meta.partition)</font>
<font color="green"> 241.         if client_meta.region_name not in regions:</font>
<font color="red"> 242.             return</font>
<font color="black"> 243. </font>
<font color="black"> 244.         # If it is a region we know about, we want to default to sigv2, so here</font>
<font color="black"> 245.         # we check to see if it is available.</font>
<font color="green"> 246.         endpoint = self._endpoint_resolver.construct_endpoint(</font>
<font color="green"> 247.             's3', client_meta.region_name)</font>
<font color="green"> 248.         signature_versions = endpoint['signatureVersions']</font>
<font color="green"> 249.         if 's3' not in signature_versions:</font>
<font color="red"> 250.             return</font>
<font color="black"> 251. </font>
<font color="black"> 252.         # We now know that we're in a known region that supports sigv2 and</font>
<font color="black"> 253.         # the customer hasn't set a signature version so we default the</font>
<font color="black"> 254.         # signature version to sigv2.</font>
<font color="green"> 255.         client_meta.events.register(</font>
<font color="green"> 256.             'choose-signer.s3', self._default_s3_presign_to_sigv2)</font>
<font color="black"> 257. </font>
<font color="green"> 258.     def _default_s3_presign_to_sigv2(self, signature_version, **kwargs):</font>
<font color="black"> 259.         &quot;&quot;&quot;</font>
<font color="black"> 260.         Returns the 's3' (sigv2) signer if presigning an s3 request. This is</font>
<font color="black"> 261.         intended to be used to set the default signature version for the signer</font>
<font color="black"> 262.         to sigv2.</font>
<font color="black"> 263. </font>
<font color="black"> 264.         :type signature_version: str</font>
<font color="black"> 265.         :param signature_version: The current client signature version.</font>
<font color="black"> 266. </font>
<font color="black"> 267.         :type signing_name: str</font>
<font color="black"> 268.         :param signing_name: The signing name of the service.</font>
<font color="black"> 269. </font>
<font color="black"> 270.         :return: 's3' if the request is an s3 presign request, None otherwise</font>
<font color="black"> 271.         &quot;&quot;&quot;</font>
<font color="green"> 272.         for suffix in ['-query', '-presign-post']:</font>
<font color="green"> 273.             if signature_version.endswith(suffix):</font>
<font color="red"> 274.                 return 's3' + suffix</font>
<font color="black"> 275. </font>
<font color="green"> 276.     def _get_client_args(self, service_model, region_name, is_secure,</font>
<font color="black"> 277.                          endpoint_url, verify, credentials,</font>
<font color="black"> 278.                          scoped_config, client_config, endpoint_bridge):</font>
<font color="green"> 279.         args_creator = ClientArgsCreator(</font>
<font color="green"> 280.             self._event_emitter, self._user_agent,</font>
<font color="green"> 281.             self._response_parser_factory, self._loader,</font>
<font color="green"> 282.             self._exceptions_factory)</font>
<font color="green"> 283.         return args_creator.get_client_args(</font>
<font color="green"> 284.             service_model, region_name, is_secure, endpoint_url,</font>
<font color="green"> 285.             verify, credentials, scoped_config, client_config, endpoint_bridge)</font>
<font color="black"> 286. </font>
<font color="green"> 287.     def _create_methods(self, service_model):</font>
<font color="green"> 288.         op_dict = {}</font>
<font color="green"> 289.         for operation_name in service_model.operation_names:</font>
<font color="green"> 290.             py_operation_name = xform_name(operation_name)</font>
<font color="green"> 291.             op_dict[py_operation_name] = self._create_api_method(</font>
<font color="green"> 292.                 py_operation_name, operation_name, service_model)</font>
<font color="green"> 293.         return op_dict</font>
<font color="black"> 294. </font>
<font color="green"> 295.     def _create_name_mapping(self, service_model):</font>
<font color="black"> 296.         # py_name -&gt; OperationName, for every operation available</font>
<font color="black"> 297.         # for a service.</font>
<font color="green"> 298.         mapping = {}</font>
<font color="green"> 299.         for operation_name in service_model.operation_names:</font>
<font color="green"> 300.             py_operation_name = xform_name(operation_name)</font>
<font color="green"> 301.             mapping[py_operation_name] = operation_name</font>
<font color="green"> 302.         return mapping</font>
<font color="black"> 303. </font>
<font color="green"> 304.     def _create_api_method(self, py_operation_name, operation_name,</font>
<font color="black"> 305.                            service_model):</font>
<font color="green"> 306.         def _api_call(self, *args, **kwargs):</font>
<font color="black"> 307.             # We're accepting *args so that we can give a more helpful</font>
<font color="black"> 308.             # error message than TypeError: _api_call takes exactly</font>
<font color="black"> 309.             # 1 argument.</font>
<font color="green"> 310.             if args:</font>
<font color="red"> 311.                 raise TypeError(</font>
<font color="red"> 312.                     &quot;%s() only accepts keyword arguments.&quot; % py_operation_name)</font>
<font color="black"> 313.             # The &quot;self&quot; in this scope is referring to the BaseClient.</font>
<font color="green"> 314.             return self._make_api_call(operation_name, kwargs)</font>
<font color="black"> 315. </font>
<font color="green"> 316.         _api_call.__name__ = str(py_operation_name)</font>
<font color="black"> 317. </font>
<font color="black"> 318.         # Add the docstring to the client method</font>
<font color="green"> 319.         operation_model = service_model.operation_model(operation_name)</font>
<font color="green"> 320.         docstring = ClientMethodDocstring(</font>
<font color="green"> 321.             operation_model=operation_model,</font>
<font color="green"> 322.             method_name=operation_name,</font>
<font color="green"> 323.             event_emitter=self._event_emitter,</font>
<font color="green"> 324.             method_description=operation_model.documentation,</font>
<font color="green"> 325.             example_prefix='response = client.%s' % py_operation_name,</font>
<font color="green"> 326.             include_signature=False</font>
<font color="black"> 327.         )</font>
<font color="green"> 328.         _api_call.__doc__ = docstring</font>
<font color="green"> 329.         return _api_call</font>
<font color="black"> 330. </font>
<font color="black"> 331. </font>
<font color="green"> 332. class ClientEndpointBridge(object):</font>
<font color="black"> 333.     &quot;&quot;&quot;Bridges endpoint data and client creation</font>
<font color="black"> 334. </font>
<font color="black"> 335.     This class handles taking out the relevant arguments from the endpoint</font>
<font color="black"> 336.     resolver and determining which values to use, taking into account any</font>
<font color="black"> 337.     client configuration options and scope configuration options.</font>
<font color="black"> 338. </font>
<font color="black"> 339.     This class also handles determining what, if any, region to use if no</font>
<font color="black"> 340.     explicit region setting is provided. For example, Amazon S3 client will</font>
<font color="green"> 341.     utilize &quot;us-east-1&quot; by default if no region can be resolved.&quot;&quot;&quot;</font>
<font color="black"> 342. </font>
<font color="green"> 343.     DEFAULT_ENDPOINT = '{service}.{region}.amazonaws.com'</font>
<font color="black"> 344. </font>
<font color="green"> 345.     def __init__(self, endpoint_resolver, scoped_config=None,</font>
<font color="green"> 346.                  client_config=None, default_endpoint=None,</font>
<font color="green"> 347.                  service_signing_name=None):</font>
<font color="green"> 348.         self.service_signing_name = service_signing_name</font>
<font color="green"> 349.         self.endpoint_resolver = endpoint_resolver</font>
<font color="green"> 350.         self.scoped_config = scoped_config</font>
<font color="green"> 351.         self.client_config = client_config</font>
<font color="green"> 352.         self.default_endpoint = default_endpoint or self.DEFAULT_ENDPOINT</font>
<font color="black"> 353. </font>
<font color="green"> 354.     def resolve(self, service_name, region_name=None, endpoint_url=None,</font>
<font color="green"> 355.                 is_secure=True):</font>
<font color="green"> 356.         region_name = self._check_default_region(service_name, region_name)</font>
<font color="green"> 357.         resolved = self.endpoint_resolver.construct_endpoint(</font>
<font color="green"> 358.             service_name, region_name)</font>
<font color="green"> 359.         if resolved:</font>
<font color="green"> 360.             return self._create_endpoint(</font>
<font color="green"> 361.                 resolved, service_name, region_name, endpoint_url, is_secure)</font>
<font color="black"> 362.         else:</font>
<font color="red"> 363.             return self._assume_endpoint(service_name, region_name,</font>
<font color="red"> 364.                                          endpoint_url, is_secure)</font>
<font color="black"> 365. </font>
<font color="green"> 366.     def _check_default_region(self, service_name, region_name):</font>
<font color="green"> 367.         if region_name is not None:</font>
<font color="green"> 368.             return region_name</font>
<font color="black"> 369.         # Use the client_config region if no explicit region was provided.</font>
<font color="red"> 370.         if self.client_config and self.client_config.region_name is not None:</font>
<font color="red"> 371.             return self.client_config.region_name</font>
<font color="black"> 372. </font>
<font color="green"> 373.     def _create_endpoint(self, resolved, service_name, region_name,</font>
<font color="black"> 374.                          endpoint_url, is_secure):</font>
<font color="green"> 375.         region_name, signing_region = self._pick_region_values(</font>
<font color="green"> 376.             resolved, region_name, endpoint_url)</font>
<font color="green"> 377.         if endpoint_url is None:</font>
<font color="green"> 378.             if self._is_s3_dualstack_mode(service_name):</font>
<font color="red"> 379.                 endpoint_url = self._create_dualstack_endpoint(</font>
<font color="red"> 380.                     service_name, region_name,</font>
<font color="red"> 381.                     resolved['dnsSuffix'], is_secure)</font>
<font color="black"> 382.             else:</font>
<font color="black"> 383.                 # Use the sslCommonName over the hostname for Python 2.6 compat.</font>
<font color="green"> 384.                 hostname = resolved.get('sslCommonName', resolved.get('hostname'))</font>
<font color="green"> 385.                 endpoint_url = self._make_url(hostname, is_secure,</font>
<font color="green"> 386.                                             resolved.get('protocols', []))</font>
<font color="green"> 387.         signature_version = self._resolve_signature_version(</font>
<font color="green"> 388.             service_name, resolved)</font>
<font color="green"> 389.         signing_name = self._resolve_signing_name(service_name, resolved)</font>
<font color="green"> 390.         return self._create_result(</font>
<font color="green"> 391.             service_name=service_name, region_name=region_name,</font>
<font color="green"> 392.             signing_region=signing_region, signing_name=signing_name,</font>
<font color="green"> 393.             endpoint_url=endpoint_url, metadata=resolved,</font>
<font color="green"> 394.             signature_version=signature_version)</font>
<font color="black"> 395. </font>
<font color="green"> 396.     def _is_s3_dualstack_mode(self, service_name):</font>
<font color="green"> 397.         if service_name != 's3':</font>
<font color="red"> 398.             return False</font>
<font color="black"> 399.         # TODO: This normalization logic is duplicated from the</font>
<font color="black"> 400.         # ClientArgsCreator class.  Consolidate everything to</font>
<font color="black"> 401.         # ClientArgsCreator.  _resolve_signature_version also has similarly</font>
<font color="black"> 402.         # duplicated logic.</font>
<font color="green"> 403.         client_config = self.client_config</font>
<font color="green"> 404.         if client_config is not None and client_config.s3 is not None and \</font>
<font color="red"> 405.                 'use_dualstack_endpoint' in client_config.s3:</font>
<font color="black"> 406.             # Client config trumps scoped config.</font>
<font color="red"> 407.             return client_config.s3['use_dualstack_endpoint']</font>
<font color="green"> 408.         if self.scoped_config is None:</font>
<font color="red"> 409.             return False</font>
<font color="green"> 410.         enabled = self.scoped_config.get('s3', {}).get(</font>
<font color="green"> 411.             'use_dualstack_endpoint', False)</font>
<font color="green"> 412.         if enabled in [True, 'True', 'true']:</font>
<font color="red"> 413.             return True</font>
<font color="green"> 414.         return False</font>
<font color="black"> 415. </font>
<font color="green"> 416.     def _create_dualstack_endpoint(self, service_name, region_name,</font>
<font color="black"> 417.                                    dns_suffix, is_secure):</font>
<font color="red"> 418.         hostname = '{service}.dualstack.{region}.{dns_suffix}'.format(</font>
<font color="red"> 419.             service=service_name, region=region_name,</font>
<font color="red"> 420.             dns_suffix=dns_suffix)</font>
<font color="black"> 421.         # Dualstack supports http and https so were hardcoding this value for</font>
<font color="black"> 422.         # now.  This can potentially move into the endpoints.json file.</font>
<font color="red"> 423.         return self._make_url(hostname, is_secure, ['http', 'https'])</font>
<font color="black"> 424. </font>
<font color="green"> 425.     def _assume_endpoint(self, service_name, region_name, endpoint_url,</font>
<font color="black"> 426.                          is_secure):</font>
<font color="red"> 427.         if endpoint_url is None:</font>
<font color="black"> 428.             # Expand the default hostname URI template.</font>
<font color="red"> 429.             hostname = self.default_endpoint.format(</font>
<font color="red"> 430.                 service=service_name, region=region_name)</font>
<font color="red"> 431.             endpoint_url = self._make_url(hostname, is_secure,</font>
<font color="red"> 432.                                           ['http', 'https'])</font>
<font color="red"> 433.         logger.debug('Assuming an endpoint for %s, %s: %s',</font>
<font color="red"> 434.                      service_name, region_name, endpoint_url)</font>
<font color="black"> 435.         # We still want to allow the user to provide an explicit version.</font>
<font color="red"> 436.         signature_version = self._resolve_signature_version(</font>
<font color="red"> 437.             service_name, {'signatureVersions': ['v4']})</font>
<font color="red"> 438.         signing_name = self._resolve_signing_name(service_name, resolved={})</font>
<font color="red"> 439.         return self._create_result(</font>
<font color="red"> 440.             service_name=service_name, region_name=region_name,</font>
<font color="red"> 441.             signing_region=region_name, signing_name=signing_name,</font>
<font color="red"> 442.             signature_version=signature_version, endpoint_url=endpoint_url,</font>
<font color="red"> 443.             metadata={})</font>
<font color="black"> 444. </font>
<font color="green"> 445.     def _create_result(self, service_name, region_name, signing_region,</font>
<font color="black"> 446.                        signing_name, endpoint_url, signature_version,</font>
<font color="black"> 447.                        metadata):</font>
<font color="green"> 448.         return {</font>
<font color="green"> 449.             'service_name': service_name,</font>
<font color="green"> 450.             'region_name': region_name,</font>
<font color="green"> 451.             'signing_region': signing_region,</font>
<font color="green"> 452.             'signing_name': signing_name,</font>
<font color="green"> 453.             'endpoint_url': endpoint_url,</font>
<font color="green"> 454.             'signature_version': signature_version,</font>
<font color="green"> 455.             'metadata': metadata</font>
<font color="black"> 456.         }</font>
<font color="black"> 457. </font>
<font color="green"> 458.     def _make_url(self, hostname, is_secure, supported_protocols):</font>
<font color="green"> 459.         if is_secure and 'https' in supported_protocols:</font>
<font color="green"> 460.             scheme = 'https'</font>
<font color="black"> 461.         else:</font>
<font color="red"> 462.             scheme = 'http'</font>
<font color="green"> 463.         return '%s://%s' % (scheme, hostname)</font>
<font color="black"> 464. </font>
<font color="green"> 465.     def _resolve_signing_name(self, service_name, resolved):</font>
<font color="black"> 466.         # CredentialScope overrides everything else.</font>
<font color="green"> 467.         if 'credentialScope' in resolved \</font>
<font color="red"> 468.                 and 'service' in resolved['credentialScope']:</font>
<font color="red"> 469.             return resolved['credentialScope']['service']</font>
<font color="black"> 470.         # Use the signingName from the model if present.</font>
<font color="green"> 471.         if self.service_signing_name:</font>
<font color="red"> 472.             return self.service_signing_name</font>
<font color="black"> 473.         # Just assume is the same as the service name.</font>
<font color="green"> 474.         return service_name</font>
<font color="black"> 475. </font>
<font color="green"> 476.     def _pick_region_values(self, resolved, region_name, endpoint_url):</font>
<font color="green"> 477.         signing_region = region_name</font>
<font color="green"> 478.         if endpoint_url is None:</font>
<font color="black"> 479.             # Do not use the region name or signing name from the resolved</font>
<font color="black"> 480.             # endpoint if the user explicitly provides an endpoint_url. This</font>
<font color="black"> 481.             # would happen if we resolve to an endpoint where the service has</font>
<font color="black"> 482.             # a &quot;defaults&quot; section that overrides all endpoint with a single</font>
<font color="black"> 483.             # hostname and credentialScope. This has been the case historically</font>
<font color="black"> 484.             # for how STS has worked. The only way to resolve an STS endpoint</font>
<font color="black"> 485.             # was to provide a region_name and an endpoint_url. In that case,</font>
<font color="black"> 486.             # we would still resolve an endpoint, but we would not use the</font>
<font color="black"> 487.             # resolved endpointName or signingRegion because we want to allow</font>
<font color="black"> 488.             # custom endpoints.</font>
<font color="green"> 489.             region_name = resolved['endpointName']</font>
<font color="green"> 490.             signing_region = region_name</font>
<font color="green"> 491.             if 'credentialScope' in resolved \</font>
<font color="red"> 492.                     and 'region' in resolved['credentialScope']:</font>
<font color="red"> 493.                 signing_region = resolved['credentialScope']['region']</font>
<font color="green"> 494.         return region_name, signing_region</font>
<font color="black"> 495. </font>
<font color="green"> 496.     def _resolve_signature_version(self, service_name, resolved):</font>
<font color="green"> 497.         configured_version = _get_configured_signature_version(</font>
<font color="green"> 498.             service_name, self.client_config, self.scoped_config)</font>
<font color="green"> 499.         if configured_version is not None:</font>
<font color="red"> 500.             return configured_version</font>
<font color="black"> 501. </font>
<font color="black"> 502.         # Pick a signature version from the endpoint metadata if present.</font>
<font color="green"> 503.         if 'signatureVersions' in resolved:</font>
<font color="green"> 504.             potential_versions = resolved['signatureVersions']</font>
<font color="green"> 505.             if service_name == 's3':</font>
<font color="green"> 506.                 return 's3v4'</font>
<font color="red"> 507.             if 'v4' in potential_versions:</font>
<font color="red"> 508.                 return 'v4'</font>
<font color="black"> 509.             # Now just iterate over the signature versions in order until we</font>
<font color="black"> 510.             # find the first one that is known to Botocore.</font>
<font color="red"> 511.             for known in AUTH_TYPE_MAPS:</font>
<font color="red"> 512.                 if known in potential_versions:</font>
<font color="red"> 513.                     return known</font>
<font color="red"> 514.         raise UnknownSignatureVersionError(</font>
<font color="red"> 515.             signature_version=resolved.get('signatureVersions'))</font>
<font color="black"> 516. </font>
<font color="black"> 517. </font>
<font color="green"> 518. class BaseClient(object):</font>
<font color="black"> 519. </font>
<font color="black"> 520.     # This is actually reassigned with the py-&gt;op_name mapping</font>
<font color="black"> 521.     # when the client creator creates the subclass.  This value is used</font>
<font color="black"> 522.     # because calls such as client.get_paginator('list_objects') use the</font>
<font color="black"> 523.     # snake_case name, but we need to know the ListObjects form.</font>
<font color="black"> 524.     # xform_name() does the ListObjects-&gt;list_objects conversion, but</font>
<font color="black"> 525.     # we need the reverse mapping here.</font>
<font color="green"> 526.     _PY_TO_OP_NAME = {}</font>
<font color="black"> 527. </font>
<font color="green"> 528.     def __init__(self, serializer, endpoint, response_parser,</font>
<font color="black"> 529.                  event_emitter, request_signer, service_model, loader,</font>
<font color="black"> 530.                  client_config, partition, exceptions_factory):</font>
<font color="green"> 531.         self._serializer = serializer</font>
<font color="green"> 532.         self._endpoint = endpoint</font>
<font color="green"> 533.         self._response_parser = response_parser</font>
<font color="green"> 534.         self._request_signer = request_signer</font>
<font color="green"> 535.         self._cache = {}</font>
<font color="green"> 536.         self._loader = loader</font>
<font color="green"> 537.         self._client_config = client_config</font>
<font color="green"> 538.         self.meta = ClientMeta(event_emitter, self._client_config,</font>
<font color="green"> 539.                                endpoint.host, service_model,</font>
<font color="green"> 540.                                self._PY_TO_OP_NAME, partition)</font>
<font color="green"> 541.         self._exceptions_factory = exceptions_factory</font>
<font color="green"> 542.         self._exceptions = None</font>
<font color="green"> 543.         self._register_handlers()</font>
<font color="black"> 544. </font>
<font color="green"> 545.     def __getattr__(self, item):</font>
<font color="red"> 546.         event_name = 'getattr.%s.%s' % (self._service_model.service_name, item)</font>
<font color="red"> 547.         handler, event_response = self.meta.events.emit_until_response(</font>
<font color="red"> 548.             event_name, client=self)</font>
<font color="black"> 549. </font>
<font color="red"> 550.         if event_response is not None:</font>
<font color="red"> 551.             return event_response</font>
<font color="black"> 552. </font>
<font color="red"> 553.         raise AttributeError(</font>
<font color="red"> 554.             &quot;'%s' object has no attribute '%s'&quot; % (</font>
<font color="red"> 555.                 self.__class__.__name__, item)</font>
<font color="black"> 556.         )</font>
<font color="black"> 557. </font>
<font color="green"> 558.     def _register_handlers(self):</font>
<font color="black"> 559.         # Register the handler required to sign requests.</font>
<font color="green"> 560.         self.meta.events.register('request-created.%s' %</font>
<font color="green"> 561.                                   self.meta.service_model.endpoint_prefix,</font>
<font color="green"> 562.                                   self._request_signer.handler)</font>
<font color="black"> 563. </font>
<font color="green"> 564.     @property</font>
<font color="black"> 565.     def _service_model(self):</font>
<font color="green"> 566.         return self.meta.service_model</font>
<font color="black"> 567. </font>
<font color="green"> 568.     def _make_api_call(self, operation_name, api_params):</font>
<font color="green"> 569.         operation_model = self._service_model.operation_model(operation_name)</font>
<font color="green"> 570.         service_name = self._service_model.service_name</font>
<font color="green"> 571.         history_recorder.record('API_CALL', {</font>
<font color="green"> 572.             'service': service_name,</font>
<font color="green"> 573.             'operation': operation_name,</font>
<font color="green"> 574.             'params': api_params,</font>
<font color="black"> 575.         })</font>
<font color="green"> 576.         if operation_model.deprecated:</font>
<font color="red"> 577.             logger.debug('Warning: %s.%s() is deprecated',</font>
<font color="red"> 578.                          service_name, operation_name)</font>
<font color="green"> 579.         request_context = {</font>
<font color="green"> 580.             'client_region': self.meta.region_name,</font>
<font color="green"> 581.             'client_config': self.meta.config,</font>
<font color="green"> 582.             'has_streaming_input': operation_model.has_streaming_input,</font>
<font color="green"> 583.             'auth_type': operation_model.auth_type,</font>
<font color="black"> 584.         }</font>
<font color="green"> 585.         request_dict = self._convert_to_request_dict(</font>
<font color="green"> 586.             api_params, operation_model, context=request_context)</font>
<font color="black"> 587. </font>
<font color="green"> 588.         handler, event_response = self.meta.events.emit_until_response(</font>
<font color="green"> 589.             'before-call.{endpoint_prefix}.{operation_name}'.format(</font>
<font color="green"> 590.                 endpoint_prefix=self._service_model.endpoint_prefix,</font>
<font color="green"> 591.                 operation_name=operation_name),</font>
<font color="green"> 592.             model=operation_model, params=request_dict,</font>
<font color="green"> 593.             request_signer=self._request_signer, context=request_context)</font>
<font color="black"> 594. </font>
<font color="green"> 595.         if event_response is not None:</font>
<font color="red"> 596.             http, parsed_response = event_response</font>
<font color="black"> 597.         else:</font>
<font color="green"> 598.             http, parsed_response = self._endpoint.make_request(</font>
<font color="green"> 599.                 operation_model, request_dict)</font>
<font color="black"> 600. </font>
<font color="green"> 601.         self.meta.events.emit(</font>
<font color="green"> 602.             'after-call.{endpoint_prefix}.{operation_name}'.format(</font>
<font color="green"> 603.                 endpoint_prefix=self._service_model.endpoint_prefix,</font>
<font color="green"> 604.                 operation_name=operation_name),</font>
<font color="green"> 605.             http_response=http, parsed=parsed_response,</font>
<font color="green"> 606.             model=operation_model, context=request_context</font>
<font color="black"> 607.         )</font>
<font color="black"> 608. </font>
<font color="green"> 609.         if http.status_code &gt;= 300:</font>
<font color="red"> 610.             error_code = parsed_response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;)</font>
<font color="red"> 611.             error_class = self.exceptions.from_code(error_code)</font>
<font color="red"> 612.             raise error_class(parsed_response, operation_name)</font>
<font color="black"> 613.         else:</font>
<font color="green"> 614.             return parsed_response</font>
<font color="black"> 615. </font>
<font color="black"> 616.     def _convert_to_request_dict(self, api_params, operation_model,</font>
<font color="green"> 617.                                  context=None):</font>
<font color="green"> 618.         api_params = self._emit_api_params(</font>
<font color="green"> 619.             api_params, operation_model, context)</font>
<font color="green"> 620.         request_dict = self._serializer.serialize_to_request(</font>
<font color="green"> 621.             api_params, operation_model)</font>
<font color="green"> 622.         prepare_request_dict(request_dict, endpoint_url=self._endpoint.host,</font>
<font color="green"> 623.                              user_agent=self._client_config.user_agent,</font>
<font color="green"> 624.                              context=context)</font>
<font color="green"> 625.         return request_dict</font>
<font color="black"> 626. </font>
<font color="green"> 627.     def _emit_api_params(self, api_params, operation_model, context):</font>
<font color="black"> 628.         # Given the API params provided by the user and the operation_model</font>
<font color="black"> 629.         # we can serialize the request to a request_dict.</font>
<font color="green"> 630.         operation_name = operation_model.name</font>
<font color="black"> 631. </font>
<font color="black"> 632.         # Emit an event that allows users to modify the parameters at the</font>
<font color="black"> 633.         # beginning of the method. It allows handlers to modify existing</font>
<font color="black"> 634.         # parameters or return a new set of parameters to use.</font>
<font color="green"> 635.         responses = self.meta.events.emit(</font>
<font color="green"> 636.             'provide-client-params.{endpoint_prefix}.{operation_name}'.format(</font>
<font color="green"> 637.                 endpoint_prefix=self._service_model.endpoint_prefix,</font>
<font color="green"> 638.                 operation_name=operation_name),</font>
<font color="green"> 639.             params=api_params, model=operation_model, context=context)</font>
<font color="green"> 640.         api_params = first_non_none_response(responses, default=api_params)</font>
<font color="black"> 641. </font>
<font color="black"> 642.         event_name = (</font>
<font color="green"> 643.             'before-parameter-build.{endpoint_prefix}.{operation_name}')</font>
<font color="green"> 644.         self.meta.events.emit(</font>
<font color="green"> 645.             event_name.format(</font>
<font color="green"> 646.                 endpoint_prefix=self._service_model.endpoint_prefix,</font>
<font color="green"> 647.                 operation_name=operation_name),</font>
<font color="green"> 648.             params=api_params, model=operation_model, context=context)</font>
<font color="green"> 649.         return api_params</font>
<font color="black"> 650. </font>
<font color="green"> 651.     def get_paginator(self, operation_name):</font>
<font color="black"> 652.         &quot;&quot;&quot;Create a paginator for an operation.</font>
<font color="black"> 653. </font>
<font color="black"> 654.         :type operation_name: string</font>
<font color="black"> 655.         :param operation_name: The operation name.  This is the same name</font>
<font color="black"> 656.             as the method name on the client.  For example, if the</font>
<font color="black"> 657.             method name is ``create_foo``, and you'd normally invoke the</font>
<font color="black"> 658.             operation as ``client.create_foo(**kwargs)``, if the</font>
<font color="black"> 659.             ``create_foo`` operation can be paginated, you can use the</font>
<font color="black"> 660.             call ``client.get_paginator(&quot;create_foo&quot;)``.</font>
<font color="black"> 661. </font>
<font color="black"> 662.         :raise OperationNotPageableError: Raised if the operation is not</font>
<font color="black"> 663.             pageable.  You can use the ``client.can_paginate`` method to</font>
<font color="black"> 664.             check if an operation is pageable.</font>
<font color="black"> 665. </font>
<font color="black"> 666.         :rtype: L{botocore.paginate.Paginator}</font>
<font color="black"> 667.         :return: A paginator object.</font>
<font color="black"> 668. </font>
<font color="black"> 669.         &quot;&quot;&quot;</font>
<font color="red"> 670.         if not self.can_paginate(operation_name):</font>
<font color="red"> 671.             raise OperationNotPageableError(operation_name=operation_name)</font>
<font color="black"> 672.         else:</font>
<font color="red"> 673.             actual_operation_name = self._PY_TO_OP_NAME[operation_name]</font>
<font color="black"> 674. </font>
<font color="black"> 675.             # Create a new paginate method that will serve as a proxy to</font>
<font color="black"> 676.             # the underlying Paginator.paginate method. This is needed to</font>
<font color="black"> 677.             # attach a docstring to the method.</font>
<font color="red"> 678.             def paginate(self, **kwargs):</font>
<font color="red"> 679.                 return Paginator.paginate(self, **kwargs)</font>
<font color="black"> 680. </font>
<font color="red"> 681.             paginator_config = self._cache['page_config'][</font>
<font color="red"> 682.                 actual_operation_name]</font>
<font color="black"> 683.             # Add the docstring for the paginate method.</font>
<font color="red"> 684.             paginate.__doc__ = PaginatorDocstring(</font>
<font color="red"> 685.                 paginator_name=actual_operation_name,</font>
<font color="red"> 686.                 event_emitter=self.meta.events,</font>
<font color="red"> 687.                 service_model=self.meta.service_model,</font>
<font color="red"> 688.                 paginator_config=paginator_config,</font>
<font color="red"> 689.                 include_signature=False</font>
<font color="black"> 690.             )</font>
<font color="black"> 691. </font>
<font color="black"> 692.             # Rename the paginator class based on the type of paginator.</font>
<font color="red"> 693.             paginator_class_name = str('%s.Paginator.%s' % (</font>
<font color="red"> 694.                 get_service_module_name(self.meta.service_model),</font>
<font color="red"> 695.                 actual_operation_name))</font>
<font color="black"> 696. </font>
<font color="black"> 697.             # Create the new paginator class</font>
<font color="red"> 698.             documented_paginator_cls = type(</font>
<font color="red"> 699.                 paginator_class_name, (Paginator,), {'paginate': paginate})</font>
<font color="black"> 700. </font>
<font color="red"> 701.             operation_model = self._service_model.operation_model(actual_operation_name)</font>
<font color="red"> 702.             paginator = documented_paginator_cls(</font>
<font color="red"> 703.                 getattr(self, operation_name),</font>
<font color="red"> 704.                 paginator_config,</font>
<font color="red"> 705.                 operation_model)</font>
<font color="red"> 706.             return paginator</font>
<font color="black"> 707. </font>
<font color="green"> 708.     def can_paginate(self, operation_name):</font>
<font color="black"> 709.         &quot;&quot;&quot;Check if an operation can be paginated.</font>
<font color="black"> 710. </font>
<font color="black"> 711.         :type operation_name: string</font>
<font color="black"> 712.         :param operation_name: The operation name.  This is the same name</font>
<font color="black"> 713.             as the method name on the client.  For example, if the</font>
<font color="black"> 714.             method name is ``create_foo``, and you'd normally invoke the</font>
<font color="black"> 715.             operation as ``client.create_foo(**kwargs)``, if the</font>
<font color="black"> 716.             ``create_foo`` operation can be paginated, you can use the</font>
<font color="black"> 717.             call ``client.get_paginator(&quot;create_foo&quot;)``.</font>
<font color="black"> 718. </font>
<font color="black"> 719.         :return: ``True`` if the operation can be paginated,</font>
<font color="black"> 720.             ``False`` otherwise.</font>
<font color="black"> 721. </font>
<font color="black"> 722.         &quot;&quot;&quot;</font>
<font color="red"> 723.         if 'page_config' not in self._cache:</font>
<font color="red"> 724.             try:</font>
<font color="red"> 725.                 page_config = self._loader.load_service_model(</font>
<font color="red"> 726.                     self._service_model.service_name,</font>
<font color="red"> 727.                     'paginators-1',</font>
<font color="red"> 728.                     self._service_model.api_version)['pagination']</font>
<font color="red"> 729.                 self._cache['page_config'] = page_config</font>
<font color="red"> 730.             except DataNotFoundError:</font>
<font color="red"> 731.                 self._cache['page_config'] = {}</font>
<font color="red"> 732.         actual_operation_name = self._PY_TO_OP_NAME[operation_name]</font>
<font color="red"> 733.         return actual_operation_name in self._cache['page_config']</font>
<font color="black"> 734. </font>
<font color="green"> 735.     def _get_waiter_config(self):</font>
<font color="red"> 736.         if 'waiter_config' not in self._cache:</font>
<font color="red"> 737.             try:</font>
<font color="red"> 738.                 waiter_config = self._loader.load_service_model(</font>
<font color="red"> 739.                     self._service_model.service_name,</font>
<font color="red"> 740.                     'waiters-2',</font>
<font color="red"> 741.                     self._service_model.api_version)</font>
<font color="red"> 742.                 self._cache['waiter_config'] = waiter_config</font>
<font color="red"> 743.             except DataNotFoundError:</font>
<font color="red"> 744.                 self._cache['waiter_config'] = {}</font>
<font color="red"> 745.         return self._cache['waiter_config']</font>
<font color="black"> 746. </font>
<font color="green"> 747.     def get_waiter(self, waiter_name):</font>
<font color="black"> 748.         &quot;&quot;&quot;Returns an object that can wait for some condition.</font>
<font color="black"> 749. </font>
<font color="black"> 750.         :type waiter_name: str</font>
<font color="black"> 751.         :param waiter_name: The name of the waiter to get. See the waiters</font>
<font color="black"> 752.             section of the service docs for a list of available waiters.</font>
<font color="black"> 753. </font>
<font color="black"> 754.         :returns: The specified waiter object.</font>
<font color="black"> 755.         :rtype: botocore.waiter.Waiter</font>
<font color="black"> 756.         &quot;&quot;&quot;</font>
<font color="red"> 757.         config = self._get_waiter_config()</font>
<font color="red"> 758.         if not config:</font>
<font color="red"> 759.             raise ValueError(&quot;Waiter does not exist: %s&quot; % waiter_name)</font>
<font color="red"> 760.         model = waiter.WaiterModel(config)</font>
<font color="red"> 761.         mapping = {}</font>
<font color="red"> 762.         for name in model.waiter_names:</font>
<font color="red"> 763.             mapping[xform_name(name)] = name</font>
<font color="red"> 764.         if waiter_name not in mapping:</font>
<font color="red"> 765.             raise ValueError(&quot;Waiter does not exist: %s&quot; % waiter_name)</font>
<font color="black"> 766. </font>
<font color="red"> 767.         return waiter.create_waiter_with_client(</font>
<font color="red"> 768.             mapping[waiter_name], model, self)</font>
<font color="black"> 769. </font>
<font color="green"> 770.     @CachedProperty</font>
<font color="black"> 771.     def waiter_names(self):</font>
<font color="black"> 772.         &quot;&quot;&quot;Returns a list of all available waiters.&quot;&quot;&quot;</font>
<font color="red"> 773.         config = self._get_waiter_config()</font>
<font color="red"> 774.         if not config:</font>
<font color="red"> 775.             return []</font>
<font color="red"> 776.         model = waiter.WaiterModel(config)</font>
<font color="black"> 777.         # Waiter configs is a dict, we just want the waiter names</font>
<font color="black"> 778.         # which are the keys in the dict.</font>
<font color="red"> 779.         return [xform_name(name) for name in model.waiter_names]</font>
<font color="black"> 780. </font>
<font color="green"> 781.     @property</font>
<font color="black"> 782.     def exceptions(self):</font>
<font color="red"> 783.         if self._exceptions is None:</font>
<font color="red"> 784.             self._exceptions = self._load_exceptions()</font>
<font color="red"> 785.         return self._exceptions</font>
<font color="black"> 786. </font>
<font color="green"> 787.     def _load_exceptions(self):</font>
<font color="red"> 788.         return self._exceptions_factory.create_client_exceptions(</font>
<font color="red"> 789.             self._service_model)</font>
<font color="black"> 790. </font>
<font color="black"> 791. </font>
<font color="green"> 792. class ClientMeta(object):</font>
<font color="black"> 793.     &quot;&quot;&quot;Holds additional client methods.</font>
<font color="black"> 794. </font>
<font color="black"> 795.     This class holds additional information for clients.  It exists for</font>
<font color="black"> 796.     two reasons:</font>
<font color="black"> 797. </font>
<font color="black"> 798.         * To give advanced functionality to clients</font>
<font color="black"> 799.         * To namespace additional client attributes from the operation</font>
<font color="black"> 800.           names which are mapped to methods at runtime.  This avoids</font>
<font color="black"> 801.           ever running into collisions with operation names.</font>
<font color="black"> 802. </font>
<font color="green"> 803.     &quot;&quot;&quot;</font>
<font color="black"> 804. </font>
<font color="green"> 805.     def __init__(self, events, client_config, endpoint_url, service_model,</font>
<font color="black"> 806.                  method_to_api_mapping, partition):</font>
<font color="green"> 807.         self.events = events</font>
<font color="green"> 808.         self._client_config = client_config</font>
<font color="green"> 809.         self._endpoint_url = endpoint_url</font>
<font color="green"> 810.         self._service_model = service_model</font>
<font color="green"> 811.         self._method_to_api_mapping = method_to_api_mapping</font>
<font color="green"> 812.         self._partition = partition</font>
<font color="black"> 813. </font>
<font color="green"> 814.     @property</font>
<font color="black"> 815.     def service_model(self):</font>
<font color="green"> 816.         return self._service_model</font>
<font color="black"> 817. </font>
<font color="green"> 818.     @property</font>
<font color="black"> 819.     def region_name(self):</font>
<font color="green"> 820.         return self._client_config.region_name</font>
<font color="black"> 821. </font>
<font color="green"> 822.     @property</font>
<font color="black"> 823.     def endpoint_url(self):</font>
<font color="red"> 824.         return self._endpoint_url</font>
<font color="black"> 825. </font>
<font color="green"> 826.     @property</font>
<font color="black"> 827.     def config(self):</font>
<font color="green"> 828.         return self._client_config</font>
<font color="black"> 829. </font>
<font color="green"> 830.     @property</font>
<font color="black"> 831.     def method_to_api_mapping(self):</font>
<font color="red"> 832.         return self._method_to_api_mapping</font>
<font color="black"> 833. </font>
<font color="green"> 834.     @property</font>
<font color="black"> 835.     def partition(self):</font>
<font color="green"> 836.         return self._partition</font>
<font color="black"> 837. </font>
<font color="black"> 838. </font>
<font color="green"> 839. def _get_configured_signature_version(service_name, client_config,</font>
<font color="black"> 840.                                       scoped_config):</font>
<font color="black"> 841.     &quot;&quot;&quot;</font>
<font color="black"> 842.     Gets the manually configured signature version.</font>
<font color="black"> 843. </font>
<font color="black"> 844.     :returns: the customer configured signature version, or None if no</font>
<font color="black"> 845.         signature version was configured.</font>
<font color="black"> 846.     &quot;&quot;&quot;</font>
<font color="black"> 847.     # Client config overrides everything.</font>
<font color="green"> 848.     if client_config and client_config.signature_version is not None:</font>
<font color="red"> 849.         return client_config.signature_version</font>
<font color="black"> 850. </font>
<font color="black"> 851.     # Scoped config overrides picking from the endpoint metadata.</font>
<font color="green"> 852.     if scoped_config is not None:</font>
<font color="black"> 853.         # A given service may have service specific configuration in the</font>
<font color="black"> 854.         # config file, so we need to check there as well.</font>
<font color="green"> 855.         service_config = scoped_config.get(service_name)</font>
<font color="green"> 856.         if service_config is not None and isinstance(service_config, dict):</font>
<font color="red"> 857.             version = service_config.get('signature_version')</font>
<font color="red"> 858.             if version:</font>
<font color="red"> 859.                 logger.debug(</font>
<font color="red"> 860.                     &quot;Switching signature version for service %s &quot;</font>
<font color="black"> 861.                     &quot;to version %s based on config file override.&quot;,</font>
<font color="red"> 862.                     service_name, version)</font>
<font color="red"> 863.                 return version</font>
<font color="green"> 864.     return None</font>
</pre>

