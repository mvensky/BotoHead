source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/retryhandler.py</b><br>


file stats: <b>194 lines, 129 executed: 66.5% covered</b>
<pre>
<font color="black">   1. # Copyright (c) 2012-2013 Mitch Garnaat http://garnaat.org/</font>
<font color="black">   2. # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   3. #</font>
<font color="black">   4. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   5. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   6. # the License is located at</font>
<font color="black">   7. #</font>
<font color="black">   8. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   9. #</font>
<font color="black">  10. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  11. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  12. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  13. # language governing permissions and limitations under the License.</font>
<font color="black">  14. </font>
<font color="green">  15. import random</font>
<font color="green">  16. import functools</font>
<font color="green">  17. import logging</font>
<font color="green">  18. from binascii import crc32</font>
<font color="black">  19. </font>
<font color="green">  20. from botocore.vendored.requests import ConnectionError, Timeout</font>
<font color="green">  21. from botocore.vendored.requests.packages.urllib3.exceptions import ClosedPoolError</font>
<font color="black">  22. </font>
<font color="green">  23. from botocore.exceptions import ChecksumError, EndpointConnectionError</font>
<font color="black">  24. </font>
<font color="black">  25. </font>
<font color="green">  26. logger = logging.getLogger(__name__)</font>
<font color="black">  27. # The only supported error for now is GENERAL_CONNECTION_ERROR</font>
<font color="black">  28. # which maps to requests generic ConnectionError.  If we're able</font>
<font color="black">  29. # to get more specific exceptions from requests we can update</font>
<font color="black">  30. # this mapping with more specific exceptions.</font>
<font color="green">  31. EXCEPTION_MAP = {</font>
<font color="black">  32.     'GENERAL_CONNECTION_ERROR': [</font>
<font color="green">  33.         ConnectionError, ClosedPoolError, Timeout,</font>
<font color="green">  34.         EndpointConnectionError</font>
<font color="black">  35.     ],</font>
<font color="black">  36. }</font>
<font color="black">  37. </font>
<font color="black">  38. </font>
<font color="green">  39. def delay_exponential(base, growth_factor, attempts):</font>
<font color="black">  40.     &quot;&quot;&quot;Calculate time to sleep based on exponential function.</font>
<font color="black">  41. </font>
<font color="black">  42.     The format is::</font>
<font color="black">  43. </font>
<font color="black">  44.         base * growth_factor ^ (attempts - 1)</font>
<font color="black">  45. </font>
<font color="black">  46.     If ``base`` is set to 'rand' then a random number between</font>
<font color="black">  47.     0 and 1 will be used as the base.</font>
<font color="black">  48.     Base must be greater than 0, otherwise a ValueError will be</font>
<font color="black">  49.     raised.</font>
<font color="black">  50. </font>
<font color="black">  51.     &quot;&quot;&quot;</font>
<font color="red">  52.     if base == 'rand':</font>
<font color="red">  53.         base = random.random()</font>
<font color="red">  54.     elif base &lt;= 0:</font>
<font color="red">  55.         raise ValueError(&quot;The 'base' param must be greater than 0, &quot;</font>
<font color="red">  56.                          &quot;got: %s&quot; % base)</font>
<font color="red">  57.     time_to_sleep = base * (growth_factor ** (attempts - 1))</font>
<font color="red">  58.     return time_to_sleep</font>
<font color="black">  59. </font>
<font color="black">  60. </font>
<font color="green">  61. def create_exponential_delay_function(base, growth_factor):</font>
<font color="black">  62.     &quot;&quot;&quot;Create an exponential delay function based on the attempts.</font>
<font color="black">  63. </font>
<font color="black">  64.     This is used so that you only have to pass it the attempts</font>
<font color="black">  65.     parameter to calculate the delay.</font>
<font color="black">  66. </font>
<font color="black">  67.     &quot;&quot;&quot;</font>
<font color="green">  68.     return functools.partial(</font>
<font color="green">  69.         delay_exponential, base=base, growth_factor=growth_factor)</font>
<font color="black">  70. </font>
<font color="black">  71. </font>
<font color="green">  72. def create_retry_handler(config, operation_name=None):</font>
<font color="green">  73.     checker = create_checker_from_retry_config(</font>
<font color="green">  74.         config, operation_name=operation_name)</font>
<font color="green">  75.     action = create_retry_action_from_config(</font>
<font color="green">  76.         config, operation_name=operation_name)</font>
<font color="green">  77.     return RetryHandler(checker=checker, action=action)</font>
<font color="black">  78. </font>
<font color="black">  79. </font>
<font color="green">  80. def create_retry_action_from_config(config, operation_name=None):</font>
<font color="black">  81.     # The spec has the possibility of supporting per policy</font>
<font color="black">  82.     # actions, but right now, we assume this comes from the</font>
<font color="black">  83.     # default section, which means that delay functions apply</font>
<font color="black">  84.     # for every policy in the retry config (per service).</font>
<font color="green">  85.     delay_config = config['__default__']['delay']</font>
<font color="green">  86.     if delay_config['type'] == 'exponential':</font>
<font color="green">  87.         return create_exponential_delay_function(</font>
<font color="green">  88.             base=delay_config['base'],</font>
<font color="green">  89.             growth_factor=delay_config['growth_factor'])</font>
<font color="black">  90. </font>
<font color="black">  91. </font>
<font color="green">  92. def create_checker_from_retry_config(config, operation_name=None):</font>
<font color="green">  93.     checkers = []</font>
<font color="green">  94.     max_attempts = None</font>
<font color="green">  95.     retryable_exceptions = []</font>
<font color="green">  96.     if '__default__' in config:</font>
<font color="green">  97.         policies = config['__default__'].get('policies', [])</font>
<font color="green">  98.         max_attempts = config['__default__']['max_attempts']</font>
<font color="green">  99.         for key in policies:</font>
<font color="green"> 100.             current_config = policies[key]</font>
<font color="green"> 101.             checkers.append(_create_single_checker(current_config))</font>
<font color="green"> 102.             retry_exception = _extract_retryable_exception(current_config)</font>
<font color="green"> 103.             if retry_exception is not None:</font>
<font color="green"> 104.                 retryable_exceptions.extend(retry_exception)</font>
<font color="green"> 105.     if operation_name is not None and config.get(operation_name) is not None:</font>
<font color="red"> 106.         operation_policies = config[operation_name]['policies']</font>
<font color="red"> 107.         for key in operation_policies:</font>
<font color="red"> 108.             checkers.append(_create_single_checker(operation_policies[key]))</font>
<font color="red"> 109.             retry_exception = _extract_retryable_exception(</font>
<font color="red"> 110.                 operation_policies[key])</font>
<font color="red"> 111.             if retry_exception is not None:</font>
<font color="red"> 112.                 retryable_exceptions.extend(retry_exception)</font>
<font color="green"> 113.     if len(checkers) == 1:</font>
<font color="black"> 114.         # Don't need to use a MultiChecker</font>
<font color="red"> 115.         return MaxAttemptsDecorator(checkers[0], max_attempts=max_attempts)</font>
<font color="black"> 116.     else:</font>
<font color="green"> 117.         multi_checker = MultiChecker(checkers)</font>
<font color="green"> 118.         return MaxAttemptsDecorator(</font>
<font color="green"> 119.             multi_checker, max_attempts=max_attempts,</font>
<font color="green"> 120.             retryable_exceptions=tuple(retryable_exceptions))</font>
<font color="black"> 121. </font>
<font color="black"> 122. </font>
<font color="green"> 123. def _create_single_checker(config):</font>
<font color="green"> 124.     if 'response' in config['applies_when']:</font>
<font color="green"> 125.         return _create_single_response_checker(</font>
<font color="green"> 126.             config['applies_when']['response'])</font>
<font color="green"> 127.     elif 'socket_errors' in config['applies_when']:</font>
<font color="green"> 128.         return ExceptionRaiser()</font>
<font color="black"> 129. </font>
<font color="black"> 130. </font>
<font color="green"> 131. def _create_single_response_checker(response):</font>
<font color="green"> 132.     if 'service_error_code' in response:</font>
<font color="green"> 133.         checker = ServiceErrorCodeChecker(</font>
<font color="green"> 134.             status_code=response['http_status_code'],</font>
<font color="green"> 135.             error_code=response['service_error_code'])</font>
<font color="green"> 136.     elif 'http_status_code' in response:</font>
<font color="green"> 137.         checker = HTTPStatusCodeChecker(</font>
<font color="green"> 138.             status_code=response['http_status_code'])</font>
<font color="red"> 139.     elif 'crc32body' in response:</font>
<font color="red"> 140.         checker = CRC32Checker(header=response['crc32body'])</font>
<font color="black"> 141.     else:</font>
<font color="black"> 142.         # TODO: send a signal.</font>
<font color="red"> 143.         raise ValueError(&quot;Unknown retry policy: %s&quot; % config)</font>
<font color="green"> 144.     return checker</font>
<font color="black"> 145. </font>
<font color="black"> 146. </font>
<font color="green"> 147. def _extract_retryable_exception(config):</font>
<font color="green"> 148.     applies_when = config['applies_when']</font>
<font color="green"> 149.     if 'crc32body' in applies_when.get('response', {}):</font>
<font color="red"> 150.         return [ChecksumError]</font>
<font color="green"> 151.     elif 'socket_errors' in applies_when:</font>
<font color="green"> 152.         exceptions = []</font>
<font color="green"> 153.         for name in applies_when['socket_errors']:</font>
<font color="green"> 154.             exceptions.extend(EXCEPTION_MAP[name])</font>
<font color="green"> 155.         return exceptions</font>
<font color="black"> 156. </font>
<font color="black"> 157. </font>
<font color="green"> 158. class RetryHandler(object):</font>
<font color="black"> 159.     &quot;&quot;&quot;Retry handler.</font>
<font color="black"> 160. </font>
<font color="black"> 161.     The retry handler takes two params, ``checker`` object</font>
<font color="black"> 162.     and an ``action`` object.</font>
<font color="black"> 163. </font>
<font color="black"> 164.     The ``checker`` object must be a callable object and based on a response</font>
<font color="black"> 165.     and an attempt number, determines whether or not sufficient criteria for</font>
<font color="black"> 166.     a retry has been met.  If this is the case then the ``action`` object</font>
<font color="black"> 167.     (which also is a callable) determines what needs to happen in the event</font>
<font color="black"> 168.     of a retry.</font>
<font color="black"> 169. </font>
<font color="green"> 170.     &quot;&quot;&quot;</font>
<font color="black"> 171. </font>
<font color="green"> 172.     def __init__(self, checker, action):</font>
<font color="green"> 173.         self._checker = checker</font>
<font color="green"> 174.         self._action = action</font>
<font color="black"> 175. </font>
<font color="green"> 176.     def __call__(self, attempts, response, caught_exception, **kwargs):</font>
<font color="black"> 177.         &quot;&quot;&quot;Handler for a retry.</font>
<font color="black"> 178. </font>
<font color="black"> 179.         Intended to be hooked up to an event handler (hence the **kwargs),</font>
<font color="black"> 180.         this will process retries appropriately.</font>
<font color="black"> 181. </font>
<font color="black"> 182.         &quot;&quot;&quot;</font>
<font color="green"> 183.         if self._checker(attempts, response, caught_exception):</font>
<font color="red"> 184.             result = self._action(attempts=attempts)</font>
<font color="red"> 185.             logger.debug(&quot;Retry needed, action of: %s&quot;, result)</font>
<font color="red"> 186.             return result</font>
<font color="green"> 187.         logger.debug(&quot;No retry needed.&quot;)</font>
<font color="black"> 188. </font>
<font color="black"> 189. </font>
<font color="green"> 190. class BaseChecker(object):</font>
<font color="black"> 191.     &quot;&quot;&quot;Base class for retry checkers.</font>
<font color="black"> 192. </font>
<font color="black"> 193.     Each class is responsible for checking a single criteria that determines</font>
<font color="black"> 194.     whether or not a retry should not happen.</font>
<font color="black"> 195. </font>
<font color="green"> 196.     &quot;&quot;&quot;</font>
<font color="green"> 197.     def __call__(self, attempt_number, response, caught_exception):</font>
<font color="black"> 198.         &quot;&quot;&quot;Determine if retry criteria matches.</font>
<font color="black"> 199. </font>
<font color="black"> 200.         Note that either ``response`` is not None and ``caught_exception`` is</font>
<font color="black"> 201.         None or ``response`` is None and ``caught_exception`` is not None.</font>
<font color="black"> 202. </font>
<font color="black"> 203.         :type attempt_number: int</font>
<font color="black"> 204.         :param attempt_number: The total number of times we've attempted</font>
<font color="black"> 205.             to send the request.</font>
<font color="black"> 206. </font>
<font color="black"> 207.         :param response: The HTTP response (if one was received).</font>
<font color="black"> 208. </font>
<font color="black"> 209.         :type caught_exception: Exception</font>
<font color="black"> 210.         :param caught_exception: Any exception that was caught while trying to</font>
<font color="black"> 211.             send the HTTP response.</font>
<font color="black"> 212. </font>
<font color="black"> 213.         :return: True, if the retry criteria matches (and therefore a retry</font>
<font color="black"> 214.             should occur.  False if the criteria does not match.</font>
<font color="black"> 215. </font>
<font color="black"> 216.         &quot;&quot;&quot;</font>
<font color="black"> 217.         # The default implementation allows subclasses to not have to check</font>
<font color="black"> 218.         # whether or not response is None or not.</font>
<font color="green"> 219.         if response is not None:</font>
<font color="green"> 220.             return self._check_response(attempt_number, response)</font>
<font color="red"> 221.         elif caught_exception is not None:</font>
<font color="red"> 222.             return self._check_caught_exception(</font>
<font color="red"> 223.                 attempt_number, caught_exception)</font>
<font color="black"> 224.         else:</font>
<font color="red"> 225.             raise ValueError(&quot;Both response and caught_exception are None.&quot;)</font>
<font color="black"> 226. </font>
<font color="green"> 227.     def _check_response(self, attempt_number, response):</font>
<font color="green"> 228.         pass</font>
<font color="black"> 229. </font>
<font color="green"> 230.     def _check_caught_exception(self, attempt_number, caught_exception):</font>
<font color="red"> 231.         pass</font>
<font color="black"> 232. </font>
<font color="black"> 233. </font>
<font color="green"> 234. class MaxAttemptsDecorator(BaseChecker):</font>
<font color="black"> 235.     &quot;&quot;&quot;Allow retries up to a maximum number of attempts.</font>
<font color="black"> 236. </font>
<font color="black"> 237.     This will pass through calls to the decorated retry checker, provided</font>
<font color="black"> 238.     that the number of attempts does not exceed max_attempts.  It will</font>
<font color="black"> 239.     also catch any retryable_exceptions passed in.  Once max_attempts has</font>
<font color="black"> 240.     been exceeded, then False will be returned or the retryable_exceptions</font>
<font color="black"> 241.     that was previously being caught will be raised.</font>
<font color="black"> 242. </font>
<font color="green"> 243.     &quot;&quot;&quot;</font>
<font color="green"> 244.     def __init__(self, checker, max_attempts, retryable_exceptions=None):</font>
<font color="green"> 245.         self._checker = checker</font>
<font color="green"> 246.         self._max_attempts = max_attempts</font>
<font color="green"> 247.         self._retryable_exceptions = retryable_exceptions</font>
<font color="black"> 248. </font>
<font color="green"> 249.     def __call__(self, attempt_number, response, caught_exception):</font>
<font color="green"> 250.         should_retry = self._should_retry(attempt_number, response,</font>
<font color="green"> 251.                                           caught_exception)</font>
<font color="green"> 252.         if should_retry:</font>
<font color="red"> 253.             if attempt_number &gt;= self._max_attempts:</font>
<font color="black"> 254.                 # explicitly set MaxAttemptsReached</font>
<font color="red"> 255.                 if response is not None and 'ResponseMetadata' in response[1]:</font>
<font color="red"> 256.                     response[1]['ResponseMetadata']['MaxAttemptsReached'] = True</font>
<font color="red"> 257.                 logger.debug(&quot;Reached the maximum number of retry &quot;</font>
<font color="red"> 258.                              &quot;attempts: %s&quot;, attempt_number)</font>
<font color="red"> 259.                 return False</font>
<font color="black"> 260.             else:</font>
<font color="red"> 261.                 return should_retry</font>
<font color="black"> 262.         else:</font>
<font color="green"> 263.             return False</font>
<font color="black"> 264. </font>
<font color="green"> 265.     def _should_retry(self, attempt_number, response, caught_exception):</font>
<font color="green"> 266.         if self._retryable_exceptions and \</font>
<font color="green"> 267.                 attempt_number &lt; self._max_attempts:</font>
<font color="green"> 268.             try:</font>
<font color="green"> 269.                 return self._checker(attempt_number, response, caught_exception)</font>
<font color="red"> 270.             except self._retryable_exceptions as e:</font>
<font color="red"> 271.                 logger.debug(&quot;retry needed, retryable exception caught: %s&quot;,</font>
<font color="red"> 272.                              e, exc_info=True)</font>
<font color="red"> 273.                 return True</font>
<font color="black"> 274.         else:</font>
<font color="black"> 275.             # If we've exceeded the max attempts we just let the exception</font>
<font color="black"> 276.             # propogate if one has occurred.</font>
<font color="red"> 277.             return self._checker(attempt_number, response, caught_exception)</font>
<font color="black"> 278. </font>
<font color="black"> 279. </font>
<font color="green"> 280. class HTTPStatusCodeChecker(BaseChecker):</font>
<font color="green"> 281.     def __init__(self, status_code):</font>
<font color="green"> 282.         self._status_code = status_code</font>
<font color="black"> 283. </font>
<font color="green"> 284.     def _check_response(self, attempt_number, response):</font>
<font color="green"> 285.         if response[0].status_code == self._status_code:</font>
<font color="red"> 286.             logger.debug(</font>
<font color="red"> 287.                 &quot;retry needed: retryable HTTP status code received: %s&quot;,</font>
<font color="red"> 288.                 self._status_code)</font>
<font color="red"> 289.             return True</font>
<font color="black"> 290.         else:</font>
<font color="green"> 291.             return False</font>
<font color="black"> 292. </font>
<font color="black"> 293. </font>
<font color="green"> 294. class ServiceErrorCodeChecker(BaseChecker):</font>
<font color="green"> 295.     def __init__(self, status_code, error_code):</font>
<font color="green"> 296.         self._status_code = status_code</font>
<font color="green"> 297.         self._error_code = error_code</font>
<font color="black"> 298. </font>
<font color="green"> 299.     def _check_response(self, attempt_number, response):</font>
<font color="green"> 300.         if response[0].status_code == self._status_code:</font>
<font color="red"> 301.             actual_error_code = response[1].get('Error', {}).get('Code')</font>
<font color="red"> 302.             if actual_error_code == self._error_code:</font>
<font color="red"> 303.                 logger.debug(</font>
<font color="red"> 304.                     &quot;retry needed: matching HTTP status and error code seen: &quot;</font>
<font color="red"> 305.                     &quot;%s, %s&quot;, self._status_code, self._error_code)</font>
<font color="red"> 306.                 return True</font>
<font color="green"> 307.         return False</font>
<font color="black"> 308. </font>
<font color="black"> 309. </font>
<font color="green"> 310. class MultiChecker(BaseChecker):</font>
<font color="green"> 311.     def __init__(self, checkers):</font>
<font color="green"> 312.         self._checkers = checkers</font>
<font color="black"> 313. </font>
<font color="green"> 314.     def __call__(self, attempt_number, response, caught_exception):</font>
<font color="green"> 315.         for checker in self._checkers:</font>
<font color="green"> 316.             checker_response = checker(attempt_number, response,</font>
<font color="green"> 317.                                        caught_exception)</font>
<font color="green"> 318.             if checker_response:</font>
<font color="red"> 319.                 return checker_response</font>
<font color="green"> 320.         return False</font>
<font color="black"> 321. </font>
<font color="black"> 322. </font>
<font color="green"> 323. class CRC32Checker(BaseChecker):</font>
<font color="green"> 324.     def __init__(self, header):</font>
<font color="black"> 325.         # The header where the expected crc32 is located.</font>
<font color="red"> 326.         self._header_name = header</font>
<font color="black"> 327. </font>
<font color="green"> 328.     def _check_response(self, attempt_number, response):</font>
<font color="red"> 329.         http_response = response[0]</font>
<font color="red"> 330.         expected_crc = http_response.headers.get(self._header_name)</font>
<font color="red"> 331.         if expected_crc is None:</font>
<font color="red"> 332.             logger.debug(&quot;crc32 check skipped, the %s header is not &quot;</font>
<font color="red"> 333.                          &quot;in the http response.&quot;, self._header_name)</font>
<font color="black"> 334.         else:</font>
<font color="red"> 335.             actual_crc32 = crc32(response[0].content) &amp; 0xffffffff</font>
<font color="red"> 336.             if not actual_crc32 == int(expected_crc):</font>
<font color="red"> 337.                 logger.debug(</font>
<font color="red"> 338.                     &quot;retry needed: crc32 check failed, expected != actual: &quot;</font>
<font color="red"> 339.                     &quot;%s != %s&quot;, int(expected_crc), actual_crc32)</font>
<font color="red"> 340.                 raise ChecksumError(checksum_type='crc32',</font>
<font color="red"> 341.                                     expected_checksum=int(expected_crc),</font>
<font color="red"> 342.                                     actual_checksum=actual_crc32)</font>
<font color="black"> 343. </font>
<font color="black"> 344. </font>
<font color="green"> 345. class ExceptionRaiser(BaseChecker):</font>
<font color="black"> 346.     &quot;&quot;&quot;Raise any caught exceptions.</font>
<font color="black"> 347. </font>
<font color="black"> 348.     This class will raise any non None ``caught_exception``.</font>
<font color="black"> 349. </font>
<font color="green"> 350.     &quot;&quot;&quot;</font>
<font color="green"> 351.     def _check_caught_exception(self, attempt_number, caught_exception):</font>
<font color="black"> 352.         # This is implementation specific, but this class is useful by</font>
<font color="black"> 353.         # coordinating with the MaxAttemptsDecorator.</font>
<font color="black"> 354.         # The MaxAttemptsDecorator has a list of exceptions it should catch</font>
<font color="black"> 355.         # and retry, but something needs to come along and actually raise the</font>
<font color="black"> 356.         # caught_exception.  That's what this class is being used for.  If</font>
<font color="black"> 357.         # the MaxAttemptsDecorator is not interested in retrying the exception</font>
<font color="black"> 358.         # then this exception just propogates out past the retry code.</font>
<font color="red"> 359.         raise caught_exception</font>
</pre>

