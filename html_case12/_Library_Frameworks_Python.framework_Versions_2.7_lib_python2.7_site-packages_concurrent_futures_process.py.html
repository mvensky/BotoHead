source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/concurrent/futures/process.py</b><br>


file stats: <b>178 lines, 34 executed: 19.1% covered</b>
<pre>
<font color="black">   1. # Copyright 2009 Brian Quinlan. All Rights Reserved.</font>
<font color="black">   2. # Licensed to PSF under a Contributor Agreement.</font>
<font color="black">   3. </font>
<font color="black">   4. &quot;&quot;&quot;Implements ProcessPoolExecutor.</font>
<font color="black">   5. </font>
<font color="black">   6. The follow diagram and text describe the data-flow through the system:</font>
<font color="black">   7. </font>
<font color="black">   8. |======================= In-process =====================|== Out-of-process ==|</font>
<font color="black">   9. </font>
<font color="black">  10. +----------+     +----------+       +--------+     +-----------+    +---------+</font>
<font color="black">  11. |          |  =&gt; | Work Ids |    =&gt; |        |  =&gt; | Call Q    | =&gt; |         |</font>
<font color="black">  12. |          |     +----------+       |        |     +-----------+    |         |</font>
<font color="black">  13. |          |     | ...      |       |        |     | ...       |    |         |</font>
<font color="black">  14. |          |     | 6        |       |        |     | 5, call() |    |         |</font>
<font color="black">  15. |          |     | 7        |       |        |     | ...       |    |         |</font>
<font color="black">  16. | Process  |     | ...      |       | Local  |     +-----------+    | Process |</font>
<font color="black">  17. |  Pool    |     +----------+       | Worker |                      |  #1..n  |</font>
<font color="black">  18. | Executor |                        | Thread |                      |         |</font>
<font color="black">  19. |          |     +----------- +     |        |     +-----------+    |         |</font>
<font color="black">  20. |          | &lt;=&gt; | Work Items | &lt;=&gt; |        | &lt;=  | Result Q  | &lt;= |         |</font>
<font color="black">  21. |          |     +------------+     |        |     +-----------+    |         |</font>
<font color="black">  22. |          |     | 6: call()  |     |        |     | ...       |    |         |</font>
<font color="black">  23. |          |     |    future  |     |        |     | 4, result |    |         |</font>
<font color="black">  24. |          |     | ...        |     |        |     | 3, except |    |         |</font>
<font color="black">  25. +----------+     +------------+     +--------+     +-----------+    +---------+</font>
<font color="black">  26. </font>
<font color="black">  27. Executor.submit() called:</font>
<font color="black">  28. - creates a uniquely numbered _WorkItem and adds it to the &quot;Work Items&quot; dict</font>
<font color="black">  29. - adds the id of the _WorkItem to the &quot;Work Ids&quot; queue</font>
<font color="black">  30. </font>
<font color="black">  31. Local worker thread:</font>
<font color="black">  32. - reads work ids from the &quot;Work Ids&quot; queue and looks up the corresponding</font>
<font color="black">  33.   WorkItem from the &quot;Work Items&quot; dict: if the work item has been cancelled then</font>
<font color="black">  34.   it is simply removed from the dict, otherwise it is repackaged as a</font>
<font color="black">  35.   _CallItem and put in the &quot;Call Q&quot;. New _CallItems are put in the &quot;Call Q&quot;</font>
<font color="black">  36.   until &quot;Call Q&quot; is full. NOTE: the size of the &quot;Call Q&quot; is kept small because</font>
<font color="black">  37.   calls placed in the &quot;Call Q&quot; can no longer be cancelled with Future.cancel().</font>
<font color="black">  38. - reads _ResultItems from &quot;Result Q&quot;, updates the future stored in the</font>
<font color="black">  39.   &quot;Work Items&quot; dict and deletes the dict entry</font>
<font color="black">  40. </font>
<font color="black">  41. Process #1..n:</font>
<font color="black">  42. - reads _CallItems from &quot;Call Q&quot;, executes the calls, and puts the resulting</font>
<font color="black">  43.   _ResultItems in &quot;Request Q&quot;</font>
<font color="green">  44. &quot;&quot;&quot;</font>
<font color="black">  45. </font>
<font color="green">  46. import atexit</font>
<font color="green">  47. from concurrent.futures import _base</font>
<font color="green">  48. import Queue as queue</font>
<font color="green">  49. import multiprocessing</font>
<font color="green">  50. import threading</font>
<font color="green">  51. import weakref</font>
<font color="green">  52. import sys</font>
<font color="black">  53. </font>
<font color="green">  54. __author__ = 'Brian Quinlan (brian@sweetapp.com)'</font>
<font color="black">  55. </font>
<font color="black">  56. # Workers are created as daemon threads and processes. This is done to allow the</font>
<font color="black">  57. # interpreter to exit when there are still idle processes in a</font>
<font color="black">  58. # ProcessPoolExecutor's process pool (i.e. shutdown() was not called). However,</font>
<font color="black">  59. # allowing workers to die with the interpreter has two undesirable properties:</font>
<font color="black">  60. #   - The workers would still be running during interpretor shutdown,</font>
<font color="black">  61. #     meaning that they would fail in unpredictable ways.</font>
<font color="black">  62. #   - The workers could be killed while evaluating a work item, which could</font>
<font color="black">  63. #     be bad if the callable being evaluated has external side-effects e.g.</font>
<font color="black">  64. #     writing to a file.</font>
<font color="black">  65. #</font>
<font color="black">  66. # To work around this problem, an exit handler is installed which tells the</font>
<font color="black">  67. # workers to exit when their work queues are empty and then waits until the</font>
<font color="black">  68. # threads/processes finish.</font>
<font color="black">  69. </font>
<font color="green">  70. _threads_queues = weakref.WeakKeyDictionary()</font>
<font color="green">  71. _shutdown = False</font>
<font color="black">  72. </font>
<font color="green">  73. def _python_exit():</font>
<font color="black">  74.     global _shutdown</font>
<font color="red">  75.     _shutdown = True</font>
<font color="red">  76.     items = list(_threads_queues.items()) if _threads_queues else ()</font>
<font color="red">  77.     for t, q in items:</font>
<font color="red">  78.         q.put(None)</font>
<font color="red">  79.     for t, q in items:</font>
<font color="red">  80.         t.join(sys.maxint)</font>
<font color="black">  81. </font>
<font color="black">  82. # Controls how many more calls than processes will be queued in the call queue.</font>
<font color="black">  83. # A smaller number will mean that processes spend more time idle waiting for</font>
<font color="black">  84. # work while a larger number will make Future.cancel() succeed less frequently</font>
<font color="black">  85. # (Futures in the call queue cannot be cancelled).</font>
<font color="green">  86. EXTRA_QUEUED_CALLS = 1</font>
<font color="black">  87. </font>
<font color="green">  88. class _WorkItem(object):</font>
<font color="green">  89.     def __init__(self, future, fn, args, kwargs):</font>
<font color="red">  90.         self.future = future</font>
<font color="red">  91.         self.fn = fn</font>
<font color="red">  92.         self.args = args</font>
<font color="red">  93.         self.kwargs = kwargs</font>
<font color="black">  94. </font>
<font color="green">  95. class _ResultItem(object):</font>
<font color="green">  96.     def __init__(self, work_id, exception=None, result=None):</font>
<font color="red">  97.         self.work_id = work_id</font>
<font color="red">  98.         self.exception = exception</font>
<font color="red">  99.         self.result = result</font>
<font color="black"> 100. </font>
<font color="green"> 101. class _CallItem(object):</font>
<font color="green"> 102.     def __init__(self, work_id, fn, args, kwargs):</font>
<font color="red"> 103.         self.work_id = work_id</font>
<font color="red"> 104.         self.fn = fn</font>
<font color="red"> 105.         self.args = args</font>
<font color="red"> 106.         self.kwargs = kwargs</font>
<font color="black"> 107. </font>
<font color="green"> 108. def _process_worker(call_queue, result_queue):</font>
<font color="black"> 109.     &quot;&quot;&quot;Evaluates calls from call_queue and places the results in result_queue.</font>
<font color="black"> 110. </font>
<font color="black"> 111.     This worker is run in a separate process.</font>
<font color="black"> 112. </font>
<font color="black"> 113.     Args:</font>
<font color="black"> 114.         call_queue: A multiprocessing.Queue of _CallItems that will be read and</font>
<font color="black"> 115.             evaluated by the worker.</font>
<font color="black"> 116.         result_queue: A multiprocessing.Queue of _ResultItems that will written</font>
<font color="black"> 117.             to by the worker.</font>
<font color="black"> 118.         shutdown: A multiprocessing.Event that will be set as a signal to the</font>
<font color="black"> 119.             worker that it should exit when call_queue is empty.</font>
<font color="black"> 120.     &quot;&quot;&quot;</font>
<font color="red"> 121.     while True:</font>
<font color="red"> 122.         call_item = call_queue.get(block=True)</font>
<font color="red"> 123.         if call_item is None:</font>
<font color="black"> 124.             # Wake up queue management thread</font>
<font color="red"> 125.             result_queue.put(None)</font>
<font color="red"> 126.             return</font>
<font color="red"> 127.         try:</font>
<font color="red"> 128.             r = call_item.fn(*call_item.args, **call_item.kwargs)</font>
<font color="red"> 129.         except BaseException:</font>
<font color="red"> 130.             e = sys.exc_info()[1]</font>
<font color="red"> 131.             result_queue.put(_ResultItem(call_item.work_id,</font>
<font color="red"> 132.                                          exception=e))</font>
<font color="black"> 133.         else:</font>
<font color="red"> 134.             result_queue.put(_ResultItem(call_item.work_id,</font>
<font color="red"> 135.                                          result=r))</font>
<font color="black"> 136. </font>
<font color="green"> 137. def _add_call_item_to_queue(pending_work_items,</font>
<font color="black"> 138.                             work_ids,</font>
<font color="black"> 139.                             call_queue):</font>
<font color="black"> 140.     &quot;&quot;&quot;Fills call_queue with _WorkItems from pending_work_items.</font>
<font color="black"> 141. </font>
<font color="black"> 142.     This function never blocks.</font>
<font color="black"> 143. </font>
<font color="black"> 144.     Args:</font>
<font color="black"> 145.         pending_work_items: A dict mapping work ids to _WorkItems e.g.</font>
<font color="black"> 146.             {5: &lt;_WorkItem...&gt;, 6: &lt;_WorkItem...&gt;, ...}</font>
<font color="black"> 147.         work_ids: A queue.Queue of work ids e.g. Queue([5, 6, ...]). Work ids</font>
<font color="black"> 148.             are consumed and the corresponding _WorkItems from</font>
<font color="black"> 149.             pending_work_items are transformed into _CallItems and put in</font>
<font color="black"> 150.             call_queue.</font>
<font color="black"> 151.         call_queue: A multiprocessing.Queue that will be filled with _CallItems</font>
<font color="black"> 152.             derived from _WorkItems.</font>
<font color="black"> 153.     &quot;&quot;&quot;</font>
<font color="red"> 154.     while True:</font>
<font color="red"> 155.         if call_queue.full():</font>
<font color="red"> 156.             return</font>
<font color="red"> 157.         try:</font>
<font color="red"> 158.             work_id = work_ids.get(block=False)</font>
<font color="red"> 159.         except queue.Empty:</font>
<font color="red"> 160.             return</font>
<font color="black"> 161.         else:</font>
<font color="red"> 162.             work_item = pending_work_items[work_id]</font>
<font color="black"> 163. </font>
<font color="red"> 164.             if work_item.future.set_running_or_notify_cancel():</font>
<font color="red"> 165.                 call_queue.put(_CallItem(work_id,</font>
<font color="red"> 166.                                          work_item.fn,</font>
<font color="red"> 167.                                          work_item.args,</font>
<font color="red"> 168.                                          work_item.kwargs),</font>
<font color="red"> 169.                                block=True)</font>
<font color="black"> 170.             else:</font>
<font color="red"> 171.                 del pending_work_items[work_id]</font>
<font color="red"> 172.                 continue</font>
<font color="black"> 173. </font>
<font color="green"> 174. def _queue_management_worker(executor_reference,</font>
<font color="black"> 175.                              processes,</font>
<font color="black"> 176.                              pending_work_items,</font>
<font color="black"> 177.                              work_ids_queue,</font>
<font color="black"> 178.                              call_queue,</font>
<font color="black"> 179.                              result_queue):</font>
<font color="black"> 180.     &quot;&quot;&quot;Manages the communication between this process and the worker processes.</font>
<font color="black"> 181. </font>
<font color="black"> 182.     This function is run in a local thread.</font>
<font color="black"> 183. </font>
<font color="black"> 184.     Args:</font>
<font color="black"> 185.         executor_reference: A weakref.ref to the ProcessPoolExecutor that owns</font>
<font color="black"> 186.             this thread. Used to determine if the ProcessPoolExecutor has been</font>
<font color="black"> 187.             garbage collected and that this function can exit.</font>
<font color="black"> 188.         process: A list of the multiprocessing.Process instances used as</font>
<font color="black"> 189.             workers.</font>
<font color="black"> 190.         pending_work_items: A dict mapping work ids to _WorkItems e.g.</font>
<font color="black"> 191.             {5: &lt;_WorkItem...&gt;, 6: &lt;_WorkItem...&gt;, ...}</font>
<font color="black"> 192.         work_ids_queue: A queue.Queue of work ids e.g. Queue([5, 6, ...]).</font>
<font color="black"> 193.         call_queue: A multiprocessing.Queue that will be filled with _CallItems</font>
<font color="black"> 194.             derived from _WorkItems for processing by the process workers.</font>
<font color="black"> 195.         result_queue: A multiprocessing.Queue of _ResultItems generated by the</font>
<font color="black"> 196.             process workers.</font>
<font color="black"> 197.     &quot;&quot;&quot;</font>
<font color="red"> 198.     nb_shutdown_processes = [0]</font>
<font color="red"> 199.     def shutdown_one_process():</font>
<font color="black"> 200.         &quot;&quot;&quot;Tell a worker to terminate, which will in turn wake us again&quot;&quot;&quot;</font>
<font color="red"> 201.         call_queue.put(None)</font>
<font color="red"> 202.         nb_shutdown_processes[0] += 1</font>
<font color="red"> 203.     while True:</font>
<font color="red"> 204.         _add_call_item_to_queue(pending_work_items,</font>
<font color="red"> 205.                                 work_ids_queue,</font>
<font color="red"> 206.                                 call_queue)</font>
<font color="black"> 207. </font>
<font color="red"> 208.         result_item = result_queue.get(block=True)</font>
<font color="red"> 209.         if result_item is not None:</font>
<font color="red"> 210.             work_item = pending_work_items[result_item.work_id]</font>
<font color="red"> 211.             del pending_work_items[result_item.work_id]</font>
<font color="black"> 212. </font>
<font color="red"> 213.             if result_item.exception:</font>
<font color="red"> 214.                 work_item.future.set_exception(result_item.exception)</font>
<font color="black"> 215.             else:</font>
<font color="red"> 216.                 work_item.future.set_result(result_item.result)</font>
<font color="black"> 217.             # Delete references to object. See issue16284</font>
<font color="red"> 218.             del work_item</font>
<font color="black"> 219.         # Check whether we should start shutting down.</font>
<font color="red"> 220.         executor = executor_reference()</font>
<font color="black"> 221.         # No more work items can be added if:</font>
<font color="black"> 222.         #   - The interpreter is shutting down OR</font>
<font color="black"> 223.         #   - The executor that owns this worker has been collected OR</font>
<font color="black"> 224.         #   - The executor that owns this worker has been shutdown.</font>
<font color="red"> 225.         if _shutdown or executor is None or executor._shutdown_thread:</font>
<font color="black"> 226.             # Since no new work items can be added, it is safe to shutdown</font>
<font color="black"> 227.             # this thread if there are no pending work items.</font>
<font color="red"> 228.             if not pending_work_items:</font>
<font color="red"> 229.                 while nb_shutdown_processes[0] &lt; len(processes):</font>
<font color="red"> 230.                     shutdown_one_process()</font>
<font color="black"> 231.                 # If .join() is not called on the created processes then</font>
<font color="black"> 232.                 # some multiprocessing.Queue methods may deadlock on Mac OS</font>
<font color="black"> 233.                 # X.</font>
<font color="red"> 234.                 for p in processes:</font>
<font color="red"> 235.                     p.join()</font>
<font color="red"> 236.                 call_queue.close()</font>
<font color="red"> 237.                 return</font>
<font color="red"> 238.         del executor</font>
<font color="black"> 239. </font>
<font color="green"> 240. _system_limits_checked = False</font>
<font color="green"> 241. _system_limited = None</font>
<font color="green"> 242. def _check_system_limits():</font>
<font color="black"> 243.     global _system_limits_checked, _system_limited</font>
<font color="red"> 244.     if _system_limits_checked:</font>
<font color="red"> 245.         if _system_limited:</font>
<font color="red"> 246.             raise NotImplementedError(_system_limited)</font>
<font color="red"> 247.     _system_limits_checked = True</font>
<font color="red"> 248.     try:</font>
<font color="red"> 249.         import os</font>
<font color="red"> 250.         nsems_max = os.sysconf(&quot;SC_SEM_NSEMS_MAX&quot;)</font>
<font color="red"> 251.     except (AttributeError, ValueError):</font>
<font color="black"> 252.         # sysconf not available or setting not available</font>
<font color="red"> 253.         return</font>
<font color="red"> 254.     if nsems_max == -1:</font>
<font color="black"> 255.         # indetermine limit, assume that limit is determined</font>
<font color="black"> 256.         # by available memory only</font>
<font color="red"> 257.         return</font>
<font color="red"> 258.     if nsems_max &gt;= 256:</font>
<font color="black"> 259.         # minimum number of semaphores available</font>
<font color="black"> 260.         # according to POSIX</font>
<font color="red"> 261.         return</font>
<font color="red"> 262.     _system_limited = &quot;system provides too few semaphores (%d available, 256 necessary)&quot; % nsems_max</font>
<font color="red"> 263.     raise NotImplementedError(_system_limited)</font>
<font color="black"> 264. </font>
<font color="green"> 265. class ProcessPoolExecutor(_base.Executor):</font>
<font color="green"> 266.     def __init__(self, max_workers=None):</font>
<font color="black"> 267.         &quot;&quot;&quot;Initializes a new ProcessPoolExecutor instance.</font>
<font color="black"> 268. </font>
<font color="black"> 269.         Args:</font>
<font color="black"> 270.             max_workers: The maximum number of processes that can be used to</font>
<font color="black"> 271.                 execute the given calls. If None or not given then as many</font>
<font color="black"> 272.                 worker processes will be created as the machine has processors.</font>
<font color="black"> 273.         &quot;&quot;&quot;</font>
<font color="red"> 274.         _check_system_limits()</font>
<font color="black"> 275. </font>
<font color="red"> 276.         if max_workers is None:</font>
<font color="red"> 277.             self._max_workers = multiprocessing.cpu_count()</font>
<font color="black"> 278.         else:</font>
<font color="red"> 279.             self._max_workers = max_workers</font>
<font color="black"> 280. </font>
<font color="black"> 281.         # Make the call queue slightly larger than the number of processes to</font>
<font color="black"> 282.         # prevent the worker processes from idling. But don't make it too big</font>
<font color="black"> 283.         # because futures in the call queue cannot be cancelled.</font>
<font color="red"> 284.         self._call_queue = multiprocessing.Queue(self._max_workers +</font>
<font color="red"> 285.                                                  EXTRA_QUEUED_CALLS)</font>
<font color="red"> 286.         self._result_queue = multiprocessing.Queue()</font>
<font color="red"> 287.         self._work_ids = queue.Queue()</font>
<font color="red"> 288.         self._queue_management_thread = None</font>
<font color="red"> 289.         self._processes = set()</font>
<font color="black"> 290. </font>
<font color="black"> 291.         # Shutdown is a two-step process.</font>
<font color="red"> 292.         self._shutdown_thread = False</font>
<font color="red"> 293.         self._shutdown_lock = threading.Lock()</font>
<font color="red"> 294.         self._queue_count = 0</font>
<font color="red"> 295.         self._pending_work_items = {}</font>
<font color="black"> 296. </font>
<font color="green"> 297.     def _start_queue_management_thread(self):</font>
<font color="black"> 298.         # When the executor gets lost, the weakref callback will wake up</font>
<font color="black"> 299.         # the queue management thread.</font>
<font color="red"> 300.         def weakref_cb(_, q=self._result_queue):</font>
<font color="red"> 301.             q.put(None)</font>
<font color="red"> 302.         if self._queue_management_thread is None:</font>
<font color="red"> 303.             self._queue_management_thread = threading.Thread(</font>
<font color="red"> 304.                     target=_queue_management_worker,</font>
<font color="red"> 305.                     args=(weakref.ref(self, weakref_cb),</font>
<font color="red"> 306.                           self._processes,</font>
<font color="red"> 307.                           self._pending_work_items,</font>
<font color="red"> 308.                           self._work_ids,</font>
<font color="red"> 309.                           self._call_queue,</font>
<font color="red"> 310.                           self._result_queue))</font>
<font color="red"> 311.             self._queue_management_thread.daemon = True</font>
<font color="red"> 312.             self._queue_management_thread.start()</font>
<font color="red"> 313.             _threads_queues[self._queue_management_thread] = self._result_queue</font>
<font color="black"> 314. </font>
<font color="green"> 315.     def _adjust_process_count(self):</font>
<font color="red"> 316.         for _ in range(len(self._processes), self._max_workers):</font>
<font color="red"> 317.             p = multiprocessing.Process(</font>
<font color="red"> 318.                     target=_process_worker,</font>
<font color="red"> 319.                     args=(self._call_queue,</font>
<font color="red"> 320.                           self._result_queue))</font>
<font color="red"> 321.             p.start()</font>
<font color="red"> 322.             self._processes.add(p)</font>
<font color="black"> 323. </font>
<font color="green"> 324.     def submit(self, fn, *args, **kwargs):</font>
<font color="red"> 325.         with self._shutdown_lock:</font>
<font color="red"> 326.             if self._shutdown_thread:</font>
<font color="red"> 327.                 raise RuntimeError('cannot schedule new futures after shutdown')</font>
<font color="black"> 328. </font>
<font color="red"> 329.             f = _base.Future()</font>
<font color="red"> 330.             w = _WorkItem(f, fn, args, kwargs)</font>
<font color="black"> 331. </font>
<font color="red"> 332.             self._pending_work_items[self._queue_count] = w</font>
<font color="red"> 333.             self._work_ids.put(self._queue_count)</font>
<font color="red"> 334.             self._queue_count += 1</font>
<font color="black"> 335.             # Wake up queue management thread</font>
<font color="red"> 336.             self._result_queue.put(None)</font>
<font color="black"> 337. </font>
<font color="red"> 338.             self._start_queue_management_thread()</font>
<font color="red"> 339.             self._adjust_process_count()</font>
<font color="red"> 340.             return f</font>
<font color="green"> 341.     submit.__doc__ = _base.Executor.submit.__doc__</font>
<font color="black"> 342. </font>
<font color="green"> 343.     def shutdown(self, wait=True):</font>
<font color="red"> 344.         with self._shutdown_lock:</font>
<font color="red"> 345.             self._shutdown_thread = True</font>
<font color="red"> 346.         if self._queue_management_thread:</font>
<font color="black"> 347.             # Wake up queue management thread</font>
<font color="red"> 348.             self._result_queue.put(None)</font>
<font color="red"> 349.             if wait:</font>
<font color="red"> 350.                 self._queue_management_thread.join(sys.maxint)</font>
<font color="black"> 351.         # To reduce the risk of openning too many files, remove references to</font>
<font color="black"> 352.         # objects that use file descriptors.</font>
<font color="red"> 353.         self._queue_management_thread = None</font>
<font color="red"> 354.         self._call_queue = None</font>
<font color="red"> 355.         self._result_queue = None</font>
<font color="red"> 356.         self._processes = None</font>
<font color="green"> 357.     shutdown.__doc__ = _base.Executor.shutdown.__doc__</font>
<font color="black"> 358. </font>
<font color="green"> 359. atexit.register(_python_exit)</font>
</pre>

