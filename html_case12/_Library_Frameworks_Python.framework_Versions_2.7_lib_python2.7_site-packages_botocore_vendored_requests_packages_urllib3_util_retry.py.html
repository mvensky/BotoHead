source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/packages/urllib3/util/retry.py</b><br>


file stats: <b>114 lines, 37 executed: 32.5% covered</b>
<pre>
<font color="green">   1. import time</font>
<font color="green">   2. import logging</font>
<font color="black">   3. </font>
<font color="green">   4. from ..exceptions import (</font>
<font color="black">   5.     ConnectTimeoutError,</font>
<font color="black">   6.     MaxRetryError,</font>
<font color="black">   7.     ProtocolError,</font>
<font color="black">   8.     ReadTimeoutError,</font>
<font color="black">   9.     ResponseError,</font>
<font color="black">  10. )</font>
<font color="green">  11. from ..packages import six</font>
<font color="black">  12. </font>
<font color="black">  13. </font>
<font color="green">  14. log = logging.getLogger(__name__)</font>
<font color="black">  15. </font>
<font color="black">  16. </font>
<font color="green">  17. class Retry(object):</font>
<font color="black">  18.     &quot;&quot;&quot; Retry configuration.</font>
<font color="black">  19. </font>
<font color="black">  20.     Each retry attempt will create a new Retry object with updated values, so</font>
<font color="black">  21.     they can be safely reused.</font>
<font color="black">  22. </font>
<font color="black">  23.     Retries can be defined as a default for a pool::</font>
<font color="black">  24. </font>
<font color="black">  25.         retries = Retry(connect=5, read=2, redirect=5)</font>
<font color="black">  26.         http = PoolManager(retries=retries)</font>
<font color="black">  27.         response = http.request('GET', 'http://example.com/')</font>
<font color="black">  28. </font>
<font color="black">  29.     Or per-request (which overrides the default for the pool)::</font>
<font color="black">  30. </font>
<font color="black">  31.         response = http.request('GET', 'http://example.com/', retries=Retry(10))</font>
<font color="black">  32. </font>
<font color="black">  33.     Retries can be disabled by passing ``False``::</font>
<font color="black">  34. </font>
<font color="black">  35.         response = http.request('GET', 'http://example.com/', retries=False)</font>
<font color="black">  36. </font>
<font color="black">  37.     Errors will be wrapped in :class:`~urllib3.exceptions.MaxRetryError` unless</font>
<font color="black">  38.     retries are disabled, in which case the causing exception will be raised.</font>
<font color="black">  39. </font>
<font color="black">  40.     :param int total:</font>
<font color="black">  41.         Total number of retries to allow. Takes precedence over other counts.</font>
<font color="black">  42. </font>
<font color="black">  43.         Set to ``None`` to remove this constraint and fall back on other</font>
<font color="black">  44.         counts. It's a good idea to set this to some sensibly-high value to</font>
<font color="black">  45.         account for unexpected edge cases and avoid infinite retry loops.</font>
<font color="black">  46. </font>
<font color="black">  47.         Set to ``0`` to fail on the first retry.</font>
<font color="black">  48. </font>
<font color="black">  49.         Set to ``False`` to disable and imply ``raise_on_redirect=False``.</font>
<font color="black">  50. </font>
<font color="black">  51.     :param int connect:</font>
<font color="black">  52.         How many connection-related errors to retry on.</font>
<font color="black">  53. </font>
<font color="black">  54.         These are errors raised before the request is sent to the remote server,</font>
<font color="black">  55.         which we assume has not triggered the server to process the request.</font>
<font color="black">  56. </font>
<font color="black">  57.         Set to ``0`` to fail on the first retry of this type.</font>
<font color="black">  58. </font>
<font color="black">  59.     :param int read:</font>
<font color="black">  60.         How many times to retry on read errors.</font>
<font color="black">  61. </font>
<font color="black">  62.         These errors are raised after the request was sent to the server, so the</font>
<font color="black">  63.         request may have side-effects.</font>
<font color="black">  64. </font>
<font color="black">  65.         Set to ``0`` to fail on the first retry of this type.</font>
<font color="black">  66. </font>
<font color="black">  67.     :param int redirect:</font>
<font color="black">  68.         How many redirects to perform. Limit this to avoid infinite redirect</font>
<font color="black">  69.         loops.</font>
<font color="black">  70. </font>
<font color="black">  71.         A redirect is a HTTP response with a status code 301, 302, 303, 307 or</font>
<font color="black">  72.         308.</font>
<font color="black">  73. </font>
<font color="black">  74.         Set to ``0`` to fail on the first retry of this type.</font>
<font color="black">  75. </font>
<font color="black">  76.         Set to ``False`` to disable and imply ``raise_on_redirect=False``.</font>
<font color="black">  77. </font>
<font color="black">  78.     :param iterable method_whitelist:</font>
<font color="black">  79.         Set of uppercased HTTP method verbs that we should retry on.</font>
<font color="black">  80. </font>
<font color="black">  81.         By default, we only retry on methods which are considered to be</font>
<font color="black">  82.         indempotent (multiple requests with the same parameters end with the</font>
<font color="black">  83.         same state). See :attr:`Retry.DEFAULT_METHOD_WHITELIST`.</font>
<font color="black">  84. </font>
<font color="black">  85.     :param iterable status_forcelist:</font>
<font color="black">  86.         A set of HTTP status codes that we should force a retry on.</font>
<font color="black">  87. </font>
<font color="black">  88.         By default, this is disabled with ``None``.</font>
<font color="black">  89. </font>
<font color="black">  90.     :param float backoff_factor:</font>
<font color="black">  91.         A backoff factor to apply between attempts. urllib3 will sleep for::</font>
<font color="black">  92. </font>
<font color="black">  93.             {backoff factor} * (2 ^ ({number of total retries} - 1))</font>
<font color="black">  94. </font>
<font color="black">  95.         seconds. If the backoff_factor is 0.1, then :func:`.sleep` will sleep</font>
<font color="black">  96.         for [0.1s, 0.2s, 0.4s, ...] between retries. It will never be longer</font>
<font color="black">  97.         than :attr:`Retry.MAX_BACKOFF`.</font>
<font color="black">  98. </font>
<font color="black">  99.         By default, backoff is disabled (set to 0).</font>
<font color="black"> 100. </font>
<font color="black"> 101.     :param bool raise_on_redirect: Whether, if the number of redirects is</font>
<font color="black"> 102.         exhausted, to raise a MaxRetryError, or to return a response with a</font>
<font color="black"> 103.         response code in the 3xx range.</font>
<font color="green"> 104.     &quot;&quot;&quot;</font>
<font color="black"> 105. </font>
<font color="green"> 106.     DEFAULT_METHOD_WHITELIST = frozenset([</font>
<font color="green"> 107.         'HEAD', 'GET', 'PUT', 'DELETE', 'OPTIONS', 'TRACE'])</font>
<font color="black"> 108. </font>
<font color="black"> 109.     #: Maximum backoff time.</font>
<font color="green"> 110.     BACKOFF_MAX = 120</font>
<font color="black"> 111. </font>
<font color="green"> 112.     def __init__(self, total=10, connect=None, read=None, redirect=None,</font>
<font color="green"> 113.                  method_whitelist=DEFAULT_METHOD_WHITELIST, status_forcelist=None,</font>
<font color="green"> 114.                  backoff_factor=0, raise_on_redirect=True, _observed_errors=0):</font>
<font color="black"> 115. </font>
<font color="green"> 116.         self.total = total</font>
<font color="green"> 117.         self.connect = connect</font>
<font color="green"> 118.         self.read = read</font>
<font color="black"> 119. </font>
<font color="green"> 120.         if redirect is False or total is False:</font>
<font color="red"> 121.             redirect = 0</font>
<font color="red"> 122.             raise_on_redirect = False</font>
<font color="black"> 123. </font>
<font color="green"> 124.         self.redirect = redirect</font>
<font color="green"> 125.         self.status_forcelist = status_forcelist or set()</font>
<font color="green"> 126.         self.method_whitelist = method_whitelist</font>
<font color="green"> 127.         self.backoff_factor = backoff_factor</font>
<font color="green"> 128.         self.raise_on_redirect = raise_on_redirect</font>
<font color="green"> 129.         self._observed_errors = _observed_errors # TODO: use .history instead?</font>
<font color="black"> 130. </font>
<font color="green"> 131.     def new(self, **kw):</font>
<font color="red"> 132.         params = dict(</font>
<font color="red"> 133.             total=self.total,</font>
<font color="red"> 134.             connect=self.connect, read=self.read, redirect=self.redirect,</font>
<font color="red"> 135.             method_whitelist=self.method_whitelist,</font>
<font color="red"> 136.             status_forcelist=self.status_forcelist,</font>
<font color="red"> 137.             backoff_factor=self.backoff_factor,</font>
<font color="red"> 138.             raise_on_redirect=self.raise_on_redirect,</font>
<font color="red"> 139.             _observed_errors=self._observed_errors,</font>
<font color="black"> 140.         )</font>
<font color="red"> 141.         params.update(kw)</font>
<font color="red"> 142.         return type(self)(**params)</font>
<font color="black"> 143. </font>
<font color="green"> 144.     @classmethod</font>
<font color="green"> 145.     def from_int(cls, retries, redirect=True, default=None):</font>
<font color="black"> 146.         &quot;&quot;&quot; Backwards-compatibility for the old retries format.&quot;&quot;&quot;</font>
<font color="red"> 147.         if retries is None:</font>
<font color="red"> 148.             retries = default if default is not None else cls.DEFAULT</font>
<font color="black"> 149. </font>
<font color="red"> 150.         if isinstance(retries, Retry):</font>
<font color="red"> 151.             return retries</font>
<font color="black"> 152. </font>
<font color="red"> 153.         redirect = bool(redirect) and None</font>
<font color="red"> 154.         new_retries = cls(retries, redirect=redirect)</font>
<font color="red"> 155.         log.debug(&quot;Converted retries value: %r -&gt; %r&quot; % (retries, new_retries))</font>
<font color="red"> 156.         return new_retries</font>
<font color="black"> 157. </font>
<font color="green"> 158.     def get_backoff_time(self):</font>
<font color="black"> 159.         &quot;&quot;&quot; Formula for computing the current backoff</font>
<font color="black"> 160. </font>
<font color="black"> 161.         :rtype: float</font>
<font color="black"> 162.         &quot;&quot;&quot;</font>
<font color="red"> 163.         if self._observed_errors &lt;= 1:</font>
<font color="red"> 164.             return 0</font>
<font color="black"> 165. </font>
<font color="red"> 166.         backoff_value = self.backoff_factor * (2 ** (self._observed_errors - 1))</font>
<font color="red"> 167.         return min(self.BACKOFF_MAX, backoff_value)</font>
<font color="black"> 168. </font>
<font color="green"> 169.     def sleep(self):</font>
<font color="black"> 170.         &quot;&quot;&quot; Sleep between retry attempts using an exponential backoff.</font>
<font color="black"> 171. </font>
<font color="black"> 172.         By default, the backoff factor is 0 and this method will return</font>
<font color="black"> 173.         immediately.</font>
<font color="black"> 174.         &quot;&quot;&quot;</font>
<font color="red"> 175.         backoff = self.get_backoff_time()</font>
<font color="red"> 176.         if backoff &lt;= 0:</font>
<font color="red"> 177.             return</font>
<font color="red"> 178.         time.sleep(backoff)</font>
<font color="black"> 179. </font>
<font color="green"> 180.     def _is_connection_error(self, err):</font>
<font color="black"> 181.         &quot;&quot;&quot; Errors when we're fairly sure that the server did not receive the</font>
<font color="black"> 182.         request, so it should be safe to retry.</font>
<font color="black"> 183.         &quot;&quot;&quot;</font>
<font color="red"> 184.         return isinstance(err, ConnectTimeoutError)</font>
<font color="black"> 185. </font>
<font color="green"> 186.     def _is_read_error(self, err):</font>
<font color="black"> 187.         &quot;&quot;&quot; Errors that occur after the request has been started, so we should</font>
<font color="black"> 188.         assume that the server began processing it.</font>
<font color="black"> 189.         &quot;&quot;&quot;</font>
<font color="red"> 190.         return isinstance(err, (ReadTimeoutError, ProtocolError))</font>
<font color="black"> 191. </font>
<font color="green"> 192.     def is_forced_retry(self, method, status_code):</font>
<font color="black"> 193.         &quot;&quot;&quot; Is this method/status code retryable? (Based on method/codes whitelists)</font>
<font color="black"> 194.         &quot;&quot;&quot;</font>
<font color="green"> 195.         if self.method_whitelist and method.upper() not in self.method_whitelist:</font>
<font color="red"> 196.             return False</font>
<font color="black"> 197. </font>
<font color="green"> 198.         return self.status_forcelist and status_code in self.status_forcelist</font>
<font color="black"> 199. </font>
<font color="green"> 200.     def is_exhausted(self):</font>
<font color="black"> 201.         &quot;&quot;&quot; Are we out of retries? &quot;&quot;&quot;</font>
<font color="red"> 202.         retry_counts = (self.total, self.connect, self.read, self.redirect)</font>
<font color="red"> 203.         retry_counts = list(filter(None, retry_counts))</font>
<font color="red"> 204.         if not retry_counts:</font>
<font color="red"> 205.             return False</font>
<font color="black"> 206. </font>
<font color="red"> 207.         return min(retry_counts) &lt; 0</font>
<font color="black"> 208. </font>
<font color="green"> 209.     def increment(self, method=None, url=None, response=None, error=None, _pool=None, _stacktrace=None):</font>
<font color="black"> 210.         &quot;&quot;&quot; Return a new Retry object with incremented retry counters.</font>
<font color="black"> 211. </font>
<font color="black"> 212.         :param response: A response object, or None, if the server did not</font>
<font color="black"> 213.             return a response.</font>
<font color="black"> 214.         :type response: :class:`~urllib3.response.HTTPResponse`</font>
<font color="black"> 215.         :param Exception error: An error encountered during the request, or</font>
<font color="black"> 216.             None if the response was received successfully.</font>
<font color="black"> 217. </font>
<font color="black"> 218.         :return: A new ``Retry`` object.</font>
<font color="black"> 219.         &quot;&quot;&quot;</font>
<font color="red"> 220.         if self.total is False and error:</font>
<font color="black"> 221.             # Disabled, indicate to re-raise the error.</font>
<font color="red"> 222.             raise six.reraise(type(error), error, _stacktrace)</font>
<font color="black"> 223. </font>
<font color="red"> 224.         total = self.total</font>
<font color="red"> 225.         if total is not None:</font>
<font color="red"> 226.             total -= 1</font>
<font color="black"> 227. </font>
<font color="red"> 228.         _observed_errors = self._observed_errors</font>
<font color="red"> 229.         connect = self.connect</font>
<font color="red"> 230.         read = self.read</font>
<font color="red"> 231.         redirect = self.redirect</font>
<font color="red"> 232.         cause = 'unknown'</font>
<font color="black"> 233. </font>
<font color="red"> 234.         if error and self._is_connection_error(error):</font>
<font color="black"> 235.             # Connect retry?</font>
<font color="red"> 236.             if connect is False:</font>
<font color="red"> 237.                 raise six.reraise(type(error), error, _stacktrace)</font>
<font color="red"> 238.             elif connect is not None:</font>
<font color="red"> 239.                 connect -= 1</font>
<font color="red"> 240.             _observed_errors += 1</font>
<font color="black"> 241. </font>
<font color="red"> 242.         elif error and self._is_read_error(error):</font>
<font color="black"> 243.             # Read retry?</font>
<font color="red"> 244.             if read is False:</font>
<font color="red"> 245.                 raise six.reraise(type(error), error, _stacktrace)</font>
<font color="red"> 246.             elif read is not None:</font>
<font color="red"> 247.                 read -= 1</font>
<font color="red"> 248.             _observed_errors += 1</font>
<font color="black"> 249. </font>
<font color="red"> 250.         elif response and response.get_redirect_location():</font>
<font color="black"> 251.             # Redirect retry?</font>
<font color="red"> 252.             if redirect is not None:</font>
<font color="red"> 253.                 redirect -= 1</font>
<font color="red"> 254.             cause = 'too many redirects'</font>
<font color="black"> 255. </font>
<font color="black"> 256.         else:</font>
<font color="black"> 257.             # Incrementing because of a server error like a 500 in</font>
<font color="black"> 258.             # status_forcelist and a the given method is in the whitelist</font>
<font color="red"> 259.             _observed_errors += 1</font>
<font color="red"> 260.             cause = ResponseError.GENERIC_ERROR</font>
<font color="red"> 261.             if response and response.status:</font>
<font color="red"> 262.                 cause = ResponseError.SPECIFIC_ERROR.format(</font>
<font color="red"> 263.                     status_code=response.status)</font>
<font color="black"> 264. </font>
<font color="red"> 265.         new_retry = self.new(</font>
<font color="red"> 266.             total=total,</font>
<font color="red"> 267.             connect=connect, read=read, redirect=redirect,</font>
<font color="red"> 268.             _observed_errors=_observed_errors)</font>
<font color="black"> 269. </font>
<font color="red"> 270.         if new_retry.is_exhausted():</font>
<font color="red"> 271.             raise MaxRetryError(_pool, url, error or ResponseError(cause))</font>
<font color="black"> 272. </font>
<font color="red"> 273.         log.debug(&quot;Incremented Retry for (url='%s'): %r&quot; % (url, new_retry))</font>
<font color="black"> 274. </font>
<font color="red"> 275.         return new_retry</font>
<font color="black"> 276. </font>
<font color="black"> 277. </font>
<font color="green"> 278.     def __repr__(self):</font>
<font color="red"> 279.         return ('{cls.__name__}(total={self.total}, connect={self.connect}, '</font>
<font color="black"> 280.                 'read={self.read}, redirect={self.redirect})').format(</font>
<font color="red"> 281.                     cls=type(self), self=self)</font>
<font color="black"> 282. </font>
<font color="black"> 283. </font>
<font color="black"> 284. # For backwards compatibility (equivalent to pre-v1.9):</font>
<font color="green"> 285. Retry.DEFAULT = Retry(3)</font>
</pre>

