source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/model.py</b><br>


file stats: <b>326 lines, 214 executed: 65.6% covered</b>
<pre>
<font color="black">   1. # Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="green">  13. &quot;&quot;&quot;Abstractions to interact with service models.&quot;&quot;&quot;</font>
<font color="green">  14. from collections import defaultdict</font>
<font color="black">  15. </font>
<font color="green">  16. from botocore.utils import CachedProperty, instance_cache</font>
<font color="green">  17. from botocore.compat import OrderedDict</font>
<font color="black">  18. </font>
<font color="black">  19. </font>
<font color="green">  20. NOT_SET = object()</font>
<font color="black">  21. </font>
<font color="black">  22. </font>
<font color="green">  23. class NoShapeFoundError(Exception):</font>
<font color="green">  24.     pass</font>
<font color="black">  25. </font>
<font color="black">  26. </font>
<font color="green">  27. class InvalidShapeError(Exception):</font>
<font color="green">  28.     pass</font>
<font color="black">  29. </font>
<font color="black">  30. </font>
<font color="green">  31. class OperationNotFoundError(Exception):</font>
<font color="green">  32.     pass</font>
<font color="black">  33. </font>
<font color="black">  34. </font>
<font color="green">  35. class InvalidShapeReferenceError(Exception):</font>
<font color="green">  36.     pass</font>
<font color="black">  37. </font>
<font color="black">  38. </font>
<font color="green">  39. class UndefinedModelAttributeError(Exception):</font>
<font color="green">  40.     pass</font>
<font color="black">  41. </font>
<font color="black">  42. </font>
<font color="green">  43. class Shape(object):</font>
<font color="green">  44.     &quot;&quot;&quot;Object representing a shape from the service model.&quot;&quot;&quot;</font>
<font color="black">  45.     # To simplify serialization logic, all shape params that are</font>
<font color="black">  46.     # related to serialization are moved from the top level hash into</font>
<font color="black">  47.     # a 'serialization' hash.  This list below contains the names of all</font>
<font color="black">  48.     # the attributes that should be moved.</font>
<font color="green">  49.     SERIALIZED_ATTRS = ['locationName', 'queryName', 'flattened', 'location',</font>
<font color="green">  50.                         'payload', 'streaming', 'timestampFormat',</font>
<font color="green">  51.                         'xmlNamespace', 'resultWrapper', 'xmlAttribute',</font>
<font color="green">  52.                         'eventstream', 'event', 'eventheader', 'eventpayload',</font>
<font color="green">  53.                         'jsonvalue']</font>
<font color="green">  54.     METADATA_ATTRS = ['required', 'min', 'max', 'sensitive', 'enum',</font>
<font color="green">  55.                       'idempotencyToken', 'error', 'exception']</font>
<font color="green">  56.     MAP_TYPE = OrderedDict</font>
<font color="black">  57. </font>
<font color="green">  58.     def __init__(self, shape_name, shape_model, shape_resolver=None):</font>
<font color="black">  59.         &quot;&quot;&quot;</font>
<font color="black">  60. </font>
<font color="black">  61.         :type shape_name: string</font>
<font color="black">  62.         :param shape_name: The name of the shape.</font>
<font color="black">  63. </font>
<font color="black">  64.         :type shape_model: dict</font>
<font color="black">  65.         :param shape_model: The shape model.  This would be the value</font>
<font color="black">  66.             associated with the key in the &quot;shapes&quot; dict of the</font>
<font color="black">  67.             service model (i.e ``model['shapes'][shape_name]``)</font>
<font color="black">  68. </font>
<font color="black">  69.         :type shape_resolver: botocore.model.ShapeResolver</font>
<font color="black">  70.         :param shape_resolver: A shape resolver object.  This is used to</font>
<font color="black">  71.             resolve references to other shapes.  For scalar shape types</font>
<font color="black">  72.             (string, integer, boolean, etc.), this argument is not</font>
<font color="black">  73.             required.  If a shape_resolver is not provided for a complex</font>
<font color="black">  74.             type, then a ``ValueError`` will be raised when an attempt</font>
<font color="black">  75.             to resolve a shape is made.</font>
<font color="black">  76. </font>
<font color="black">  77.         &quot;&quot;&quot;</font>
<font color="green">  78.         self.name = shape_name</font>
<font color="green">  79.         self.type_name = shape_model['type']</font>
<font color="green">  80.         self.documentation = shape_model.get('documentation', '')</font>
<font color="green">  81.         self._shape_model = shape_model</font>
<font color="green">  82.         if shape_resolver is None:</font>
<font color="black">  83.             # If a shape_resolver is not provided, we create an object</font>
<font color="black">  84.             # that will throw errors if you attempt to resolve</font>
<font color="black">  85.             # a shape.  This is actually ok for scalar shapes</font>
<font color="black">  86.             # because they don't need to resolve shapes and shouldn't</font>
<font color="black">  87.             # be required to provide an object they won't use.</font>
<font color="red">  88.             shape_resolver = UnresolvableShapeMap()</font>
<font color="green">  89.         self._shape_resolver = shape_resolver</font>
<font color="green">  90.         self._cache = {}</font>
<font color="black">  91. </font>
<font color="green">  92.     @CachedProperty</font>
<font color="black">  93.     def serialization(self):</font>
<font color="black">  94.         &quot;&quot;&quot;Serialization information about the shape.</font>
<font color="black">  95. </font>
<font color="black">  96.         This contains information that may be needed for input serialization</font>
<font color="black">  97.         or response parsing.  This can include:</font>
<font color="black">  98. </font>
<font color="black">  99.             * name</font>
<font color="black"> 100.             * queryName</font>
<font color="black"> 101.             * flattened</font>
<font color="black"> 102.             * location</font>
<font color="black"> 103.             * payload</font>
<font color="black"> 104.             * streaming</font>
<font color="black"> 105.             * xmlNamespace</font>
<font color="black"> 106.             * resultWrapper</font>
<font color="black"> 107.             * xmlAttribute</font>
<font color="black"> 108.             * jsonvalue</font>
<font color="black"> 109. </font>
<font color="black"> 110.         :rtype: dict</font>
<font color="black"> 111.         :return: Serialization information about the shape.</font>
<font color="black"> 112. </font>
<font color="black"> 113.         &quot;&quot;&quot;</font>
<font color="green"> 114.         model = self._shape_model</font>
<font color="green"> 115.         serialization = {}</font>
<font color="green"> 116.         for attr in self.SERIALIZED_ATTRS:</font>
<font color="green"> 117.             if attr in self._shape_model:</font>
<font color="green"> 118.                 serialization[attr] = model[attr]</font>
<font color="black"> 119.         # For consistency, locationName is renamed to just 'name'.</font>
<font color="green"> 120.         if 'locationName' in serialization:</font>
<font color="green"> 121.             serialization['name'] = serialization.pop('locationName')</font>
<font color="green"> 122.         return serialization</font>
<font color="black"> 123. </font>
<font color="green"> 124.     @CachedProperty</font>
<font color="black"> 125.     def metadata(self):</font>
<font color="black"> 126.         &quot;&quot;&quot;Metadata about the shape.</font>
<font color="black"> 127. </font>
<font color="black"> 128.         This requires optional information about the shape, including:</font>
<font color="black"> 129. </font>
<font color="black"> 130.             * min</font>
<font color="black"> 131.             * max</font>
<font color="black"> 132.             * enum</font>
<font color="black"> 133.             * sensitive</font>
<font color="black"> 134.             * required</font>
<font color="black"> 135.             * idempotencyToken</font>
<font color="black"> 136. </font>
<font color="black"> 137.         :rtype: dict</font>
<font color="black"> 138.         :return: Metadata about the shape.</font>
<font color="black"> 139. </font>
<font color="black"> 140.         &quot;&quot;&quot;</font>
<font color="green"> 141.         model = self._shape_model</font>
<font color="green"> 142.         metadata = {}</font>
<font color="green"> 143.         for attr in self.METADATA_ATTRS:</font>
<font color="green"> 144.             if attr in self._shape_model:</font>
<font color="green"> 145.                 metadata[attr] = model[attr]</font>
<font color="green"> 146.         return metadata</font>
<font color="black"> 147. </font>
<font color="green"> 148.     @CachedProperty</font>
<font color="black"> 149.     def required_members(self):</font>
<font color="black"> 150.         &quot;&quot;&quot;A list of members that are required.</font>
<font color="black"> 151. </font>
<font color="black"> 152.         A structure shape can define members that are required.</font>
<font color="black"> 153.         This value will return a list of required members.  If there</font>
<font color="black"> 154.         are no required members an empty list is returned.</font>
<font color="black"> 155. </font>
<font color="black"> 156.         &quot;&quot;&quot;</font>
<font color="red"> 157.         return self.metadata.get('required', [])</font>
<font color="black"> 158. </font>
<font color="green"> 159.     def _resolve_shape_ref(self, shape_ref):</font>
<font color="green"> 160.         return self._shape_resolver.resolve_shape_ref(shape_ref)</font>
<font color="black"> 161. </font>
<font color="green"> 162.     def __repr__(self):</font>
<font color="red"> 163.         return &quot;&lt;%s(%s)&gt;&quot; % (self.__class__.__name__,</font>
<font color="red"> 164.                              self.name)</font>
<font color="black"> 165. </font>
<font color="black"> 166. </font>
<font color="green"> 167. class StructureShape(Shape):</font>
<font color="green"> 168.     @CachedProperty</font>
<font color="black"> 169.     def members(self):</font>
<font color="green"> 170.         members = self._shape_model['members']</font>
<font color="black"> 171.         # The members dict looks like:</font>
<font color="black"> 172.         #    'members': {</font>
<font color="black"> 173.         #        'MemberName': {'shape': 'shapeName'},</font>
<font color="black"> 174.         #        'MemberName2': {'shape': 'shapeName'},</font>
<font color="black"> 175.         #    }</font>
<font color="black"> 176.         # We return a dict of member name to Shape object.</font>
<font color="green"> 177.         shape_members = self.MAP_TYPE()</font>
<font color="green"> 178.         for name, shape_ref in members.items():</font>
<font color="green"> 179.             shape_members[name] = self._resolve_shape_ref(shape_ref)</font>
<font color="green"> 180.         return shape_members</font>
<font color="black"> 181. </font>
<font color="black"> 182. </font>
<font color="green"> 183. class ListShape(Shape):</font>
<font color="green"> 184.     @CachedProperty</font>
<font color="black"> 185.     def member(self):</font>
<font color="green"> 186.         return self._resolve_shape_ref(self._shape_model['member'])</font>
<font color="black"> 187. </font>
<font color="black"> 188. </font>
<font color="green"> 189. class MapShape(Shape):</font>
<font color="green"> 190.     @CachedProperty</font>
<font color="black"> 191.     def key(self):</font>
<font color="red"> 192.         return self._resolve_shape_ref(self._shape_model['key'])</font>
<font color="black"> 193. </font>
<font color="green"> 194.     @CachedProperty</font>
<font color="black"> 195.     def value(self):</font>
<font color="red"> 196.         return self._resolve_shape_ref(self._shape_model['value'])</font>
<font color="black"> 197. </font>
<font color="black"> 198. </font>
<font color="green"> 199. class StringShape(Shape):</font>
<font color="green"> 200.     @CachedProperty</font>
<font color="black"> 201.     def enum(self):</font>
<font color="red"> 202.         return self.metadata.get('enum', [])</font>
<font color="black"> 203. </font>
<font color="black"> 204. </font>
<font color="green"> 205. class ServiceModel(object):</font>
<font color="black"> 206.     &quot;&quot;&quot;</font>
<font color="black"> 207. </font>
<font color="black"> 208.     :ivar service_description: The parsed service description dictionary.</font>
<font color="black"> 209. </font>
<font color="green"> 210.     &quot;&quot;&quot;</font>
<font color="black"> 211. </font>
<font color="green"> 212.     def __init__(self, service_description, service_name=None):</font>
<font color="black"> 213.         &quot;&quot;&quot;</font>
<font color="black"> 214. </font>
<font color="black"> 215.         :type service_description: dict</font>
<font color="black"> 216.         :param service_description: The service description model.  This value</font>
<font color="black"> 217.             is obtained from a botocore.loader.Loader, or from directly loading</font>
<font color="black"> 218.             the file yourself::</font>
<font color="black"> 219. </font>
<font color="black"> 220.                 service_description = json.load(</font>
<font color="black"> 221.                     open('/path/to/service-description-model.json'))</font>
<font color="black"> 222.                 model = ServiceModel(service_description)</font>
<font color="black"> 223. </font>
<font color="black"> 224.         :type service_name: str</font>
<font color="black"> 225.         :param service_name: The name of the service.  Normally this is</font>
<font color="black"> 226.             the endpoint prefix defined in the service_description.  However,</font>
<font color="black"> 227.             you can override this value to provide a more convenient name.</font>
<font color="black"> 228.             This is done in a few places in botocore (ses instead of email,</font>
<font color="black"> 229.             emr instead of elasticmapreduce).  If this value is not provided,</font>
<font color="black"> 230.             it will default to the endpointPrefix defined in the model.</font>
<font color="black"> 231. </font>
<font color="black"> 232.         &quot;&quot;&quot;</font>
<font color="green"> 233.         self._service_description = service_description</font>
<font color="black"> 234.         # We want clients to be able to access metadata directly.</font>
<font color="green"> 235.         self.metadata = service_description.get('metadata', {})</font>
<font color="green"> 236.         self._shape_resolver = ShapeResolver(</font>
<font color="green"> 237.             service_description.get('shapes', {}))</font>
<font color="green"> 238.         self._signature_version = NOT_SET</font>
<font color="green"> 239.         self._service_name = service_name</font>
<font color="green"> 240.         self._instance_cache = {}</font>
<font color="black"> 241. </font>
<font color="green"> 242.     def shape_for(self, shape_name, member_traits=None):</font>
<font color="red"> 243.         return self._shape_resolver.get_shape_by_name(</font>
<font color="red"> 244.             shape_name, member_traits)</font>
<font color="black"> 245. </font>
<font color="green"> 246.     def resolve_shape_ref(self, shape_ref):</font>
<font color="green"> 247.         return self._shape_resolver.resolve_shape_ref(shape_ref)</font>
<font color="black"> 248. </font>
<font color="green"> 249.     @CachedProperty</font>
<font color="black"> 250.     def shape_names(self):</font>
<font color="red"> 251.         return list(self._service_description.get('shapes', {}))</font>
<font color="black"> 252. </font>
<font color="green"> 253.     @instance_cache</font>
<font color="black"> 254.     def operation_model(self, operation_name):</font>
<font color="green"> 255.         try:</font>
<font color="green"> 256.             model = self._service_description['operations'][operation_name]</font>
<font color="red"> 257.         except KeyError:</font>
<font color="red"> 258.             raise OperationNotFoundError(operation_name)</font>
<font color="green"> 259.         return OperationModel(model, self, operation_name)</font>
<font color="black"> 260. </font>
<font color="green"> 261.     @CachedProperty</font>
<font color="black"> 262.     def documentation(self):</font>
<font color="red"> 263.         return self._service_description.get('documentation', '')</font>
<font color="black"> 264. </font>
<font color="green"> 265.     @CachedProperty</font>
<font color="black"> 266.     def operation_names(self):</font>
<font color="green"> 267.         return list(self._service_description.get('operations', []))</font>
<font color="black"> 268. </font>
<font color="green"> 269.     @CachedProperty</font>
<font color="black"> 270.     def service_name(self):</font>
<font color="black"> 271.         &quot;&quot;&quot;The name of the service.</font>
<font color="black"> 272. </font>
<font color="black"> 273.         This defaults to the endpointPrefix defined in the service model.</font>
<font color="black"> 274.         However, this value can be overriden when a ``ServiceModel`` is</font>
<font color="black"> 275.         created.  If a service_name was not provided when the ``ServiceModel``</font>
<font color="black"> 276.         was created and if there is no endpointPrefix defined in the</font>
<font color="black"> 277.         service model, then an ``UndefinedModelAttributeError`` exception</font>
<font color="black"> 278.         will be raised.</font>
<font color="black"> 279. </font>
<font color="black"> 280.         &quot;&quot;&quot;</font>
<font color="green"> 281.         if self._service_name is not None:</font>
<font color="green"> 282.             return self._service_name</font>
<font color="black"> 283.         else:</font>
<font color="red"> 284.             return self.endpoint_prefix</font>
<font color="black"> 285. </font>
<font color="green"> 286.     @CachedProperty</font>
<font color="black"> 287.     def signing_name(self):</font>
<font color="black"> 288.         &quot;&quot;&quot;The name to use when computing signatures.</font>
<font color="black"> 289. </font>
<font color="black"> 290.         If the model does not define a signing name, this</font>
<font color="black"> 291.         value will be the endpoint prefix defined in the model.</font>
<font color="black"> 292.         &quot;&quot;&quot;</font>
<font color="red"> 293.         signing_name = self.metadata.get('signingName')</font>
<font color="red"> 294.         if signing_name is None:</font>
<font color="red"> 295.             signing_name = self.endpoint_prefix</font>
<font color="red"> 296.         return signing_name</font>
<font color="black"> 297. </font>
<font color="green"> 298.     @CachedProperty</font>
<font color="black"> 299.     def api_version(self):</font>
<font color="red"> 300.         return self._get_metadata_property('apiVersion')</font>
<font color="black"> 301. </font>
<font color="green"> 302.     @CachedProperty</font>
<font color="black"> 303.     def protocol(self):</font>
<font color="red"> 304.         return self._get_metadata_property('protocol')</font>
<font color="black"> 305. </font>
<font color="green"> 306.     @CachedProperty</font>
<font color="black"> 307.     def endpoint_prefix(self):</font>
<font color="green"> 308.         return self._get_metadata_property('endpointPrefix')</font>
<font color="black"> 309. </font>
<font color="green"> 310.     def _get_metadata_property(self, name):</font>
<font color="green"> 311.         try:</font>
<font color="green"> 312.             return self.metadata[name]</font>
<font color="red"> 313.         except KeyError:</font>
<font color="red"> 314.             raise UndefinedModelAttributeError(</font>
<font color="red"> 315.                 '&quot;%s&quot; not defined in the metadata of the the model: %s' %</font>
<font color="red"> 316.                 (name, self))</font>
<font color="black"> 317. </font>
<font color="black"> 318.     # Signature version is one of the rare properties</font>
<font color="black"> 319.     # than can be modified so a CachedProperty is not used here.</font>
<font color="black"> 320. </font>
<font color="green"> 321.     @property</font>
<font color="black"> 322.     def signature_version(self):</font>
<font color="red"> 323.         if self._signature_version is NOT_SET:</font>
<font color="red"> 324.             signature_version = self.metadata.get('signatureVersion')</font>
<font color="red"> 325.             self._signature_version = signature_version</font>
<font color="red"> 326.         return self._signature_version</font>
<font color="black"> 327. </font>
<font color="green"> 328.     @signature_version.setter</font>
<font color="black"> 329.     def signature_version(self, value):</font>
<font color="red"> 330.         self._signature_version = value</font>
<font color="black"> 331. </font>
<font color="black"> 332. </font>
<font color="green"> 333. class OperationModel(object):</font>
<font color="green"> 334.     def __init__(self, operation_model, service_model, name=None):</font>
<font color="black"> 335.         &quot;&quot;&quot;</font>
<font color="black"> 336. </font>
<font color="black"> 337.         :type operation_model: dict</font>
<font color="black"> 338.         :param operation_model: The operation model.  This comes from the</font>
<font color="black"> 339.             service model, and is the value associated with the operation</font>
<font color="black"> 340.             name in the service model (i.e ``model['operations'][op_name]``).</font>
<font color="black"> 341. </font>
<font color="black"> 342.         :type service_model: botocore.model.ServiceModel</font>
<font color="black"> 343.         :param service_model: The service model associated with the operation.</font>
<font color="black"> 344. </font>
<font color="black"> 345.         :type name: string</font>
<font color="black"> 346.         :param name: The operation name.  This is the operation name exposed to</font>
<font color="black"> 347.             the users of this model.  This can potentially be different from</font>
<font color="black"> 348.             the &quot;wire_name&quot;, which is the operation name that *must* by</font>
<font color="black"> 349.             provided over the wire.  For example, given::</font>
<font color="black"> 350. </font>
<font color="black"> 351.                &quot;CreateCloudFrontOriginAccessIdentity&quot;:{</font>
<font color="black"> 352.                  &quot;name&quot;:&quot;CreateCloudFrontOriginAccessIdentity2014_11_06&quot;,</font>
<font color="black"> 353.                   ...</font>
<font color="black"> 354.               }</font>
<font color="black"> 355. </font>
<font color="black"> 356.            The ``name`` would be ``CreateCloudFrontOriginAccessIdentity``,</font>
<font color="black"> 357.            but the ``self.wire_name`` would be</font>
<font color="black"> 358.            ``CreateCloudFrontOriginAccessIdentity2014_11_06``, which is the</font>
<font color="black"> 359.            value we must send in the corresponding HTTP request.</font>
<font color="black"> 360. </font>
<font color="black"> 361.         &quot;&quot;&quot;</font>
<font color="green"> 362.         self._operation_model = operation_model</font>
<font color="green"> 363.         self._service_model = service_model</font>
<font color="green"> 364.         self._api_name = name</font>
<font color="black"> 365.         # Clients can access '.name' to get the operation name</font>
<font color="black"> 366.         # and '.metadata' to get the top level metdata of the service.</font>
<font color="green"> 367.         self._wire_name = operation_model.get('name')</font>
<font color="green"> 368.         self.metadata = service_model.metadata</font>
<font color="green"> 369.         self.http = operation_model.get('http', {})</font>
<font color="black"> 370. </font>
<font color="green"> 371.     @CachedProperty</font>
<font color="black"> 372.     def name(self):</font>
<font color="green"> 373.         if self._api_name is not None:</font>
<font color="green"> 374.             return self._api_name</font>
<font color="black"> 375.         else:</font>
<font color="red"> 376.             return self.wire_name</font>
<font color="black"> 377. </font>
<font color="green"> 378.     @property</font>
<font color="black"> 379.     def wire_name(self):</font>
<font color="black"> 380.         &quot;&quot;&quot;The wire name of the operation.</font>
<font color="black"> 381. </font>
<font color="black"> 382.         In many situations this is the same value as the</font>
<font color="black"> 383.         ``name``, value, but in some services, the operation name</font>
<font color="black"> 384.         exposed to the user is different from the operaiton name</font>
<font color="black"> 385.         we send across the wire (e.g cloudfront).</font>
<font color="black"> 386. </font>
<font color="black"> 387.         Any serialization code should use ``wire_name``.</font>
<font color="black"> 388. </font>
<font color="black"> 389.         &quot;&quot;&quot;</font>
<font color="red"> 390.         return self._operation_model.get('name')</font>
<font color="black"> 391. </font>
<font color="green"> 392.     @property</font>
<font color="black"> 393.     def service_model(self):</font>
<font color="red"> 394.         return self._service_model</font>
<font color="black"> 395. </font>
<font color="green"> 396.     @CachedProperty</font>
<font color="black"> 397.     def documentation(self):</font>
<font color="green"> 398.         return self._operation_model.get('documentation', '')</font>
<font color="black"> 399. </font>
<font color="green"> 400.     @CachedProperty</font>
<font color="black"> 401.     def deprecated(self):</font>
<font color="green"> 402.         return self._operation_model.get('deprecated', False)</font>
<font color="black"> 403. </font>
<font color="green"> 404.     @CachedProperty</font>
<font color="black"> 405.     def input_shape(self):</font>
<font color="green"> 406.         if 'input' not in self._operation_model:</font>
<font color="black"> 407.             # Some operations do not accept any input and do not define an</font>
<font color="black"> 408.             # input shape.</font>
<font color="green"> 409.             return None</font>
<font color="green"> 410.         return self._service_model.resolve_shape_ref(</font>
<font color="green"> 411.             self._operation_model['input'])</font>
<font color="black"> 412. </font>
<font color="green"> 413.     @CachedProperty</font>
<font color="black"> 414.     def output_shape(self):</font>
<font color="green"> 415.         if 'output' not in self._operation_model:</font>
<font color="black"> 416.             # Some operations do not define an output shape,</font>
<font color="black"> 417.             # in which case we return None to indicate the</font>
<font color="black"> 418.             # operation has no expected output.</font>
<font color="green"> 419.             return None</font>
<font color="green"> 420.         return self._service_model.resolve_shape_ref(</font>
<font color="green"> 421.             self._operation_model['output'])</font>
<font color="black"> 422. </font>
<font color="green"> 423.     @CachedProperty</font>
<font color="black"> 424.     def idempotent_members(self):</font>
<font color="green"> 425.         input_shape = self.input_shape</font>
<font color="green"> 426.         if not input_shape:</font>
<font color="green"> 427.             return []</font>
<font color="black"> 428. </font>
<font color="green"> 429.         return [name for (name, shape) in input_shape.members.items()</font>
<font color="green"> 430.                 if 'idempotencyToken' in shape.metadata and</font>
<font color="red"> 431.                 shape.metadata['idempotencyToken']]</font>
<font color="black"> 432. </font>
<font color="green"> 433.     @CachedProperty</font>
<font color="black"> 434.     def auth_type(self):</font>
<font color="green"> 435.         return self._operation_model.get('authtype')</font>
<font color="black"> 436. </font>
<font color="green"> 437.     @CachedProperty</font>
<font color="black"> 438.     def error_shapes(self):</font>
<font color="red"> 439.         shapes = self._operation_model.get(&quot;errors&quot;, [])</font>
<font color="red"> 440.         return list(self._service_model.resolve_shape_ref(s) for s in shapes)</font>
<font color="black"> 441. </font>
<font color="green"> 442.     @CachedProperty</font>
<font color="black"> 443.     def has_event_stream_input(self):</font>
<font color="red"> 444.         return self.get_event_stream_input() is not None</font>
<font color="black"> 445. </font>
<font color="green"> 446.     @CachedProperty</font>
<font color="black"> 447.     def has_event_stream_output(self):</font>
<font color="green"> 448.         return self.get_event_stream_output() is not None</font>
<font color="black"> 449. </font>
<font color="green"> 450.     def get_event_stream_input(self):</font>
<font color="red"> 451.         return self._get_event_stream(self.input_shape)</font>
<font color="black"> 452. </font>
<font color="green"> 453.     def get_event_stream_output(self):</font>
<font color="green"> 454.         return self._get_event_stream(self.output_shape)</font>
<font color="black"> 455. </font>
<font color="green"> 456.     def _get_event_stream(self, shape):</font>
<font color="black"> 457.         &quot;&quot;&quot;Returns the event stream member's shape if any or None otherwise.&quot;&quot;&quot;</font>
<font color="green"> 458.         if shape is None:</font>
<font color="green"> 459.             return None</font>
<font color="green"> 460.         for member in shape.members.values():</font>
<font color="green"> 461.             if member.serialization.get('eventstream'):</font>
<font color="red"> 462.                 return member</font>
<font color="green"> 463.         return None</font>
<font color="black"> 464. </font>
<font color="green"> 465.     @CachedProperty</font>
<font color="black"> 466.     def has_streaming_input(self):</font>
<font color="green"> 467.         return self.get_streaming_input() is not None</font>
<font color="black"> 468. </font>
<font color="green"> 469.     @CachedProperty</font>
<font color="black"> 470.     def has_streaming_output(self):</font>
<font color="green"> 471.         return self.get_streaming_output() is not None</font>
<font color="black"> 472. </font>
<font color="green"> 473.     def get_streaming_input(self):</font>
<font color="green"> 474.         return self._get_streaming_body(self.input_shape)</font>
<font color="black"> 475. </font>
<font color="green"> 476.     def get_streaming_output(self):</font>
<font color="green"> 477.         return self._get_streaming_body(self.output_shape)</font>
<font color="black"> 478. </font>
<font color="green"> 479.     def _get_streaming_body(self, shape):</font>
<font color="black"> 480.         &quot;&quot;&quot;Returns the streaming member's shape if any; or None otherwise.&quot;&quot;&quot;</font>
<font color="green"> 481.         if shape is None:</font>
<font color="green"> 482.             return None</font>
<font color="green"> 483.         payload = shape.serialization.get('payload')</font>
<font color="green"> 484.         if payload is not None:</font>
<font color="green"> 485.             payload_shape = shape.members[payload]</font>
<font color="green"> 486.             if payload_shape.type_name == 'blob':</font>
<font color="red"> 487.                 return payload_shape</font>
<font color="green"> 488.         return None</font>
<font color="black"> 489. </font>
<font color="green"> 490.     def __repr__(self):</font>
<font color="red"> 491.         return '%s(name=%s)' % (self.__class__.__name__, self.name)</font>
<font color="black"> 492. </font>
<font color="black"> 493. </font>
<font color="green"> 494. class ShapeResolver(object):</font>
<font color="green"> 495.     &quot;&quot;&quot;Resolves shape references.&quot;&quot;&quot;</font>
<font color="black"> 496. </font>
<font color="black"> 497.     # Any type not in this mapping will default to the Shape class.</font>
<font color="green"> 498.     SHAPE_CLASSES = {</font>
<font color="green"> 499.         'structure': StructureShape,</font>
<font color="green"> 500.         'list': ListShape,</font>
<font color="green"> 501.         'map': MapShape,</font>
<font color="green"> 502.         'string': StringShape</font>
<font color="black"> 503.     }</font>
<font color="black"> 504. </font>
<font color="green"> 505.     def __init__(self, shape_map):</font>
<font color="green"> 506.         self._shape_map = shape_map</font>
<font color="green"> 507.         self._shape_cache = {}</font>
<font color="black"> 508. </font>
<font color="green"> 509.     def get_shape_by_name(self, shape_name, member_traits=None):</font>
<font color="green"> 510.         try:</font>
<font color="green"> 511.             shape_model = self._shape_map[shape_name]</font>
<font color="red"> 512.         except KeyError:</font>
<font color="red"> 513.             raise NoShapeFoundError(shape_name)</font>
<font color="green"> 514.         try:</font>
<font color="green"> 515.             shape_cls = self.SHAPE_CLASSES.get(shape_model['type'], Shape)</font>
<font color="red"> 516.         except KeyError:</font>
<font color="red"> 517.             raise InvalidShapeError(&quot;Shape is missing required key 'type': %s&quot;</font>
<font color="red"> 518.                                     % shape_model)</font>
<font color="green"> 519.         if member_traits:</font>
<font color="green"> 520.             shape_model = shape_model.copy()</font>
<font color="green"> 521.             shape_model.update(member_traits)</font>
<font color="green"> 522.         result = shape_cls(shape_name, shape_model, self)</font>
<font color="green"> 523.         return result</font>
<font color="black"> 524. </font>
<font color="green"> 525.     def resolve_shape_ref(self, shape_ref):</font>
<font color="black"> 526.         # A shape_ref is a dict that has a 'shape' key that</font>
<font color="black"> 527.         # refers to a shape name as well as any additional</font>
<font color="black"> 528.         # member traits that are then merged over the shape</font>
<font color="black"> 529.         # definition.  For example:</font>
<font color="black"> 530.         # {&quot;shape&quot;: &quot;StringType&quot;, &quot;locationName&quot;: &quot;Foobar&quot;}</font>
<font color="green"> 531.         if len(shape_ref) == 1 and 'shape' in shape_ref:</font>
<font color="black"> 532.             # It's just a shape ref with no member traits, we can avoid</font>
<font color="black"> 533.             # a .copy().  This is the common case so it's specifically</font>
<font color="black"> 534.             # called out here.</font>
<font color="green"> 535.             return self.get_shape_by_name(shape_ref['shape'])</font>
<font color="black"> 536.         else:</font>
<font color="green"> 537.             member_traits = shape_ref.copy()</font>
<font color="green"> 538.             try:</font>
<font color="green"> 539.                 shape_name = member_traits.pop('shape')</font>
<font color="red"> 540.             except KeyError:</font>
<font color="red"> 541.                 raise InvalidShapeReferenceError(</font>
<font color="red"> 542.                     &quot;Invalid model, missing shape reference: %s&quot; % shape_ref)</font>
<font color="green"> 543.             return self.get_shape_by_name(shape_name, member_traits)</font>
<font color="black"> 544. </font>
<font color="black"> 545. </font>
<font color="green"> 546. class UnresolvableShapeMap(object):</font>
<font color="black"> 547.     &quot;&quot;&quot;A ShapeResolver that will throw ValueErrors when shapes are resolved.</font>
<font color="green"> 548.     &quot;&quot;&quot;</font>
<font color="green"> 549.     def get_shape_by_name(self, shape_name, member_traits=None):</font>
<font color="red"> 550.         raise ValueError(&quot;Attempted to lookup shape '%s', but no shape &quot;</font>
<font color="black"> 551.                          &quot;map was provided.&quot;)</font>
<font color="black"> 552. </font>
<font color="green"> 553.     def resolve_shape_ref(self, shape_ref):</font>
<font color="red"> 554.         raise ValueError(&quot;Attempted to resolve shape '%s', but no shape &quot;</font>
<font color="black"> 555.                          &quot;map was provided.&quot;)</font>
<font color="black"> 556. </font>
<font color="black"> 557. </font>
<font color="green"> 558. class DenormalizedStructureBuilder(object):</font>
<font color="black"> 559.     &quot;&quot;&quot;Build a StructureShape from a denormalized model.</font>
<font color="black"> 560. </font>
<font color="black"> 561.     This is a convenience builder class that makes it easy to construct</font>
<font color="black"> 562.     ``StructureShape``s based on a denormalized model.</font>
<font color="black"> 563. </font>
<font color="black"> 564.     It will handle the details of creating unique shape names and creating</font>
<font color="black"> 565.     the appropriate shape map needed by the ``StructureShape`` class.</font>
<font color="black"> 566. </font>
<font color="black"> 567.     Example usage::</font>
<font color="black"> 568. </font>
<font color="black"> 569.         builder = DenormalizedStructureBuilder()</font>
<font color="black"> 570.         shape = builder.with_members({</font>
<font color="black"> 571.             'A': {</font>
<font color="black"> 572.                 'type': 'structure',</font>
<font color="black"> 573.                 'members': {</font>
<font color="black"> 574.                     'B': {</font>
<font color="black"> 575.                         'type': 'structure',</font>
<font color="black"> 576.                         'members': {</font>
<font color="black"> 577.                             'C': {</font>
<font color="black"> 578.                                 'type': 'string',</font>
<font color="black"> 579.                             }</font>
<font color="black"> 580.                         }</font>
<font color="black"> 581.                     }</font>
<font color="black"> 582.                 }</font>
<font color="black"> 583.             }</font>
<font color="black"> 584.         }).build_model()</font>
<font color="black"> 585.         # ``shape`` is now an instance of botocore.model.StructureShape</font>
<font color="black"> 586. </font>
<font color="black"> 587.     :type dict_type: class</font>
<font color="black"> 588.     :param dict_type: The dictionary type to use, allowing you to opt-in</font>
<font color="black"> 589.                       to using OrderedDict or another dict type. This can</font>
<font color="black"> 590.                       be particularly useful for testing when order</font>
<font color="black"> 591.                       matters, such as for documentation.</font>
<font color="black"> 592. </font>
<font color="green"> 593.     &quot;&quot;&quot;</font>
<font color="green"> 594.     def __init__(self, name=None):</font>
<font color="red"> 595.         self.members = OrderedDict()</font>
<font color="red"> 596.         self._name_generator = ShapeNameGenerator()</font>
<font color="red"> 597.         if name is None:</font>
<font color="red"> 598.             self.name = self._name_generator.new_shape_name('structure')</font>
<font color="black"> 599. </font>
<font color="green"> 600.     def with_members(self, members):</font>
<font color="black"> 601.         &quot;&quot;&quot;</font>
<font color="black"> 602. </font>
<font color="black"> 603.         :type members: dict</font>
<font color="black"> 604.         :param members: The denormalized members.</font>
<font color="black"> 605. </font>
<font color="black"> 606.         :return: self</font>
<font color="black"> 607. </font>
<font color="black"> 608.         &quot;&quot;&quot;</font>
<font color="red"> 609.         self._members = members</font>
<font color="red"> 610.         return self</font>
<font color="black"> 611. </font>
<font color="green"> 612.     def build_model(self):</font>
<font color="black"> 613.         &quot;&quot;&quot;Build the model based on the provided members.</font>
<font color="black"> 614. </font>
<font color="black"> 615.         :rtype: botocore.model.StructureShape</font>
<font color="black"> 616.         :return: The built StructureShape object.</font>
<font color="black"> 617. </font>
<font color="black"> 618.         &quot;&quot;&quot;</font>
<font color="red"> 619.         shapes = OrderedDict()</font>
<font color="red"> 620.         denormalized = {</font>
<font color="red"> 621.             'type': 'structure',</font>
<font color="red"> 622.             'members': self._members,</font>
<font color="black"> 623.         }</font>
<font color="red"> 624.         self._build_model(denormalized, shapes, self.name)</font>
<font color="red"> 625.         resolver = ShapeResolver(shape_map=shapes)</font>
<font color="red"> 626.         return StructureShape(shape_name=self.name,</font>
<font color="red"> 627.                               shape_model=shapes[self.name],</font>
<font color="red"> 628.                               shape_resolver=resolver)</font>
<font color="black"> 629. </font>
<font color="green"> 630.     def _build_model(self, model, shapes, shape_name):</font>
<font color="red"> 631.         if model['type'] == 'structure':</font>
<font color="red"> 632.             shapes[shape_name] = self._build_structure(model, shapes)</font>
<font color="red"> 633.         elif model['type'] == 'list':</font>
<font color="red"> 634.             shapes[shape_name] = self._build_list(model, shapes)</font>
<font color="red"> 635.         elif model['type'] == 'map':</font>
<font color="red"> 636.             shapes[shape_name] = self._build_map(model, shapes)</font>
<font color="red"> 637.         elif model['type'] in ['string', 'integer', 'boolean', 'blob', 'float',</font>
<font color="red"> 638.                                'timestamp', 'long', 'double', 'char']:</font>
<font color="red"> 639.             shapes[shape_name] = self._build_scalar(model)</font>
<font color="black"> 640.         else:</font>
<font color="red"> 641.             raise InvalidShapeError(&quot;Unknown shape type: %s&quot; % model['type'])</font>
<font color="black"> 642. </font>
<font color="green"> 643.     def _build_structure(self, model, shapes):</font>
<font color="red"> 644.         members = OrderedDict()</font>
<font color="red"> 645.         shape = self._build_initial_shape(model)</font>
<font color="red"> 646.         shape['members'] = members</font>
<font color="black"> 647. </font>
<font color="red"> 648.         for name, member_model in model['members'].items():</font>
<font color="red"> 649.             member_shape_name = self._get_shape_name(member_model)</font>
<font color="red"> 650.             members[name] = {'shape': member_shape_name}</font>
<font color="red"> 651.             self._build_model(member_model, shapes, member_shape_name)</font>
<font color="red"> 652.         return shape</font>
<font color="black"> 653. </font>
<font color="green"> 654.     def _build_list(self, model, shapes):</font>
<font color="red"> 655.         member_shape_name = self._get_shape_name(model)</font>
<font color="red"> 656.         shape = self._build_initial_shape(model)</font>
<font color="red"> 657.         shape['member'] = {'shape': member_shape_name}</font>
<font color="red"> 658.         self._build_model(model['member'], shapes, member_shape_name)</font>
<font color="red"> 659.         return shape</font>
<font color="black"> 660. </font>
<font color="green"> 661.     def _build_map(self, model, shapes):</font>
<font color="red"> 662.         key_shape_name = self._get_shape_name(model['key'])</font>
<font color="red"> 663.         value_shape_name = self._get_shape_name(model['value'])</font>
<font color="red"> 664.         shape = self._build_initial_shape(model)</font>
<font color="red"> 665.         shape['key'] = {'shape': key_shape_name}</font>
<font color="red"> 666.         shape['value'] = {'shape': value_shape_name}</font>
<font color="red"> 667.         self._build_model(model['key'], shapes, key_shape_name)</font>
<font color="red"> 668.         self._build_model(model['value'], shapes, value_shape_name)</font>
<font color="red"> 669.         return shape</font>
<font color="black"> 670. </font>
<font color="green"> 671.     def _build_initial_shape(self, model):</font>
<font color="red"> 672.         shape = {</font>
<font color="red"> 673.             'type': model['type'],</font>
<font color="black"> 674.         }</font>
<font color="red"> 675.         if 'documentation' in model:</font>
<font color="red"> 676.             shape['documentation'] = model['documentation']</font>
<font color="red"> 677.         if 'enum' in model:</font>
<font color="red"> 678.             shape['enum'] = model['enum']</font>
<font color="red"> 679.         return shape</font>
<font color="black"> 680. </font>
<font color="green"> 681.     def _build_scalar(self, model):</font>
<font color="red"> 682.         return self._build_initial_shape(model)</font>
<font color="black"> 683. </font>
<font color="green"> 684.     def _get_shape_name(self, model):</font>
<font color="red"> 685.         if 'shape_name' in model:</font>
<font color="red"> 686.             return model['shape_name']</font>
<font color="black"> 687.         else:</font>
<font color="red"> 688.             return self._name_generator.new_shape_name(model['type'])</font>
<font color="black"> 689. </font>
<font color="black"> 690. </font>
<font color="green"> 691. class ShapeNameGenerator(object):</font>
<font color="black"> 692.     &quot;&quot;&quot;Generate unique shape names for a type.</font>
<font color="black"> 693. </font>
<font color="black"> 694.     This class can be used in conjunction with the DenormalizedStructureBuilder</font>
<font color="black"> 695.     to generate unique shape names for a given type.</font>
<font color="black"> 696. </font>
<font color="green"> 697.     &quot;&quot;&quot;</font>
<font color="green"> 698.     def __init__(self):</font>
<font color="red"> 699.         self._name_cache = defaultdict(int)</font>
<font color="black"> 700. </font>
<font color="green"> 701.     def new_shape_name(self, type_name):</font>
<font color="black"> 702.         &quot;&quot;&quot;Generate a unique shape name.</font>
<font color="black"> 703. </font>
<font color="black"> 704.         This method will guarantee a unique shape name each time it is</font>
<font color="black"> 705.         called with the same type.</font>
<font color="black"> 706. </font>
<font color="black"> 707.         ::</font>
<font color="black"> 708. </font>
<font color="black"> 709.             &gt;&gt;&gt; s = ShapeNameGenerator()</font>
<font color="black"> 710.             &gt;&gt;&gt; s.new_shape_name('structure')</font>
<font color="black"> 711.             'StructureType1'</font>
<font color="black"> 712.             &gt;&gt;&gt; s.new_shape_name('structure')</font>
<font color="black"> 713.             'StructureType2'</font>
<font color="black"> 714.             &gt;&gt;&gt; s.new_shape_name('list')</font>
<font color="black"> 715.             'ListType1'</font>
<font color="black"> 716.             &gt;&gt;&gt; s.new_shape_name('list')</font>
<font color="black"> 717.             'ListType2'</font>
<font color="black"> 718. </font>
<font color="black"> 719. </font>
<font color="black"> 720.         :type type_name: string</font>
<font color="black"> 721.         :param type_name: The type name (structure, list, map, string, etc.)</font>
<font color="black"> 722. </font>
<font color="black"> 723.         :rtype: string</font>
<font color="black"> 724.         :return: A unique shape name for the given type</font>
<font color="black"> 725. </font>
<font color="black"> 726.         &quot;&quot;&quot;</font>
<font color="red"> 727.         self._name_cache[type_name] += 1</font>
<font color="red"> 728.         current_index = self._name_cache[type_name]</font>
<font color="red"> 729.         return '%sType%s' % (type_name.capitalize(),</font>
<font color="red"> 730.                              current_index)</font>
</pre>

