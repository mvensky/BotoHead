source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/models.py</b><br>


file stats: <b>452 lines, 232 executed: 51.3% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. </font>
<font color="black">   3. &quot;&quot;&quot;</font>
<font color="black">   4. requests.models</font>
<font color="black">   5. ~~~~~~~~~~~~~~~</font>
<font color="black">   6. </font>
<font color="black">   7. This module contains the primary objects that power Requests.</font>
<font color="green">   8. &quot;&quot;&quot;</font>
<font color="black">   9. </font>
<font color="green">  10. import collections</font>
<font color="green">  11. import datetime</font>
<font color="black">  12. </font>
<font color="green">  13. from io import BytesIO, UnsupportedOperation</font>
<font color="green">  14. from .hooks import default_hooks</font>
<font color="green">  15. from .structures import CaseInsensitiveDict</font>
<font color="black">  16. </font>
<font color="green">  17. from .auth import HTTPBasicAuth</font>
<font color="green">  18. from .cookies import cookiejar_from_dict, get_cookie_header, _copy_cookie_jar</font>
<font color="green">  19. from .packages.urllib3.fields import RequestField</font>
<font color="green">  20. from .packages.urllib3.filepost import encode_multipart_formdata</font>
<font color="green">  21. from .packages.urllib3.util import parse_url</font>
<font color="green">  22. from .packages.urllib3.exceptions import (</font>
<font color="black">  23.     DecodeError, ReadTimeoutError, ProtocolError, LocationParseError)</font>
<font color="green">  24. from .exceptions import (</font>
<font color="black">  25.     HTTPError, MissingSchema, InvalidURL, ChunkedEncodingError,</font>
<font color="black">  26.     ContentDecodingError, ConnectionError, StreamConsumedError)</font>
<font color="green">  27. from .utils import (</font>
<font color="black">  28.     guess_filename, get_auth_from_url, requote_uri,</font>
<font color="black">  29.     stream_decode_response_unicode, to_key_val_list, parse_header_links,</font>
<font color="black">  30.     iter_slices, guess_json_utf, super_len, to_native_string)</font>
<font color="green">  31. from .compat import (</font>
<font color="black">  32.     cookielib, urlunparse, urlsplit, urlencode, str, bytes, StringIO,</font>
<font color="black">  33.     is_py2, chardet, json, builtin_str, basestring)</font>
<font color="green">  34. from .status_codes import codes</font>
<font color="black">  35. </font>
<font color="black">  36. #: The set of HTTP status codes that indicate an automatically</font>
<font color="black">  37. #: processable redirect.</font>
<font color="black">  38. REDIRECT_STATI = (</font>
<font color="green">  39.     codes.moved,              # 301</font>
<font color="green">  40.     codes.found,              # 302</font>
<font color="green">  41.     codes.other,              # 303</font>
<font color="green">  42.     codes.temporary_redirect, # 307</font>
<font color="green">  43.     codes.permanent_redirect, # 308</font>
<font color="black">  44. )</font>
<font color="green">  45. DEFAULT_REDIRECT_LIMIT = 30</font>
<font color="green">  46. CONTENT_CHUNK_SIZE = 10 * 1024</font>
<font color="green">  47. ITER_CHUNK_SIZE = 512</font>
<font color="black">  48. </font>
<font color="green">  49. json_dumps = json.dumps</font>
<font color="black">  50. </font>
<font color="black">  51. </font>
<font color="green">  52. class RequestEncodingMixin(object):</font>
<font color="green">  53.     @property</font>
<font color="black">  54.     def path_url(self):</font>
<font color="black">  55.         &quot;&quot;&quot;Build the path URL to use.&quot;&quot;&quot;</font>
<font color="black">  56. </font>
<font color="green">  57.         url = []</font>
<font color="black">  58. </font>
<font color="green">  59.         p = urlsplit(self.url)</font>
<font color="black">  60. </font>
<font color="green">  61.         path = p.path</font>
<font color="green">  62.         if not path:</font>
<font color="red">  63.             path = '/'</font>
<font color="black">  64. </font>
<font color="green">  65.         url.append(path)</font>
<font color="black">  66. </font>
<font color="green">  67.         query = p.query</font>
<font color="green">  68.         if query:</font>
<font color="green">  69.             url.append('?')</font>
<font color="green">  70.             url.append(query)</font>
<font color="black">  71. </font>
<font color="green">  72.         return ''.join(url)</font>
<font color="black">  73. </font>
<font color="green">  74.     @staticmethod</font>
<font color="black">  75.     def _encode_params(data):</font>
<font color="black">  76.         &quot;&quot;&quot;Encode parameters in a piece of data.</font>
<font color="black">  77. </font>
<font color="black">  78.         Will successfully encode parameters when passed as a dict or a list of</font>
<font color="black">  79.         2-tuples. Order is retained if data is a list of 2-tuples but arbitrary</font>
<font color="black">  80.         if parameters are supplied as a dict.</font>
<font color="black">  81.         &quot;&quot;&quot;</font>
<font color="black">  82. </font>
<font color="green">  83.         if isinstance(data, (str, bytes)):</font>
<font color="green">  84.             return data</font>
<font color="green">  85.         elif hasattr(data, 'read'):</font>
<font color="red">  86.             return data</font>
<font color="green">  87.         elif hasattr(data, '__iter__'):</font>
<font color="green">  88.             result = []</font>
<font color="green">  89.             for k, vs in to_key_val_list(data):</font>
<font color="red">  90.                 if isinstance(vs, basestring) or not hasattr(vs, '__iter__'):</font>
<font color="red">  91.                     vs = [vs]</font>
<font color="red">  92.                 for v in vs:</font>
<font color="red">  93.                     if v is not None:</font>
<font color="red">  94.                         result.append(</font>
<font color="red">  95.                             (k.encode('utf-8') if isinstance(k, str) else k,</font>
<font color="red">  96.                              v.encode('utf-8') if isinstance(v, str) else v))</font>
<font color="green">  97.             return urlencode(result, doseq=True)</font>
<font color="black">  98.         else:</font>
<font color="red">  99.             return data</font>
<font color="black"> 100. </font>
<font color="green"> 101.     @staticmethod</font>
<font color="black"> 102.     def _encode_files(files, data):</font>
<font color="black"> 103.         &quot;&quot;&quot;Build the body for a multipart/form-data request.</font>
<font color="black"> 104. </font>
<font color="black"> 105.         Will successfully encode files when passed as a dict or a list of</font>
<font color="black"> 106.         2-tuples. Order is retained if data is a list of 2-tuples but arbitrary</font>
<font color="black"> 107.         if parameters are supplied as a dict.</font>
<font color="black"> 108. </font>
<font color="black"> 109.         &quot;&quot;&quot;</font>
<font color="red"> 110.         if (not files):</font>
<font color="red"> 111.             raise ValueError(&quot;Files must be provided.&quot;)</font>
<font color="red"> 112.         elif isinstance(data, basestring):</font>
<font color="red"> 113.             raise ValueError(&quot;Data must not be a string.&quot;)</font>
<font color="black"> 114. </font>
<font color="red"> 115.         new_fields = []</font>
<font color="red"> 116.         fields = to_key_val_list(data or {})</font>
<font color="red"> 117.         files = to_key_val_list(files or {})</font>
<font color="black"> 118. </font>
<font color="red"> 119.         for field, val in fields:</font>
<font color="red"> 120.             if isinstance(val, basestring) or not hasattr(val, '__iter__'):</font>
<font color="red"> 121.                 val = [val]</font>
<font color="red"> 122.             for v in val:</font>
<font color="red"> 123.                 if v is not None:</font>
<font color="black"> 124.                     # Don't call str() on bytestrings: in Py3 it all goes wrong.</font>
<font color="red"> 125.                     if not isinstance(v, bytes):</font>
<font color="red"> 126.                         v = str(v)</font>
<font color="black"> 127. </font>
<font color="red"> 128.                     new_fields.append(</font>
<font color="red"> 129.                         (field.decode('utf-8') if isinstance(field, bytes) else field,</font>
<font color="red"> 130.                          v.encode('utf-8') if isinstance(v, str) else v))</font>
<font color="black"> 131. </font>
<font color="red"> 132.         for (k, v) in files:</font>
<font color="black"> 133.             # support for explicit filename</font>
<font color="red"> 134.             ft = None</font>
<font color="red"> 135.             fh = None</font>
<font color="red"> 136.             if isinstance(v, (tuple, list)):</font>
<font color="red"> 137.                 if len(v) == 2:</font>
<font color="red"> 138.                     fn, fp = v</font>
<font color="red"> 139.                 elif len(v) == 3:</font>
<font color="red"> 140.                     fn, fp, ft = v</font>
<font color="black"> 141.                 else:</font>
<font color="red"> 142.                     fn, fp, ft, fh = v</font>
<font color="black"> 143.             else:</font>
<font color="red"> 144.                 fn = guess_filename(v) or k</font>
<font color="red"> 145.                 fp = v</font>
<font color="black"> 146. </font>
<font color="red"> 147.             if isinstance(fp, (str, bytes, bytearray)):</font>
<font color="red"> 148.                 fdata = fp</font>
<font color="black"> 149.             else:</font>
<font color="red"> 150.                 fdata = fp.read()</font>
<font color="black"> 151. </font>
<font color="red"> 152.             rf = RequestField(name=k, data=fdata,</font>
<font color="red"> 153.                               filename=fn, headers=fh)</font>
<font color="red"> 154.             rf.make_multipart(content_type=ft)</font>
<font color="red"> 155.             new_fields.append(rf)</font>
<font color="black"> 156. </font>
<font color="red"> 157.         body, content_type = encode_multipart_formdata(new_fields)</font>
<font color="black"> 158. </font>
<font color="red"> 159.         return body, content_type</font>
<font color="black"> 160. </font>
<font color="black"> 161. </font>
<font color="green"> 162. class RequestHooksMixin(object):</font>
<font color="green"> 163.     def register_hook(self, event, hook):</font>
<font color="black"> 164.         &quot;&quot;&quot;Properly register a hook.&quot;&quot;&quot;</font>
<font color="black"> 165. </font>
<font color="red"> 166.         if event not in self.hooks:</font>
<font color="red"> 167.             raise ValueError('Unsupported event specified, with event name &quot;%s&quot;' % (event))</font>
<font color="black"> 168. </font>
<font color="red"> 169.         if isinstance(hook, collections.Callable):</font>
<font color="red"> 170.             self.hooks[event].append(hook)</font>
<font color="red"> 171.         elif hasattr(hook, '__iter__'):</font>
<font color="red"> 172.             self.hooks[event].extend(h for h in hook if isinstance(h, collections.Callable))</font>
<font color="black"> 173. </font>
<font color="green"> 174.     def deregister_hook(self, event, hook):</font>
<font color="black"> 175.         &quot;&quot;&quot;Deregister a previously registered hook.</font>
<font color="black"> 176.         Returns True if the hook existed, False if not.</font>
<font color="black"> 177.         &quot;&quot;&quot;</font>
<font color="black"> 178. </font>
<font color="red"> 179.         try:</font>
<font color="red"> 180.             self.hooks[event].remove(hook)</font>
<font color="red"> 181.             return True</font>
<font color="red"> 182.         except ValueError:</font>
<font color="red"> 183.             return False</font>
<font color="black"> 184. </font>
<font color="black"> 185. </font>
<font color="green"> 186. class Request(RequestHooksMixin):</font>
<font color="black"> 187.     &quot;&quot;&quot;A user-created :class:`Request &lt;Request&gt;` object.</font>
<font color="black"> 188. </font>
<font color="black"> 189.     Used to prepare a :class:`PreparedRequest &lt;PreparedRequest&gt;`, which is sent to the server.</font>
<font color="black"> 190. </font>
<font color="black"> 191.     :param method: HTTP method to use.</font>
<font color="black"> 192.     :param url: URL to send.</font>
<font color="black"> 193.     :param headers: dictionary of headers to send.</font>
<font color="black"> 194.     :param files: dictionary of {filename: fileobject} files to multipart upload.</font>
<font color="black"> 195.     :param data: the body to attach to the request. If a dictionary is provided, form-encoding will take place.</font>
<font color="black"> 196.     :param json: json for the body to attach to the request (if data is not specified).</font>
<font color="black"> 197.     :param params: dictionary of URL parameters to append to the URL.</font>
<font color="black"> 198.     :param auth: Auth handler or (user, pass) tuple.</font>
<font color="black"> 199.     :param cookies: dictionary or CookieJar of cookies to attach to this request.</font>
<font color="black"> 200.     :param hooks: dictionary of callback hooks, for internal usage.</font>
<font color="black"> 201. </font>
<font color="black"> 202.     Usage::</font>
<font color="black"> 203. </font>
<font color="black"> 204.       &gt;&gt;&gt; import requests</font>
<font color="black"> 205.       &gt;&gt;&gt; req = requests.Request('GET', 'http://httpbin.org/get')</font>
<font color="black"> 206.       &gt;&gt;&gt; req.prepare()</font>
<font color="black"> 207.       &lt;PreparedRequest [GET]&gt;</font>
<font color="black"> 208. </font>
<font color="green"> 209.     &quot;&quot;&quot;</font>
<font color="black"> 210.     def __init__(self,</font>
<font color="green"> 211.         method=None,</font>
<font color="green"> 212.         url=None,</font>
<font color="green"> 213.         headers=None,</font>
<font color="green"> 214.         files=None,</font>
<font color="green"> 215.         data=None,</font>
<font color="green"> 216.         params=None,</font>
<font color="green"> 217.         auth=None,</font>
<font color="green"> 218.         cookies=None,</font>
<font color="green"> 219.         hooks=None,</font>
<font color="green"> 220.         json=None):</font>
<font color="black"> 221. </font>
<font color="black"> 222.         # Default empty dicts for dict params.</font>
<font color="green"> 223.         data = [] if data is None else data</font>
<font color="green"> 224.         files = [] if files is None else files</font>
<font color="green"> 225.         headers = {} if headers is None else headers</font>
<font color="green"> 226.         params = {} if params is None else params</font>
<font color="green"> 227.         hooks = {} if hooks is None else hooks</font>
<font color="black"> 228. </font>
<font color="green"> 229.         self.hooks = default_hooks()</font>
<font color="green"> 230.         for (k, v) in list(hooks.items()):</font>
<font color="red"> 231.             self.register_hook(event=k, hook=v)</font>
<font color="black"> 232. </font>
<font color="green"> 233.         self.method = method</font>
<font color="green"> 234.         self.url = url</font>
<font color="green"> 235.         self.headers = headers</font>
<font color="green"> 236.         self.files = files</font>
<font color="green"> 237.         self.data = data</font>
<font color="green"> 238.         self.json = json</font>
<font color="green"> 239.         self.params = params</font>
<font color="green"> 240.         self.auth = auth</font>
<font color="green"> 241.         self.cookies = cookies</font>
<font color="black"> 242. </font>
<font color="green"> 243.     def __repr__(self):</font>
<font color="red"> 244.         return '&lt;Request [%s]&gt;' % (self.method)</font>
<font color="black"> 245. </font>
<font color="green"> 246.     def prepare(self):</font>
<font color="black"> 247.         &quot;&quot;&quot;Constructs a :class:`PreparedRequest &lt;PreparedRequest&gt;` for transmission and returns it.&quot;&quot;&quot;</font>
<font color="red"> 248.         p = PreparedRequest()</font>
<font color="red"> 249.         p.prepare(</font>
<font color="red"> 250.             method=self.method,</font>
<font color="red"> 251.             url=self.url,</font>
<font color="red"> 252.             headers=self.headers,</font>
<font color="red"> 253.             files=self.files,</font>
<font color="red"> 254.             data=self.data,</font>
<font color="red"> 255.             json=self.json,</font>
<font color="red"> 256.             params=self.params,</font>
<font color="red"> 257.             auth=self.auth,</font>
<font color="red"> 258.             cookies=self.cookies,</font>
<font color="red"> 259.             hooks=self.hooks,</font>
<font color="black"> 260.         )</font>
<font color="red"> 261.         return p</font>
<font color="black"> 262. </font>
<font color="black"> 263. </font>
<font color="green"> 264. class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):</font>
<font color="black"> 265.     &quot;&quot;&quot;The fully mutable :class:`PreparedRequest &lt;PreparedRequest&gt;` object,</font>
<font color="black"> 266.     containing the exact bytes that will be sent to the server.</font>
<font color="black"> 267. </font>
<font color="black"> 268.     Generated from either a :class:`Request &lt;Request&gt;` object or manually.</font>
<font color="black"> 269. </font>
<font color="black"> 270.     Usage::</font>
<font color="black"> 271. </font>
<font color="black"> 272.       &gt;&gt;&gt; import requests</font>
<font color="black"> 273.       &gt;&gt;&gt; req = requests.Request('GET', 'http://httpbin.org/get')</font>
<font color="black"> 274.       &gt;&gt;&gt; r = req.prepare()</font>
<font color="black"> 275.       &lt;PreparedRequest [GET]&gt;</font>
<font color="black"> 276. </font>
<font color="black"> 277.       &gt;&gt;&gt; s = requests.Session()</font>
<font color="black"> 278.       &gt;&gt;&gt; s.send(r)</font>
<font color="black"> 279.       &lt;Response [200]&gt;</font>
<font color="black"> 280. </font>
<font color="green"> 281.     &quot;&quot;&quot;</font>
<font color="black"> 282. </font>
<font color="green"> 283.     def __init__(self):</font>
<font color="black"> 284.         #: HTTP verb to send to the server.</font>
<font color="green"> 285.         self.method = None</font>
<font color="black"> 286.         #: HTTP URL to send the request to.</font>
<font color="green"> 287.         self.url = None</font>
<font color="black"> 288.         #: dictionary of HTTP headers.</font>
<font color="green"> 289.         self.headers = None</font>
<font color="black"> 290.         # The `CookieJar` used to create the Cookie header will be stored here</font>
<font color="black"> 291.         # after prepare_cookies is called</font>
<font color="green"> 292.         self._cookies = None</font>
<font color="black"> 293.         #: request body to send to the server.</font>
<font color="green"> 294.         self.body = None</font>
<font color="black"> 295.         #: dictionary of callback hooks, for internal usage.</font>
<font color="green"> 296.         self.hooks = default_hooks()</font>
<font color="black"> 297. </font>
<font color="green"> 298.     def prepare(self, method=None, url=None, headers=None, files=None,</font>
<font color="green"> 299.                 data=None, params=None, auth=None, cookies=None, hooks=None,</font>
<font color="green"> 300.                 json=None):</font>
<font color="black"> 301.         &quot;&quot;&quot;Prepares the entire request with the given parameters.&quot;&quot;&quot;</font>
<font color="black"> 302. </font>
<font color="red"> 303.         self.prepare_method(method)</font>
<font color="red"> 304.         self.prepare_url(url, params)</font>
<font color="red"> 305.         self.prepare_headers(headers)</font>
<font color="red"> 306.         self.prepare_cookies(cookies)</font>
<font color="red"> 307.         self.prepare_body(data, files, json)</font>
<font color="red"> 308.         self.prepare_auth(auth, url)</font>
<font color="black"> 309.         # Note that prepare_auth must be last to enable authentication schemes</font>
<font color="black"> 310.         # such as OAuth to work on a fully prepared request.</font>
<font color="black"> 311. </font>
<font color="black"> 312.         # This MUST go after prepare_auth. Authenticators could add a hook</font>
<font color="red"> 313.         self.prepare_hooks(hooks)</font>
<font color="black"> 314. </font>
<font color="green"> 315.     def __repr__(self):</font>
<font color="red"> 316.         return '&lt;PreparedRequest [%s]&gt;' % (self.method)</font>
<font color="black"> 317. </font>
<font color="green"> 318.     def copy(self):</font>
<font color="red"> 319.         p = PreparedRequest()</font>
<font color="red"> 320.         p.method = self.method</font>
<font color="red"> 321.         p.url = self.url</font>
<font color="red"> 322.         p.headers = self.headers.copy() if self.headers is not None else None</font>
<font color="red"> 323.         p._cookies = _copy_cookie_jar(self._cookies)</font>
<font color="red"> 324.         p.body = self.body</font>
<font color="red"> 325.         p.hooks = self.hooks</font>
<font color="red"> 326.         return p</font>
<font color="black"> 327. </font>
<font color="green"> 328.     def prepare_method(self, method):</font>
<font color="black"> 329.         &quot;&quot;&quot;Prepares the given HTTP method.&quot;&quot;&quot;</font>
<font color="green"> 330.         self.method = method</font>
<font color="green"> 331.         if self.method is not None:</font>
<font color="green"> 332.             self.method = self.method.upper()</font>
<font color="black"> 333. </font>
<font color="green"> 334.     def prepare_url(self, url, params):</font>
<font color="black"> 335.         &quot;&quot;&quot;Prepares the given HTTP URL.&quot;&quot;&quot;</font>
<font color="black"> 336.         #: Accept objects that have string representations.</font>
<font color="black"> 337.         #: We're unable to blindy call unicode/str functions</font>
<font color="black"> 338.         #: as this will include the bytestring indicator (b'')</font>
<font color="black"> 339.         #: on python 3.x.</font>
<font color="black"> 340.         #: https://github.com/kennethreitz/requests/pull/2238</font>
<font color="green"> 341.         if isinstance(url, bytes):</font>
<font color="red"> 342.             url = url.decode('utf8')</font>
<font color="black"> 343.         else:</font>
<font color="green"> 344.             url = unicode(url) if is_py2 else str(url)</font>
<font color="black"> 345. </font>
<font color="black"> 346.         # Don't do any URL preparation for non-HTTP schemes like `mailto`,</font>
<font color="black"> 347.         # `data` etc to work around exceptions from `url_parse`, which</font>
<font color="black"> 348.         # handles RFC 3986 only.</font>
<font color="green"> 349.         if ':' in url and not url.lower().startswith('http'):</font>
<font color="red"> 350.             self.url = url</font>
<font color="red"> 351.             return</font>
<font color="black"> 352. </font>
<font color="black"> 353.         # Support for unicode domain names and paths.</font>
<font color="green"> 354.         try:</font>
<font color="green"> 355.             scheme, auth, host, port, path, query, fragment = parse_url(url)</font>
<font color="red"> 356.         except LocationParseError as e:</font>
<font color="red"> 357.             raise InvalidURL(*e.args)</font>
<font color="black"> 358. </font>
<font color="green"> 359.         if not scheme:</font>
<font color="red"> 360.             raise MissingSchema(&quot;Invalid URL {0!r}: No schema supplied. &quot;</font>
<font color="black"> 361.                                 &quot;Perhaps you meant http://{0}?&quot;.format(</font>
<font color="red"> 362.                                     to_native_string(url, 'utf8')))</font>
<font color="black"> 363. </font>
<font color="green"> 364.         if not host:</font>
<font color="red"> 365.             raise InvalidURL(&quot;Invalid URL %r: No host supplied&quot; % url)</font>
<font color="black"> 366. </font>
<font color="black"> 367.         # Only want to apply IDNA to the hostname</font>
<font color="green"> 368.         try:</font>
<font color="green"> 369.             host = host.encode('idna').decode('utf-8')</font>
<font color="red"> 370.         except UnicodeError:</font>
<font color="red"> 371.             raise InvalidURL('URL has an invalid label.')</font>
<font color="black"> 372. </font>
<font color="black"> 373.         # Carefully reconstruct the network location</font>
<font color="green"> 374.         netloc = auth or ''</font>
<font color="green"> 375.         if netloc:</font>
<font color="red"> 376.             netloc += '@'</font>
<font color="green"> 377.         netloc += host</font>
<font color="green"> 378.         if port:</font>
<font color="red"> 379.             netloc += ':' + str(port)</font>
<font color="black"> 380. </font>
<font color="black"> 381.         # Bare domains aren't valid URLs.</font>
<font color="green"> 382.         if not path:</font>
<font color="red"> 383.             path = '/'</font>
<font color="black"> 384. </font>
<font color="green"> 385.         if is_py2:</font>
<font color="green"> 386.             if isinstance(scheme, str):</font>
<font color="green"> 387.                 scheme = scheme.encode('utf-8')</font>
<font color="green"> 388.             if isinstance(netloc, str):</font>
<font color="green"> 389.                 netloc = netloc.encode('utf-8')</font>
<font color="green"> 390.             if isinstance(path, str):</font>
<font color="green"> 391.                 path = path.encode('utf-8')</font>
<font color="green"> 392.             if isinstance(query, str):</font>
<font color="green"> 393.                 query = query.encode('utf-8')</font>
<font color="green"> 394.             if isinstance(fragment, str):</font>
<font color="red"> 395.                 fragment = fragment.encode('utf-8')</font>
<font color="black"> 396. </font>
<font color="green"> 397.         enc_params = self._encode_params(params)</font>
<font color="green"> 398.         if enc_params:</font>
<font color="red"> 399.             if query:</font>
<font color="red"> 400.                 query = '%s&amp;%s' % (query, enc_params)</font>
<font color="black"> 401.             else:</font>
<font color="red"> 402.                 query = enc_params</font>
<font color="black"> 403. </font>
<font color="green"> 404.         url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))</font>
<font color="green"> 405.         self.url = url</font>
<font color="black"> 406. </font>
<font color="green"> 407.     def prepare_headers(self, headers):</font>
<font color="black"> 408.         &quot;&quot;&quot;Prepares the given HTTP headers.&quot;&quot;&quot;</font>
<font color="black"> 409. </font>
<font color="green"> 410.         if headers:</font>
<font color="green"> 411.             self.headers = CaseInsensitiveDict((to_native_string(name), value) for name, value in headers.items())</font>
<font color="black"> 412.         else:</font>
<font color="green"> 413.             self.headers = CaseInsensitiveDict()</font>
<font color="black"> 414. </font>
<font color="green"> 415.     def prepare_body(self, data, files, json=None):</font>
<font color="black"> 416.         &quot;&quot;&quot;Prepares the given HTTP body data.&quot;&quot;&quot;</font>
<font color="black"> 417. </font>
<font color="black"> 418.         # Check if file, fo, generator, iterator.</font>
<font color="black"> 419.         # If not, run through normal process.</font>
<font color="black"> 420. </font>
<font color="black"> 421.         # Nottin' on you.</font>
<font color="green"> 422.         body = None</font>
<font color="green"> 423.         content_type = None</font>
<font color="green"> 424.         length = None</font>
<font color="black"> 425. </font>
<font color="green"> 426.         if json is not None:</font>
<font color="red"> 427.             content_type = 'application/json'</font>
<font color="red"> 428.             body = json_dumps(json)</font>
<font color="black"> 429. </font>
<font color="green"> 430.         is_stream = all([</font>
<font color="green"> 431.             hasattr(data, '__iter__'),</font>
<font color="green"> 432.             not isinstance(data, (basestring, list, tuple, dict))</font>
<font color="black"> 433.         ])</font>
<font color="black"> 434. </font>
<font color="green"> 435.         try:</font>
<font color="green"> 436.             length = super_len(data)</font>
<font color="red"> 437.         except (TypeError, AttributeError, UnsupportedOperation):</font>
<font color="red"> 438.             length = None</font>
<font color="black"> 439. </font>
<font color="green"> 440.         if is_stream:</font>
<font color="red"> 441.             body = data</font>
<font color="black"> 442. </font>
<font color="red"> 443.             if files:</font>
<font color="red"> 444.                 raise NotImplementedError('Streamed bodies and files are mutually exclusive.')</font>
<font color="black"> 445. </font>
<font color="red"> 446.             if length is not None:</font>
<font color="red"> 447.                 self.headers['Content-Length'] = builtin_str(length)</font>
<font color="black"> 448.             else:</font>
<font color="red"> 449.                 self.headers['Transfer-Encoding'] = 'chunked'</font>
<font color="black"> 450.         else:</font>
<font color="black"> 451.             # Multi-part file uploads.</font>
<font color="green"> 452.             if files:</font>
<font color="red"> 453.                 (body, content_type) = self._encode_files(files, data)</font>
<font color="black"> 454.             else:</font>
<font color="green"> 455.                 if data and json is None:</font>
<font color="green"> 456.                     body = self._encode_params(data)</font>
<font color="green"> 457.                     if isinstance(data, basestring) or hasattr(data, 'read'):</font>
<font color="green"> 458.                         content_type = None</font>
<font color="black"> 459.                     else:</font>
<font color="red"> 460.                         content_type = 'application/x-www-form-urlencoded'</font>
<font color="black"> 461. </font>
<font color="green"> 462.             self.prepare_content_length(body)</font>
<font color="black"> 463. </font>
<font color="black"> 464.             # Add content-type if it wasn't explicitly provided.</font>
<font color="green"> 465.             if content_type and ('content-type' not in self.headers):</font>
<font color="red"> 466.                 self.headers['Content-Type'] = content_type</font>
<font color="black"> 467. </font>
<font color="green"> 468.         self.body = body</font>
<font color="black"> 469. </font>
<font color="green"> 470.     def prepare_content_length(self, body):</font>
<font color="green"> 471.         if hasattr(body, 'seek') and hasattr(body, 'tell'):</font>
<font color="red"> 472.             body.seek(0, 2)</font>
<font color="red"> 473.             self.headers['Content-Length'] = builtin_str(body.tell())</font>
<font color="red"> 474.             body.seek(0, 0)</font>
<font color="green"> 475.         elif body is not None:</font>
<font color="green"> 476.             l = super_len(body)</font>
<font color="green"> 477.             if l:</font>
<font color="green"> 478.                 self.headers['Content-Length'] = builtin_str(l)</font>
<font color="green"> 479.         elif (self.method not in ('GET', 'HEAD')) and (self.headers.get('Content-Length') is None):</font>
<font color="green"> 480.             self.headers['Content-Length'] = '0'</font>
<font color="black"> 481. </font>
<font color="green"> 482.     def prepare_auth(self, auth, url=''):</font>
<font color="black"> 483.         &quot;&quot;&quot;Prepares the given HTTP auth data.&quot;&quot;&quot;</font>
<font color="black"> 484. </font>
<font color="black"> 485.         # If no Auth is explicitly provided, extract it from the URL first.</font>
<font color="green"> 486.         if auth is None:</font>
<font color="green"> 487.             url_auth = get_auth_from_url(self.url)</font>
<font color="green"> 488.             auth = url_auth if any(url_auth) else None</font>
<font color="black"> 489. </font>
<font color="green"> 490.         if auth:</font>
<font color="red"> 491.             if isinstance(auth, tuple) and len(auth) == 2:</font>
<font color="black"> 492.                 # special-case basic HTTP auth</font>
<font color="red"> 493.                 auth = HTTPBasicAuth(*auth)</font>
<font color="black"> 494. </font>
<font color="black"> 495.             # Allow auth to make its changes.</font>
<font color="red"> 496.             r = auth(self)</font>
<font color="black"> 497. </font>
<font color="black"> 498.             # Update self to reflect the auth changes.</font>
<font color="red"> 499.             self.__dict__.update(r.__dict__)</font>
<font color="black"> 500. </font>
<font color="black"> 501.             # Recompute Content-Length</font>
<font color="red"> 502.             self.prepare_content_length(self.body)</font>
<font color="black"> 503. </font>
<font color="green"> 504.     def prepare_cookies(self, cookies):</font>
<font color="black"> 505.         &quot;&quot;&quot;Prepares the given HTTP cookie data.</font>
<font color="black"> 506. </font>
<font color="black"> 507.         This function eventually generates a ``Cookie`` header from the</font>
<font color="black"> 508.         given cookies using cookielib. Due to cookielib's design, the header</font>
<font color="black"> 509.         will not be regenerated if it already exists, meaning this function</font>
<font color="black"> 510.         can only be called once for the life of the</font>
<font color="black"> 511.         :class:`PreparedRequest &lt;PreparedRequest&gt;` object. Any subsequent calls</font>
<font color="black"> 512.         to ``prepare_cookies`` will have no actual effect, unless the &quot;Cookie&quot;</font>
<font color="black"> 513.         header is removed beforehand.&quot;&quot;&quot;</font>
<font color="black"> 514. </font>
<font color="green"> 515.         if isinstance(cookies, cookielib.CookieJar):</font>
<font color="red"> 516.             self._cookies = cookies</font>
<font color="black"> 517.         else:</font>
<font color="green"> 518.             self._cookies = cookiejar_from_dict(cookies)</font>
<font color="black"> 519. </font>
<font color="green"> 520.         cookie_header = get_cookie_header(self._cookies, self)</font>
<font color="green"> 521.         if cookie_header is not None:</font>
<font color="red"> 522.             self.headers['Cookie'] = cookie_header</font>
<font color="black"> 523. </font>
<font color="green"> 524.     def prepare_hooks(self, hooks):</font>
<font color="black"> 525.         &quot;&quot;&quot;Prepares the given hooks.&quot;&quot;&quot;</font>
<font color="black"> 526.         # hooks can be passed as None to the prepare method and to this</font>
<font color="black"> 527.         # method. To prevent iterating over None, simply use an empty list</font>
<font color="black"> 528.         # if hooks is False-y</font>
<font color="red"> 529.         hooks = hooks or []</font>
<font color="red"> 530.         for event in hooks:</font>
<font color="red"> 531.             self.register_hook(event, hooks[event])</font>
<font color="black"> 532. </font>
<font color="black"> 533. </font>
<font color="green"> 534. class Response(object):</font>
<font color="black"> 535.     &quot;&quot;&quot;The :class:`Response &lt;Response&gt;` object, which contains a</font>
<font color="black"> 536.     server's response to an HTTP request.</font>
<font color="green"> 537.     &quot;&quot;&quot;</font>
<font color="black"> 538. </font>
<font color="black"> 539.     __attrs__ = [</font>
<font color="green"> 540.         '_content',</font>
<font color="green"> 541.         'status_code',</font>
<font color="green"> 542.         'headers',</font>
<font color="green"> 543.         'url',</font>
<font color="green"> 544.         'history',</font>
<font color="green"> 545.         'encoding',</font>
<font color="green"> 546.         'reason',</font>
<font color="green"> 547.         'cookies',</font>
<font color="green"> 548.         'elapsed',</font>
<font color="green"> 549.         'request',</font>
<font color="black"> 550.     ]</font>
<font color="black"> 551. </font>
<font color="green"> 552.     def __init__(self):</font>
<font color="green"> 553.         super(Response, self).__init__()</font>
<font color="black"> 554. </font>
<font color="green"> 555.         self._content = False</font>
<font color="green"> 556.         self._content_consumed = False</font>
<font color="black"> 557. </font>
<font color="black"> 558.         #: Integer Code of responded HTTP Status, e.g. 404 or 200.</font>
<font color="green"> 559.         self.status_code = None</font>
<font color="black"> 560. </font>
<font color="black"> 561.         #: Case-insensitive Dictionary of Response Headers.</font>
<font color="black"> 562.         #: For example, ``headers['content-encoding']`` will return the</font>
<font color="black"> 563.         #: value of a ``'Content-Encoding'`` response header.</font>
<font color="green"> 564.         self.headers = CaseInsensitiveDict()</font>
<font color="black"> 565. </font>
<font color="black"> 566.         #: File-like object representation of response (for advanced usage).</font>
<font color="black"> 567.         #: Use of ``raw`` requires that ``stream=True`` be set on the request.</font>
<font color="black"> 568.         # This requirement does not apply for use internally to Requests.</font>
<font color="green"> 569.         self.raw = None</font>
<font color="black"> 570. </font>
<font color="black"> 571.         #: Final URL location of Response.</font>
<font color="green"> 572.         self.url = None</font>
<font color="black"> 573. </font>
<font color="black"> 574.         #: Encoding to decode with when accessing r.text.</font>
<font color="green"> 575.         self.encoding = None</font>
<font color="black"> 576. </font>
<font color="black"> 577.         #: A list of :class:`Response &lt;Response&gt;` objects from</font>
<font color="black"> 578.         #: the history of the Request. Any redirect responses will end</font>
<font color="black"> 579.         #: up here. The list is sorted from the oldest to the most recent request.</font>
<font color="green"> 580.         self.history = []</font>
<font color="black"> 581. </font>
<font color="black"> 582.         #: Textual reason of responded HTTP Status, e.g. &quot;Not Found&quot; or &quot;OK&quot;.</font>
<font color="green"> 583.         self.reason = None</font>
<font color="black"> 584. </font>
<font color="black"> 585.         #: A CookieJar of Cookies the server sent back.</font>
<font color="green"> 586.         self.cookies = cookiejar_from_dict({})</font>
<font color="black"> 587. </font>
<font color="black"> 588.         #: The amount of time elapsed between sending the request</font>
<font color="black"> 589.         #: and the arrival of the response (as a timedelta).</font>
<font color="black"> 590.         #: This property specifically measures the time taken between sending</font>
<font color="black"> 591.         #: the first byte of the request and finishing parsing the headers. It</font>
<font color="black"> 592.         #: is therefore unaffected by consuming the response content or the</font>
<font color="black"> 593.         #: value of the ``stream`` keyword argument.</font>
<font color="green"> 594.         self.elapsed = datetime.timedelta(0)</font>
<font color="black"> 595. </font>
<font color="black"> 596.         #: The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to which this</font>
<font color="black"> 597.         #: is a response.</font>
<font color="green"> 598.         self.request = None</font>
<font color="black"> 599. </font>
<font color="green"> 600.     def __getstate__(self):</font>
<font color="black"> 601.         # Consume everything; accessing the content attribute makes</font>
<font color="black"> 602.         # sure the content has been fully read.</font>
<font color="red"> 603.         if not self._content_consumed:</font>
<font color="red"> 604.             self.content</font>
<font color="black"> 605. </font>
<font color="red"> 606.         return dict(</font>
<font color="red"> 607.             (attr, getattr(self, attr, None))</font>
<font color="red"> 608.             for attr in self.__attrs__</font>
<font color="black"> 609.         )</font>
<font color="black"> 610. </font>
<font color="green"> 611.     def __setstate__(self, state):</font>
<font color="red"> 612.         for name, value in state.items():</font>
<font color="red"> 613.             setattr(self, name, value)</font>
<font color="black"> 614. </font>
<font color="black"> 615.         # pickled objects do not have .raw</font>
<font color="red"> 616.         setattr(self, '_content_consumed', True)</font>
<font color="red"> 617.         setattr(self, 'raw', None)</font>
<font color="black"> 618. </font>
<font color="green"> 619.     def __repr__(self):</font>
<font color="red"> 620.         return '&lt;Response [%s]&gt;' % (self.status_code)</font>
<font color="black"> 621. </font>
<font color="green"> 622.     def __bool__(self):</font>
<font color="black"> 623.         &quot;&quot;&quot;Returns true if :attr:`status_code` is 'OK'.&quot;&quot;&quot;</font>
<font color="red"> 624.         return self.ok</font>
<font color="black"> 625. </font>
<font color="green"> 626.     def __nonzero__(self):</font>
<font color="black"> 627.         &quot;&quot;&quot;Returns true if :attr:`status_code` is 'OK'.&quot;&quot;&quot;</font>
<font color="red"> 628.         return self.ok</font>
<font color="black"> 629. </font>
<font color="green"> 630.     def __iter__(self):</font>
<font color="black"> 631.         &quot;&quot;&quot;Allows you to use a response as an iterator.&quot;&quot;&quot;</font>
<font color="red"> 632.         return self.iter_content(128)</font>
<font color="black"> 633. </font>
<font color="green"> 634.     @property</font>
<font color="black"> 635.     def ok(self):</font>
<font color="red"> 636.         try:</font>
<font color="red"> 637.             self.raise_for_status()</font>
<font color="red"> 638.         except HTTPError:</font>
<font color="red"> 639.             return False</font>
<font color="red"> 640.         return True</font>
<font color="black"> 641. </font>
<font color="green"> 642.     @property</font>
<font color="black"> 643.     def is_redirect(self):</font>
<font color="black"> 644.         &quot;&quot;&quot;True if this Response is a well-formed HTTP redirect that could have</font>
<font color="black"> 645.         been processed automatically (by :meth:`Session.resolve_redirects`).</font>
<font color="black"> 646.         &quot;&quot;&quot;</font>
<font color="green"> 647.         return ('location' in self.headers and self.status_code in REDIRECT_STATI)</font>
<font color="black"> 648. </font>
<font color="green"> 649.     @property</font>
<font color="black"> 650.     def is_permanent_redirect(self):</font>
<font color="black"> 651.         &quot;&quot;&quot;True if this Response one of the permanant versions of redirect&quot;&quot;&quot;</font>
<font color="red"> 652.         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))</font>
<font color="black"> 653. </font>
<font color="green"> 654.     @property</font>
<font color="black"> 655.     def apparent_encoding(self):</font>
<font color="black"> 656.         &quot;&quot;&quot;The apparent encoding, provided by the chardet library&quot;&quot;&quot;</font>
<font color="red"> 657.         return chardet.detect(self.content)['encoding']</font>
<font color="black"> 658. </font>
<font color="green"> 659.     def iter_content(self, chunk_size=1, decode_unicode=False):</font>
<font color="black"> 660.         &quot;&quot;&quot;Iterates over the response data.  When stream=True is set on the</font>
<font color="black"> 661.         request, this avoids reading the content at once into memory for</font>
<font color="black"> 662.         large responses.  The chunk size is the number of bytes it should</font>
<font color="black"> 663.         read into memory.  This is not necessarily the length of each item</font>
<font color="black"> 664.         returned as decoding can take place.</font>
<font color="black"> 665. </font>
<font color="black"> 666.         If decode_unicode is True, content will be decoded using the best</font>
<font color="black"> 667.         available encoding based on the response.</font>
<font color="black"> 668.         &quot;&quot;&quot;</font>
<font color="green"> 669.         def generate():</font>
<font color="green"> 670.             try:</font>
<font color="black"> 671.                 # Special case for urllib3.</font>
<font color="green"> 672.                 try:</font>
<font color="green"> 673.                     for chunk in self.raw.stream(chunk_size, decode_content=True):</font>
<font color="green"> 674.                         yield chunk</font>
<font color="red"> 675.                 except ProtocolError as e:</font>
<font color="red"> 676.                     raise ChunkedEncodingError(e)</font>
<font color="red"> 677.                 except DecodeError as e:</font>
<font color="red"> 678.                     raise ContentDecodingError(e)</font>
<font color="red"> 679.                 except ReadTimeoutError as e:</font>
<font color="red"> 680.                     raise ConnectionError(e)</font>
<font color="red"> 681.             except AttributeError:</font>
<font color="black"> 682.                 # Standard file-like object.</font>
<font color="red"> 683.                 while True:</font>
<font color="red"> 684.                     chunk = self.raw.read(chunk_size)</font>
<font color="red"> 685.                     if not chunk:</font>
<font color="red"> 686.                         break</font>
<font color="red"> 687.                     yield chunk</font>
<font color="black"> 688. </font>
<font color="green"> 689.             self._content_consumed = True</font>
<font color="black"> 690. </font>
<font color="green"> 691.         if self._content_consumed and isinstance(self._content, bool):</font>
<font color="red"> 692.             raise StreamConsumedError()</font>
<font color="black"> 693.         # simulate reading small chunks of the content</font>
<font color="green"> 694.         reused_chunks = iter_slices(self._content, chunk_size)</font>
<font color="black"> 695. </font>
<font color="green"> 696.         stream_chunks = generate()</font>
<font color="black"> 697. </font>
<font color="green"> 698.         chunks = reused_chunks if self._content_consumed else stream_chunks</font>
<font color="black"> 699. </font>
<font color="green"> 700.         if decode_unicode:</font>
<font color="red"> 701.             chunks = stream_decode_response_unicode(chunks, self)</font>
<font color="black"> 702. </font>
<font color="green"> 703.         return chunks</font>
<font color="black"> 704. </font>
<font color="green"> 705.     def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=None, delimiter=None):</font>
<font color="black"> 706.         &quot;&quot;&quot;Iterates over the response data, one line at a time.  When</font>
<font color="black"> 707.         stream=True is set on the request, this avoids reading the</font>
<font color="black"> 708.         content at once into memory for large responses.</font>
<font color="black"> 709. </font>
<font color="black"> 710.         .. note:: This method is not reentrant safe.</font>
<font color="black"> 711.         &quot;&quot;&quot;</font>
<font color="black"> 712. </font>
<font color="red"> 713.         pending = None</font>
<font color="black"> 714. </font>
<font color="red"> 715.         for chunk in self.iter_content(chunk_size=chunk_size, decode_unicode=decode_unicode):</font>
<font color="black"> 716. </font>
<font color="red"> 717.             if pending is not None:</font>
<font color="red"> 718.                 chunk = pending + chunk</font>
<font color="black"> 719. </font>
<font color="red"> 720.             if delimiter:</font>
<font color="red"> 721.                 lines = chunk.split(delimiter)</font>
<font color="black"> 722.             else:</font>
<font color="red"> 723.                 lines = chunk.splitlines()</font>
<font color="black"> 724. </font>
<font color="red"> 725.             if lines and lines[-1] and chunk and lines[-1][-1] == chunk[-1]:</font>
<font color="red"> 726.                 pending = lines.pop()</font>
<font color="black"> 727.             else:</font>
<font color="red"> 728.                 pending = None</font>
<font color="black"> 729. </font>
<font color="red"> 730.             for line in lines:</font>
<font color="red"> 731.                 yield line</font>
<font color="black"> 732. </font>
<font color="red"> 733.         if pending is not None:</font>
<font color="red"> 734.             yield pending</font>
<font color="black"> 735. </font>
<font color="green"> 736.     @property</font>
<font color="black"> 737.     def content(self):</font>
<font color="black"> 738.         &quot;&quot;&quot;Content of the response, in bytes.&quot;&quot;&quot;</font>
<font color="black"> 739. </font>
<font color="green"> 740.         if self._content is False:</font>
<font color="black"> 741.             # Read the contents.</font>
<font color="green"> 742.             try:</font>
<font color="green"> 743.                 if self._content_consumed:</font>
<font color="red"> 744.                     raise RuntimeError(</font>
<font color="red"> 745.                         'The content for this response was already consumed')</font>
<font color="black"> 746. </font>
<font color="green"> 747.                 if self.status_code == 0:</font>
<font color="red"> 748.                     self._content = None</font>
<font color="black"> 749.                 else:</font>
<font color="green"> 750.                     self._content = bytes().join(self.iter_content(CONTENT_CHUNK_SIZE)) or bytes()</font>
<font color="black"> 751. </font>
<font color="red"> 752.             except AttributeError:</font>
<font color="red"> 753.                 self._content = None</font>
<font color="black"> 754. </font>
<font color="green"> 755.         self._content_consumed = True</font>
<font color="black"> 756.         # don't need to release the connection; that's been handled by urllib3</font>
<font color="black"> 757.         # since we exhausted the data.</font>
<font color="green"> 758.         return self._content</font>
<font color="black"> 759. </font>
<font color="green"> 760.     @property</font>
<font color="black"> 761.     def text(self):</font>
<font color="black"> 762.         &quot;&quot;&quot;Content of the response, in unicode.</font>
<font color="black"> 763. </font>
<font color="black"> 764.         If Response.encoding is None, encoding will be guessed using</font>
<font color="black"> 765.         ``chardet``.</font>
<font color="black"> 766. </font>
<font color="black"> 767.         The encoding of the response content is determined based solely on HTTP</font>
<font color="black"> 768.         headers, following RFC 2616 to the letter. If you can take advantage of</font>
<font color="black"> 769.         non-HTTP knowledge to make a better guess at the encoding, you should</font>
<font color="black"> 770.         set ``r.encoding`` appropriately before accessing this property.</font>
<font color="black"> 771.         &quot;&quot;&quot;</font>
<font color="black"> 772. </font>
<font color="black"> 773.         # Try charset from content-type</font>
<font color="red"> 774.         content = None</font>
<font color="red"> 775.         encoding = self.encoding</font>
<font color="black"> 776. </font>
<font color="red"> 777.         if not self.content:</font>
<font color="red"> 778.             return str('')</font>
<font color="black"> 779. </font>
<font color="black"> 780.         # Fallback to auto-detected encoding.</font>
<font color="red"> 781.         if self.encoding is None:</font>
<font color="red"> 782.             encoding = self.apparent_encoding</font>
<font color="black"> 783. </font>
<font color="black"> 784.         # Decode unicode from given encoding.</font>
<font color="red"> 785.         try:</font>
<font color="red"> 786.             content = str(self.content, encoding, errors='replace')</font>
<font color="red"> 787.         except (LookupError, TypeError):</font>
<font color="black"> 788.             # A LookupError is raised if the encoding was not found which could</font>
<font color="black"> 789.             # indicate a misspelling or similar mistake.</font>
<font color="black"> 790.             #</font>
<font color="black"> 791.             # A TypeError can be raised if encoding is None</font>
<font color="black"> 792.             #</font>
<font color="black"> 793.             # So we try blindly encoding.</font>
<font color="red"> 794.             content = str(self.content, errors='replace')</font>
<font color="black"> 795. </font>
<font color="red"> 796.         return content</font>
<font color="black"> 797. </font>
<font color="green"> 798.     def json(self, **kwargs):</font>
<font color="black"> 799.         &quot;&quot;&quot;Returns the json-encoded content of a response, if any.</font>
<font color="black"> 800. </font>
<font color="black"> 801.         :param \*\*kwargs: Optional arguments that ``json.loads`` takes.</font>
<font color="black"> 802.         &quot;&quot;&quot;</font>
<font color="black"> 803. </font>
<font color="red"> 804.         if not self.encoding and len(self.content) &gt; 3:</font>
<font color="black"> 805.             # No encoding set. JSON RFC 4627 section 3 states we should expect</font>
<font color="black"> 806.             # UTF-8, -16 or -32. Detect which one to use; If the detection or</font>
<font color="black"> 807.             # decoding fails, fall back to `self.text` (using chardet to make</font>
<font color="black"> 808.             # a best guess).</font>
<font color="red"> 809.             encoding = guess_json_utf(self.content)</font>
<font color="red"> 810.             if encoding is not None:</font>
<font color="red"> 811.                 try:</font>
<font color="red"> 812.                     return json.loads(self.content.decode(encoding), **kwargs)</font>
<font color="red"> 813.                 except UnicodeDecodeError:</font>
<font color="black"> 814.                     # Wrong UTF codec detected; usually because it's not UTF-8</font>
<font color="black"> 815.                     # but some other 8-bit codec.  This is an RFC violation,</font>
<font color="black"> 816.                     # and the server didn't bother to tell us what codec *was*</font>
<font color="black"> 817.                     # used.</font>
<font color="red"> 818.                     pass</font>
<font color="red"> 819.         return json.loads(self.text, **kwargs)</font>
<font color="black"> 820. </font>
<font color="green"> 821.     @property</font>
<font color="black"> 822.     def links(self):</font>
<font color="black"> 823.         &quot;&quot;&quot;Returns the parsed header links of the response, if any.&quot;&quot;&quot;</font>
<font color="black"> 824. </font>
<font color="red"> 825.         header = self.headers.get('link')</font>
<font color="black"> 826. </font>
<font color="black"> 827.         # l = MultiDict()</font>
<font color="red"> 828.         l = {}</font>
<font color="black"> 829. </font>
<font color="red"> 830.         if header:</font>
<font color="red"> 831.             links = parse_header_links(header)</font>
<font color="black"> 832. </font>
<font color="red"> 833.             for link in links:</font>
<font color="red"> 834.                 key = link.get('rel') or link.get('url')</font>
<font color="red"> 835.                 l[key] = link</font>
<font color="black"> 836. </font>
<font color="red"> 837.         return l</font>
<font color="black"> 838. </font>
<font color="green"> 839.     def raise_for_status(self):</font>
<font color="black"> 840.         &quot;&quot;&quot;Raises stored :class:`HTTPError`, if one occurred.&quot;&quot;&quot;</font>
<font color="black"> 841. </font>
<font color="red"> 842.         http_error_msg = ''</font>
<font color="black"> 843. </font>
<font color="red"> 844.         if 400 &lt;= self.status_code &lt; 500:</font>
<font color="red"> 845.             http_error_msg = '%s Client Error: %s' % (self.status_code, self.reason)</font>
<font color="black"> 846. </font>
<font color="red"> 847.         elif 500 &lt;= self.status_code &lt; 600:</font>
<font color="red"> 848.             http_error_msg = '%s Server Error: %s' % (self.status_code, self.reason)</font>
<font color="black"> 849. </font>
<font color="red"> 850.         if http_error_msg:</font>
<font color="red"> 851.             raise HTTPError(http_error_msg, response=self)</font>
<font color="black"> 852. </font>
<font color="green"> 853.     def close(self):</font>
<font color="black"> 854.         &quot;&quot;&quot;Releases the connection back to the pool. Once this method has been</font>
<font color="black"> 855.         called the underlying ``raw`` object must not be accessed again.</font>
<font color="black"> 856. </font>
<font color="black"> 857.         *Note: Should not normally need to be called explicitly.*</font>
<font color="black"> 858.         &quot;&quot;&quot;</font>
<font color="red"> 859.         return self.raw.release_conn()</font>
</pre>

