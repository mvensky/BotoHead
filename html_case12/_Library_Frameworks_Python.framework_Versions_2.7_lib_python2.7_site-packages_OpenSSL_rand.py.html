source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/OpenSSL/rand.py</b><br>


file stats: <b>61 lines, 23 executed: 37.7% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;</font>
<font color="black">   2. PRNG management routines, thin wrappers.</font>
<font color="green">   3. &quot;&quot;&quot;</font>
<font color="black">   4. </font>
<font color="green">   5. import os</font>
<font color="green">   6. import warnings</font>
<font color="black">   7. </font>
<font color="green">   8. from functools import partial</font>
<font color="black">   9. </font>
<font color="green">  10. from six import integer_types as _integer_types</font>
<font color="black">  11. </font>
<font color="green">  12. from OpenSSL._util import (</font>
<font color="black">  13.     ffi as _ffi,</font>
<font color="black">  14.     lib as _lib,</font>
<font color="black">  15.     exception_from_error_queue as _exception_from_error_queue,</font>
<font color="black">  16.     path_string as _path_string)</font>
<font color="black">  17. </font>
<font color="black">  18. </font>
<font color="green">  19. class Error(Exception):</font>
<font color="black">  20.     &quot;&quot;&quot;</font>
<font color="black">  21.     An error occurred in an :mod:`OpenSSL.rand` API.</font>
<font color="black">  22. </font>
<font color="black">  23.     If the current RAND method supports any errors, this is raised when needed.</font>
<font color="black">  24.     The default method does not raise this when the entropy pool is depleted.</font>
<font color="black">  25. </font>
<font color="black">  26.     Whenever this exception is raised directly, it has a list of error messages</font>
<font color="black">  27.     from the OpenSSL error queue, where each item is a tuple *(lib, function,</font>
<font color="black">  28.     reason)*. Here *lib*, *function* and *reason* are all strings, describing</font>
<font color="black">  29.     where and what the problem is.</font>
<font color="black">  30. </font>
<font color="black">  31.     See :manpage:`err(3)` for more information.</font>
<font color="green">  32.     &quot;&quot;&quot;</font>
<font color="black">  33. </font>
<font color="green">  34. _raise_current_error = partial(_exception_from_error_queue, Error)</font>
<font color="black">  35. </font>
<font color="green">  36. _unspecified = object()</font>
<font color="black">  37. </font>
<font color="green">  38. _builtin_bytes = bytes</font>
<font color="black">  39. </font>
<font color="black">  40. </font>
<font color="green">  41. def bytes(num_bytes):</font>
<font color="black">  42.     &quot;&quot;&quot;</font>
<font color="black">  43.     Get some random bytes from the PRNG as a string.</font>
<font color="black">  44. </font>
<font color="black">  45.     This is a wrapper for the C function ``RAND_bytes``.</font>
<font color="black">  46. </font>
<font color="black">  47.     :param num_bytes: The number of bytes to fetch.</font>
<font color="black">  48. </font>
<font color="black">  49.     :return: A string of random bytes.</font>
<font color="black">  50.     &quot;&quot;&quot;</font>
<font color="red">  51.     if not isinstance(num_bytes, _integer_types):</font>
<font color="red">  52.         raise TypeError(&quot;num_bytes must be an integer&quot;)</font>
<font color="black">  53. </font>
<font color="red">  54.     if num_bytes &lt; 0:</font>
<font color="red">  55.         raise ValueError(&quot;num_bytes must not be negative&quot;)</font>
<font color="black">  56. </font>
<font color="red">  57.     result_buffer = _ffi.new(&quot;unsigned char[]&quot;, num_bytes)</font>
<font color="red">  58.     result_code = _lib.RAND_bytes(result_buffer, num_bytes)</font>
<font color="red">  59.     if result_code == -1:</font>
<font color="black">  60.         # TODO: No tests for this code path.  Triggering a RAND_bytes failure</font>
<font color="black">  61.         # might involve supplying a custom ENGINE?  That's hard.</font>
<font color="red">  62.         _raise_current_error()</font>
<font color="black">  63. </font>
<font color="red">  64.     return _ffi.buffer(result_buffer)[:]</font>
<font color="black">  65. </font>
<font color="black">  66. </font>
<font color="green">  67. def add(buffer, entropy):</font>
<font color="black">  68.     &quot;&quot;&quot;</font>
<font color="black">  69.     Mix bytes from *string* into the PRNG state.</font>
<font color="black">  70. </font>
<font color="black">  71.     The *entropy* argument is (the lower bound of) an estimate of how much</font>
<font color="black">  72.     randomness is contained in *string*, measured in bytes.</font>
<font color="black">  73. </font>
<font color="black">  74.     For more information, see e.g. :rfc:`1750`.</font>
<font color="black">  75. </font>
<font color="black">  76.     :param buffer: Buffer with random data.</font>
<font color="black">  77.     :param entropy: The entropy (in bytes) measurement of the buffer.</font>
<font color="black">  78. </font>
<font color="black">  79.     :return: :obj:`None`</font>
<font color="black">  80.     &quot;&quot;&quot;</font>
<font color="red">  81.     if not isinstance(buffer, _builtin_bytes):</font>
<font color="red">  82.         raise TypeError(&quot;buffer must be a byte string&quot;)</font>
<font color="black">  83. </font>
<font color="red">  84.     if not isinstance(entropy, int):</font>
<font color="red">  85.         raise TypeError(&quot;entropy must be an integer&quot;)</font>
<font color="black">  86. </font>
<font color="black">  87.     # TODO Nothing tests this call actually being made, or made properly.</font>
<font color="red">  88.     _lib.RAND_add(buffer, len(buffer), entropy)</font>
<font color="black">  89. </font>
<font color="black">  90. </font>
<font color="green">  91. def seed(buffer):</font>
<font color="black">  92.     &quot;&quot;&quot;</font>
<font color="black">  93.     Equivalent to calling :func:`add` with *entropy* as the length of *buffer*.</font>
<font color="black">  94. </font>
<font color="black">  95.     :param buffer: Buffer with random data</font>
<font color="black">  96. </font>
<font color="black">  97.     :return: :obj:`None`</font>
<font color="black">  98.     &quot;&quot;&quot;</font>
<font color="red">  99.     if not isinstance(buffer, _builtin_bytes):</font>
<font color="red"> 100.         raise TypeError(&quot;buffer must be a byte string&quot;)</font>
<font color="black"> 101. </font>
<font color="black"> 102.     # TODO Nothing tests this call actually being made, or made properly.</font>
<font color="red"> 103.     _lib.RAND_seed(buffer, len(buffer))</font>
<font color="black"> 104. </font>
<font color="black"> 105. </font>
<font color="green"> 106. def status():</font>
<font color="black"> 107.     &quot;&quot;&quot;</font>
<font color="black"> 108.     Check whether the PRNG has been seeded with enough data.</font>
<font color="black"> 109. </font>
<font color="black"> 110.     :return: :obj:`True` if the PRNG is seeded enough, :obj:`False` otherwise.</font>
<font color="black"> 111.     &quot;&quot;&quot;</font>
<font color="red"> 112.     return _lib.RAND_status()</font>
<font color="black"> 113. </font>
<font color="black"> 114. </font>
<font color="green"> 115. def egd(path, bytes=_unspecified):</font>
<font color="black"> 116.     &quot;&quot;&quot;</font>
<font color="black"> 117.     Query the system random source and seed the PRNG.</font>
<font color="black"> 118. </font>
<font color="black"> 119.     Does *not* actually query the EGD.</font>
<font color="black"> 120. </font>
<font color="black"> 121.     .. deprecated:: 16.0.0</font>
<font color="black"> 122.         EGD was only necessary for some commercial UNIX systems that all</font>
<font color="black"> 123.         reached their ends of life more than a decade ago.  See</font>
<font color="black"> 124.         `pyca/cryptography#1636</font>
<font color="black"> 125.         &lt;https://github.com/pyca/cryptography/pull/1636&gt;`_.</font>
<font color="black"> 126. </font>
<font color="black"> 127.     :param path: Ignored.</font>
<font color="black"> 128.     :param bytes: (optional) The number of bytes to read, default is 255.</font>
<font color="black"> 129. </font>
<font color="black"> 130.     :returns: ``len(bytes)`` or 255 if not specified.</font>
<font color="black"> 131.     &quot;&quot;&quot;</font>
<font color="red"> 132.     warnings.warn(&quot;OpenSSL.rand.egd() is deprecated as of 16.0.0.&quot;,</font>
<font color="red"> 133.                   DeprecationWarning)</font>
<font color="black"> 134. </font>
<font color="red"> 135.     if not isinstance(path, _builtin_bytes):</font>
<font color="red"> 136.         raise TypeError(&quot;path must be a byte string&quot;)</font>
<font color="black"> 137. </font>
<font color="red"> 138.     if bytes is _unspecified:</font>
<font color="red"> 139.         bytes = 255</font>
<font color="red"> 140.     elif not isinstance(bytes, int):</font>
<font color="red"> 141.         raise TypeError(&quot;bytes must be an integer&quot;)</font>
<font color="black"> 142. </font>
<font color="red"> 143.     seed(os.urandom(bytes))</font>
<font color="red"> 144.     return bytes</font>
<font color="black"> 145. </font>
<font color="black"> 146. </font>
<font color="green"> 147. def cleanup():</font>
<font color="black"> 148.     &quot;&quot;&quot;</font>
<font color="black"> 149.     Erase the memory used by the PRNG.</font>
<font color="black"> 150. </font>
<font color="black"> 151.     This is a wrapper for the C function ``RAND_cleanup``.</font>
<font color="black"> 152. </font>
<font color="black"> 153.     :return: :obj:`None`</font>
<font color="black"> 154.     &quot;&quot;&quot;</font>
<font color="black"> 155.     # TODO Nothing tests this call actually being made, or made properly.</font>
<font color="red"> 156.     _lib.RAND_cleanup()</font>
<font color="black"> 157. </font>
<font color="black"> 158. </font>
<font color="green"> 159. def load_file(filename, maxbytes=_unspecified):</font>
<font color="black"> 160.     &quot;&quot;&quot;</font>
<font color="black"> 161.     Read *maxbytes* of data from *filename* and seed the PRNG with it.</font>
<font color="black"> 162. </font>
<font color="black"> 163.     Read the whole file if *maxbytes* is not specified or negative.</font>
<font color="black"> 164. </font>
<font color="black"> 165.     :param filename: The file to read data from (``bytes`` or ``unicode``).</font>
<font color="black"> 166.     :param maxbytes: (optional) The number of bytes to read.    Default is to</font>
<font color="black"> 167.         read the entire file.</font>
<font color="black"> 168. </font>
<font color="black"> 169.     :return: The number of bytes read</font>
<font color="black"> 170.     &quot;&quot;&quot;</font>
<font color="red"> 171.     filename = _path_string(filename)</font>
<font color="black"> 172. </font>
<font color="red"> 173.     if maxbytes is _unspecified:</font>
<font color="red"> 174.         maxbytes = -1</font>
<font color="red"> 175.     elif not isinstance(maxbytes, int):</font>
<font color="red"> 176.         raise TypeError(&quot;maxbytes must be an integer&quot;)</font>
<font color="black"> 177. </font>
<font color="red"> 178.     return _lib.RAND_load_file(filename, maxbytes)</font>
<font color="black"> 179. </font>
<font color="black"> 180. </font>
<font color="green"> 181. def write_file(filename):</font>
<font color="black"> 182.     &quot;&quot;&quot;</font>
<font color="black"> 183.     Write a number of random bytes (currently 1024) to the file *path*.  This</font>
<font color="black"> 184.     file can then be used with :func:`load_file` to seed the PRNG again.</font>
<font color="black"> 185. </font>
<font color="black"> 186.     :param filename: The file to write data to (``bytes`` or ``unicode``).</font>
<font color="black"> 187. </font>
<font color="black"> 188.     :return: The number of bytes written.</font>
<font color="black"> 189.     &quot;&quot;&quot;</font>
<font color="red"> 190.     filename = _path_string(filename)</font>
<font color="red"> 191.     return _lib.RAND_write_file(filename)</font>
<font color="black"> 192. </font>
<font color="black"> 193. </font>
<font color="black"> 194. # TODO There are no tests for screen at all</font>
<font color="green"> 195. def screen():</font>
<font color="black"> 196.     &quot;&quot;&quot;</font>
<font color="black"> 197.     Add the current contents of the screen to the PRNG state.</font>
<font color="black"> 198. </font>
<font color="black"> 199.     Availability: Windows.</font>
<font color="black"> 200. </font>
<font color="black"> 201.     :return: None</font>
<font color="black"> 202.     &quot;&quot;&quot;</font>
<font color="red"> 203.     _lib.RAND_screen()</font>
<font color="black"> 204. </font>
<font color="green"> 205. if getattr(_lib, 'RAND_screen', None) is None:</font>
<font color="green"> 206.     del screen</font>
<font color="black"> 207. </font>
<font color="black"> 208. </font>
<font color="black"> 209. # TODO There are no tests for the RAND strings being loaded, whatever that</font>
<font color="black"> 210. # means.</font>
<font color="green"> 211. _lib.ERR_load_RAND_strings()</font>
</pre>

