source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/pyasn1/compat/integer.py</b><br>


file stats: <b>60 lines, 16 executed: 26.7% covered</b>
<pre>
<font color="black">   1. #</font>
<font color="black">   2. # This file is part of pyasn1 software.</font>
<font color="black">   3. #</font>
<font color="black">   4. # Copyright (c) 2005-2017, Ilya Etingof &lt;etingof@gmail.com&gt;</font>
<font color="black">   5. # License: http://pyasn1.sf.net/license.html</font>
<font color="black">   6. #</font>
<font color="green">   7. import sys</font>
<font color="green">   8. if sys.version_info[0:2] &lt; (3, 2):</font>
<font color="green">   9.     from binascii import a2b_hex, b2a_hex</font>
<font color="green">  10. from pyasn1.compat.octets import oct2int, null</font>
<font color="black">  11. </font>
<font color="green">  12. if sys.version_info[0:2] &lt; (3, 2):</font>
<font color="green">  13.     def from_bytes(octets, signed=False):</font>
<font color="red">  14.         value = long(b2a_hex(str(octets)), 16)</font>
<font color="black">  15. </font>
<font color="red">  16.         if signed and oct2int(octets[0]) &amp; 0x80:</font>
<font color="red">  17.             return value - (1 &lt;&lt; len(octets) * 8)</font>
<font color="black">  18. </font>
<font color="red">  19.         return value</font>
<font color="black">  20. </font>
<font color="green">  21.     def to_bytes(value, signed=False, length=0):</font>
<font color="red">  22.         if value &lt; 0:</font>
<font color="red">  23.             if signed:</font>
<font color="red">  24.                 bits = bitLength(value)</font>
<font color="black">  25. </font>
<font color="black">  26.                 # two's complement form</font>
<font color="red">  27.                 maxValue = 1 &lt;&lt; bits</font>
<font color="red">  28.                 valueToEncode = (value + maxValue) % maxValue</font>
<font color="black">  29. </font>
<font color="black">  30.             else:</font>
<font color="red">  31.                 raise OverflowError('can\'t convert negative int to unsigned')</font>
<font color="red">  32.         elif value == 0 and length == 0:</font>
<font color="red">  33.             return null</font>
<font color="black">  34.         else:</font>
<font color="red">  35.             bits = 0</font>
<font color="red">  36.             valueToEncode = value</font>
<font color="black">  37. </font>
<font color="red">  38.         hexValue = hex(valueToEncode)[2:]</font>
<font color="red">  39.         if hexValue.endswith('L'):</font>
<font color="red">  40.             hexValue = hexValue[:-1]</font>
<font color="black">  41. </font>
<font color="red">  42.         if len(hexValue) &amp; 1:</font>
<font color="red">  43.             hexValue = '0' + hexValue</font>
<font color="black">  44. </font>
<font color="black">  45.         # padding may be needed for two's complement encoding</font>
<font color="red">  46.         if value != valueToEncode or length:</font>
<font color="red">  47.             hexLength = len(hexValue) * 4</font>
<font color="black">  48. </font>
<font color="red">  49.             padLength = max(length, bits)</font>
<font color="black">  50. </font>
<font color="red">  51.             if padLength &gt; hexLength:</font>
<font color="red">  52.                 hexValue = '00' * ((padLength - hexLength - 1) // 8 + 1) + hexValue</font>
<font color="red">  53.             elif length and hexLength - length &gt; 7:</font>
<font color="red">  54.                 raise OverflowError('int too big to convert')</font>
<font color="black">  55. </font>
<font color="red">  56.         firstOctet = int(hexValue[:2], 16)</font>
<font color="black">  57. </font>
<font color="red">  58.         if signed:</font>
<font color="red">  59.             if firstOctet &amp; 0x80:</font>
<font color="red">  60.                 if value &gt;= 0:</font>
<font color="red">  61.                     hexValue = '00' + hexValue</font>
<font color="red">  62.             elif value &lt; 0:</font>
<font color="red">  63.                 hexValue = 'ff' + hexValue</font>
<font color="black">  64. </font>
<font color="red">  65.         octets_value = a2b_hex(hexValue)</font>
<font color="black">  66. </font>
<font color="red">  67.         return octets_value</font>
<font color="black">  68. </font>
<font color="green">  69.     def bitLength(number):</font>
<font color="black">  70.         # bits in unsigned number</font>
<font color="green">  71.         hexValue = hex(abs(number))</font>
<font color="green">  72.         bits = len(hexValue) - 2</font>
<font color="green">  73.         if hexValue.endswith('L'):</font>
<font color="green">  74.             bits -= 1</font>
<font color="green">  75.         if bits &amp; 1:</font>
<font color="green">  76.             bits += 1</font>
<font color="green">  77.         bits *= 4</font>
<font color="black">  78.         # TODO: strip lhs zeros</font>
<font color="green">  79.         return bits</font>
<font color="black">  80. </font>
<font color="black">  81. else:</font>
<font color="black">  82. </font>
<font color="red">  83.     def from_bytes(octets, signed=False):</font>
<font color="red">  84.         return int.from_bytes(bytes(octets), 'big', signed=signed)</font>
<font color="black">  85. </font>
<font color="red">  86.     def to_bytes(value, signed=False, length=0):</font>
<font color="red">  87.         length = max(value.bit_length(), length)</font>
<font color="black">  88. </font>
<font color="red">  89.         if signed and length % 8 == 0:</font>
<font color="red">  90.             length += 1</font>
<font color="black">  91. </font>
<font color="red">  92.         return value.to_bytes(length // 8 + (length % 8 and 1 or 0), 'big', signed=signed)</font>
<font color="black">  93. </font>
<font color="red">  94.     def bitLength(number):</font>
<font color="red">  95.         return int(number).bit_length()</font>
<font color="black">  96. </font>
</pre>

