source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/cryptography/hazmat/primitives/asymmetric/rsa.py</b><br>


file stats: <b>182 lines, 59 executed: 32.4% covered</b>
<pre>
<font color="black">   1. # This file is dual licensed under the terms of the Apache License, Version</font>
<font color="black">   2. # 2.0, and the BSD License. See the LICENSE file in the root of this repository</font>
<font color="black">   3. # for complete details.</font>
<font color="black">   4. </font>
<font color="green">   5. from __future__ import absolute_import, division, print_function</font>
<font color="black">   6. </font>
<font color="green">   7. import abc</font>
<font color="green">   8. from fractions import gcd</font>
<font color="black">   9. </font>
<font color="green">  10. import six</font>
<font color="black">  11. </font>
<font color="green">  12. from cryptography import utils</font>
<font color="green">  13. from cryptography.exceptions import UnsupportedAlgorithm, _Reasons</font>
<font color="green">  14. from cryptography.hazmat.backends.interfaces import RSABackend</font>
<font color="black">  15. </font>
<font color="black">  16. </font>
<font color="green">  17. @six.add_metaclass(abc.ABCMeta)</font>
<font color="green">  18. class RSAPrivateKey(object):</font>
<font color="green">  19.     @abc.abstractmethod</font>
<font color="black">  20.     def signer(self, padding, algorithm):</font>
<font color="black">  21.         &quot;&quot;&quot;</font>
<font color="black">  22.         Returns an AsymmetricSignatureContext used for signing data.</font>
<font color="black">  23.         &quot;&quot;&quot;</font>
<font color="black">  24. </font>
<font color="green">  25.     @abc.abstractmethod</font>
<font color="black">  26.     def decrypt(self, ciphertext, padding):</font>
<font color="black">  27.         &quot;&quot;&quot;</font>
<font color="black">  28.         Decrypts the provided ciphertext.</font>
<font color="black">  29.         &quot;&quot;&quot;</font>
<font color="black">  30. </font>
<font color="green">  31.     @abc.abstractproperty</font>
<font color="black">  32.     def key_size(self):</font>
<font color="black">  33.         &quot;&quot;&quot;</font>
<font color="black">  34.         The bit length of the public modulus.</font>
<font color="black">  35.         &quot;&quot;&quot;</font>
<font color="black">  36. </font>
<font color="green">  37.     @abc.abstractmethod</font>
<font color="black">  38.     def public_key(self):</font>
<font color="black">  39.         &quot;&quot;&quot;</font>
<font color="black">  40.         The RSAPublicKey associated with this private key.</font>
<font color="black">  41.         &quot;&quot;&quot;</font>
<font color="black">  42. </font>
<font color="green">  43.     @abc.abstractmethod</font>
<font color="black">  44.     def sign(self, data, padding, algorithm):</font>
<font color="black">  45.         &quot;&quot;&quot;</font>
<font color="black">  46.         Signs the data.</font>
<font color="black">  47.         &quot;&quot;&quot;</font>
<font color="black">  48. </font>
<font color="black">  49. </font>
<font color="green">  50. @six.add_metaclass(abc.ABCMeta)</font>
<font color="green">  51. class RSAPrivateKeyWithSerialization(RSAPrivateKey):</font>
<font color="green">  52.     @abc.abstractmethod</font>
<font color="black">  53.     def private_numbers(self):</font>
<font color="black">  54.         &quot;&quot;&quot;</font>
<font color="black">  55.         Returns an RSAPrivateNumbers.</font>
<font color="black">  56.         &quot;&quot;&quot;</font>
<font color="black">  57. </font>
<font color="green">  58.     @abc.abstractmethod</font>
<font color="black">  59.     def private_bytes(self, encoding, format, encryption_algorithm):</font>
<font color="black">  60.         &quot;&quot;&quot;</font>
<font color="black">  61.         Returns the key serialized as bytes.</font>
<font color="black">  62.         &quot;&quot;&quot;</font>
<font color="black">  63. </font>
<font color="black">  64. </font>
<font color="green">  65. @six.add_metaclass(abc.ABCMeta)</font>
<font color="green">  66. class RSAPublicKey(object):</font>
<font color="green">  67.     @abc.abstractmethod</font>
<font color="black">  68.     def verifier(self, signature, padding, algorithm):</font>
<font color="black">  69.         &quot;&quot;&quot;</font>
<font color="black">  70.         Returns an AsymmetricVerificationContext used for verifying signatures.</font>
<font color="black">  71.         &quot;&quot;&quot;</font>
<font color="black">  72. </font>
<font color="green">  73.     @abc.abstractmethod</font>
<font color="black">  74.     def encrypt(self, plaintext, padding):</font>
<font color="black">  75.         &quot;&quot;&quot;</font>
<font color="black">  76.         Encrypts the given plaintext.</font>
<font color="black">  77.         &quot;&quot;&quot;</font>
<font color="black">  78. </font>
<font color="green">  79.     @abc.abstractproperty</font>
<font color="black">  80.     def key_size(self):</font>
<font color="black">  81.         &quot;&quot;&quot;</font>
<font color="black">  82.         The bit length of the public modulus.</font>
<font color="black">  83.         &quot;&quot;&quot;</font>
<font color="black">  84. </font>
<font color="green">  85.     @abc.abstractmethod</font>
<font color="black">  86.     def public_numbers(self):</font>
<font color="black">  87.         &quot;&quot;&quot;</font>
<font color="black">  88.         Returns an RSAPublicNumbers</font>
<font color="black">  89.         &quot;&quot;&quot;</font>
<font color="black">  90. </font>
<font color="green">  91.     @abc.abstractmethod</font>
<font color="black">  92.     def public_bytes(self, encoding, format):</font>
<font color="black">  93.         &quot;&quot;&quot;</font>
<font color="black">  94.         Returns the key serialized as bytes.</font>
<font color="black">  95.         &quot;&quot;&quot;</font>
<font color="black">  96. </font>
<font color="green">  97.     @abc.abstractmethod</font>
<font color="black">  98.     def verify(self, signature, data, padding, algorithm):</font>
<font color="black">  99.         &quot;&quot;&quot;</font>
<font color="black"> 100.         Verifies the signature of the data.</font>
<font color="black"> 101.         &quot;&quot;&quot;</font>
<font color="black"> 102. </font>
<font color="black"> 103. </font>
<font color="green"> 104. RSAPublicKeyWithSerialization = RSAPublicKey</font>
<font color="black"> 105. </font>
<font color="black"> 106. </font>
<font color="green"> 107. def generate_private_key(public_exponent, key_size, backend):</font>
<font color="red"> 108.     if not isinstance(backend, RSABackend):</font>
<font color="red"> 109.         raise UnsupportedAlgorithm(</font>
<font color="red"> 110.             &quot;Backend object does not implement RSABackend.&quot;,</font>
<font color="red"> 111.             _Reasons.BACKEND_MISSING_INTERFACE</font>
<font color="black"> 112.         )</font>
<font color="black"> 113. </font>
<font color="red"> 114.     _verify_rsa_parameters(public_exponent, key_size)</font>
<font color="red"> 115.     return backend.generate_rsa_private_key(public_exponent, key_size)</font>
<font color="black"> 116. </font>
<font color="black"> 117. </font>
<font color="green"> 118. def _verify_rsa_parameters(public_exponent, key_size):</font>
<font color="red"> 119.     if public_exponent &lt; 3:</font>
<font color="red"> 120.         raise ValueError(&quot;public_exponent must be &gt;= 3.&quot;)</font>
<font color="black"> 121. </font>
<font color="red"> 122.     if public_exponent &amp; 1 == 0:</font>
<font color="red"> 123.         raise ValueError(&quot;public_exponent must be odd.&quot;)</font>
<font color="black"> 124. </font>
<font color="red"> 125.     if key_size &lt; 512:</font>
<font color="red"> 126.         raise ValueError(&quot;key_size must be at least 512-bits.&quot;)</font>
<font color="black"> 127. </font>
<font color="black"> 128. </font>
<font color="green"> 129. def _check_private_key_components(p, q, private_exponent, dmp1, dmq1, iqmp,</font>
<font color="black"> 130.                                   public_exponent, modulus):</font>
<font color="red"> 131.     if modulus &lt; 3:</font>
<font color="red"> 132.         raise ValueError(&quot;modulus must be &gt;= 3.&quot;)</font>
<font color="black"> 133. </font>
<font color="red"> 134.     if p &gt;= modulus:</font>
<font color="red"> 135.         raise ValueError(&quot;p must be &lt; modulus.&quot;)</font>
<font color="black"> 136. </font>
<font color="red"> 137.     if q &gt;= modulus:</font>
<font color="red"> 138.         raise ValueError(&quot;q must be &lt; modulus.&quot;)</font>
<font color="black"> 139. </font>
<font color="red"> 140.     if dmp1 &gt;= modulus:</font>
<font color="red"> 141.         raise ValueError(&quot;dmp1 must be &lt; modulus.&quot;)</font>
<font color="black"> 142. </font>
<font color="red"> 143.     if dmq1 &gt;= modulus:</font>
<font color="red"> 144.         raise ValueError(&quot;dmq1 must be &lt; modulus.&quot;)</font>
<font color="black"> 145. </font>
<font color="red"> 146.     if iqmp &gt;= modulus:</font>
<font color="red"> 147.         raise ValueError(&quot;iqmp must be &lt; modulus.&quot;)</font>
<font color="black"> 148. </font>
<font color="red"> 149.     if private_exponent &gt;= modulus:</font>
<font color="red"> 150.         raise ValueError(&quot;private_exponent must be &lt; modulus.&quot;)</font>
<font color="black"> 151. </font>
<font color="red"> 152.     if public_exponent &lt; 3 or public_exponent &gt;= modulus:</font>
<font color="red"> 153.         raise ValueError(&quot;public_exponent must be &gt;= 3 and &lt; modulus.&quot;)</font>
<font color="black"> 154. </font>
<font color="red"> 155.     if public_exponent &amp; 1 == 0:</font>
<font color="red"> 156.         raise ValueError(&quot;public_exponent must be odd.&quot;)</font>
<font color="black"> 157. </font>
<font color="red"> 158.     if dmp1 &amp; 1 == 0:</font>
<font color="red"> 159.         raise ValueError(&quot;dmp1 must be odd.&quot;)</font>
<font color="black"> 160. </font>
<font color="red"> 161.     if dmq1 &amp; 1 == 0:</font>
<font color="red"> 162.         raise ValueError(&quot;dmq1 must be odd.&quot;)</font>
<font color="black"> 163. </font>
<font color="red"> 164.     if p * q != modulus:</font>
<font color="red"> 165.         raise ValueError(&quot;p*q must equal modulus.&quot;)</font>
<font color="black"> 166. </font>
<font color="black"> 167. </font>
<font color="green"> 168. def _check_public_key_components(e, n):</font>
<font color="red"> 169.     if n &lt; 3:</font>
<font color="red"> 170.         raise ValueError(&quot;n must be &gt;= 3.&quot;)</font>
<font color="black"> 171. </font>
<font color="red"> 172.     if e &lt; 3 or e &gt;= n:</font>
<font color="red"> 173.         raise ValueError(&quot;e must be &gt;= 3 and &lt; n.&quot;)</font>
<font color="black"> 174. </font>
<font color="red"> 175.     if e &amp; 1 == 0:</font>
<font color="red"> 176.         raise ValueError(&quot;e must be odd.&quot;)</font>
<font color="black"> 177. </font>
<font color="black"> 178. </font>
<font color="green"> 179. def _modinv(e, m):</font>
<font color="black"> 180.     &quot;&quot;&quot;</font>
<font color="black"> 181.     Modular Multiplicative Inverse. Returns x such that: (x*e) mod m == 1</font>
<font color="black"> 182.     &quot;&quot;&quot;</font>
<font color="red"> 183.     x1, y1, x2, y2 = 1, 0, 0, 1</font>
<font color="red"> 184.     a, b = e, m</font>
<font color="red"> 185.     while b &gt; 0:</font>
<font color="red"> 186.         q, r = divmod(a, b)</font>
<font color="red"> 187.         xn, yn = x1 - q * x2, y1 - q * y2</font>
<font color="red"> 188.         a, b, x1, y1, x2, y2 = b, r, x2, y2, xn, yn</font>
<font color="red"> 189.     return x1 % m</font>
<font color="black"> 190. </font>
<font color="black"> 191. </font>
<font color="green"> 192. def rsa_crt_iqmp(p, q):</font>
<font color="black"> 193.     &quot;&quot;&quot;</font>
<font color="black"> 194.     Compute the CRT (q ** -1) % p value from RSA primes p and q.</font>
<font color="black"> 195.     &quot;&quot;&quot;</font>
<font color="red"> 196.     return _modinv(q, p)</font>
<font color="black"> 197. </font>
<font color="black"> 198. </font>
<font color="green"> 199. def rsa_crt_dmp1(private_exponent, p):</font>
<font color="black"> 200.     &quot;&quot;&quot;</font>
<font color="black"> 201.     Compute the CRT private_exponent % (p - 1) value from the RSA</font>
<font color="black"> 202.     private_exponent (d) and p.</font>
<font color="black"> 203.     &quot;&quot;&quot;</font>
<font color="red"> 204.     return private_exponent % (p - 1)</font>
<font color="black"> 205. </font>
<font color="black"> 206. </font>
<font color="green"> 207. def rsa_crt_dmq1(private_exponent, q):</font>
<font color="black"> 208.     &quot;&quot;&quot;</font>
<font color="black"> 209.     Compute the CRT private_exponent % (q - 1) value from the RSA</font>
<font color="black"> 210.     private_exponent (d) and q.</font>
<font color="black"> 211.     &quot;&quot;&quot;</font>
<font color="red"> 212.     return private_exponent % (q - 1)</font>
<font color="black"> 213. </font>
<font color="black"> 214. </font>
<font color="black"> 215. # Controls the number of iterations rsa_recover_prime_factors will perform</font>
<font color="black"> 216. # to obtain the prime factors. Each iteration increments by 2 so the actual</font>
<font color="black"> 217. # maximum attempts is half this number.</font>
<font color="green"> 218. _MAX_RECOVERY_ATTEMPTS = 1000</font>
<font color="black"> 219. </font>
<font color="black"> 220. </font>
<font color="green"> 221. def rsa_recover_prime_factors(n, e, d):</font>
<font color="black"> 222.     &quot;&quot;&quot;</font>
<font color="black"> 223.     Compute factors p and q from the private exponent d. We assume that n has</font>
<font color="black"> 224.     no more than two factors. This function is adapted from code in PyCrypto.</font>
<font color="black"> 225.     &quot;&quot;&quot;</font>
<font color="black"> 226.     # See 8.2.2(i) in Handbook of Applied Cryptography.</font>
<font color="red"> 227.     ktot = d * e - 1</font>
<font color="black"> 228.     # The quantity d*e-1 is a multiple of phi(n), even,</font>
<font color="black"> 229.     # and can be represented as t*2^s.</font>
<font color="red"> 230.     t = ktot</font>
<font color="red"> 231.     while t % 2 == 0:</font>
<font color="red"> 232.         t = t // 2</font>
<font color="black"> 233.     # Cycle through all multiplicative inverses in Zn.</font>
<font color="black"> 234.     # The algorithm is non-deterministic, but there is a 50% chance</font>
<font color="black"> 235.     # any candidate a leads to successful factoring.</font>
<font color="black"> 236.     # See &quot;Digitalized Signatures and Public Key Functions as Intractable</font>
<font color="black"> 237.     # as Factorization&quot;, M. Rabin, 1979</font>
<font color="red"> 238.     spotted = False</font>
<font color="red"> 239.     a = 2</font>
<font color="red"> 240.     while not spotted and a &lt; _MAX_RECOVERY_ATTEMPTS:</font>
<font color="red"> 241.         k = t</font>
<font color="black"> 242.         # Cycle through all values a^{t*2^i}=a^k</font>
<font color="red"> 243.         while k &lt; ktot:</font>
<font color="red"> 244.             cand = pow(a, k, n)</font>
<font color="black"> 245.             # Check if a^k is a non-trivial root of unity (mod n)</font>
<font color="red"> 246.             if cand != 1 and cand != (n - 1) and pow(cand, 2, n) == 1:</font>
<font color="black"> 247.                 # We have found a number such that (cand-1)(cand+1)=0 (mod n).</font>
<font color="black"> 248.                 # Either of the terms divides n.</font>
<font color="red"> 249.                 p = gcd(cand + 1, n)</font>
<font color="red"> 250.                 spotted = True</font>
<font color="red"> 251.                 break</font>
<font color="red"> 252.             k *= 2</font>
<font color="black"> 253.         # This value was not any good... let's try another!</font>
<font color="red"> 254.         a += 2</font>
<font color="red"> 255.     if not spotted:</font>
<font color="red"> 256.         raise ValueError(&quot;Unable to compute factors p and q from exponent d.&quot;)</font>
<font color="black"> 257.     # Found !</font>
<font color="red"> 258.     q, r = divmod(n, p)</font>
<font color="red"> 259.     assert r == 0</font>
<font color="red"> 260.     p, q = sorted((p, q), reverse=True)</font>
<font color="red"> 261.     return (p, q)</font>
<font color="black"> 262. </font>
<font color="black"> 263. </font>
<font color="green"> 264. class RSAPrivateNumbers(object):</font>
<font color="green"> 265.     def __init__(self, p, q, d, dmp1, dmq1, iqmp,</font>
<font color="black"> 266.                  public_numbers):</font>
<font color="black"> 267.         if (</font>
<font color="red"> 268.             not isinstance(p, six.integer_types) or</font>
<font color="red"> 269.             not isinstance(q, six.integer_types) or</font>
<font color="red"> 270.             not isinstance(d, six.integer_types) or</font>
<font color="red"> 271.             not isinstance(dmp1, six.integer_types) or</font>
<font color="red"> 272.             not isinstance(dmq1, six.integer_types) or</font>
<font color="red"> 273.             not isinstance(iqmp, six.integer_types)</font>
<font color="black"> 274.         ):</font>
<font color="red"> 275.             raise TypeError(</font>
<font color="red"> 276.                 &quot;RSAPrivateNumbers p, q, d, dmp1, dmq1, iqmp arguments must&quot;</font>
<font color="black"> 277.                 &quot; all be an integers.&quot;</font>
<font color="black"> 278.             )</font>
<font color="black"> 279. </font>
<font color="red"> 280.         if not isinstance(public_numbers, RSAPublicNumbers):</font>
<font color="red"> 281.             raise TypeError(</font>
<font color="red"> 282.                 &quot;RSAPrivateNumbers public_numbers must be an RSAPublicNumbers&quot;</font>
<font color="black"> 283.                 &quot; instance.&quot;</font>
<font color="black"> 284.             )</font>
<font color="black"> 285. </font>
<font color="red"> 286.         self._p = p</font>
<font color="red"> 287.         self._q = q</font>
<font color="red"> 288.         self._d = d</font>
<font color="red"> 289.         self._dmp1 = dmp1</font>
<font color="red"> 290.         self._dmq1 = dmq1</font>
<font color="red"> 291.         self._iqmp = iqmp</font>
<font color="red"> 292.         self._public_numbers = public_numbers</font>
<font color="black"> 293. </font>
<font color="green"> 294.     p = utils.read_only_property(&quot;_p&quot;)</font>
<font color="green"> 295.     q = utils.read_only_property(&quot;_q&quot;)</font>
<font color="green"> 296.     d = utils.read_only_property(&quot;_d&quot;)</font>
<font color="green"> 297.     dmp1 = utils.read_only_property(&quot;_dmp1&quot;)</font>
<font color="green"> 298.     dmq1 = utils.read_only_property(&quot;_dmq1&quot;)</font>
<font color="green"> 299.     iqmp = utils.read_only_property(&quot;_iqmp&quot;)</font>
<font color="green"> 300.     public_numbers = utils.read_only_property(&quot;_public_numbers&quot;)</font>
<font color="black"> 301. </font>
<font color="green"> 302.     def private_key(self, backend):</font>
<font color="red"> 303.         return backend.load_rsa_private_numbers(self)</font>
<font color="black"> 304. </font>
<font color="green"> 305.     def __eq__(self, other):</font>
<font color="red"> 306.         if not isinstance(other, RSAPrivateNumbers):</font>
<font color="red"> 307.             return NotImplemented</font>
<font color="black"> 308. </font>
<font color="black"> 309.         return (</font>
<font color="red"> 310.             self.p == other.p and</font>
<font color="red"> 311.             self.q == other.q and</font>
<font color="red"> 312.             self.d == other.d and</font>
<font color="red"> 313.             self.dmp1 == other.dmp1 and</font>
<font color="red"> 314.             self.dmq1 == other.dmq1 and</font>
<font color="red"> 315.             self.iqmp == other.iqmp and</font>
<font color="red"> 316.             self.public_numbers == other.public_numbers</font>
<font color="black"> 317.         )</font>
<font color="black"> 318. </font>
<font color="green"> 319.     def __ne__(self, other):</font>
<font color="red"> 320.         return not self == other</font>
<font color="black"> 321. </font>
<font color="green"> 322.     def __hash__(self):</font>
<font color="red"> 323.         return hash((</font>
<font color="red"> 324.             self.p,</font>
<font color="red"> 325.             self.q,</font>
<font color="red"> 326.             self.d,</font>
<font color="red"> 327.             self.dmp1,</font>
<font color="red"> 328.             self.dmq1,</font>
<font color="red"> 329.             self.iqmp,</font>
<font color="red"> 330.             self.public_numbers,</font>
<font color="black"> 331.         ))</font>
<font color="black"> 332. </font>
<font color="black"> 333. </font>
<font color="green"> 334. class RSAPublicNumbers(object):</font>
<font color="green"> 335.     def __init__(self, e, n):</font>
<font color="black"> 336.         if (</font>
<font color="red"> 337.             not isinstance(e, six.integer_types) or</font>
<font color="red"> 338.             not isinstance(n, six.integer_types)</font>
<font color="black"> 339.         ):</font>
<font color="red"> 340.             raise TypeError(&quot;RSAPublicNumbers arguments must be integers.&quot;)</font>
<font color="black"> 341. </font>
<font color="red"> 342.         self._e = e</font>
<font color="red"> 343.         self._n = n</font>
<font color="black"> 344. </font>
<font color="green"> 345.     e = utils.read_only_property(&quot;_e&quot;)</font>
<font color="green"> 346.     n = utils.read_only_property(&quot;_n&quot;)</font>
<font color="black"> 347. </font>
<font color="green"> 348.     def public_key(self, backend):</font>
<font color="red"> 349.         return backend.load_rsa_public_numbers(self)</font>
<font color="black"> 350. </font>
<font color="green"> 351.     def __repr__(self):</font>
<font color="red"> 352.         return &quot;&lt;RSAPublicNumbers(e={0.e}, n={0.n})&gt;&quot;.format(self)</font>
<font color="black"> 353. </font>
<font color="green"> 354.     def __eq__(self, other):</font>
<font color="red"> 355.         if not isinstance(other, RSAPublicNumbers):</font>
<font color="red"> 356.             return NotImplemented</font>
<font color="black"> 357. </font>
<font color="red"> 358.         return self.e == other.e and self.n == other.n</font>
<font color="black"> 359. </font>
<font color="green"> 360.     def __ne__(self, other):</font>
<font color="red"> 361.         return not self == other</font>
<font color="black"> 362. </font>
<font color="green"> 363.     def __hash__(self):</font>
<font color="red"> 364.         return hash((self.e, self.n))</font>
</pre>

