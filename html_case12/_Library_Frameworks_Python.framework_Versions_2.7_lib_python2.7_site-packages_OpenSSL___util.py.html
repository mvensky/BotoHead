source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/OpenSSL/_util.py</b><br>


file stats: <b>58 lines, 20 executed: 34.5% covered</b>
<pre>
<font color="green">   1. import sys</font>
<font color="green">   2. import warnings</font>
<font color="black">   3. </font>
<font color="green">   4. from six import PY3, binary_type, text_type</font>
<font color="black">   5. </font>
<font color="green">   6. from cryptography.hazmat.bindings.openssl.binding import Binding</font>
<font color="black">   7. </font>
<font color="black">   8. </font>
<font color="green">   9. binding = Binding()</font>
<font color="green">  10. binding.init_static_locks()</font>
<font color="green">  11. ffi = binding.ffi</font>
<font color="green">  12. lib = binding.lib</font>
<font color="black">  13. </font>
<font color="black">  14. </font>
<font color="green">  15. def text(charp):</font>
<font color="black">  16.     &quot;&quot;&quot;</font>
<font color="black">  17.     Get a native string type representing of the given CFFI ``char*`` object.</font>
<font color="black">  18. </font>
<font color="black">  19.     :param charp: A C-style string represented using CFFI.</font>
<font color="black">  20. </font>
<font color="black">  21.     :return: :class:`str`</font>
<font color="black">  22.     &quot;&quot;&quot;</font>
<font color="red">  23.     if not charp:</font>
<font color="red">  24.         return &quot;&quot;</font>
<font color="red">  25.     return native(ffi.string(charp))</font>
<font color="black">  26. </font>
<font color="black">  27. </font>
<font color="green">  28. def exception_from_error_queue(exception_type):</font>
<font color="black">  29.     &quot;&quot;&quot;</font>
<font color="black">  30.     Convert an OpenSSL library failure into a Python exception.</font>
<font color="black">  31. </font>
<font color="black">  32.     When a call to the native OpenSSL library fails, this is usually signalled</font>
<font color="black">  33.     by the return value, and an error code is stored in an error queue</font>
<font color="black">  34.     associated with the current thread. The err library provides functions to</font>
<font color="black">  35.     obtain these error codes and textual error messages.</font>
<font color="black">  36.     &quot;&quot;&quot;</font>
<font color="red">  37.     errors = []</font>
<font color="black">  38. </font>
<font color="red">  39.     while True:</font>
<font color="red">  40.         error = lib.ERR_get_error()</font>
<font color="red">  41.         if error == 0:</font>
<font color="red">  42.             break</font>
<font color="red">  43.         errors.append((</font>
<font color="red">  44.             text(lib.ERR_lib_error_string(error)),</font>
<font color="red">  45.             text(lib.ERR_func_error_string(error)),</font>
<font color="red">  46.             text(lib.ERR_reason_error_string(error))))</font>
<font color="black">  47. </font>
<font color="red">  48.     raise exception_type(errors)</font>
<font color="black">  49. </font>
<font color="black">  50. </font>
<font color="green">  51. def make_assert(error):</font>
<font color="black">  52.     &quot;&quot;&quot;</font>
<font color="black">  53.     Create an assert function that uses :func:`exception_from_error_queue` to</font>
<font color="black">  54.     raise an exception wrapped by *error*.</font>
<font color="black">  55.     &quot;&quot;&quot;</font>
<font color="green">  56.     def openssl_assert(ok):</font>
<font color="black">  57.         &quot;&quot;&quot;</font>
<font color="black">  58.         If *ok* is not True, retrieve the error from OpenSSL and raise it.</font>
<font color="black">  59.         &quot;&quot;&quot;</font>
<font color="red">  60.         if ok is not True:</font>
<font color="red">  61.             exception_from_error_queue(error)</font>
<font color="black">  62. </font>
<font color="green">  63.     return openssl_assert</font>
<font color="black">  64. </font>
<font color="black">  65. </font>
<font color="green">  66. def native(s):</font>
<font color="black">  67.     &quot;&quot;&quot;</font>
<font color="black">  68.     Convert :py:class:`bytes` or :py:class:`unicode` to the native</font>
<font color="black">  69.     :py:class:`str` type, using UTF-8 encoding if conversion is necessary.</font>
<font color="black">  70. </font>
<font color="black">  71.     :raise UnicodeError: The input string is not UTF-8 decodeable.</font>
<font color="black">  72. </font>
<font color="black">  73.     :raise TypeError: The input is neither :py:class:`bytes` nor</font>
<font color="black">  74.         :py:class:`unicode`.</font>
<font color="black">  75.     &quot;&quot;&quot;</font>
<font color="red">  76.     if not isinstance(s, (binary_type, text_type)):</font>
<font color="red">  77.         raise TypeError(&quot;%r is neither bytes nor unicode&quot; % s)</font>
<font color="red">  78.     if PY3:</font>
<font color="red">  79.         if isinstance(s, binary_type):</font>
<font color="red">  80.             return s.decode(&quot;utf-8&quot;)</font>
<font color="black">  81.     else:</font>
<font color="red">  82.         if isinstance(s, text_type):</font>
<font color="red">  83.             return s.encode(&quot;utf-8&quot;)</font>
<font color="red">  84.     return s</font>
<font color="black">  85. </font>
<font color="black">  86. </font>
<font color="green">  87. def path_string(s):</font>
<font color="black">  88.     &quot;&quot;&quot;</font>
<font color="black">  89.     Convert a Python string to a :py:class:`bytes` string identifying the same</font>
<font color="black">  90.     path and which can be passed into an OpenSSL API accepting a filename.</font>
<font color="black">  91. </font>
<font color="black">  92.     :param s: An instance of :py:class:`bytes` or :py:class:`unicode`.</font>
<font color="black">  93. </font>
<font color="black">  94.     :return: An instance of :py:class:`bytes`.</font>
<font color="black">  95.     &quot;&quot;&quot;</font>
<font color="red">  96.     if isinstance(s, binary_type):</font>
<font color="red">  97.         return s</font>
<font color="red">  98.     elif isinstance(s, text_type):</font>
<font color="red">  99.         return s.encode(sys.getfilesystemencoding())</font>
<font color="black"> 100.     else:</font>
<font color="red"> 101.         raise TypeError(&quot;Path must be represented as bytes or unicode string&quot;)</font>
<font color="black"> 102. </font>
<font color="black"> 103. </font>
<font color="green"> 104. if PY3:</font>
<font color="red"> 105.     def byte_string(s):</font>
<font color="red"> 106.         return s.encode(&quot;charmap&quot;)</font>
<font color="black"> 107. else:</font>
<font color="green"> 108.     def byte_string(s):</font>
<font color="red"> 109.         return s</font>
<font color="black"> 110. </font>
<font color="black"> 111. </font>
<font color="black"> 112. # A marker object to observe whether some optional arguments are passed any</font>
<font color="black"> 113. # value or not.</font>
<font color="green"> 114. UNSPECIFIED = object()</font>
<font color="black"> 115. </font>
<font color="black"> 116. _TEXT_WARNING = (</font>
<font color="green"> 117.     text_type.__name__ + &quot; for {0} is no longer accepted, use bytes&quot;</font>
<font color="black"> 118. )</font>
<font color="black"> 119. </font>
<font color="black"> 120. </font>
<font color="green"> 121. def text_to_bytes_and_warn(label, obj):</font>
<font color="black"> 122.     &quot;&quot;&quot;</font>
<font color="black"> 123.     If ``obj`` is text, emit a warning that it should be bytes instead and try</font>
<font color="black"> 124.     to convert it to bytes automatically.</font>
<font color="black"> 125. </font>
<font color="black"> 126.     :param str label: The name of the parameter from which ``obj`` was taken</font>
<font color="black"> 127.         (so a developer can easily find the source of the problem and correct</font>
<font color="black"> 128.         it).</font>
<font color="black"> 129. </font>
<font color="black"> 130.     :return: If ``obj`` is the text string type, a ``bytes`` object giving the</font>
<font color="black"> 131.         UTF-8 encoding of that text is returned.  Otherwise, ``obj`` itself is</font>
<font color="black"> 132.         returned.</font>
<font color="black"> 133.     &quot;&quot;&quot;</font>
<font color="red"> 134.     if isinstance(obj, text_type):</font>
<font color="red"> 135.         warnings.warn(</font>
<font color="red"> 136.             _TEXT_WARNING.format(label),</font>
<font color="red"> 137.             category=DeprecationWarning,</font>
<font color="red"> 138.             stacklevel=3</font>
<font color="black"> 139.         )</font>
<font color="red"> 140.         return obj.encode('utf-8')</font>
<font color="red"> 141.     return obj</font>
</pre>

