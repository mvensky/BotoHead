source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/boto3/resources/collection.py</b><br>


file stats: <b>207 lines, 42 executed: 20.3% covered</b>
<pre>
<font color="black">   1. # Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="black">  13. </font>
<font color="green">  14. import copy</font>
<font color="green">  15. import logging</font>
<font color="black">  16. </font>
<font color="green">  17. from botocore import xform_name</font>
<font color="green">  18. from botocore.utils import merge_dicts</font>
<font color="black">  19. </font>
<font color="green">  20. from .action import BatchAction</font>
<font color="green">  21. from .params import create_request_parameters</font>
<font color="green">  22. from .response import ResourceHandler</font>
<font color="green">  23. from ..docs import docstring</font>
<font color="black">  24. </font>
<font color="black">  25. </font>
<font color="green">  26. logger = logging.getLogger(__name__)</font>
<font color="black">  27. </font>
<font color="black">  28. </font>
<font color="green">  29. class ResourceCollection(object):</font>
<font color="black">  30.     &quot;&quot;&quot;</font>
<font color="black">  31.     Represents a collection of resources, which can be iterated through,</font>
<font color="black">  32.     optionally with filtering. Collections automatically handle pagination</font>
<font color="black">  33.     for you.</font>
<font color="black">  34. </font>
<font color="black">  35.     See :ref:`guide_collections` for a high-level overview of collections,</font>
<font color="black">  36.     including when remote service requests are performed.</font>
<font color="black">  37. </font>
<font color="black">  38.     :type model: :py:class:`~boto3.resources.model.Collection`</font>
<font color="black">  39.     :param model: Collection model</font>
<font color="black">  40.     :type parent: :py:class:`~boto3.resources.base.ServiceResource`</font>
<font color="black">  41.     :param parent: The collection's parent resource</font>
<font color="black">  42.     :type handler: :py:class:`~boto3.resources.response.ResourceHandler`</font>
<font color="black">  43.     :param handler: The resource response handler used to create resource</font>
<font color="black">  44.                     instances</font>
<font color="green">  45.     &quot;&quot;&quot;</font>
<font color="green">  46.     def __init__(self, model, parent, handler, **kwargs):</font>
<font color="red">  47.         self._model = model</font>
<font color="red">  48.         self._parent = parent</font>
<font color="red">  49.         self._py_operation_name = xform_name(</font>
<font color="red">  50.             model.request.operation)</font>
<font color="red">  51.         self._handler = handler</font>
<font color="red">  52.         self._params = copy.deepcopy(kwargs)</font>
<font color="black">  53. </font>
<font color="green">  54.     def __repr__(self):</font>
<font color="red">  55.         return '{0}({1}, {2})'.format(</font>
<font color="red">  56.             self.__class__.__name__,</font>
<font color="red">  57.             self._parent,</font>
<font color="red">  58.             '{0}.{1}'.format(</font>
<font color="red">  59.                 self._parent.meta.service_name,</font>
<font color="red">  60.                 self._model.resource.type</font>
<font color="black">  61.             )</font>
<font color="black">  62.         )</font>
<font color="black">  63. </font>
<font color="green">  64.     def __iter__(self):</font>
<font color="black">  65.         &quot;&quot;&quot;</font>
<font color="black">  66.         A generator which yields resource instances after doing the</font>
<font color="black">  67.         appropriate service operation calls and handling any pagination</font>
<font color="black">  68.         on your behalf.</font>
<font color="black">  69. </font>
<font color="black">  70.         Page size, item limit, and filter parameters are applied</font>
<font color="black">  71.         if they have previously been set.</font>
<font color="black">  72. </font>
<font color="black">  73.             &gt;&gt;&gt; bucket = s3.Bucket('boto3')</font>
<font color="black">  74.             &gt;&gt;&gt; for obj in bucket.objects.all():</font>
<font color="black">  75.             ...     print(obj.key)</font>
<font color="black">  76.             'key1'</font>
<font color="black">  77.             'key2'</font>
<font color="black">  78. </font>
<font color="black">  79.         &quot;&quot;&quot;</font>
<font color="red">  80.         limit = self._params.get('limit', None)</font>
<font color="black">  81. </font>
<font color="red">  82.         count = 0</font>
<font color="red">  83.         for page in self.pages():</font>
<font color="red">  84.             for item in page:</font>
<font color="red">  85.                 yield item</font>
<font color="black">  86. </font>
<font color="black">  87.                 # If the limit is set and has been reached, then</font>
<font color="black">  88.                 # we stop processing items here.</font>
<font color="red">  89.                 count += 1</font>
<font color="red">  90.                 if limit is not None and count &gt;= limit:</font>
<font color="red">  91.                     return</font>
<font color="black">  92. </font>
<font color="green">  93.     def _clone(self, **kwargs):</font>
<font color="black">  94.         &quot;&quot;&quot;</font>
<font color="black">  95.         Create a clone of this collection. This is used by the methods</font>
<font color="black">  96.         below to provide a chainable interface that returns copies</font>
<font color="black">  97.         rather than the original. This allows things like:</font>
<font color="black">  98. </font>
<font color="black">  99.             &gt;&gt;&gt; base = collection.filter(Param1=1)</font>
<font color="black"> 100.             &gt;&gt;&gt; query1 = base.filter(Param2=2)</font>
<font color="black"> 101.             &gt;&gt;&gt; query2 = base.filter(Param3=3)</font>
<font color="black"> 102.             &gt;&gt;&gt; query1.params</font>
<font color="black"> 103.             {'Param1': 1, 'Param2': 2}</font>
<font color="black"> 104.             &gt;&gt;&gt; query2.params</font>
<font color="black"> 105.             {'Param1': 1, 'Param3': 3}</font>
<font color="black"> 106. </font>
<font color="black"> 107.         :rtype: :py:class:`ResourceCollection`</font>
<font color="black"> 108.         :return: A clone of this resource collection</font>
<font color="black"> 109.         &quot;&quot;&quot;</font>
<font color="red"> 110.         params = copy.deepcopy(self._params)</font>
<font color="red"> 111.         merge_dicts(params, kwargs, append_lists=True)</font>
<font color="red"> 112.         clone = self.__class__(self._model, self._parent,</font>
<font color="red"> 113.                                self._handler, **params)</font>
<font color="red"> 114.         return clone</font>
<font color="black"> 115. </font>
<font color="green"> 116.     def pages(self):</font>
<font color="black"> 117.         &quot;&quot;&quot;</font>
<font color="black"> 118.         A generator which yields pages of resource instances after</font>
<font color="black"> 119.         doing the appropriate service operation calls and handling</font>
<font color="black"> 120.         any pagination on your behalf. Non-paginated calls will</font>
<font color="black"> 121.         return a single page of items.</font>
<font color="black"> 122. </font>
<font color="black"> 123.         Page size, item limit, and filter parameters are applied</font>
<font color="black"> 124.         if they have previously been set.</font>
<font color="black"> 125. </font>
<font color="black"> 126.             &gt;&gt;&gt; bucket = s3.Bucket('boto3')</font>
<font color="black"> 127.             &gt;&gt;&gt; for page in bucket.objects.pages():</font>
<font color="black"> 128.             ...     for obj in page:</font>
<font color="black"> 129.             ...         print(obj.key)</font>
<font color="black"> 130.             'key1'</font>
<font color="black"> 131.             'key2'</font>
<font color="black"> 132. </font>
<font color="black"> 133.         :rtype: list(:py:class:`~boto3.resources.base.ServiceResource`)</font>
<font color="black"> 134.         :return: List of resource instances</font>
<font color="black"> 135.         &quot;&quot;&quot;</font>
<font color="red"> 136.         client = self._parent.meta.client</font>
<font color="red"> 137.         cleaned_params = self._params.copy()</font>
<font color="red"> 138.         limit = cleaned_params.pop('limit', None)</font>
<font color="red"> 139.         page_size = cleaned_params.pop('page_size', None)</font>
<font color="red"> 140.         params = create_request_parameters(</font>
<font color="red"> 141.             self._parent, self._model.request)</font>
<font color="red"> 142.         merge_dicts(params, cleaned_params, append_lists=True)</font>
<font color="black"> 143. </font>
<font color="black"> 144.         # Is this a paginated operation? If so, we need to get an</font>
<font color="black"> 145.         # iterator for the various pages. If not, then we simply</font>
<font color="black"> 146.         # call the operation and return the result as a single</font>
<font color="black"> 147.         # page in a list. For non-paginated results, we just ignore</font>
<font color="black"> 148.         # the page size parameter.</font>
<font color="red"> 149.         if client.can_paginate(self._py_operation_name):</font>
<font color="red"> 150.             logger.debug('Calling paginated %s:%s with %r',</font>
<font color="red"> 151.                          self._parent.meta.service_name,</font>
<font color="red"> 152.                          self._py_operation_name, params)</font>
<font color="red"> 153.             paginator = client.get_paginator(self._py_operation_name)</font>
<font color="red"> 154.             pages = paginator.paginate(</font>
<font color="red"> 155.                 PaginationConfig={</font>
<font color="red"> 156.                     'MaxItems': limit, 'PageSize': page_size}, **params)</font>
<font color="black"> 157.         else:</font>
<font color="red"> 158.             logger.debug('Calling %s:%s with %r',</font>
<font color="red"> 159.                          self._parent.meta.service_name,</font>
<font color="red"> 160.                          self._py_operation_name, params)</font>
<font color="red"> 161.             pages = [getattr(client, self._py_operation_name)(**params)]</font>
<font color="black"> 162. </font>
<font color="black"> 163.         # Now that we have a page iterator or single page of results</font>
<font color="black"> 164.         # we start processing and yielding individual items.</font>
<font color="red"> 165.         count = 0</font>
<font color="red"> 166.         for page in pages:</font>
<font color="red"> 167.             page_items = []</font>
<font color="red"> 168.             for item in self._handler(self._parent, params, page):</font>
<font color="red"> 169.                 page_items.append(item)</font>
<font color="black"> 170. </font>
<font color="black"> 171.                 # If the limit is set and has been reached, then</font>
<font color="black"> 172.                 # we stop processing items here.</font>
<font color="red"> 173.                 count += 1</font>
<font color="red"> 174.                 if limit is not None and count &gt;= limit:</font>
<font color="red"> 175.                     break</font>
<font color="black"> 176. </font>
<font color="red"> 177.             yield page_items</font>
<font color="black"> 178. </font>
<font color="black"> 179.             # Stop reading pages if we've reached out limit</font>
<font color="red"> 180.             if limit is not None and count &gt;= limit:</font>
<font color="red"> 181.                 break</font>
<font color="black"> 182. </font>
<font color="green"> 183.     def all(self):</font>
<font color="black"> 184.         &quot;&quot;&quot;</font>
<font color="black"> 185.         Get all items from the collection, optionally with a custom</font>
<font color="black"> 186.         page size and item count limit.</font>
<font color="black"> 187. </font>
<font color="black"> 188.         This method returns an iterable generator which yields</font>
<font color="black"> 189.         individual resource instances. Example use::</font>
<font color="black"> 190. </font>
<font color="black"> 191.             # Iterate through items</font>
<font color="black"> 192.             &gt;&gt;&gt; for queue in sqs.queues.all():</font>
<font color="black"> 193.             ...     print(queue.url)</font>
<font color="black"> 194.             'https://url1'</font>
<font color="black"> 195.             'https://url2'</font>
<font color="black"> 196. </font>
<font color="black"> 197.             # Convert to list</font>
<font color="black"> 198.             &gt;&gt;&gt; queues = list(sqs.queues.all())</font>
<font color="black"> 199.             &gt;&gt;&gt; len(queues)</font>
<font color="black"> 200.             2</font>
<font color="black"> 201.         &quot;&quot;&quot;</font>
<font color="red"> 202.         return self._clone()</font>
<font color="black"> 203. </font>
<font color="green"> 204.     def filter(self, **kwargs):</font>
<font color="black"> 205.         &quot;&quot;&quot;</font>
<font color="black"> 206.         Get items from the collection, passing keyword arguments along</font>
<font color="black"> 207.         as parameters to the underlying service operation, which are</font>
<font color="black"> 208.         typically used to filter the results.</font>
<font color="black"> 209. </font>
<font color="black"> 210.         This method returns an iterable generator which yields</font>
<font color="black"> 211.         individual resource instances. Example use::</font>
<font color="black"> 212. </font>
<font color="black"> 213.             # Iterate through items</font>
<font color="black"> 214.             &gt;&gt;&gt; for queue in sqs.queues.filter(Param='foo'):</font>
<font color="black"> 215.             ...     print(queue.url)</font>
<font color="black"> 216.             'https://url1'</font>
<font color="black"> 217.             'https://url2'</font>
<font color="black"> 218. </font>
<font color="black"> 219.             # Convert to list</font>
<font color="black"> 220.             &gt;&gt;&gt; queues = list(sqs.queues.filter(Param='foo'))</font>
<font color="black"> 221.             &gt;&gt;&gt; len(queues)</font>
<font color="black"> 222.             2</font>
<font color="black"> 223. </font>
<font color="black"> 224.         :rtype: :py:class:`ResourceCollection`</font>
<font color="black"> 225.         &quot;&quot;&quot;</font>
<font color="red"> 226.         return self._clone(**kwargs)</font>
<font color="black"> 227. </font>
<font color="green"> 228.     def limit(self, count):</font>
<font color="black"> 229.         &quot;&quot;&quot;</font>
<font color="black"> 230.         Return at most this many resources.</font>
<font color="black"> 231. </font>
<font color="black"> 232.             &gt;&gt;&gt; for bucket in s3.buckets.limit(5):</font>
<font color="black"> 233.             ...     print(bucket.name)</font>
<font color="black"> 234.             'bucket1'</font>
<font color="black"> 235.             'bucket2'</font>
<font color="black"> 236.             'bucket3'</font>
<font color="black"> 237.             'bucket4'</font>
<font color="black"> 238.             'bucket5'</font>
<font color="black"> 239. </font>
<font color="black"> 240.         :type count: int</font>
<font color="black"> 241.         :param count: Return no more than this many items</font>
<font color="black"> 242.         :rtype: :py:class:`ResourceCollection`</font>
<font color="black"> 243.         &quot;&quot;&quot;</font>
<font color="red"> 244.         return self._clone(limit=count)</font>
<font color="black"> 245. </font>
<font color="green"> 246.     def page_size(self, count):</font>
<font color="black"> 247.         &quot;&quot;&quot;</font>
<font color="black"> 248.         Fetch at most this many resources per service request.</font>
<font color="black"> 249. </font>
<font color="black"> 250.             &gt;&gt;&gt; for obj in s3.Bucket('boto3').objects.page_size(100):</font>
<font color="black"> 251.             ...     print(obj.key)</font>
<font color="black"> 252. </font>
<font color="black"> 253.         :type count: int</font>
<font color="black"> 254.         :param count: Fetch this many items per request</font>
<font color="black"> 255.         :rtype: :py:class:`ResourceCollection`</font>
<font color="black"> 256.         &quot;&quot;&quot;</font>
<font color="red"> 257.         return self._clone(page_size=count)</font>
<font color="black"> 258. </font>
<font color="black"> 259. </font>
<font color="green"> 260. class CollectionManager(object):</font>
<font color="black"> 261.     &quot;&quot;&quot;</font>
<font color="black"> 262.     A collection manager provides access to resource collection instances,</font>
<font color="black"> 263.     which can be iterated and filtered. The manager exposes some</font>
<font color="black"> 264.     convenience functions that are also found on resource collections,</font>
<font color="black"> 265.     such as :py:meth:`~ResourceCollection.all` and</font>
<font color="black"> 266.     :py:meth:`~ResourceCollection.filter`.</font>
<font color="black"> 267. </font>
<font color="black"> 268.     Get all items::</font>
<font color="black"> 269. </font>
<font color="black"> 270.         &gt;&gt;&gt; for bucket in s3.buckets.all():</font>
<font color="black"> 271.         ...     print(bucket.name)</font>
<font color="black"> 272. </font>
<font color="black"> 273.     Get only some items via filtering::</font>
<font color="black"> 274. </font>
<font color="black"> 275.         &gt;&gt;&gt; for queue in sqs.queues.filter(QueueNamePrefix='AWS'):</font>
<font color="black"> 276.         ...     print(queue.url)</font>
<font color="black"> 277. </font>
<font color="black"> 278.     Get whole pages of items:</font>
<font color="black"> 279. </font>
<font color="black"> 280.         &gt;&gt;&gt; for page in s3.Bucket('boto3').objects.pages():</font>
<font color="black"> 281.         ...     for obj in page:</font>
<font color="black"> 282.         ...         print(obj.key)</font>
<font color="black"> 283. </font>
<font color="black"> 284.     A collection manager is not iterable. You **must** call one of the</font>
<font color="black"> 285.     methods that return a :py:class:`ResourceCollection` before trying</font>
<font color="black"> 286.     to iterate, slice, or convert to a list.</font>
<font color="black"> 287. </font>
<font color="black"> 288.     See the :ref:`guide_collections` guide for a high-level overview</font>
<font color="black"> 289.     of collections, including when remote service requests are performed.</font>
<font color="black"> 290. </font>
<font color="black"> 291.     :type collection_model: :py:class:`~boto3.resources.model.Collection`</font>
<font color="black"> 292.     :param model: Collection model</font>
<font color="black"> 293. </font>
<font color="black"> 294.     :type parent: :py:class:`~boto3.resources.base.ServiceResource`</font>
<font color="black"> 295.     :param parent: The collection's parent resource</font>
<font color="black"> 296. </font>
<font color="black"> 297.     :type factory: :py:class:`~boto3.resources.factory.ResourceFactory`</font>
<font color="black"> 298.     :param factory: The resource factory to create new resources</font>
<font color="black"> 299. </font>
<font color="black"> 300.     :type service_context: :py:class:`~boto3.utils.ServiceContext`</font>
<font color="black"> 301.     :param service_context: Context about the AWS service</font>
<font color="green"> 302.     &quot;&quot;&quot;</font>
<font color="black"> 303.     # The class to use when creating an iterator</font>
<font color="green"> 304.     _collection_cls = ResourceCollection</font>
<font color="black"> 305. </font>
<font color="green"> 306.     def __init__(self, collection_model, parent, factory, service_context):</font>
<font color="red"> 307.         self._model = collection_model</font>
<font color="red"> 308.         operation_name = self._model.request.operation</font>
<font color="red"> 309.         self._parent = parent</font>
<font color="black"> 310. </font>
<font color="red"> 311.         search_path = collection_model.resource.path</font>
<font color="red"> 312.         self._handler = ResourceHandler(</font>
<font color="red"> 313.             search_path=search_path, factory=factory,</font>
<font color="red"> 314.             resource_model=collection_model.resource,</font>
<font color="red"> 315.             service_context=service_context,</font>
<font color="red"> 316.             operation_name=operation_name</font>
<font color="black"> 317.         )</font>
<font color="black"> 318. </font>
<font color="green"> 319.     def __repr__(self):</font>
<font color="red"> 320.         return '{0}({1}, {2})'.format(</font>
<font color="red"> 321.             self.__class__.__name__,</font>
<font color="red"> 322.             self._parent,</font>
<font color="red"> 323.             '{0}.{1}'.format(</font>
<font color="red"> 324.                 self._parent.meta.service_name,</font>
<font color="red"> 325.                 self._model.resource.type</font>
<font color="black"> 326.             )</font>
<font color="black"> 327.         )</font>
<font color="black"> 328. </font>
<font color="green"> 329.     def iterator(self, **kwargs):</font>
<font color="black"> 330.         &quot;&quot;&quot;</font>
<font color="black"> 331.         Get a resource collection iterator from this manager.</font>
<font color="black"> 332. </font>
<font color="black"> 333.         :rtype: :py:class:`ResourceCollection`</font>
<font color="black"> 334.         :return: An iterable representing the collection of resources</font>
<font color="black"> 335.         &quot;&quot;&quot;</font>
<font color="red"> 336.         return self._collection_cls(self._model, self._parent,</font>
<font color="red"> 337.                                     self._handler, **kwargs)</font>
<font color="black"> 338. </font>
<font color="black"> 339.     # Set up some methods to proxy ResourceCollection methods</font>
<font color="green"> 340.     def all(self):</font>
<font color="red"> 341.         return self.iterator()</font>
<font color="green"> 342.     all.__doc__ = ResourceCollection.all.__doc__</font>
<font color="black"> 343. </font>
<font color="green"> 344.     def filter(self, **kwargs):</font>
<font color="red"> 345.         return self.iterator(**kwargs)</font>
<font color="green"> 346.     filter.__doc__ = ResourceCollection.filter.__doc__</font>
<font color="black"> 347. </font>
<font color="green"> 348.     def limit(self, count):</font>
<font color="red"> 349.         return self.iterator(limit=count)</font>
<font color="green"> 350.     limit.__doc__ = ResourceCollection.limit.__doc__</font>
<font color="black"> 351. </font>
<font color="green"> 352.     def page_size(self, count):</font>
<font color="red"> 353.         return self.iterator(page_size=count)</font>
<font color="green"> 354.     page_size.__doc__ = ResourceCollection.page_size.__doc__</font>
<font color="black"> 355. </font>
<font color="green"> 356.     def pages(self):</font>
<font color="red"> 357.         return self.iterator().pages()</font>
<font color="green"> 358.     pages.__doc__ = ResourceCollection.pages.__doc__</font>
<font color="black"> 359. </font>
<font color="black"> 360. </font>
<font color="green"> 361. class CollectionFactory(object):</font>
<font color="black"> 362.     &quot;&quot;&quot;</font>
<font color="black"> 363.     A factory to create new</font>
<font color="black"> 364.     :py:class:`CollectionManager` and :py:class:`ResourceCollection`</font>
<font color="black"> 365.     subclasses from a :py:class:`~boto3.resources.model.Collection`</font>
<font color="black"> 366.     model. These subclasses include methods to perform batch operations.</font>
<font color="green"> 367.     &quot;&quot;&quot;</font>
<font color="green"> 368.     def load_from_definition(self, resource_name, collection_model,</font>
<font color="black"> 369.                              service_context, event_emitter):</font>
<font color="black"> 370.         &quot;&quot;&quot;</font>
<font color="black"> 371.         Loads a collection from a model, creating a new</font>
<font color="black"> 372.         :py:class:`CollectionManager` subclass</font>
<font color="black"> 373.         with the correct properties and methods, named based on the service</font>
<font color="black"> 374.         and resource name, e.g. ec2.InstanceCollectionManager. It also</font>
<font color="black"> 375.         creates a new :py:class:`ResourceCollection` subclass which is used</font>
<font color="black"> 376.         by the new manager class.</font>
<font color="black"> 377. </font>
<font color="black"> 378.         :type resource_name: string</font>
<font color="black"> 379.         :param resource_name: Name of the resource to look up. For services,</font>
<font color="black"> 380.                               this should match the ``service_name``.</font>
<font color="black"> 381. </font>
<font color="black"> 382.         :type service_context: :py:class:`~boto3.utils.ServiceContext`</font>
<font color="black"> 383.         :param service_context: Context about the AWS service</font>
<font color="black"> 384. </font>
<font color="black"> 385.         :type event_emitter: :py:class:`~botocore.hooks.HierarchialEmitter`</font>
<font color="black"> 386.         :param event_emitter: An event emitter</font>
<font color="black"> 387. </font>
<font color="black"> 388.         :rtype: Subclass of :py:class:`CollectionManager`</font>
<font color="black"> 389.         :return: The collection class.</font>
<font color="black"> 390.         &quot;&quot;&quot;</font>
<font color="red"> 391.         attrs = {}</font>
<font color="red"> 392.         collection_name = collection_model.name</font>
<font color="black"> 393. </font>
<font color="black"> 394.         # Create the batch actions for a collection</font>
<font color="red"> 395.         self._load_batch_actions(</font>
<font color="red"> 396.             attrs, resource_name, collection_model,</font>
<font color="red"> 397.             service_context.service_model, event_emitter)</font>
<font color="black"> 398.         # Add the documentation to the collection class's methods</font>
<font color="red"> 399.         self._load_documented_collection_methods(</font>
<font color="red"> 400.             attrs=attrs, resource_name=resource_name,</font>
<font color="red"> 401.             collection_model=collection_model,</font>
<font color="red"> 402.             service_model=service_context.service_model,</font>
<font color="red"> 403.             event_emitter=event_emitter,</font>
<font color="red"> 404.             base_class=ResourceCollection)</font>
<font color="black"> 405. </font>
<font color="red"> 406.         if service_context.service_name == resource_name:</font>
<font color="red"> 407.             cls_name = '{0}.{1}Collection'.format(</font>
<font color="red"> 408.                 service_context.service_name, collection_name)</font>
<font color="black"> 409.         else:</font>
<font color="red"> 410.             cls_name = '{0}.{1}.{2}Collection'.format(</font>
<font color="red"> 411.                 service_context.service_name, resource_name, collection_name)</font>
<font color="black"> 412. </font>
<font color="red"> 413.         collection_cls = type(str(cls_name), (ResourceCollection,),</font>
<font color="red"> 414.                               attrs)</font>
<font color="black"> 415. </font>
<font color="black"> 416.         # Add the documentation to the collection manager's methods</font>
<font color="red"> 417.         self._load_documented_collection_methods(</font>
<font color="red"> 418.             attrs=attrs, resource_name=resource_name,</font>
<font color="red"> 419.             collection_model=collection_model,</font>
<font color="red"> 420.             service_model=service_context.service_model,</font>
<font color="red"> 421.             event_emitter=event_emitter,</font>
<font color="red"> 422.             base_class=CollectionManager)</font>
<font color="red"> 423.         attrs['_collection_cls'] = collection_cls</font>
<font color="red"> 424.         cls_name += 'Manager'</font>
<font color="black"> 425. </font>
<font color="red"> 426.         return type(str(cls_name), (CollectionManager,), attrs)</font>
<font color="black"> 427. </font>
<font color="green"> 428.     def _load_batch_actions(self, attrs, resource_name, collection_model,</font>
<font color="black"> 429.                             service_model, event_emitter):</font>
<font color="black"> 430.         &quot;&quot;&quot;</font>
<font color="black"> 431.         Batch actions on the collection become methods on both</font>
<font color="black"> 432.         the collection manager and iterators.</font>
<font color="black"> 433.         &quot;&quot;&quot;</font>
<font color="red"> 434.         for action_model in collection_model.batch_actions:</font>
<font color="red"> 435.             snake_cased = xform_name(action_model.name)</font>
<font color="red"> 436.             attrs[snake_cased] = self._create_batch_action(</font>
<font color="red"> 437.                 resource_name, snake_cased, action_model, collection_model,</font>
<font color="red"> 438.                 service_model, event_emitter)</font>
<font color="black"> 439. </font>
<font color="green"> 440.     def _load_documented_collection_methods(</font>
<font color="black"> 441.             factory_self, attrs, resource_name, collection_model,</font>
<font color="black"> 442.             service_model, event_emitter, base_class):</font>
<font color="black"> 443.         # The base class already has these methods defined. However</font>
<font color="black"> 444.         # the docstrings are generic and not based for a particular service</font>
<font color="black"> 445.         # or resource. So we override these methods by proxying to the</font>
<font color="black"> 446.         # base class's builtin method and adding a docstring</font>
<font color="black"> 447.         # that pertains to the resource.</font>
<font color="black"> 448. </font>
<font color="black"> 449.         # A collection's all() method.</font>
<font color="red"> 450.         def all(self):</font>
<font color="red"> 451.             return base_class.all(self)</font>
<font color="black"> 452. </font>
<font color="red"> 453.         all.__doc__ = docstring.CollectionMethodDocstring(</font>
<font color="red"> 454.             resource_name=resource_name,</font>
<font color="red"> 455.             action_name='all',</font>
<font color="red"> 456.             event_emitter=event_emitter,</font>
<font color="red"> 457.             collection_model=collection_model,</font>
<font color="red"> 458.             service_model=service_model,</font>
<font color="red"> 459.             include_signature=False</font>
<font color="black"> 460.         )</font>
<font color="red"> 461.         attrs['all'] = all</font>
<font color="black"> 462. </font>
<font color="black"> 463.         # The collection's filter() method.</font>
<font color="red"> 464.         def filter(self, **kwargs):</font>
<font color="red"> 465.             return base_class.filter(self, **kwargs)</font>
<font color="black"> 466. </font>
<font color="red"> 467.         filter.__doc__ = docstring.CollectionMethodDocstring(</font>
<font color="red"> 468.             resource_name=resource_name,</font>
<font color="red"> 469.             action_name='filter',</font>
<font color="red"> 470.             event_emitter=event_emitter,</font>
<font color="red"> 471.             collection_model=collection_model,</font>
<font color="red"> 472.             service_model=service_model,</font>
<font color="red"> 473.             include_signature=False</font>
<font color="black"> 474.         )</font>
<font color="red"> 475.         attrs['filter'] = filter</font>
<font color="black"> 476. </font>
<font color="black"> 477.         # The collection's limit method.</font>
<font color="red"> 478.         def limit(self, count):</font>
<font color="red"> 479.             return base_class.limit(self, count)</font>
<font color="black"> 480. </font>
<font color="red"> 481.         limit.__doc__ = docstring.CollectionMethodDocstring(</font>
<font color="red"> 482.             resource_name=resource_name,</font>
<font color="red"> 483.             action_name='limit',</font>
<font color="red"> 484.             event_emitter=event_emitter,</font>
<font color="red"> 485.             collection_model=collection_model,</font>
<font color="red"> 486.             service_model=service_model,</font>
<font color="red"> 487.             include_signature=False</font>
<font color="black"> 488.         )</font>
<font color="red"> 489.         attrs['limit'] = limit</font>
<font color="black"> 490. </font>
<font color="black"> 491.         # The collection's page_size method.</font>
<font color="red"> 492.         def page_size(self, count):</font>
<font color="red"> 493.             return base_class.page_size(self, count)</font>
<font color="black"> 494. </font>
<font color="red"> 495.         page_size.__doc__ = docstring.CollectionMethodDocstring(</font>
<font color="red"> 496.             resource_name=resource_name,</font>
<font color="red"> 497.             action_name='page_size',</font>
<font color="red"> 498.             event_emitter=event_emitter,</font>
<font color="red"> 499.             collection_model=collection_model,</font>
<font color="red"> 500.             service_model=service_model,</font>
<font color="red"> 501.             include_signature=False</font>
<font color="black"> 502.         )</font>
<font color="red"> 503.         attrs['page_size'] = page_size</font>
<font color="black"> 504. </font>
<font color="green"> 505.     def _create_batch_action(factory_self, resource_name, snake_cased,</font>
<font color="black"> 506.                              action_model, collection_model, service_model,</font>
<font color="black"> 507.                              event_emitter):</font>
<font color="black"> 508.         &quot;&quot;&quot;</font>
<font color="black"> 509.         Creates a new method which makes a batch operation request</font>
<font color="black"> 510.         to the underlying service API.</font>
<font color="black"> 511.         &quot;&quot;&quot;</font>
<font color="red"> 512.         action = BatchAction(action_model)</font>
<font color="black"> 513. </font>
<font color="red"> 514.         def batch_action(self, *args, **kwargs):</font>
<font color="red"> 515.             return action(self, *args, **kwargs)</font>
<font color="black"> 516. </font>
<font color="red"> 517.         batch_action.__name__ = str(snake_cased)</font>
<font color="red"> 518.         batch_action.__doc__ = docstring.BatchActionDocstring(</font>
<font color="red"> 519.             resource_name=resource_name,</font>
<font color="red"> 520.             event_emitter=event_emitter,</font>
<font color="red"> 521.             batch_action_model=action_model,</font>
<font color="red"> 522.             service_model=service_model,</font>
<font color="red"> 523.             collection_model=collection_model,</font>
<font color="red"> 524.             include_signature=False</font>
<font color="black"> 525.         )</font>
<font color="red"> 526.         return batch_action</font>
</pre>

