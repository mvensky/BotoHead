source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/packages/urllib3/util/timeout.py</b><br>


file stats: <b>67 lines, 41 executed: 61.2% covered</b>
<pre>
<font color="black">   1. # The default socket timeout, used by httplib to indicate that no timeout was</font>
<font color="black">   2. # specified by the user</font>
<font color="green">   3. from socket import _GLOBAL_DEFAULT_TIMEOUT</font>
<font color="green">   4. import time</font>
<font color="black">   5. </font>
<font color="green">   6. from ..exceptions import TimeoutStateError</font>
<font color="black">   7. </font>
<font color="black">   8. # A sentinel value to indicate that no timeout was specified by the user in</font>
<font color="black">   9. # urllib3</font>
<font color="green">  10. _Default = object()</font>
<font color="black">  11. </font>
<font color="green">  12. def current_time():</font>
<font color="black">  13.     &quot;&quot;&quot;</font>
<font color="black">  14.     Retrieve the current time. This function is mocked out in unit testing.</font>
<font color="black">  15.     &quot;&quot;&quot;</font>
<font color="green">  16.     return time.time()</font>
<font color="black">  17. </font>
<font color="black">  18. </font>
<font color="green">  19. class Timeout(object):</font>
<font color="black">  20.     &quot;&quot;&quot; Timeout configuration.</font>
<font color="black">  21. </font>
<font color="black">  22.     Timeouts can be defined as a default for a pool::</font>
<font color="black">  23. </font>
<font color="black">  24.         timeout = Timeout(connect=2.0, read=7.0)</font>
<font color="black">  25.         http = PoolManager(timeout=timeout)</font>
<font color="black">  26.         response = http.request('GET', 'http://example.com/')</font>
<font color="black">  27. </font>
<font color="black">  28.     Or per-request (which overrides the default for the pool)::</font>
<font color="black">  29. </font>
<font color="black">  30.         response = http.request('GET', 'http://example.com/', timeout=Timeout(10))</font>
<font color="black">  31. </font>
<font color="black">  32.     Timeouts can be disabled by setting all the parameters to ``None``::</font>
<font color="black">  33. </font>
<font color="black">  34.         no_timeout = Timeout(connect=None, read=None)</font>
<font color="black">  35.         response = http.request('GET', 'http://example.com/, timeout=no_timeout)</font>
<font color="black">  36. </font>
<font color="black">  37. </font>
<font color="black">  38.     :param total:</font>
<font color="black">  39.         This combines the connect and read timeouts into one; the read timeout</font>
<font color="black">  40.         will be set to the time leftover from the connect attempt. In the</font>
<font color="black">  41.         event that both a connect timeout and a total are specified, or a read</font>
<font color="black">  42.         timeout and a total are specified, the shorter timeout will be applied.</font>
<font color="black">  43. </font>
<font color="black">  44.         Defaults to None.</font>
<font color="black">  45. </font>
<font color="black">  46.     :type total: integer, float, or None</font>
<font color="black">  47. </font>
<font color="black">  48.     :param connect:</font>
<font color="black">  49.         The maximum amount of time to wait for a connection attempt to a server</font>
<font color="black">  50.         to succeed. Omitting the parameter will default the connect timeout to</font>
<font color="black">  51.         the system default, probably `the global default timeout in socket.py</font>
<font color="black">  52.         &lt;http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535&gt;`_.</font>
<font color="black">  53.         None will set an infinite timeout for connection attempts.</font>
<font color="black">  54. </font>
<font color="black">  55.     :type connect: integer, float, or None</font>
<font color="black">  56. </font>
<font color="black">  57.     :param read:</font>
<font color="black">  58.         The maximum amount of time to wait between consecutive</font>
<font color="black">  59.         read operations for a response from the server. Omitting</font>
<font color="black">  60.         the parameter will default the read timeout to the system</font>
<font color="black">  61.         default, probably `the global default timeout in socket.py</font>
<font color="black">  62.         &lt;http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535&gt;`_.</font>
<font color="black">  63.         None will set an infinite timeout.</font>
<font color="black">  64. </font>
<font color="black">  65.     :type read: integer, float, or None</font>
<font color="black">  66. </font>
<font color="black">  67.     .. note::</font>
<font color="black">  68. </font>
<font color="black">  69.         Many factors can affect the total amount of time for urllib3 to return</font>
<font color="black">  70.         an HTTP response.</font>
<font color="black">  71. </font>
<font color="black">  72.         For example, Python's DNS resolver does not obey the timeout specified</font>
<font color="black">  73.         on the socket. Other factors that can affect total request time include</font>
<font color="black">  74.         high CPU load, high swap, the program running at a low priority level,</font>
<font color="black">  75.         or other behaviors.</font>
<font color="black">  76. </font>
<font color="black">  77.         In addition, the read and total timeouts only measure the time between</font>
<font color="black">  78.         read operations on the socket connecting the client and the server,</font>
<font color="black">  79.         not the total amount of time for the request to return a complete</font>
<font color="black">  80.         response. For most requests, the timeout is raised because the server</font>
<font color="black">  81.         has not sent the first byte in the specified time. This is not always</font>
<font color="black">  82.         the case; if a server streams one byte every fifteen seconds, a timeout</font>
<font color="black">  83.         of 20 seconds will not trigger, even though the request will take</font>
<font color="black">  84.         several minutes to complete.</font>
<font color="black">  85. </font>
<font color="black">  86.         If your goal is to cut off any request after a set amount of wall clock</font>
<font color="black">  87.         time, consider having a second &quot;watcher&quot; thread to cut off a slow</font>
<font color="black">  88.         request.</font>
<font color="green">  89.     &quot;&quot;&quot;</font>
<font color="black">  90. </font>
<font color="black">  91.     #: A sentinel object representing the default timeout value</font>
<font color="green">  92.     DEFAULT_TIMEOUT = _GLOBAL_DEFAULT_TIMEOUT</font>
<font color="black">  93. </font>
<font color="green">  94.     def __init__(self, total=None, connect=_Default, read=_Default):</font>
<font color="green">  95.         self._connect = self._validate_timeout(connect, 'connect')</font>
<font color="green">  96.         self._read = self._validate_timeout(read, 'read')</font>
<font color="green">  97.         self.total = self._validate_timeout(total, 'total')</font>
<font color="green">  98.         self._start_connect = None</font>
<font color="black">  99. </font>
<font color="green"> 100.     def __str__(self):</font>
<font color="red"> 101.         return '%s(connect=%r, read=%r, total=%r)' % (</font>
<font color="red"> 102.             type(self).__name__, self._connect, self._read, self.total)</font>
<font color="black"> 103. </font>
<font color="green"> 104.     @classmethod</font>
<font color="black"> 105.     def _validate_timeout(cls, value, name):</font>
<font color="black"> 106.         &quot;&quot;&quot; Check that a timeout attribute is valid.</font>
<font color="black"> 107. </font>
<font color="black"> 108.         :param value: The timeout value to validate</font>
<font color="black"> 109.         :param name: The name of the timeout attribute to validate. This is</font>
<font color="black"> 110.             used to specify in error messages.</font>
<font color="black"> 111.         :return: The validated and casted version of the given value.</font>
<font color="black"> 112.         :raises ValueError: If the type is not an integer or a float, or if it</font>
<font color="black"> 113.             is a numeric value less than zero.</font>
<font color="black"> 114.         &quot;&quot;&quot;</font>
<font color="green"> 115.         if value is _Default:</font>
<font color="red"> 116.             return cls.DEFAULT_TIMEOUT</font>
<font color="black"> 117. </font>
<font color="green"> 118.         if value is None or value is cls.DEFAULT_TIMEOUT:</font>
<font color="green"> 119.             return value</font>
<font color="black"> 120. </font>
<font color="green"> 121.         try:</font>
<font color="green"> 122.             float(value)</font>
<font color="red"> 123.         except (TypeError, ValueError):</font>
<font color="red"> 124.             raise ValueError(&quot;Timeout value %s was %s, but it must be an &quot;</font>
<font color="red"> 125.                              &quot;int or float.&quot; % (name, value))</font>
<font color="black"> 126. </font>
<font color="green"> 127.         try:</font>
<font color="green"> 128.             if value &lt; 0:</font>
<font color="red"> 129.                 raise ValueError(&quot;Attempted to set %s timeout to %s, but the &quot;</font>
<font color="black"> 130.                                  &quot;timeout cannot be set to a value less &quot;</font>
<font color="red"> 131.                                  &quot;than 0.&quot; % (name, value))</font>
<font color="red"> 132.         except TypeError:  # Python 3</font>
<font color="red"> 133.             raise ValueError(&quot;Timeout value %s was %s, but it must be an &quot;</font>
<font color="red"> 134.                              &quot;int or float.&quot; % (name, value))</font>
<font color="black"> 135. </font>
<font color="green"> 136.         return value</font>
<font color="black"> 137. </font>
<font color="green"> 138.     @classmethod</font>
<font color="black"> 139.     def from_float(cls, timeout):</font>
<font color="black"> 140.         &quot;&quot;&quot; Create a new Timeout from a legacy timeout value.</font>
<font color="black"> 141. </font>
<font color="black"> 142.         The timeout value used by httplib.py sets the same timeout on the</font>
<font color="black"> 143.         connect(), and recv() socket requests. This creates a :class:`Timeout`</font>
<font color="black"> 144.         object that sets the individual timeouts to the ``timeout`` value</font>
<font color="black"> 145.         passed to this function.</font>
<font color="black"> 146. </font>
<font color="black"> 147.         :param timeout: The legacy timeout value.</font>
<font color="black"> 148.         :type timeout: integer, float, sentinel default object, or None</font>
<font color="black"> 149.         :return: Timeout object</font>
<font color="black"> 150.         :rtype: :class:`Timeout`</font>
<font color="black"> 151.         &quot;&quot;&quot;</font>
<font color="green"> 152.         return Timeout(read=timeout, connect=timeout)</font>
<font color="black"> 153. </font>
<font color="green"> 154.     def clone(self):</font>
<font color="black"> 155.         &quot;&quot;&quot; Create a copy of the timeout object</font>
<font color="black"> 156. </font>
<font color="black"> 157.         Timeout properties are stored per-pool but each request needs a fresh</font>
<font color="black"> 158.         Timeout object to ensure each one has its own start/stop configured.</font>
<font color="black"> 159. </font>
<font color="black"> 160.         :return: a copy of the timeout object</font>
<font color="black"> 161.         :rtype: :class:`Timeout`</font>
<font color="black"> 162.         &quot;&quot;&quot;</font>
<font color="black"> 163.         # We can't use copy.deepcopy because that will also create a new object</font>
<font color="black"> 164.         # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to</font>
<font color="black"> 165.         # detect the user default.</font>
<font color="green"> 166.         return Timeout(connect=self._connect, read=self._read,</font>
<font color="green"> 167.                        total=self.total)</font>
<font color="black"> 168. </font>
<font color="green"> 169.     def start_connect(self):</font>
<font color="black"> 170.         &quot;&quot;&quot; Start the timeout clock, used during a connect() attempt</font>
<font color="black"> 171. </font>
<font color="black"> 172.         :raises urllib3.exceptions.TimeoutStateError: if you attempt</font>
<font color="black"> 173.             to start a timer that has been started already.</font>
<font color="black"> 174.         &quot;&quot;&quot;</font>
<font color="green"> 175.         if self._start_connect is not None:</font>
<font color="red"> 176.             raise TimeoutStateError(&quot;Timeout timer has already been started.&quot;)</font>
<font color="green"> 177.         self._start_connect = current_time()</font>
<font color="green"> 178.         return self._start_connect</font>
<font color="black"> 179. </font>
<font color="green"> 180.     def get_connect_duration(self):</font>
<font color="black"> 181.         &quot;&quot;&quot; Gets the time elapsed since the call to :meth:`start_connect`.</font>
<font color="black"> 182. </font>
<font color="black"> 183.         :return: Elapsed time.</font>
<font color="black"> 184.         :rtype: float</font>
<font color="black"> 185.         :raises urllib3.exceptions.TimeoutStateError: if you attempt</font>
<font color="black"> 186.             to get duration for a timer that hasn't been started.</font>
<font color="black"> 187.         &quot;&quot;&quot;</font>
<font color="red"> 188.         if self._start_connect is None:</font>
<font color="red"> 189.             raise TimeoutStateError(&quot;Can't get connect duration for timer &quot;</font>
<font color="black"> 190.                                     &quot;that has not started.&quot;)</font>
<font color="red"> 191.         return current_time() - self._start_connect</font>
<font color="black"> 192. </font>
<font color="green"> 193.     @property</font>
<font color="black"> 194.     def connect_timeout(self):</font>
<font color="black"> 195.         &quot;&quot;&quot; Get the value to use when setting a connection timeout.</font>
<font color="black"> 196. </font>
<font color="black"> 197.         This will be a positive float or integer, the value None</font>
<font color="black"> 198.         (never timeout), or the default system timeout.</font>
<font color="black"> 199. </font>
<font color="black"> 200.         :return: Connect timeout.</font>
<font color="black"> 201.         :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None</font>
<font color="black"> 202.         &quot;&quot;&quot;</font>
<font color="green"> 203.         if self.total is None:</font>
<font color="green"> 204.             return self._connect</font>
<font color="black"> 205. </font>
<font color="red"> 206.         if self._connect is None or self._connect is self.DEFAULT_TIMEOUT:</font>
<font color="red"> 207.             return self.total</font>
<font color="black"> 208. </font>
<font color="red"> 209.         return min(self._connect, self.total)</font>
<font color="black"> 210. </font>
<font color="green"> 211.     @property</font>
<font color="black"> 212.     def read_timeout(self):</font>
<font color="black"> 213.         &quot;&quot;&quot; Get the value for the read timeout.</font>
<font color="black"> 214. </font>
<font color="black"> 215.         This assumes some time has elapsed in the connection timeout and</font>
<font color="black"> 216.         computes the read timeout appropriately.</font>
<font color="black"> 217. </font>
<font color="black"> 218.         If self.total is set, the read timeout is dependent on the amount of</font>
<font color="black"> 219.         time taken by the connect timeout. If the connection time has not been</font>
<font color="black"> 220.         established, a :exc:`~urllib3.exceptions.TimeoutStateError` will be</font>
<font color="black"> 221.         raised.</font>
<font color="black"> 222. </font>
<font color="black"> 223.         :return: Value to use for the read timeout.</font>
<font color="black"> 224.         :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None</font>
<font color="black"> 225.         :raises urllib3.exceptions.TimeoutStateError: If :meth:`start_connect`</font>
<font color="black"> 226.             has not yet been called on this object.</font>
<font color="black"> 227.         &quot;&quot;&quot;</font>
<font color="green"> 228.         if (self.total is not None and</font>
<font color="red"> 229.             self.total is not self.DEFAULT_TIMEOUT and</font>
<font color="red"> 230.             self._read is not None and</font>
<font color="red"> 231.             self._read is not self.DEFAULT_TIMEOUT):</font>
<font color="black"> 232.             # In case the connect timeout has not yet been established.</font>
<font color="red"> 233.             if self._start_connect is None:</font>
<font color="red"> 234.                 return self._read</font>
<font color="red"> 235.             return max(0, min(self.total - self.get_connect_duration(),</font>
<font color="red"> 236.                               self._read))</font>
<font color="green"> 237.         elif self.total is not None and self.total is not self.DEFAULT_TIMEOUT:</font>
<font color="red"> 238.             return max(0, self.total - self.get_connect_duration())</font>
<font color="black"> 239.         else:</font>
<font color="green"> 240.             return self._read</font>
</pre>

