source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/pyasn1/type/univ.py</b><br>


file stats: <b>1257 lines, 463 executed: 36.8% covered</b>
<pre>
<font color="black">   1. #</font>
<font color="black">   2. # This file is part of pyasn1 software.</font>
<font color="black">   3. #</font>
<font color="black">   4. # Copyright (c) 2005-2017, Ilya Etingof &lt;etingof@gmail.com&gt;</font>
<font color="black">   5. # License: http://pyasn1.sf.net/license.html</font>
<font color="black">   6. #</font>
<font color="green">   7. import operator</font>
<font color="green">   8. import sys</font>
<font color="green">   9. import math</font>
<font color="green">  10. from pyasn1.type import base, tag, constraint, namedtype, namedval, tagmap</font>
<font color="green">  11. from pyasn1.codec.ber import eoo</font>
<font color="green">  12. from pyasn1.compat import octets, integer, binary</font>
<font color="green">  13. from pyasn1 import error</font>
<font color="black">  14. </font>
<font color="green">  15. NoValue = base.NoValue</font>
<font color="green">  16. noValue = NoValue()</font>
<font color="black">  17. </font>
<font color="green">  18. __all__ = ['Integer', 'Boolean', 'BitString', 'OctetString', 'Null',</font>
<font color="green">  19.            'ObjectIdentifier', 'Real', 'Enumerated', 'SequenceOfAndSetOfBase', 'SequenceOf',</font>
<font color="green">  20.            'SetOf', 'SequenceAndSetBase', 'Sequence', 'Set', 'Choice', 'Any',</font>
<font color="green">  21.            'NoValue', 'noValue']</font>
<font color="black">  22. </font>
<font color="black">  23. # &quot;Simple&quot; ASN.1 types (yet incomplete)</font>
<font color="black">  24. </font>
<font color="green">  25. class Integer(base.AbstractSimpleAsn1Item):</font>
<font color="black">  26.     &quot;&quot;&quot;Create |ASN.1| type or object.</font>
<font color="black">  27. </font>
<font color="black">  28.     |ASN.1| objects are immutable and duck-type Python :class:`int` objects.</font>
<font color="black">  29. </font>
<font color="black">  30.     Parameters</font>
<font color="black">  31.     ----------</font>
<font color="black">  32.     value : :class:`int`, :class:`str` or |ASN.1| object</font>
<font color="black">  33.         Python integer or string literal or |ASN.1| class instance.</font>
<font color="black">  34. </font>
<font color="black">  35.     tagSet: :py:class:`~pyasn1.type.tag.TagSet`</font>
<font color="black">  36.         Object representing non-default ASN.1 tag(s)</font>
<font color="black">  37. </font>
<font color="black">  38.     subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">  39.         Object representing non-default ASN.1 subtype constraint(s)</font>
<font color="black">  40. </font>
<font color="black">  41.     namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`</font>
<font color="black">  42.         Object representing non-default symbolic aliases for numbers</font>
<font color="black">  43. </font>
<font color="black">  44.     Raises</font>
<font color="black">  45.     ------</font>
<font color="black">  46.     : :py:class:`pyasn1.error.PyAsn1Error`</font>
<font color="black">  47.         On constraint violation or bad initializer.</font>
<font color="green">  48.     &quot;&quot;&quot;</font>
<font color="black">  49.     #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects</font>
<font color="green">  50.     tagSet = tag.initTagSet(</font>
<font color="green">  51.         tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x02)</font>
<font color="black">  52.     )</font>
<font color="green">  53.     baseTagSet = tagSet</font>
<font color="black">  54. </font>
<font color="black">  55.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">  56.     #: object imposing constraints on initialization values.</font>
<font color="green">  57.     subtypeSpec = constraint.ConstraintsIntersection()</font>
<font color="black">  58. </font>
<font color="black">  59.     #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object</font>
<font color="black">  60.     #: representing symbolic aliases for numbers</font>
<font color="green">  61.     namedValues = namedval.NamedValues()</font>
<font color="black">  62. </font>
<font color="green">  63.     def __init__(self, value=noValue, tagSet=None, subtypeSpec=None,</font>
<font color="green">  64.                  namedValues=None):</font>
<font color="green">  65.         if namedValues is None:</font>
<font color="green">  66.             self.__namedValues = self.namedValues</font>
<font color="black">  67.         else:</font>
<font color="red">  68.             self.__namedValues = namedValues</font>
<font color="green">  69.         base.AbstractSimpleAsn1Item.__init__(</font>
<font color="green">  70.             self, value, tagSet, subtypeSpec</font>
<font color="black">  71.         )</font>
<font color="black">  72. </font>
<font color="green">  73.     def __repr__(self):</font>
<font color="red">  74.         if self.__namedValues is not self.namedValues:</font>
<font color="red">  75.             return '%s, %r)' % (base.AbstractSimpleAsn1Item.__repr__(self)[:-1], self.__namedValues)</font>
<font color="black">  76.         else:</font>
<font color="red">  77.             return base.AbstractSimpleAsn1Item.__repr__(self)</font>
<font color="black">  78. </font>
<font color="green">  79.     def __and__(self, value):</font>
<font color="red">  80.         return self.clone(self._value &amp; value)</font>
<font color="black">  81. </font>
<font color="green">  82.     def __rand__(self, value):</font>
<font color="red">  83.         return self.clone(value &amp; self._value)</font>
<font color="black">  84. </font>
<font color="green">  85.     def __or__(self, value):</font>
<font color="red">  86.         return self.clone(self._value | value)</font>
<font color="black">  87. </font>
<font color="green">  88.     def __ror__(self, value):</font>
<font color="red">  89.         return self.clone(value | self._value)</font>
<font color="black">  90. </font>
<font color="green">  91.     def __xor__(self, value):</font>
<font color="red">  92.         return self.clone(self._value ^ value)</font>
<font color="black">  93. </font>
<font color="green">  94.     def __rxor__(self, value):</font>
<font color="red">  95.         return self.clone(value ^ self._value)</font>
<font color="black">  96. </font>
<font color="green">  97.     def __lshift__(self, value):</font>
<font color="red">  98.         return self.clone(self._value &lt;&lt; value)</font>
<font color="black">  99. </font>
<font color="green"> 100.     def __rshift__(self, value):</font>
<font color="red"> 101.         return self.clone(self._value &gt;&gt; value)</font>
<font color="black"> 102. </font>
<font color="green"> 103.     def __add__(self, value):</font>
<font color="red"> 104.         return self.clone(self._value + value)</font>
<font color="black"> 105. </font>
<font color="green"> 106.     def __radd__(self, value):</font>
<font color="red"> 107.         return self.clone(value + self._value)</font>
<font color="black"> 108. </font>
<font color="green"> 109.     def __sub__(self, value):</font>
<font color="red"> 110.         return self.clone(self._value - value)</font>
<font color="black"> 111. </font>
<font color="green"> 112.     def __rsub__(self, value):</font>
<font color="red"> 113.         return self.clone(value - self._value)</font>
<font color="black"> 114. </font>
<font color="green"> 115.     def __mul__(self, value):</font>
<font color="red"> 116.         return self.clone(self._value * value)</font>
<font color="black"> 117. </font>
<font color="green"> 118.     def __rmul__(self, value):</font>
<font color="red"> 119.         return self.clone(value * self._value)</font>
<font color="black"> 120. </font>
<font color="green"> 121.     def __mod__(self, value):</font>
<font color="red"> 122.         return self.clone(self._value % value)</font>
<font color="black"> 123. </font>
<font color="green"> 124.     def __rmod__(self, value):</font>
<font color="red"> 125.         return self.clone(value % self._value)</font>
<font color="black"> 126. </font>
<font color="green"> 127.     def __pow__(self, value, modulo=None):</font>
<font color="red"> 128.         return self.clone(pow(self._value, value, modulo))</font>
<font color="black"> 129. </font>
<font color="green"> 130.     def __rpow__(self, value):</font>
<font color="red"> 131.         return self.clone(pow(value, self._value))</font>
<font color="black"> 132. </font>
<font color="green"> 133.     def __floordiv__(self, value):</font>
<font color="red"> 134.         return self.clone(self._value // value)</font>
<font color="black"> 135. </font>
<font color="green"> 136.     def __rfloordiv__(self, value):</font>
<font color="red"> 137.         return self.clone(value // self._value)</font>
<font color="black"> 138. </font>
<font color="green"> 139.     if sys.version_info[0] &lt;= 2:</font>
<font color="green"> 140.         def __div__(self, value):</font>
<font color="red"> 141.             if isinstance(value, float):</font>
<font color="red"> 142.                 return Real(self._value / value)</font>
<font color="black"> 143.             else:</font>
<font color="red"> 144.                 return self.clone(self._value / value)</font>
<font color="black"> 145. </font>
<font color="green"> 146.         def __rdiv__(self, value):</font>
<font color="red"> 147.             if isinstance(value, float):</font>
<font color="red"> 148.                 return Real(value / self._value)</font>
<font color="black"> 149.             else:</font>
<font color="red"> 150.                 return self.clone(value / self._value)</font>
<font color="black"> 151.     else:</font>
<font color="red"> 152.         def __truediv__(self, value):</font>
<font color="red"> 153.             return Real(self._value / value)</font>
<font color="black"> 154. </font>
<font color="red"> 155.         def __rtruediv__(self, value):</font>
<font color="red"> 156.             return Real(value / self._value)</font>
<font color="black"> 157. </font>
<font color="red"> 158.         def __divmod__(self, value):</font>
<font color="red"> 159.             return self.clone(divmod(self._value, value))</font>
<font color="black"> 160. </font>
<font color="red"> 161.         def __rdivmod__(self, value):</font>
<font color="red"> 162.             return self.clone(divmod(value, self._value))</font>
<font color="black"> 163. </font>
<font color="red"> 164.         __hash__ = base.AbstractSimpleAsn1Item.__hash__</font>
<font color="black"> 165. </font>
<font color="green"> 166.     def __int__(self):</font>
<font color="red"> 167.         return int(self._value)</font>
<font color="black"> 168. </font>
<font color="green"> 169.     if sys.version_info[0] &lt;= 2:</font>
<font color="green"> 170.         def __long__(self): return long(self._value)</font>
<font color="black"> 171. </font>
<font color="green"> 172.     def __float__(self):</font>
<font color="red"> 173.         return float(self._value)</font>
<font color="black"> 174. </font>
<font color="green"> 175.     def __abs__(self):</font>
<font color="red"> 176.         return self.clone(abs(self._value))</font>
<font color="black"> 177. </font>
<font color="green"> 178.     def __index__(self):</font>
<font color="red"> 179.         return int(self._value)</font>
<font color="black"> 180. </font>
<font color="green"> 181.     def __pos__(self):</font>
<font color="red"> 182.         return self.clone(+self._value)</font>
<font color="black"> 183. </font>
<font color="green"> 184.     def __neg__(self):</font>
<font color="red"> 185.         return self.clone(-self._value)</font>
<font color="black"> 186. </font>
<font color="green"> 187.     def __invert__(self):</font>
<font color="red"> 188.         return self.clone(~self._value)</font>
<font color="black"> 189. </font>
<font color="green"> 190.     def __round__(self, n=0):</font>
<font color="red"> 191.         r = round(self._value, n)</font>
<font color="red"> 192.         if n:</font>
<font color="red"> 193.             return self.clone(r)</font>
<font color="black"> 194.         else:</font>
<font color="red"> 195.             return r</font>
<font color="black"> 196. </font>
<font color="green"> 197.     def __floor__(self):</font>
<font color="red"> 198.         return math.floor(self._value)</font>
<font color="black"> 199. </font>
<font color="green"> 200.     def __ceil__(self):</font>
<font color="red"> 201.         return math.ceil(self._value)</font>
<font color="black"> 202. </font>
<font color="green"> 203.     if sys.version_info[0:2] &gt; (2, 5):</font>
<font color="green"> 204.         def __trunc__(self): return self.clone(math.trunc(self._value))</font>
<font color="black"> 205. </font>
<font color="green"> 206.     def __lt__(self, value):</font>
<font color="red"> 207.         return self._value &lt; value</font>
<font color="black"> 208. </font>
<font color="green"> 209.     def __le__(self, value):</font>
<font color="red"> 210.         return self._value &lt;= value</font>
<font color="black"> 211. </font>
<font color="green"> 212.     def __eq__(self, value):</font>
<font color="red"> 213.         return self._value == value</font>
<font color="black"> 214. </font>
<font color="green"> 215.     def __ne__(self, value):</font>
<font color="red"> 216.         return self._value != value</font>
<font color="black"> 217. </font>
<font color="green"> 218.     def __gt__(self, value):</font>
<font color="red"> 219.         return self._value &gt; value</font>
<font color="black"> 220. </font>
<font color="green"> 221.     def __ge__(self, value):</font>
<font color="red"> 222.         return self._value &gt;= value</font>
<font color="black"> 223. </font>
<font color="green"> 224.     def prettyIn(self, value):</font>
<font color="green"> 225.         if not octets.isStringType(value):</font>
<font color="green"> 226.             try:</font>
<font color="green"> 227.                 return int(value)</font>
<font color="red"> 228.             except:</font>
<font color="red"> 229.                 raise error.PyAsn1Error(</font>
<font color="red"> 230.                     'Can\'t coerce %r into integer: %s' % (value, sys.exc_info()[1])</font>
<font color="black"> 231.                 )</font>
<font color="green"> 232.         r = self.__namedValues.getValue(value)</font>
<font color="green"> 233.         if r is not None:</font>
<font color="green"> 234.             return r</font>
<font color="red"> 235.         try:</font>
<font color="red"> 236.             return int(value)</font>
<font color="red"> 237.         except:</font>
<font color="red"> 238.             raise error.PyAsn1Error(</font>
<font color="red"> 239.                 'Can\'t coerce %r into integer: %s' % (value, sys.exc_info()[1])</font>
<font color="black"> 240.             )</font>
<font color="black"> 241. </font>
<font color="green"> 242.     def prettyOut(self, value):</font>
<font color="red"> 243.         r = self.__namedValues.getName(value)</font>
<font color="red"> 244.         return r is None and str(value) or repr(r)</font>
<font color="black"> 245. </font>
<font color="green"> 246.     def getNamedValues(self):</font>
<font color="red"> 247.         return self.__namedValues</font>
<font color="black"> 248. </font>
<font color="green"> 249.     def clone(self, value=noValue, tagSet=None, subtypeSpec=None, namedValues=None):</font>
<font color="black"> 250.         &quot;&quot;&quot;Create a copy of a |ASN.1| type or object.</font>
<font color="black"> 251. </font>
<font color="black"> 252.         Any parameters to the *clone()* method will replace corresponding</font>
<font color="black"> 253.         properties of the |ASN.1| object.</font>
<font color="black"> 254. </font>
<font color="black"> 255.         Parameters</font>
<font color="black"> 256.         ----------</font>
<font color="black"> 257.         value: :class:`int`, :class:`str` or |ASN.1| object</font>
<font color="black"> 258.             Initialization value to pass to new ASN.1 object instead of</font>
<font color="black"> 259.             inheriting one from the caller.</font>
<font color="black"> 260. </font>
<font color="black"> 261.         tagSet: :py:class:`~pyasn1.type.tag.TagSet`</font>
<font color="black"> 262.             Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller</font>
<font color="black"> 263. </font>
<font color="black"> 264.         subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black"> 265.             Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller</font>
<font color="black"> 266. </font>
<font color="black"> 267.         namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`</font>
<font color="black"> 268.             Object representing symbolic aliases for numbers to use instead of inheriting from caller</font>
<font color="black"> 269. </font>
<font color="black"> 270.         Returns</font>
<font color="black"> 271.         -------</font>
<font color="black"> 272.         :</font>
<font color="black"> 273.             new instance of |ASN.1| type/value</font>
<font color="black"> 274.         &quot;&quot;&quot;</font>
<font color="red"> 275.         if self.isNoValue(value):</font>
<font color="red"> 276.             if self.isNoValue(tagSet, subtypeSpec, namedValues):</font>
<font color="red"> 277.                 return self</font>
<font color="red"> 278.             value = self._value</font>
<font color="red"> 279.         if tagSet is None:</font>
<font color="red"> 280.             tagSet = self._tagSet</font>
<font color="red"> 281.         if subtypeSpec is None:</font>
<font color="red"> 282.             subtypeSpec = self._subtypeSpec</font>
<font color="red"> 283.         if namedValues is None:</font>
<font color="red"> 284.             namedValues = self.__namedValues</font>
<font color="red"> 285.         return self.__class__(value, tagSet, subtypeSpec, namedValues)</font>
<font color="black"> 286. </font>
<font color="green"> 287.     def subtype(self, value=noValue, implicitTag=None, explicitTag=None,</font>
<font color="green"> 288.                 subtypeSpec=None, namedValues=None):</font>
<font color="black"> 289.         &quot;&quot;&quot;Create a copy of a |ASN.1| type or object.</font>
<font color="black"> 290. </font>
<font color="black"> 291.         Any parameters to the *subtype()* method will be added to the corresponding</font>
<font color="black"> 292.         properties of the |ASN.1| object.</font>
<font color="black"> 293. </font>
<font color="black"> 294.         Parameters</font>
<font color="black"> 295.         ----------</font>
<font color="black"> 296.         value: :class:`int`, :class:`str` or |ASN.1| object</font>
<font color="black"> 297.             Initialization value to pass to new ASN.1 object instead of</font>
<font color="black"> 298.             inheriting one from the caller.</font>
<font color="black"> 299. </font>
<font color="black"> 300.         implicitTag: :py:class:`~pyasn1.type.tag.Tag`</font>
<font color="black"> 301.             Implicitly apply given ASN.1 tag object to caller's</font>
<font color="black"> 302.             :py:class:`~pyasn1.type.tag.TagSet`, then use the result as</font>
<font color="black"> 303.             new object's ASN.1 tag(s).</font>
<font color="black"> 304. </font>
<font color="black"> 305.         explicitTag: :py:class:`~pyasn1.type.tag.Tag`</font>
<font color="black"> 306.             Explicitly apply given ASN.1 tag object to caller's</font>
<font color="black"> 307.             :py:class:`~pyasn1.type.tag.TagSet`, then use the result as</font>
<font color="black"> 308.             new object's ASN.1 tag(s).</font>
<font color="black"> 309. </font>
<font color="black"> 310.         subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black"> 311.             Add ASN.1 constraints object to one of the caller, then</font>
<font color="black"> 312.             use the result as new object's ASN.1 constraints.</font>
<font color="black"> 313. </font>
<font color="black"> 314.         namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`</font>
<font color="black"> 315.             Add given object representing symbolic aliases for numbers</font>
<font color="black"> 316.             to one of the caller, then use the result as new object's</font>
<font color="black"> 317.             named numbers.</font>
<font color="black"> 318. </font>
<font color="black"> 319.         Returns</font>
<font color="black"> 320.         -------</font>
<font color="black"> 321.         :</font>
<font color="black"> 322.             new instance of |ASN.1| type/value</font>
<font color="black"> 323.         &quot;&quot;&quot;</font>
<font color="red"> 324.         if self.isNoValue(value):</font>
<font color="red"> 325.             value = self._value</font>
<font color="red"> 326.         if implicitTag is not None:</font>
<font color="red"> 327.             tagSet = self._tagSet.tagImplicitly(implicitTag)</font>
<font color="red"> 328.         elif explicitTag is not None:</font>
<font color="red"> 329.             tagSet = self._tagSet.tagExplicitly(explicitTag)</font>
<font color="black"> 330.         else:</font>
<font color="red"> 331.             tagSet = self._tagSet</font>
<font color="red"> 332.         if subtypeSpec is None:</font>
<font color="red"> 333.             subtypeSpec = self._subtypeSpec</font>
<font color="black"> 334.         else:</font>
<font color="red"> 335.             subtypeSpec = self._subtypeSpec + subtypeSpec</font>
<font color="red"> 336.         if namedValues is None:</font>
<font color="red"> 337.             namedValues = self.__namedValues</font>
<font color="black"> 338.         else:</font>
<font color="red"> 339.             namedValues = namedValues + self.__namedValues</font>
<font color="red"> 340.         return self.__class__(value, tagSet, subtypeSpec, namedValues)</font>
<font color="black"> 341. </font>
<font color="black"> 342. </font>
<font color="green"> 343. class Boolean(Integer):</font>
<font color="green"> 344.     __doc__ = Integer.__doc__</font>
<font color="black"> 345. </font>
<font color="black"> 346.     #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects</font>
<font color="green"> 347.     tagSet = tag.initTagSet(</font>
<font color="green"> 348.         tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x01),</font>
<font color="black"> 349.     )</font>
<font color="green"> 350.     baseTagSet = tagSet</font>
<font color="black"> 351. </font>
<font color="black"> 352.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black"> 353.     #: object imposing constraints on initialization values.</font>
<font color="green"> 354.     subtypeSpec = Integer.subtypeSpec + constraint.SingleValueConstraint(0, 1)</font>
<font color="black"> 355. </font>
<font color="black"> 356.     #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object</font>
<font color="black"> 357.     #: representing symbolic aliases for numbers</font>
<font color="green"> 358.     namedValues = Integer.namedValues.clone(('False', 0), ('True', 1))</font>
<font color="black"> 359. </font>
<font color="black"> 360. </font>
<font color="green"> 361. class BitString(base.AbstractSimpleAsn1Item):</font>
<font color="black"> 362.     &quot;&quot;&quot;Create |ASN.1| type or object.</font>
<font color="black"> 363. </font>
<font color="black"> 364.     |ASN.1| objects are immutable and duck-type both Python :class:`tuple` (as a tuple</font>
<font color="black"> 365.     of bits) and :class:`int` objects.</font>
<font color="black"> 366. </font>
<font color="black"> 367.     Parameters</font>
<font color="black"> 368.     ----------</font>
<font color="black"> 369.     value : :class:`int`, :class:`str` or |ASN.1| object</font>
<font color="black"> 370.         Python integer or string literal representing binary or hexadecimal</font>
<font color="black"> 371.         number or sequence of integer bits or |ASN.1| object.</font>
<font color="black"> 372. </font>
<font color="black"> 373.     tagSet: :py:class:`~pyasn1.type.tag.TagSet`</font>
<font color="black"> 374.         Object representing non-default ASN.1 tag(s)</font>
<font color="black"> 375. </font>
<font color="black"> 376.     subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black"> 377.         Object representing non-default ASN.1 subtype constraint(s)</font>
<font color="black"> 378. </font>
<font color="black"> 379.     namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`</font>
<font color="black"> 380.         Object representing non-default symbolic aliases for numbers</font>
<font color="black"> 381. </font>
<font color="black"> 382.     binValue: :py:class:`str`</font>
<font color="black"> 383.         Binary string initializer to use instead of the *value*.</font>
<font color="black"> 384.         Example: '10110011'.</font>
<font color="black"> 385. </font>
<font color="black"> 386.     hexValue: :py:class:`str`</font>
<font color="black"> 387.         Hexadecimal string initializer to use instead of the *value*.</font>
<font color="black"> 388.         Example: 'DEADBEEF'.</font>
<font color="black"> 389. </font>
<font color="black"> 390.     Raises</font>
<font color="black"> 391.     ------</font>
<font color="black"> 392.     : :py:class:`pyasn1.error.PyAsn1Error`</font>
<font color="black"> 393.         On constraint violation or bad initializer.</font>
<font color="green"> 394.     &quot;&quot;&quot;</font>
<font color="black"> 395.     #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects</font>
<font color="green"> 396.     tagSet = tag.initTagSet(</font>
<font color="green"> 397.         tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x03)</font>
<font color="black"> 398.     )</font>
<font color="green"> 399.     baseTagSet = tagSet</font>
<font color="black"> 400. </font>
<font color="black"> 401.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black"> 402.     #: object imposing constraints on initialization values.</font>
<font color="green"> 403.     subtypeSpec = constraint.ConstraintsIntersection()</font>
<font color="black"> 404. </font>
<font color="black"> 405.     #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object</font>
<font color="black"> 406.     #: representing symbolic aliases for numbers</font>
<font color="green"> 407.     namedValues = namedval.NamedValues()</font>
<font color="black"> 408. </font>
<font color="green"> 409.     defaultBinValue = defaultHexValue = noValue</font>
<font color="black"> 410. </font>
<font color="green"> 411.     if sys.version_info[0] &lt; 3:</font>
<font color="green"> 412.         SizedIntegerBase = long</font>
<font color="black"> 413.     else:</font>
<font color="red"> 414.         SizedIntegerBase = int</font>
<font color="black"> 415. </font>
<font color="green"> 416.     class SizedInteger(SizedIntegerBase):</font>
<font color="green"> 417.         bitLength = leadingZeroBits = None</font>
<font color="black"> 418. </font>
<font color="green"> 419.         def setBitLength(self, bitLength):</font>
<font color="green"> 420.             self.bitLength = bitLength</font>
<font color="green"> 421.             self.leadingZeroBits = max(bitLength - integer.bitLength(self), 0)</font>
<font color="green"> 422.             return self</font>
<font color="black"> 423. </font>
<font color="green"> 424.         def __len__(self):</font>
<font color="red"> 425.             if self.bitLength is None:</font>
<font color="red"> 426.                 self.setBitLength(integer.bitLength(self))</font>
<font color="black"> 427. </font>
<font color="red"> 428.             return self.bitLength</font>
<font color="black"> 429. </font>
<font color="green"> 430.     def __init__(self, value=noValue, tagSet=None, subtypeSpec=None,</font>
<font color="green"> 431.                  namedValues=None, binValue=noValue, hexValue=noValue):</font>
<font color="green"> 432.         if namedValues is None:</font>
<font color="green"> 433.             self.__namedValues = self.namedValues</font>
<font color="black"> 434.         else:</font>
<font color="red"> 435.             self.__namedValues = namedValues</font>
<font color="green"> 436.         if not self.isNoValue(binValue):</font>
<font color="red"> 437.             value = self.fromBinaryString(binValue)</font>
<font color="green"> 438.         if not self.isNoValue(hexValue):</font>
<font color="red"> 439.             value = self.fromHexString(hexValue)</font>
<font color="green"> 440.         if self.isNoValue(value):</font>
<font color="red"> 441.             if self.defaultBinValue is not noValue:</font>
<font color="red"> 442.                 value = self.fromBinaryString(self.defaultBinValue)</font>
<font color="red"> 443.             elif self.defaultHexValue is not noValue:</font>
<font color="red"> 444.                 value = self.fromHexString(self.defaultHexValue)</font>
<font color="green"> 445.         self.__asNumbersCache = {}</font>
<font color="green"> 446.         base.AbstractSimpleAsn1Item.__init__(</font>
<font color="green"> 447.             self, value, tagSet, subtypeSpec</font>
<font color="black"> 448.         )</font>
<font color="black"> 449. </font>
<font color="green"> 450.     def clone(self, value=noValue, tagSet=None, subtypeSpec=None,</font>
<font color="green"> 451.               namedValues=None, binValue=noValue, hexValue=noValue):</font>
<font color="black"> 452.         &quot;&quot;&quot;Create a copy of a |ASN.1| type or object.</font>
<font color="black"> 453. </font>
<font color="black"> 454.         Any parameters to the *clone()* method will replace corresponding</font>
<font color="black"> 455.         properties of the |ASN.1| object.</font>
<font color="black"> 456. </font>
<font color="black"> 457.         Parameters</font>
<font color="black"> 458.         ----------</font>
<font color="black"> 459.         value : :class:`int`, :class:`str` or |ASN.1| object</font>
<font color="black"> 460.             Initialization value to pass to new ASN.1 object instead of</font>
<font color="black"> 461.             inheriting one from the caller.</font>
<font color="black"> 462. </font>
<font color="black"> 463.         tagSet: :py:class:`~pyasn1.type.tag.TagSet`</font>
<font color="black"> 464.             Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller</font>
<font color="black"> 465. </font>
<font color="black"> 466.         subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black"> 467.             Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller</font>
<font color="black"> 468. </font>
<font color="black"> 469.         namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`</font>
<font color="black"> 470.             Class instance representing BitString type enumerations</font>
<font color="black"> 471. </font>
<font color="black"> 472.         binValue: :py:class:`str`</font>
<font color="black"> 473.             Binary string initializer to use instead of the *value*.</font>
<font color="black"> 474.             Example: '10110011'.</font>
<font color="black"> 475. </font>
<font color="black"> 476.         hexValue: :py:class:`str`</font>
<font color="black"> 477.             Hexadecimal string initializer to use instead of the *value*.</font>
<font color="black"> 478.             Example: 'DEADBEEF'.</font>
<font color="black"> 479. </font>
<font color="black"> 480.         Returns</font>
<font color="black"> 481.         -------</font>
<font color="black"> 482.         :</font>
<font color="black"> 483.             new instance of |ASN.1| type/value</font>
<font color="black"> 484.         &quot;&quot;&quot;</font>
<font color="red"> 485.         if self.isNoValue(value, binValue, hexValue):</font>
<font color="red"> 486.             if self.isNoValue(tagSet, subtypeSpec, namedValues):</font>
<font color="red"> 487.                 return self</font>
<font color="red"> 488.             value = self._value</font>
<font color="red"> 489.         if tagSet is None:</font>
<font color="red"> 490.             tagSet = self._tagSet</font>
<font color="red"> 491.         if subtypeSpec is None:</font>
<font color="red"> 492.             subtypeSpec = self._subtypeSpec</font>
<font color="red"> 493.         if namedValues is None:</font>
<font color="red"> 494.             namedValues = self.__namedValues</font>
<font color="red"> 495.         return self.__class__(value, tagSet, subtypeSpec, namedValues, binValue, hexValue)</font>
<font color="black"> 496. </font>
<font color="green"> 497.     def subtype(self, value=noValue, implicitTag=None, explicitTag=None,</font>
<font color="green"> 498.                 subtypeSpec=None, namedValues=None, binValue=noValue, hexValue=noValue):</font>
<font color="black"> 499.         &quot;&quot;&quot;Create a copy of a |ASN.1| type or object.</font>
<font color="black"> 500. </font>
<font color="black"> 501.         Any parameters to the *subtype()* method will be added to the corresponding</font>
<font color="black"> 502.         properties of the |ASN.1| object.</font>
<font color="black"> 503. </font>
<font color="black"> 504.         Parameters</font>
<font color="black"> 505.         ----------</font>
<font color="black"> 506.         value : :class:`int`, :class:`str` or |ASN.1| object</font>
<font color="black"> 507.             Initialization value to pass to new ASN.1 object instead of</font>
<font color="black"> 508.             inheriting one from the caller.</font>
<font color="black"> 509. </font>
<font color="black"> 510.         implicitTag: :py:class:`~pyasn1.type.tag.Tag`</font>
<font color="black"> 511.             Implicitly apply given ASN.1 tag object to caller's</font>
<font color="black"> 512.             :py:class:`~pyasn1.type.tag.TagSet`, then use the result as</font>
<font color="black"> 513.             new object's ASN.1 tag(s).</font>
<font color="black"> 514. </font>
<font color="black"> 515.         explicitTag: :py:class:`~pyasn1.type.tag.Tag`</font>
<font color="black"> 516.             Explicitly apply given ASN.1 tag object to caller's</font>
<font color="black"> 517.             :py:class:`~pyasn1.type.tag.TagSet`, then use the result as</font>
<font color="black"> 518.             new object's ASN.1 tag(s).</font>
<font color="black"> 519. </font>
<font color="black"> 520.         subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black"> 521.             Add ASN.1 constraints object to one of the caller, then</font>
<font color="black"> 522.             use the result as new object's ASN.1 constraints.</font>
<font color="black"> 523. </font>
<font color="black"> 524.         namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`</font>
<font color="black"> 525.             Add given object representing symbolic aliases for numbers</font>
<font color="black"> 526.             to one of the caller, then use the result as new object's</font>
<font color="black"> 527.             named numbers.</font>
<font color="black"> 528. </font>
<font color="black"> 529.         binValue: :py:class:`str`</font>
<font color="black"> 530.             Binary string initializer to use instead of the *value*.</font>
<font color="black"> 531.             Example: '10110011'.</font>
<font color="black"> 532. </font>
<font color="black"> 533.         hexValue: :py:class:`str`</font>
<font color="black"> 534.             Hexadecimal string initializer to use instead of the *value*.</font>
<font color="black"> 535.             Example: 'DEADBEEF'.</font>
<font color="black"> 536. </font>
<font color="black"> 537.         Returns</font>
<font color="black"> 538.         -------</font>
<font color="black"> 539.         :</font>
<font color="black"> 540.             new instance of |ASN.1| type/value</font>
<font color="black"> 541.         &quot;&quot;&quot;</font>
<font color="red"> 542.         if self.isNoValue(value, binValue, hexValue):</font>
<font color="red"> 543.             if self.isNoValue(implicitTag, explicitTag, subtypeSpec, namedValues):</font>
<font color="red"> 544.                 return self</font>
<font color="red"> 545.             value = self._value</font>
<font color="red"> 546.         if implicitTag is not None:</font>
<font color="red"> 547.             tagSet = self._tagSet.tagImplicitly(implicitTag)</font>
<font color="red"> 548.         elif explicitTag is not None:</font>
<font color="red"> 549.             tagSet = self._tagSet.tagExplicitly(explicitTag)</font>
<font color="black"> 550.         else:</font>
<font color="red"> 551.             tagSet = self._tagSet</font>
<font color="red"> 552.         if subtypeSpec is None:</font>
<font color="red"> 553.             subtypeSpec = self._subtypeSpec</font>
<font color="black"> 554.         else:</font>
<font color="red"> 555.             subtypeSpec = self._subtypeSpec + subtypeSpec</font>
<font color="red"> 556.         if namedValues is None:</font>
<font color="red"> 557.             namedValues = self.__namedValues</font>
<font color="black"> 558.         else:</font>
<font color="red"> 559.             namedValues = namedValues + self.__namedValues</font>
<font color="red"> 560.         return self.__class__(value, tagSet, subtypeSpec, namedValues, binValue, hexValue)</font>
<font color="black"> 561. </font>
<font color="green"> 562.     def __str__(self):</font>
<font color="red"> 563.         return self.asBinary()</font>
<font color="black"> 564. </font>
<font color="green"> 565.     def __eq__(self, other):</font>
<font color="red"> 566.         other = self.prettyIn(other)</font>
<font color="red"> 567.         return self is other or self._value == other and len(self._value) == len(other)</font>
<font color="black"> 568. </font>
<font color="green"> 569.     def __ne__(self, other):</font>
<font color="red"> 570.         other = self.prettyIn(other)</font>
<font color="red"> 571.         return self._value != other or len(self._value) != len(other)</font>
<font color="black"> 572. </font>
<font color="green"> 573.     def __lt__(self, other):</font>
<font color="red"> 574.         other = self.prettyIn(other)</font>
<font color="red"> 575.         return len(self._value) &lt; len(other) or len(self._value) == len(other) and self._value &lt; other</font>
<font color="black"> 576. </font>
<font color="green"> 577.     def __le__(self, other):</font>
<font color="red"> 578.         other = self.prettyIn(other)</font>
<font color="red"> 579.         return len(self._value) &lt;= len(other) or len(self._value) == len(other) and self._value &lt;= other</font>
<font color="black"> 580. </font>
<font color="green"> 581.     def __gt__(self, other):</font>
<font color="red"> 582.         other = self.prettyIn(other)</font>
<font color="red"> 583.         return len(self._value) &gt; len(other) or len(self._value) == len(other) and self._value &gt; other</font>
<font color="black"> 584. </font>
<font color="green"> 585.     def __ge__(self, other):</font>
<font color="red"> 586.         other = self.prettyIn(other)</font>
<font color="red"> 587.         return len(self._value) &gt;= len(other) or len(self._value) == len(other) and self._value &gt;= other</font>
<font color="black"> 588. </font>
<font color="black"> 589.     # Immutable sequence object protocol</font>
<font color="black"> 590. </font>
<font color="green"> 591.     def __len__(self):</font>
<font color="red"> 592.         return len(self._value)</font>
<font color="black"> 593. </font>
<font color="green"> 594.     def __getitem__(self, i):</font>
<font color="red"> 595.         if isinstance(i, slice):</font>
<font color="red"> 596.             return self.clone([self[x] for x in range(*i.indices(len(self)))])</font>
<font color="black"> 597.         else:</font>
<font color="red"> 598.             length = len(self._value) - 1</font>
<font color="red"> 599.             if i &gt; length or i &lt; 0:</font>
<font color="red"> 600.                 raise IndexError('bit index out of range')</font>
<font color="red"> 601.             return (self._value &gt;&gt; (length - i)) &amp; 1</font>
<font color="black"> 602. </font>
<font color="green"> 603.     def __iter__(self):</font>
<font color="red"> 604.         length = len(self._value)</font>
<font color="red"> 605.         while length:</font>
<font color="red"> 606.             length -= 1</font>
<font color="red"> 607.             yield (self._value &gt;&gt; length) &amp; 1</font>
<font color="black"> 608. </font>
<font color="green"> 609.     def __reversed__(self):</font>
<font color="red"> 610.         return reversed(tuple(self))</font>
<font color="black"> 611. </font>
<font color="black"> 612.     # arithmetic operators</font>
<font color="black"> 613. </font>
<font color="green"> 614.     def __add__(self, value):</font>
<font color="red"> 615.         value = self.prettyIn(value)</font>
<font color="red"> 616.         return self.clone(self.SizedInteger(self._value &lt;&lt; len(value) | value).setBitLength(len(self._value) + len(value)))</font>
<font color="black"> 617. </font>
<font color="green"> 618.     def __radd__(self, value):</font>
<font color="red"> 619.         value = self.prettyIn(value)</font>
<font color="red"> 620.         return self.clone(self.SizedInteger(value &lt;&lt; len(self._value) | self._value).setBitLength(len(self._value) + len(value)))</font>
<font color="black"> 621. </font>
<font color="green"> 622.     def __mul__(self, value):</font>
<font color="red"> 623.         bitString = self._value</font>
<font color="red"> 624.         while value &gt; 1:</font>
<font color="red"> 625.             bitString &lt;&lt;= len(self._value)</font>
<font color="red"> 626.             bitString |= self._value</font>
<font color="red"> 627.             value -= 1</font>
<font color="red"> 628.         return self.clone(bitString)</font>
<font color="black"> 629. </font>
<font color="green"> 630.     def __rmul__(self, value):</font>
<font color="red"> 631.         return self * value</font>
<font color="black"> 632. </font>
<font color="green"> 633.     def __lshift__(self, count):</font>
<font color="red"> 634.         return self.clone(self.SizedInteger(self._value &lt;&lt; count).setBitLength(len(self._value) + count))</font>
<font color="black"> 635. </font>
<font color="green"> 636.     def __rshift__(self, count):</font>
<font color="red"> 637.         return self.clone(self.SizedInteger(self._value &gt;&gt; count).setBitLength(max(0, len(self._value) - count)))</font>
<font color="black"> 638. </font>
<font color="green"> 639.     def __int__(self):</font>
<font color="red"> 640.         return self._value</font>
<font color="black"> 641. </font>
<font color="green"> 642.     def __float__(self):</font>
<font color="red"> 643.         return float(self._value)</font>
<font color="black"> 644. </font>
<font color="green"> 645.     if sys.version_info[0] &lt; 3:</font>
<font color="green"> 646.         def __long__(self):</font>
<font color="red"> 647.             return self._value</font>
<font color="black"> 648. </font>
<font color="green"> 649.     def asNumbers(self):</font>
<font color="black"> 650.         &quot;&quot;&quot;Get |ASN.1| value as a sequence of 8-bit integers.</font>
<font color="black"> 651. </font>
<font color="black"> 652.         If |ASN.1| object length is not a multiple of 8, result</font>
<font color="black"> 653.         will be left-padded with zeros.</font>
<font color="black"> 654.         &quot;&quot;&quot;</font>
<font color="red"> 655.         return tuple(octets.octs2ints(self.asOctets()))</font>
<font color="black"> 656. </font>
<font color="green"> 657.     def asOctets(self):</font>
<font color="black"> 658.         &quot;&quot;&quot;Get |ASN.1| value as a sequence of octets.</font>
<font color="black"> 659. </font>
<font color="black"> 660.         If |ASN.1| object length is not a multiple of 8, result</font>
<font color="black"> 661.         will be left-padded with zeros.</font>
<font color="black"> 662.         &quot;&quot;&quot;</font>
<font color="red"> 663.         return integer.to_bytes(self._value, length=len(self))</font>
<font color="black"> 664. </font>
<font color="green"> 665.     def asInteger(self):</font>
<font color="black"> 666.         &quot;&quot;&quot;Get |ASN.1| value as a single integer value.</font>
<font color="black"> 667.         &quot;&quot;&quot;</font>
<font color="red"> 668.         return self._value</font>
<font color="black"> 669. </font>
<font color="green"> 670.     def asBinary(self):</font>
<font color="black"> 671.         &quot;&quot;&quot;Get |ASN.1| value as a text string of bits.</font>
<font color="black"> 672.         &quot;&quot;&quot;</font>
<font color="red"> 673.         binString = binary.bin(self._value)[2:]</font>
<font color="red"> 674.         return '0'*(len(self._value) - len(binString)) + binString</font>
<font color="black"> 675. </font>
<font color="green"> 676.     @classmethod</font>
<font color="black"> 677.     def fromHexString(cls, value):</font>
<font color="red"> 678.         try:</font>
<font color="red"> 679.             return cls.SizedInteger(value, 16).setBitLength(len(value) * 4)</font>
<font color="black"> 680. </font>
<font color="red"> 681.         except ValueError:</font>
<font color="red"> 682.             raise error.PyAsn1Error('%s.fromHexString() error: %s' % (cls.__name__, sys.exc_info()[1]))</font>
<font color="black"> 683. </font>
<font color="green"> 684.     @classmethod</font>
<font color="black"> 685.     def fromBinaryString(cls, value):</font>
<font color="green"> 686.         try:</font>
<font color="green"> 687.             return cls.SizedInteger(value or '0', 2).setBitLength(len(value))</font>
<font color="black"> 688. </font>
<font color="red"> 689.         except ValueError:</font>
<font color="red"> 690.             raise error.PyAsn1Error('%s.fromBinaryString() error: %s' % (cls.__name__, sys.exc_info()[1]))</font>
<font color="black"> 691. </font>
<font color="green"> 692.     @classmethod</font>
<font color="green"> 693.     def fromOctetString(cls, value, padding=0):</font>
<font color="red"> 694.         return cls(cls.SizedInteger(integer.from_bytes(value) &gt;&gt; padding).setBitLength(len(value) * 8 - padding))</font>
<font color="black"> 695. </font>
<font color="green"> 696.     def prettyIn(self, value):</font>
<font color="green"> 697.         if octets.isStringType(value):</font>
<font color="red"> 698.             if not value:</font>
<font color="red"> 699.                 return self.SizedInteger(0).setBitLength(0)</font>
<font color="black"> 700. </font>
<font color="red"> 701.             elif value[0] == '\'':  # &quot;'1011'B&quot; -- ASN.1 schema representation (deprecated)</font>
<font color="red"> 702.                 if value[-2:] == '\'B':</font>
<font color="red"> 703.                     return self.fromBinaryString(value[1:-2])</font>
<font color="red"> 704.                 elif value[-2:] == '\'H':</font>
<font color="red"> 705.                     return self.fromHexString(value[1:-2])</font>
<font color="black"> 706.                 else:</font>
<font color="red"> 707.                     raise error.PyAsn1Error(</font>
<font color="red"> 708.                         'Bad BIT STRING value notation %s' % (value,)</font>
<font color="black"> 709.                     )</font>
<font color="black"> 710. </font>
<font color="red"> 711.             elif self.__namedValues and not value.isdigit():  # named bits like 'Urgent, Active'</font>
<font color="red"> 712.                 number = 0</font>
<font color="red"> 713.                 highestBitPosition = 0</font>
<font color="red"> 714.                 for namedBit in value.split(','):</font>
<font color="red"> 715.                     bitPosition = self.__namedValues.getValue(namedBit)</font>
<font color="red"> 716.                     if bitPosition is None:</font>
<font color="red"> 717.                         raise error.PyAsn1Error(</font>
<font color="red"> 718.                             'Unknown bit identifier \'%s\'' % (namedBit,)</font>
<font color="black"> 719.                         )</font>
<font color="black"> 720. </font>
<font color="red"> 721.                     number |= (1 &lt;&lt; bitPosition)</font>
<font color="black"> 722. </font>
<font color="red"> 723.                     highestBitPosition = max(highestBitPosition, bitPosition)</font>
<font color="black"> 724. </font>
<font color="red"> 725.                 return self.SizedInteger(number).setBitLength(highestBitPosition + 1)</font>
<font color="black"> 726. </font>
<font color="red"> 727.             elif value.startswith('0x'):</font>
<font color="red"> 728.                 return self.fromHexString(value[2:])</font>
<font color="black"> 729. </font>
<font color="red"> 730.             elif value.startswith('0b'):</font>
<font color="red"> 731.                 return self.fromBinaryString(value[2:])</font>
<font color="black"> 732. </font>
<font color="black"> 733.             else:  # assume plain binary string like '1011'</font>
<font color="red"> 734.                 return self.fromBinaryString(value)</font>
<font color="black"> 735. </font>
<font color="green"> 736.         elif isinstance(value, (tuple, list)):</font>
<font color="green"> 737.             return self.fromBinaryString(''.join([b and '1' or '0' for b in value]))</font>
<font color="black"> 738. </font>
<font color="red"> 739.         elif isinstance(value, (self.SizedInteger, BitString)):</font>
<font color="red"> 740.             return self.SizedInteger(value).setBitLength(len(value))</font>
<font color="black"> 741. </font>
<font color="red"> 742.         elif isinstance(value, intTypes):</font>
<font color="red"> 743.             return self.SizedInteger(value)</font>
<font color="black"> 744. </font>
<font color="black"> 745.         else:</font>
<font color="red"> 746.             raise error.PyAsn1Error(</font>
<font color="red"> 747.                 'Bad BitString initializer type \'%s\'' % (value,)</font>
<font color="black"> 748.             )</font>
<font color="black"> 749. </font>
<font color="green"> 750.     def prettyOut(self, value):</font>
<font color="red"> 751.         return '\'%s\'' % str(self)</font>
<font color="black"> 752. </font>
<font color="black"> 753. </font>
<font color="green"> 754. try:</font>
<font color="black"> 755.     # noinspection PyStatementEffect</font>
<font color="green"> 756.     all</font>
<font color="black"> 757. </font>
<font color="red"> 758. except NameError:  # Python 2.4</font>
<font color="black"> 759.     # noinspection PyShadowingBuiltins</font>
<font color="red"> 760.     def all(iterable):</font>
<font color="red"> 761.         for element in iterable:</font>
<font color="red"> 762.             if not element:</font>
<font color="red"> 763.                 return False</font>
<font color="red"> 764.         return True</font>
<font color="black"> 765. </font>
<font color="black"> 766. </font>
<font color="green"> 767. class OctetString(base.AbstractSimpleAsn1Item):</font>
<font color="black"> 768.     &quot;&quot;&quot;Create |ASN.1| type or object.</font>
<font color="black"> 769. </font>
<font color="black"> 770.     |ASN.1| objects are immutable and duck-type Python 2 :class:`str` or Python 3 :class:`bytes`.</font>
<font color="black"> 771.     When used in Unicode context, |ASN.1| type assumes &quot;|encoding|&quot; serialization.</font>
<font color="black"> 772. </font>
<font color="black"> 773.     Parameters</font>
<font color="black"> 774.     ----------</font>
<font color="black"> 775.     value : :class:`str`, :class:`bytes` or |ASN.1| object</font>
<font color="black"> 776.         string (Python 2) or bytes (Python 3), alternatively unicode object</font>
<font color="black"> 777.         (Python 2) or string (Python 3) representing character string to be</font>
<font color="black"> 778.         serialized into octets (note `encoding` parameter) or |ASN.1| object.</font>
<font color="black"> 779. </font>
<font color="black"> 780.     tagSet: :py:class:`~pyasn1.type.tag.TagSet`</font>
<font color="black"> 781.         Object representing non-default ASN.1 tag(s)</font>
<font color="black"> 782. </font>
<font color="black"> 783.     subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black"> 784.         Object representing non-default ASN.1 subtype constraint(s)</font>
<font color="black"> 785. </font>
<font color="black"> 786.     encoding: :py:class:`str`</font>
<font color="black"> 787.         Unicode codec ID to encode/decode :class:`unicode` (Python 2) or</font>
<font color="black"> 788.         :class:`str` (Python 3) the payload when |ASN.1| object is used</font>
<font color="black"> 789.         in text string context.</font>
<font color="black"> 790. </font>
<font color="black"> 791.     binValue: :py:class:`str`</font>
<font color="black"> 792.         Binary string initializer to use instead of the *value*.</font>
<font color="black"> 793.         Example: '10110011'.</font>
<font color="black"> 794. </font>
<font color="black"> 795.     hexValue: :py:class:`str`</font>
<font color="black"> 796.         Hexadecimal string initializer to use instead of the *value*.</font>
<font color="black"> 797.         Example: 'DEADBEEF'.</font>
<font color="black"> 798. </font>
<font color="black"> 799.     Raises</font>
<font color="black"> 800.     ------</font>
<font color="black"> 801.     : :py:class:`pyasn1.error.PyAsn1Error`</font>
<font color="black"> 802.         On constraint violation or bad initializer.</font>
<font color="green"> 803.     &quot;&quot;&quot;</font>
<font color="black"> 804.     #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects</font>
<font color="green"> 805.     tagSet = tag.initTagSet(</font>
<font color="green"> 806.         tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x04)</font>
<font color="black"> 807.     )</font>
<font color="green"> 808.     baseTagSet = tagSet</font>
<font color="black"> 809. </font>
<font color="black"> 810.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black"> 811.     #: object imposing constraints on initialization values.</font>
<font color="green"> 812.     subtypeSpec = constraint.ConstraintsIntersection()</font>
<font color="black"> 813. </font>
<font color="green"> 814.     defaultBinValue = defaultHexValue = noValue</font>
<font color="green"> 815.     encoding = 'iso-8859-1'</font>
<font color="black"> 816. </font>
<font color="green"> 817.     def __init__(self, value=noValue, tagSet=None, subtypeSpec=None,</font>
<font color="green"> 818.                  encoding=None, binValue=noValue, hexValue=noValue):</font>
<font color="green"> 819.         if encoding is None:</font>
<font color="green"> 820.             self._encoding = self.encoding</font>
<font color="black"> 821.         else:</font>
<font color="green"> 822.             self._encoding = encoding</font>
<font color="green"> 823.         if not self.isNoValue(binValue):</font>
<font color="red"> 824.             value = self.fromBinaryString(binValue)</font>
<font color="green"> 825.         if not self.isNoValue(hexValue):</font>
<font color="red"> 826.             value = self.fromHexString(hexValue)</font>
<font color="green"> 827.         if self.isNoValue(value):</font>
<font color="green"> 828.             if self.defaultBinValue is not noValue:</font>
<font color="red"> 829.                 value = self.fromBinaryString(self.defaultBinValue)</font>
<font color="green"> 830.             elif self.defaultHexValue is not noValue:</font>
<font color="red"> 831.                 value = self.fromHexString(self.defaultHexValue)</font>
<font color="green"> 832.         self.__asNumbersCache = None</font>
<font color="green"> 833.         base.AbstractSimpleAsn1Item.__init__(self, value, tagSet, subtypeSpec)</font>
<font color="black"> 834. </font>
<font color="green"> 835.     def clone(self, value=noValue, tagSet=None, subtypeSpec=None,</font>
<font color="green"> 836.               encoding=None, binValue=noValue, hexValue=noValue):</font>
<font color="black"> 837.         &quot;&quot;&quot;Create a copy of a |ASN.1| type or object.</font>
<font color="black"> 838. </font>
<font color="black"> 839.         Any parameters to the *clone()* method will replace corresponding</font>
<font color="black"> 840.         properties of the |ASN.1| object.</font>
<font color="black"> 841. </font>
<font color="black"> 842.         Parameters</font>
<font color="black"> 843.         ----------</font>
<font color="black"> 844.         value : :class:`str`, :class:`bytes` or |ASN.1| object</font>
<font color="black"> 845.             Initialization value to pass to new ASN.1 object instead of</font>
<font color="black"> 846.             inheriting one from the caller.</font>
<font color="black"> 847. </font>
<font color="black"> 848.         tagSet: :py:class:`~pyasn1.type.tag.TagSet`</font>
<font color="black"> 849.             Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller</font>
<font color="black"> 850. </font>
<font color="black"> 851.         subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black"> 852.             Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller</font>
<font color="black"> 853. </font>
<font color="black"> 854.         encoding: :py:class:`str`</font>
<font color="black"> 855.             Unicode codec ID to encode/decode :class:`unicode` (Python 2)</font>
<font color="black"> 856.             or :class:`str` (Python 3) the payload when |ASN.1|</font>
<font color="black"> 857.             object is used in string context.</font>
<font color="black"> 858. </font>
<font color="black"> 859.         binValue: :py:class:`str`</font>
<font color="black"> 860.             Binary string initializer. Example: '10110011'.</font>
<font color="black"> 861. </font>
<font color="black"> 862.         hexValue: :py:class:`str`</font>
<font color="black"> 863.             Hexadecimal string initializer. Example: 'DEADBEEF'.</font>
<font color="black"> 864. </font>
<font color="black"> 865.         Returns</font>
<font color="black"> 866.         -------</font>
<font color="black"> 867.         :</font>
<font color="black"> 868.             new instance of |ASN.1| type/value</font>
<font color="black"> 869.         &quot;&quot;&quot;</font>
<font color="red"> 870.         if self.isNoValue(value, binValue, hexValue):</font>
<font color="red"> 871.             if self.isNoValue(tagSet, subtypeSpec, encoding):</font>
<font color="red"> 872.                 return self</font>
<font color="red"> 873.             value = self._value</font>
<font color="red"> 874.         if tagSet is None:</font>
<font color="red"> 875.             tagSet = self._tagSet</font>
<font color="red"> 876.         if subtypeSpec is None:</font>
<font color="red"> 877.             subtypeSpec = self._subtypeSpec</font>
<font color="red"> 878.         if encoding is None:</font>
<font color="red"> 879.             encoding = self._encoding</font>
<font color="red"> 880.         return self.__class__(</font>
<font color="red"> 881.             value, tagSet, subtypeSpec, encoding, binValue, hexValue</font>
<font color="black"> 882.         )</font>
<font color="black"> 883. </font>
<font color="green"> 884.     def subtype(self, value=noValue, implicitTag=None, explicitTag=None,</font>
<font color="green"> 885.                 subtypeSpec=None, encoding=None, binValue=noValue,</font>
<font color="green"> 886.                 hexValue=noValue):</font>
<font color="black"> 887.         &quot;&quot;&quot;Create a copy of a |ASN.1| type or object.</font>
<font color="black"> 888. </font>
<font color="black"> 889.         Any parameters to the *subtype()* method will be added to the corresponding</font>
<font color="black"> 890.         properties of the |ASN.1| object.</font>
<font color="black"> 891. </font>
<font color="black"> 892.         Parameters</font>
<font color="black"> 893.         ----------</font>
<font color="black"> 894.         value : :class:`str`, :class:`bytes` or |ASN.1| object</font>
<font color="black"> 895.             Initialization value to pass to new ASN.1 object instead of</font>
<font color="black"> 896.             inheriting one from the caller.</font>
<font color="black"> 897. </font>
<font color="black"> 898.         implicitTag: :py:class:`~pyasn1.type.tag.Tag`</font>
<font color="black"> 899.             Implicitly apply given ASN.1 tag object to |ASN.1| object tag set</font>
<font color="black"> 900.             :py:class:`~pyasn1.type.tag.TagSet`, then use the result as</font>
<font color="black"> 901.             new object's ASN.1 tag(s).</font>
<font color="black"> 902. </font>
<font color="black"> 903.         explicitTag: :py:class:`~pyasn1.type.tag.Tag`</font>
<font color="black"> 904.             Explicitly apply given ASN.1 tag object to |ASN.1| object tag set</font>
<font color="black"> 905.             :py:class:`~pyasn1.type.tag.TagSet`, then use the result as</font>
<font color="black"> 906.             new object's ASN.1 tag(s).</font>
<font color="black"> 907. </font>
<font color="black"> 908.         subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black"> 909.             Add ASN.1 constraints object to one of the caller, then</font>
<font color="black"> 910.             use the result as new object's ASN.1 constraints.</font>
<font color="black"> 911. </font>
<font color="black"> 912.         encoding: :py:class:`str`</font>
<font color="black"> 913.             Unicode codec ID to encode/decode :class:`unicode` (Python 2)</font>
<font color="black"> 914.             or :class:`str` (Python 3) the payload when *OctetString*</font>
<font color="black"> 915.             object is used in string context.</font>
<font color="black"> 916. </font>
<font color="black"> 917.         binValue: :py:class:`str`</font>
<font color="black"> 918.             Binary string initializer. Example: '10110011'.</font>
<font color="black"> 919. </font>
<font color="black"> 920.         hexValue: :py:class:`str`</font>
<font color="black"> 921.             Hexadecimal string initializer. Example: 'DEADBEEF'.</font>
<font color="black"> 922. </font>
<font color="black"> 923.         Returns</font>
<font color="black"> 924.         -------</font>
<font color="black"> 925.         :</font>
<font color="black"> 926.              new instance of |ASN.1| type/value</font>
<font color="black"> 927.         &quot;&quot;&quot;</font>
<font color="green"> 928.         if self.isNoValue(value, binValue, hexValue):</font>
<font color="green"> 929.             if self.isNoValue(implicitTag, explicitTag, subtypeSpec, encoding):</font>
<font color="red"> 930.                 return self</font>
<font color="green"> 931.             value = self._value</font>
<font color="green"> 932.         if implicitTag is not None:</font>
<font color="green"> 933.             tagSet = self._tagSet.tagImplicitly(implicitTag)</font>
<font color="green"> 934.         elif explicitTag is not None:</font>
<font color="green"> 935.             tagSet = self._tagSet.tagExplicitly(explicitTag)</font>
<font color="black"> 936.         else:</font>
<font color="green"> 937.             tagSet = self._tagSet</font>
<font color="green"> 938.         if subtypeSpec is None:</font>
<font color="green"> 939.             subtypeSpec = self._subtypeSpec</font>
<font color="black"> 940.         else:</font>
<font color="green"> 941.             subtypeSpec = self._subtypeSpec + subtypeSpec</font>
<font color="green"> 942.         if encoding is None:</font>
<font color="green"> 943.             encoding = self._encoding</font>
<font color="green"> 944.         return self.__class__(</font>
<font color="green"> 945.             value, tagSet, subtypeSpec, encoding, binValue, hexValue</font>
<font color="black"> 946.         )</font>
<font color="black"> 947. </font>
<font color="green"> 948.     if sys.version_info[0] &lt;= 2:</font>
<font color="green"> 949.         def prettyIn(self, value):</font>
<font color="green"> 950.             if isinstance(value, str):</font>
<font color="green"> 951.                 return value</font>
<font color="red"> 952.             elif isinstance(value, unicode):</font>
<font color="red"> 953.                 try:</font>
<font color="red"> 954.                     return value.encode(self._encoding)</font>
<font color="red"> 955.                 except (LookupError, UnicodeEncodeError):</font>
<font color="red"> 956.                     raise error.PyAsn1Error(</font>
<font color="red"> 957.                         'Can\'t encode string \'%s\' with \'%s\' codec' % (value, self._encoding)</font>
<font color="black"> 958.                     )</font>
<font color="red"> 959.             elif isinstance(value, (tuple, list)):</font>
<font color="red"> 960.                 try:</font>
<font color="red"> 961.                     return ''.join([chr(x) for x in value])</font>
<font color="red"> 962.                 except ValueError:</font>
<font color="red"> 963.                     raise error.PyAsn1Error(</font>
<font color="red"> 964.                         'Bad %s initializer \'%s\'' % (self.__class__.__name__, value)</font>
<font color="black"> 965.                     )</font>
<font color="black"> 966.             else:</font>
<font color="red"> 967.                 return str(value)</font>
<font color="black"> 968. </font>
<font color="green"> 969.         def __str__(self):</font>
<font color="red"> 970.             return str(self._value)</font>
<font color="black"> 971. </font>
<font color="green"> 972.         def __unicode__(self):</font>
<font color="red"> 973.             try:</font>
<font color="red"> 974.                 return self._value.decode(self._encoding)</font>
<font color="black"> 975. </font>
<font color="red"> 976.             except UnicodeDecodeError:</font>
<font color="red"> 977.                 raise error.PyAsn1Error(</font>
<font color="red"> 978.                     'Can\'t decode string \'%s\' with \'%s\' codec' % (self._value, self._encoding)</font>
<font color="black"> 979.                 )</font>
<font color="black"> 980. </font>
<font color="green"> 981.         def asOctets(self):</font>
<font color="red"> 982.             return str(self._value)</font>
<font color="black"> 983. </font>
<font color="green"> 984.         def asNumbers(self):</font>
<font color="red"> 985.             if self.__asNumbersCache is None:</font>
<font color="red"> 986.                 self.__asNumbersCache = tuple([ord(x) for x in self._value])</font>
<font color="red"> 987.             return self.__asNumbersCache</font>
<font color="black"> 988. </font>
<font color="black"> 989.     else:</font>
<font color="red"> 990.         def prettyIn(self, value):</font>
<font color="red"> 991.             if isinstance(value, bytes):</font>
<font color="red"> 992.                 return value</font>
<font color="red"> 993.             elif isinstance(value, str):</font>
<font color="red"> 994.                 try:</font>
<font color="red"> 995.                     return value.encode(self._encoding)</font>
<font color="red"> 996.                 except UnicodeEncodeError:</font>
<font color="red"> 997.                     raise error.PyAsn1Error(</font>
<font color="red"> 998.                         'Can\'t encode string \'%s\' with \'%s\' codec' % (value, self._encoding)</font>
<font color="black"> 999.                     )</font>
<font color="red">1000.             elif isinstance(value, OctetString):  # a shortcut, bytes() would work the same way</font>
<font color="red">1001.                 return value.asOctets()</font>
<font color="red">1002.             elif isinstance(value, base.AbstractSimpleAsn1Item):  # this mostly targets Integer objects</font>
<font color="red">1003.                 return self.prettyIn(str(value))</font>
<font color="red">1004.             elif isinstance(value, (tuple, list)):</font>
<font color="red">1005.                 return self.prettyIn(bytes(value))</font>
<font color="black">1006.             else:</font>
<font color="red">1007.                 return bytes(value)</font>
<font color="black">1008. </font>
<font color="red">1009.         def __str__(self):</font>
<font color="red">1010.             try:</font>
<font color="red">1011.                 return self._value.decode(self._encoding)</font>
<font color="black">1012. </font>
<font color="red">1013.             except UnicodeDecodeError:</font>
<font color="red">1014.                 raise error.PyAsn1Error(</font>
<font color="red">1015.                     'Can\'t decode string \'%s\' with \'%s\' codec at \'%s\'' % (self._value, self._encoding, self.__class__.__name__)</font>
<font color="black">1016.                 )</font>
<font color="black">1017. </font>
<font color="red">1018.         def __bytes__(self):</font>
<font color="red">1019.             return bytes(self._value)</font>
<font color="black">1020. </font>
<font color="red">1021.         def asOctets(self):</font>
<font color="red">1022.             return bytes(self._value)</font>
<font color="black">1023. </font>
<font color="red">1024.         def asNumbers(self):</font>
<font color="red">1025.             if self.__asNumbersCache is None:</font>
<font color="red">1026.                 self.__asNumbersCache = tuple(self._value)</font>
<font color="red">1027.             return self.__asNumbersCache</font>
<font color="black">1028. </font>
<font color="green">1029.     def prettyOut(self, value):</font>
<font color="red">1030.         if sys.version_info[0] &lt;= 2:</font>
<font color="red">1031.             numbers = tuple((ord(x) for x in value))</font>
<font color="black">1032.         else:</font>
<font color="red">1033.             numbers = tuple(value)</font>
<font color="red">1034.         for x in numbers:</font>
<font color="red">1035.             if x &lt; 32 or x &gt; 126:</font>
<font color="red">1036.                 return '0x' + ''.join(('%.2x' % x for x in numbers))</font>
<font color="black">1037.         else:</font>
<font color="red">1038.             return octets.octs2str(value)</font>
<font color="black">1039. </font>
<font color="green">1040.     @staticmethod</font>
<font color="black">1041.     def fromBinaryString(value):</font>
<font color="red">1042.         bitNo = 8</font>
<font color="red">1043.         byte = 0</font>
<font color="red">1044.         r = []</font>
<font color="red">1045.         for v in value:</font>
<font color="red">1046.             if bitNo:</font>
<font color="red">1047.                 bitNo -= 1</font>
<font color="black">1048.             else:</font>
<font color="red">1049.                 bitNo = 7</font>
<font color="red">1050.                 r.append(byte)</font>
<font color="red">1051.                 byte = 0</font>
<font color="red">1052.             if v in ('0', '1'):</font>
<font color="red">1053.                 v = int(v)</font>
<font color="black">1054.             else:</font>
<font color="red">1055.                 raise error.PyAsn1Error(</font>
<font color="red">1056.                     'Non-binary OCTET STRING initializer %s' % (v,)</font>
<font color="black">1057.                 )</font>
<font color="red">1058.             byte |= v &lt;&lt; bitNo</font>
<font color="black">1059. </font>
<font color="red">1060.         r.append(byte)</font>
<font color="black">1061. </font>
<font color="red">1062.         return octets.ints2octs(r)</font>
<font color="black">1063. </font>
<font color="green">1064.     @staticmethod</font>
<font color="black">1065.     def fromHexString(value):</font>
<font color="red">1066.         r = []</font>
<font color="red">1067.         p = []</font>
<font color="red">1068.         for v in value:</font>
<font color="red">1069.             if p:</font>
<font color="red">1070.                 r.append(int(p + v, 16))</font>
<font color="red">1071.                 p = None</font>
<font color="black">1072.             else:</font>
<font color="red">1073.                 p = v</font>
<font color="red">1074.         if p:</font>
<font color="red">1075.             r.append(int(p + '0', 16))</font>
<font color="black">1076. </font>
<font color="red">1077.         return octets.ints2octs(r)</font>
<font color="black">1078. </font>
<font color="green">1079.     def __repr__(self):</font>
<font color="red">1080.         r = []</font>
<font color="red">1081.         doHex = False</font>
<font color="red">1082.         if self._value is not self.defaultValue:</font>
<font color="red">1083.             for x in self.asNumbers():</font>
<font color="red">1084.                 if x &lt; 32 or x &gt; 126:</font>
<font color="red">1085.                     doHex = True</font>
<font color="red">1086.                     break</font>
<font color="red">1087.             if not doHex:</font>
<font color="red">1088.                 r.append('%r' % (self._value,))</font>
<font color="red">1089.         if self._tagSet is not self.tagSet:</font>
<font color="red">1090.             r.append('tagSet=%r' % (self._tagSet,))</font>
<font color="red">1091.         if self._subtypeSpec is not self.subtypeSpec:</font>
<font color="red">1092.             r.append('subtypeSpec=%r' % (self._subtypeSpec,))</font>
<font color="red">1093.         if self.encoding is not self._encoding:</font>
<font color="red">1094.             r.append('encoding=%r' % (self._encoding,))</font>
<font color="red">1095.         if doHex:</font>
<font color="red">1096.             r.append('hexValue=%r' % ''.join(['%.2x' % x for x in self.asNumbers()]))</font>
<font color="red">1097.         return '%s(%s)' % (self.__class__.__name__, ', '.join(r))</font>
<font color="black">1098. </font>
<font color="black">1099.     # Immutable sequence object protocol</font>
<font color="black">1100. </font>
<font color="green">1101.     def __len__(self):</font>
<font color="red">1102.         if self._len is None:</font>
<font color="red">1103.             self._len = len(self._value)</font>
<font color="red">1104.         return self._len</font>
<font color="black">1105. </font>
<font color="green">1106.     def __getitem__(self, i):</font>
<font color="red">1107.         if isinstance(i, slice):</font>
<font color="red">1108.             return self.clone(operator.getitem(self._value, i))</font>
<font color="black">1109.         else:</font>
<font color="red">1110.             return self._value[i]</font>
<font color="black">1111. </font>
<font color="green">1112.     def __iter__(self):</font>
<font color="red">1113.         return iter(self._value)</font>
<font color="black">1114. </font>
<font color="green">1115.     def __contains__(self, value):</font>
<font color="red">1116.         return value in self._value</font>
<font color="black">1117. </font>
<font color="green">1118.     def __add__(self, value):</font>
<font color="red">1119.         return self.clone(self._value + self.prettyIn(value))</font>
<font color="black">1120. </font>
<font color="green">1121.     def __radd__(self, value):</font>
<font color="red">1122.         return self.clone(self.prettyIn(value) + self._value)</font>
<font color="black">1123. </font>
<font color="green">1124.     def __mul__(self, value):</font>
<font color="red">1125.         return self.clone(self._value * value)</font>
<font color="black">1126. </font>
<font color="green">1127.     def __rmul__(self, value):</font>
<font color="red">1128.         return self * value</font>
<font color="black">1129. </font>
<font color="green">1130.     def __int__(self):</font>
<font color="red">1131.         return int(self._value)</font>
<font color="black">1132. </font>
<font color="green">1133.     def __float__(self):</font>
<font color="red">1134.         return float(self._value)</font>
<font color="black">1135. </font>
<font color="green">1136.     def __reversed__(self):</font>
<font color="red">1137.         return reversed(self._value)</font>
<font color="black">1138. </font>
<font color="black">1139. </font>
<font color="green">1140. class Null(OctetString):</font>
<font color="black">1141.     &quot;&quot;&quot;Create |ASN.1| type or object.</font>
<font color="black">1142. </font>
<font color="black">1143.     |ASN.1| objects are immutable and duck-type Python :class:`str` objects (always empty).</font>
<font color="black">1144. </font>
<font color="black">1145.     Parameters</font>
<font color="black">1146.     ----------</font>
<font color="black">1147.     value : :class:`str` or :py:class:`~pyasn1.type.univ.Null` object</font>
<font color="black">1148.         Python empty string literal or *Null* class instance.</font>
<font color="black">1149. </font>
<font color="black">1150.     tagSet: :py:class:`~pyasn1.type.tag.TagSet`</font>
<font color="black">1151.         Object representing non-default ASN.1 tag(s)</font>
<font color="black">1152. </font>
<font color="black">1153.     Raises</font>
<font color="black">1154.     ------</font>
<font color="black">1155.     : :py:class:`pyasn1.error.PyAsn1Error`</font>
<font color="black">1156.         On constraint violation or bad initializer.</font>
<font color="green">1157.     &quot;&quot;&quot;</font>
<font color="green">1158.     defaultValue = ''.encode()  # This is tightly constrained</font>
<font color="black">1159. </font>
<font color="black">1160.     #: Default :py:class:`~pyasn1.type.tag.TagSet` object for ASN.1</font>
<font color="black">1161.     #: *Null* objects</font>
<font color="green">1162.     tagSet = tag.initTagSet(</font>
<font color="green">1163.         tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x05)</font>
<font color="black">1164.     )</font>
<font color="green">1165.     baseTagSet = tagSet</font>
<font color="green">1166.     subtypeSpec = OctetString.subtypeSpec + constraint.SingleValueConstraint(octets.str2octs(''))</font>
<font color="black">1167. </font>
<font color="green">1168.     def clone(self, value=noValue, tagSet=None):</font>
<font color="black">1169.         &quot;&quot;&quot;Create a copy of a |ASN.1| type or object.</font>
<font color="black">1170. </font>
<font color="black">1171.         Any parameters to the *clone()* method will replace corresponding</font>
<font color="black">1172.         properties of the |ASN.1| object.</font>
<font color="black">1173. </font>
<font color="black">1174.         Parameters</font>
<font color="black">1175.         ----------</font>
<font color="black">1176.         value: :class:`str` or |ASN.1| object</font>
<font color="black">1177.             Initialization value to pass to new ASN.1 object instead of</font>
<font color="black">1178.             inheriting one from the caller.</font>
<font color="black">1179. </font>
<font color="black">1180.         tagSet: :py:class:`~pyasn1.type.tag.TagSet`</font>
<font color="black">1181.             Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller</font>
<font color="black">1182. </font>
<font color="black">1183.         Returns</font>
<font color="black">1184.         -------</font>
<font color="black">1185.         : :py:class:`~pyasn1.type.univ.Null`</font>
<font color="black">1186.             new instance of NULL type/value</font>
<font color="black">1187.         &quot;&quot;&quot;</font>
<font color="red">1188.         return OctetString.clone(self, value, tagSet)</font>
<font color="black">1189. </font>
<font color="green">1190.     def subtype(self, value=noValue, implicitTag=None, explicitTag=None):</font>
<font color="black">1191.         &quot;&quot;&quot;Create a copy of a |ASN.1| type or object.</font>
<font color="black">1192. </font>
<font color="black">1193.         Any parameters to the *subtype()* method will be added to the corresponding</font>
<font color="black">1194.         properties of the |ASN.1| object.</font>
<font color="black">1195. </font>
<font color="black">1196.         Parameters</font>
<font color="black">1197.         ----------</font>
<font color="black">1198.         value: :class:`int`, :class:`str` or |ASN.1| object</font>
<font color="black">1199.             Initialization value to pass to new ASN.1 object instead of</font>
<font color="black">1200.             inheriting one from the caller.</font>
<font color="black">1201. </font>
<font color="black">1202.         implicitTag: :py:class:`~pyasn1.type.tag.Tag`</font>
<font color="black">1203.             Implicitly apply given ASN.1 tag object to caller's</font>
<font color="black">1204.             :py:class:`~pyasn1.type.tag.TagSet`, then use the result as</font>
<font color="black">1205.             new object's ASN.1 tag(s).</font>
<font color="black">1206. </font>
<font color="black">1207.         explicitTag: :py:class:`~pyasn1.type.tag.Tag`</font>
<font color="black">1208.             Explicitly apply given ASN.1 tag object to caller's</font>
<font color="black">1209.             :py:class:`~pyasn1.type.tag.TagSet`, then use the result as</font>
<font color="black">1210.             new object's ASN.1 tag(s).</font>
<font color="black">1211. </font>
<font color="black">1212.         Returns</font>
<font color="black">1213.         -------</font>
<font color="black">1214.         : :py:class:`~pyasn1.type.univ.Null`</font>
<font color="black">1215.             new instance of NULL type/value</font>
<font color="black">1216.         &quot;&quot;&quot;</font>
<font color="red">1217.         return OctetString.subtype(self, value, implicitTag, explicitTag)</font>
<font color="black">1218. </font>
<font color="black">1219. </font>
<font color="green">1220. if sys.version_info[0] &lt;= 2:</font>
<font color="green">1221.     intTypes = (int, long)</font>
<font color="black">1222. else:</font>
<font color="red">1223.     intTypes = (int,)</font>
<font color="black">1224. </font>
<font color="green">1225. numericTypes = intTypes + (float,)</font>
<font color="black">1226. </font>
<font color="black">1227. </font>
<font color="green">1228. class ObjectIdentifier(base.AbstractSimpleAsn1Item):</font>
<font color="black">1229.     &quot;&quot;&quot;Create |ASN.1| type or object.</font>
<font color="black">1230. </font>
<font color="black">1231.     |ASN.1| objects are immutable and duck-type Python :class:`tuple` objects (tuple of non-negative integers).</font>
<font color="black">1232. </font>
<font color="black">1233.     Parameters</font>
<font color="black">1234.     ----------</font>
<font color="black">1235.     value: :class:`tuple`, :class:`str` or |ASN.1| object</font>
<font color="black">1236.         Python sequence of :class:`int` or string literal or |ASN.1| object.</font>
<font color="black">1237. </font>
<font color="black">1238.     tagSet: :py:class:`~pyasn1.type.tag.TagSet`</font>
<font color="black">1239.         Object representing non-default ASN.1 tag(s)</font>
<font color="black">1240. </font>
<font color="black">1241.     subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">1242.         Object representing non-default ASN.1 subtype constraint(s)</font>
<font color="black">1243. </font>
<font color="black">1244.     Raises</font>
<font color="black">1245.     ------</font>
<font color="black">1246.     : :py:class:`pyasn1.error.PyAsn1Error`</font>
<font color="black">1247.         On constraint violation or bad initializer.</font>
<font color="green">1248.     &quot;&quot;&quot;</font>
<font color="black">1249.     #: Default :py:class:`~pyasn1.type.tag.TagSet` object for ASN.1</font>
<font color="black">1250.     #: *ObjectIdentifier* objects</font>
<font color="green">1251.     tagSet = tag.initTagSet(</font>
<font color="green">1252.         tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x06)</font>
<font color="black">1253.     )</font>
<font color="green">1254.     baseTagSet = tagSet</font>
<font color="black">1255. </font>
<font color="black">1256.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">1257.     #: object imposing constraints on initialization values.</font>
<font color="green">1258.     subtypeSpec = constraint.ConstraintsIntersection()</font>
<font color="black">1259. </font>
<font color="green">1260.     def __add__(self, other):</font>
<font color="red">1261.         return self.clone(self._value + other)</font>
<font color="black">1262. </font>
<font color="green">1263.     def __radd__(self, other):</font>
<font color="red">1264.         return self.clone(other + self._value)</font>
<font color="black">1265. </font>
<font color="green">1266.     def asTuple(self):</font>
<font color="red">1267.         return self._value</font>
<font color="black">1268. </font>
<font color="black">1269.     # Sequence object protocol</font>
<font color="black">1270. </font>
<font color="green">1271.     def __len__(self):</font>
<font color="red">1272.         if self._len is None:</font>
<font color="red">1273.             self._len = len(self._value)</font>
<font color="red">1274.         return self._len</font>
<font color="black">1275. </font>
<font color="green">1276.     def __getitem__(self, i):</font>
<font color="red">1277.         if isinstance(i, slice):</font>
<font color="red">1278.             return self.clone(</font>
<font color="red">1279.                 operator.getitem(self._value, i)</font>
<font color="black">1280.             )</font>
<font color="black">1281.         else:</font>
<font color="red">1282.             return self._value[i]</font>
<font color="black">1283. </font>
<font color="green">1284.     def __iter__(self):</font>
<font color="red">1285.         return iter(self._value)</font>
<font color="black">1286. </font>
<font color="green">1287.     def __contains__(self, value):</font>
<font color="red">1288.         return value in self._value</font>
<font color="black">1289. </font>
<font color="green">1290.     def __str__(self):</font>
<font color="red">1291.         return self.prettyPrint()</font>
<font color="black">1292. </font>
<font color="green">1293.     def __repr__(self):</font>
<font color="red">1294.         return '%s(%r)' % (self.__class__.__name__, self.prettyPrint())</font>
<font color="black">1295. </font>
<font color="green">1296.     def index(self, suboid):</font>
<font color="red">1297.         return self._value.index(suboid)</font>
<font color="black">1298. </font>
<font color="green">1299.     def isPrefixOf(self, other):</font>
<font color="black">1300.         &quot;&quot;&quot;Indicate if this |ASN.1| object is a prefix of other |ASN.1| object.</font>
<font color="black">1301. </font>
<font color="black">1302.         Parameters</font>
<font color="black">1303.         ----------</font>
<font color="black">1304.         other: |ASN.1| object</font>
<font color="black">1305.             |ASN.1| object</font>
<font color="black">1306. </font>
<font color="black">1307.         Returns</font>
<font color="black">1308.         -------</font>
<font color="black">1309.         : :class:`bool`</font>
<font color="black">1310.             :class:`True` if this |ASN.1| object is a parent (e.g. prefix) of the other |ASN.1| object</font>
<font color="black">1311.             or :class:`False` otherwise.</font>
<font color="black">1312.         &quot;&quot;&quot;</font>
<font color="red">1313.         l = len(self)</font>
<font color="red">1314.         if l &lt;= len(other):</font>
<font color="red">1315.             if self._value[:l] == other[:l]:</font>
<font color="red">1316.                 return True</font>
<font color="red">1317.         return False</font>
<font color="black">1318. </font>
<font color="green">1319.     def prettyIn(self, value):</font>
<font color="green">1320.         if isinstance(value, ObjectIdentifier):</font>
<font color="red">1321.             return tuple(value)</font>
<font color="green">1322.         elif octets.isStringType(value):</font>
<font color="red">1323.             if '-' in value:</font>
<font color="red">1324.                 raise error.PyAsn1Error(</font>
<font color="red">1325.                     'Malformed Object ID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])</font>
<font color="black">1326.                 )</font>
<font color="red">1327.             try:</font>
<font color="red">1328.                 return tuple([int(subOid) for subOid in value.split('.') if subOid])</font>
<font color="red">1329.             except ValueError:</font>
<font color="red">1330.                 raise error.PyAsn1Error(</font>
<font color="red">1331.                     'Malformed Object ID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])</font>
<font color="black">1332.                 )</font>
<font color="black">1333. </font>
<font color="green">1334.         try:</font>
<font color="green">1335.             tupleOfInts = tuple([int(subOid) for subOid in value if subOid &gt;= 0])</font>
<font color="black">1336. </font>
<font color="red">1337.         except (ValueError, TypeError):</font>
<font color="red">1338.             raise error.PyAsn1Error(</font>
<font color="red">1339.                 'Malformed Object ID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])</font>
<font color="black">1340.             )</font>
<font color="black">1341. </font>
<font color="green">1342.         if len(tupleOfInts) == len(value):</font>
<font color="green">1343.             return tupleOfInts</font>
<font color="black">1344. </font>
<font color="red">1345.         raise error.PyAsn1Error('Malformed Object ID %s at %s' % (value, self.__class__.__name__))</font>
<font color="black">1346. </font>
<font color="green">1347.     def prettyOut(self, value):</font>
<font color="red">1348.         return '.'.join([str(x) for x in value])</font>
<font color="black">1349. </font>
<font color="black">1350. </font>
<font color="green">1351. class Real(base.AbstractSimpleAsn1Item):</font>
<font color="black">1352.     &quot;&quot;&quot;Create |ASN.1| type or object.</font>
<font color="black">1353. </font>
<font color="black">1354.     |ASN.1| objects are immutable and duck-type Python :class:`float` objects.</font>
<font color="black">1355.     Additionally, |ASN.1| objects behave like a :class:`tuple` in which case its</font>
<font color="black">1356.     elements are mantissa, base and exponent.</font>
<font color="black">1357. </font>
<font color="black">1358.     Parameters</font>
<font color="black">1359.     ----------</font>
<font color="black">1360.     value: :class:`tuple`, :class:`float` or |ASN.1| object</font>
<font color="black">1361.         Python sequence of :class:`int` (representing mantissa, base and</font>
<font color="black">1362.         exponent) or float instance or *Real* class instance.</font>
<font color="black">1363. </font>
<font color="black">1364.     tagSet: :py:class:`~pyasn1.type.tag.TagSet`</font>
<font color="black">1365.         Object representing non-default ASN.1 tag(s)</font>
<font color="black">1366. </font>
<font color="black">1367.     subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">1368.         Object representing non-default ASN.1 subtype constraint(s)</font>
<font color="black">1369. </font>
<font color="black">1370.     Raises</font>
<font color="black">1371.     ------</font>
<font color="black">1372.     : :py:class:`pyasn1.error.PyAsn1Error`</font>
<font color="black">1373.         On constraint violation or bad initializer.</font>
<font color="black">1374. </font>
<font color="green">1375.     &quot;&quot;&quot;</font>
<font color="green">1376.     binEncBase = None  # binEncBase = 16 is recommended for large numbers</font>
<font color="black">1377. </font>
<font color="green">1378.     try:</font>
<font color="green">1379.         _plusInf = float('inf')</font>
<font color="green">1380.         _minusInf = float('-inf')</font>
<font color="green">1381.         _inf = (_plusInf, _minusInf)</font>
<font color="red">1382.     except ValueError:</font>
<font color="black">1383.         # Infinity support is platform and Python dependent</font>
<font color="red">1384.         _plusInf = _minusInf = None</font>
<font color="red">1385.         _inf = ()</font>
<font color="black">1386. </font>
<font color="black">1387.     #: Default :py:class:`~pyasn1.type.tag.TagSet` object for ASN.1</font>
<font color="black">1388.     #: *Real* objects</font>
<font color="green">1389.     tagSet = tag.initTagSet(</font>
<font color="green">1390.         tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x09)</font>
<font color="black">1391.     )</font>
<font color="green">1392.     baseTagSet = tagSet</font>
<font color="black">1393. </font>
<font color="black">1394.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">1395.     #: object imposing constraints on initialization values.</font>
<font color="green">1396.     subtypeSpec = constraint.ConstraintsIntersection()</font>
<font color="black">1397. </font>
<font color="green">1398.     def clone(self, value=noValue, tagSet=None, subtypeSpec=None):</font>
<font color="black">1399.         &quot;&quot;&quot;Create a copy of a |ASN.1| type or object.</font>
<font color="black">1400. </font>
<font color="black">1401.         Any parameters to the *clone()* method will replace corresponding</font>
<font color="black">1402.         properties of the |ASN.1| object.</font>
<font color="black">1403. </font>
<font color="black">1404.         Parameters</font>
<font color="black">1405.         ----------</font>
<font color="black">1406.         value: :class:`tuple`, :class:`float` or |ASN.1| object</font>
<font color="black">1407.             Initialization value to pass to new ASN.1 object instead of</font>
<font color="black">1408.             inheriting one from the caller.</font>
<font color="black">1409. </font>
<font color="black">1410.         tagSet: :py:class:`~pyasn1.type.tag.TagSet`</font>
<font color="black">1411.             Object representing ASN.1 tag(s) to use in new object instead of inheriting from the caller</font>
<font color="black">1412. </font>
<font color="black">1413.         subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">1414.             Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller</font>
<font color="black">1415. </font>
<font color="black">1416.         Returns</font>
<font color="black">1417.         -------</font>
<font color="black">1418.         :</font>
<font color="black">1419.             new instance of |ASN.1| type/value</font>
<font color="black">1420.         &quot;&quot;&quot;</font>
<font color="red">1421.         return base.AbstractSimpleAsn1Item.clone(self, value, tagSet, subtypeSpec)</font>
<font color="black">1422. </font>
<font color="green">1423.     def subtype(self, value=noValue, implicitTag=None, explicitTag=None,</font>
<font color="green">1424.                 subtypeSpec=None):</font>
<font color="black">1425.         &quot;&quot;&quot;Create a copy of a |ASN.1| type or object.</font>
<font color="black">1426. </font>
<font color="black">1427.         Any parameters to the *subtype()* method will be added to the corresponding</font>
<font color="black">1428.         properties of the |ASN.1| object.</font>
<font color="black">1429. </font>
<font color="black">1430.         Parameters</font>
<font color="black">1431.         ----------</font>
<font color="black">1432.         value: :class:`tuple`, :class:`float` or |ASN.1| object</font>
<font color="black">1433.             Initialization value to pass to new ASN.1 object instead of</font>
<font color="black">1434.             inheriting one from the caller.</font>
<font color="black">1435. </font>
<font color="black">1436.         implicitTag: :py:class:`~pyasn1.type.tag.Tag`</font>
<font color="black">1437.             Implicitly apply given ASN.1 tag object to caller's</font>
<font color="black">1438.             :py:class:`~pyasn1.type.tag.TagSet`, then use the result as</font>
<font color="black">1439.             new object's ASN.1 tag(s).</font>
<font color="black">1440. </font>
<font color="black">1441.         explicitTag: :py:class:`~pyasn1.type.tag.Tag`</font>
<font color="black">1442.             Explicitly apply given ASN.1 tag object to caller's</font>
<font color="black">1443.             :py:class:`~pyasn1.type.tag.TagSet`, then use the result as</font>
<font color="black">1444.             new object's ASN.1 tag(s).</font>
<font color="black">1445. </font>
<font color="black">1446.         subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">1447.              Object representing ASN.1 subtype constraint(s) to use in new object instead of inheriting from the caller</font>
<font color="black">1448. </font>
<font color="black">1449.         Returns</font>
<font color="black">1450.         -------</font>
<font color="black">1451.         :</font>
<font color="black">1452.             new instance of |ASN.1| type/value</font>
<font color="black">1453.         &quot;&quot;&quot;</font>
<font color="red">1454.         return base.AbstractSimpleAsn1Item.subtype(self, value, implicitTag, explicitTag)</font>
<font color="black">1455. </font>
<font color="green">1456.     @staticmethod</font>
<font color="black">1457.     def __normalizeBase10(value):</font>
<font color="red">1458.         m, b, e = value</font>
<font color="red">1459.         while m and m % 10 == 0:</font>
<font color="red">1460.             m /= 10</font>
<font color="red">1461.             e += 1</font>
<font color="red">1462.         return m, b, e</font>
<font color="black">1463. </font>
<font color="green">1464.     def prettyIn(self, value):</font>
<font color="red">1465.         if isinstance(value, tuple) and len(value) == 3:</font>
<font color="red">1466.             if not isinstance(value[0], numericTypes) or \</font>
<font color="red">1467.                     not isinstance(value[1], intTypes) or \</font>
<font color="red">1468.                     not isinstance(value[2], intTypes):</font>
<font color="red">1469.                 raise error.PyAsn1Error('Lame Real value syntax: %s' % (value,))</font>
<font color="red">1470.             if isinstance(value[0], float) and \</font>
<font color="red">1471.                     self._inf and value[0] in self._inf:</font>
<font color="red">1472.                 return value[0]</font>
<font color="red">1473.             if value[1] not in (2, 10):</font>
<font color="red">1474.                 raise error.PyAsn1Error(</font>
<font color="red">1475.                     'Prohibited base for Real value: %s' % (value[1],)</font>
<font color="black">1476.                 )</font>
<font color="red">1477.             if value[1] == 10:</font>
<font color="red">1478.                 value = self.__normalizeBase10(value)</font>
<font color="red">1479.             return value</font>
<font color="red">1480.         elif isinstance(value, intTypes):</font>
<font color="red">1481.             return self.__normalizeBase10((value, 10, 0))</font>
<font color="red">1482.         elif isinstance(value, float) or octets.isStringType(value):</font>
<font color="red">1483.             if octets.isStringType(value):</font>
<font color="red">1484.                 try:</font>
<font color="red">1485.                     value = float(value)</font>
<font color="red">1486.                 except ValueError:</font>
<font color="red">1487.                     raise error.PyAsn1Error(</font>
<font color="red">1488.                         'Bad real value syntax: %s' % (value,)</font>
<font color="black">1489.                     )</font>
<font color="red">1490.             if self._inf and value in self._inf:</font>
<font color="red">1491.                 return value</font>
<font color="black">1492.             else:</font>
<font color="red">1493.                 e = 0</font>
<font color="red">1494.                 while int(value) != value:</font>
<font color="red">1495.                     value *= 10</font>
<font color="red">1496.                     e -= 1</font>
<font color="red">1497.                 return self.__normalizeBase10((int(value), 10, e))</font>
<font color="red">1498.         elif isinstance(value, Real):</font>
<font color="red">1499.             return tuple(value)</font>
<font color="red">1500.         raise error.PyAsn1Error(</font>
<font color="red">1501.             'Bad real value syntax: %s' % (value,)</font>
<font color="black">1502.         )</font>
<font color="black">1503. </font>
<font color="green">1504.     def prettyOut(self, value):</font>
<font color="red">1505.         if value in self._inf:</font>
<font color="red">1506.             return '\'%s\'' % value</font>
<font color="black">1507.         else:</font>
<font color="red">1508.             return str(value)</font>
<font color="black">1509. </font>
<font color="green">1510.     def prettyPrint(self, scope=0):</font>
<font color="red">1511.         if self.isInfinity():</font>
<font color="red">1512.             return self.prettyOut(self._value)</font>
<font color="black">1513.         else:</font>
<font color="red">1514.             return str(float(self))</font>
<font color="black">1515. </font>
<font color="green">1516.     def isPlusInfinity(self):</font>
<font color="black">1517.         &quot;&quot;&quot;Indicate PLUS-INFINITY object value</font>
<font color="black">1518. </font>
<font color="black">1519.         Returns</font>
<font color="black">1520.         -------</font>
<font color="black">1521.         : :class:`bool`</font>
<font color="black">1522.             :class:`True` if calling object represents plus infinity</font>
<font color="black">1523.             or :class:`False` otherwise.</font>
<font color="black">1524. </font>
<font color="black">1525.         &quot;&quot;&quot;</font>
<font color="red">1526.         return self._value == self._plusInf</font>
<font color="black">1527. </font>
<font color="green">1528.     def isMinusInfinity(self):</font>
<font color="black">1529.         &quot;&quot;&quot;Indicate MINUS-INFINITY object value</font>
<font color="black">1530. </font>
<font color="black">1531.         Returns</font>
<font color="black">1532.         -------</font>
<font color="black">1533.         : :class:`bool`</font>
<font color="black">1534.             :class:`True` if calling object represents minus infinity</font>
<font color="black">1535.             or :class:`False` otherwise.</font>
<font color="black">1536.         &quot;&quot;&quot;</font>
<font color="red">1537.         return self._value == self._minusInf</font>
<font color="black">1538. </font>
<font color="green">1539.     def isInfinity(self):</font>
<font color="red">1540.         return self._value in self._inf</font>
<font color="black">1541. </font>
<font color="green">1542.     def __str__(self):</font>
<font color="red">1543.         return str(float(self))</font>
<font color="black">1544. </font>
<font color="green">1545.     def __add__(self, value):</font>
<font color="red">1546.         return self.clone(float(self) + value)</font>
<font color="black">1547. </font>
<font color="green">1548.     def __radd__(self, value):</font>
<font color="red">1549.         return self + value</font>
<font color="black">1550. </font>
<font color="green">1551.     def __mul__(self, value):</font>
<font color="red">1552.         return self.clone(float(self) * value)</font>
<font color="black">1553. </font>
<font color="green">1554.     def __rmul__(self, value):</font>
<font color="red">1555.         return self * value</font>
<font color="black">1556. </font>
<font color="green">1557.     def __sub__(self, value):</font>
<font color="red">1558.         return self.clone(float(self) - value)</font>
<font color="black">1559. </font>
<font color="green">1560.     def __rsub__(self, value):</font>
<font color="red">1561.         return self.clone(value - float(self))</font>
<font color="black">1562. </font>
<font color="green">1563.     def __mod__(self, value):</font>
<font color="red">1564.         return self.clone(float(self) % value)</font>
<font color="black">1565. </font>
<font color="green">1566.     def __rmod__(self, value):</font>
<font color="red">1567.         return self.clone(value % float(self))</font>
<font color="black">1568. </font>
<font color="green">1569.     def __pow__(self, value, modulo=None):</font>
<font color="red">1570.         return self.clone(pow(float(self), value, modulo))</font>
<font color="black">1571. </font>
<font color="green">1572.     def __rpow__(self, value):</font>
<font color="red">1573.         return self.clone(pow(value, float(self)))</font>
<font color="black">1574. </font>
<font color="green">1575.     if sys.version_info[0] &lt;= 2:</font>
<font color="green">1576.         def __div__(self, value):</font>
<font color="red">1577.             return self.clone(float(self) / value)</font>
<font color="black">1578. </font>
<font color="green">1579.         def __rdiv__(self, value):</font>
<font color="red">1580.             return self.clone(value / float(self))</font>
<font color="black">1581.     else:</font>
<font color="red">1582.         def __truediv__(self, value):</font>
<font color="red">1583.             return self.clone(float(self) / value)</font>
<font color="black">1584. </font>
<font color="red">1585.         def __rtruediv__(self, value):</font>
<font color="red">1586.             return self.clone(value / float(self))</font>
<font color="black">1587. </font>
<font color="red">1588.         def __divmod__(self, value):</font>
<font color="red">1589.             return self.clone(float(self) // value)</font>
<font color="black">1590. </font>
<font color="red">1591.         def __rdivmod__(self, value):</font>
<font color="red">1592.             return self.clone(value // float(self))</font>
<font color="black">1593. </font>
<font color="green">1594.     def __int__(self):</font>
<font color="red">1595.         return int(float(self))</font>
<font color="black">1596. </font>
<font color="green">1597.     if sys.version_info[0] &lt;= 2:</font>
<font color="green">1598.         def __long__(self): return long(float(self))</font>
<font color="black">1599. </font>
<font color="green">1600.     def __float__(self):</font>
<font color="red">1601.         if self._value in self._inf:</font>
<font color="red">1602.             return self._value</font>
<font color="black">1603.         else:</font>
<font color="red">1604.             return float(</font>
<font color="red">1605.                 self._value[0] * pow(self._value[1], self._value[2])</font>
<font color="black">1606.             )</font>
<font color="black">1607. </font>
<font color="green">1608.     def __abs__(self):</font>
<font color="red">1609.         return self.clone(abs(float(self)))</font>
<font color="black">1610. </font>
<font color="green">1611.     def __pos__(self):</font>
<font color="red">1612.         return self.clone(+float(self))</font>
<font color="black">1613. </font>
<font color="green">1614.     def __neg__(self):</font>
<font color="red">1615.         return self.clone(-float(self))</font>
<font color="black">1616. </font>
<font color="green">1617.     def __round__(self, n=0):</font>
<font color="red">1618.         r = round(float(self), n)</font>
<font color="red">1619.         if n:</font>
<font color="red">1620.             return self.clone(r)</font>
<font color="black">1621.         else:</font>
<font color="red">1622.             return r</font>
<font color="black">1623. </font>
<font color="green">1624.     def __floor__(self):</font>
<font color="red">1625.         return self.clone(math.floor(float(self)))</font>
<font color="black">1626. </font>
<font color="green">1627.     def __ceil__(self):</font>
<font color="red">1628.         return self.clone(math.ceil(float(self)))</font>
<font color="black">1629. </font>
<font color="green">1630.     if sys.version_info[0:2] &gt; (2, 5):</font>
<font color="green">1631.         def __trunc__(self): return self.clone(math.trunc(float(self)))</font>
<font color="black">1632. </font>
<font color="green">1633.     def __lt__(self, value):</font>
<font color="red">1634.         return float(self) &lt; value</font>
<font color="black">1635. </font>
<font color="green">1636.     def __le__(self, value):</font>
<font color="red">1637.         return float(self) &lt;= value</font>
<font color="black">1638. </font>
<font color="green">1639.     def __eq__(self, value):</font>
<font color="red">1640.         return float(self) == value</font>
<font color="black">1641. </font>
<font color="green">1642.     def __ne__(self, value):</font>
<font color="red">1643.         return float(self) != value</font>
<font color="black">1644. </font>
<font color="green">1645.     def __gt__(self, value):</font>
<font color="red">1646.         return float(self) &gt; value</font>
<font color="black">1647. </font>
<font color="green">1648.     def __ge__(self, value):</font>
<font color="red">1649.         return float(self) &gt;= value</font>
<font color="black">1650. </font>
<font color="green">1651.     if sys.version_info[0] &lt;= 2:</font>
<font color="green">1652.         def __nonzero__(self):</font>
<font color="red">1653.             return bool(float(self))</font>
<font color="black">1654.     else:</font>
<font color="red">1655.         def __bool__(self):</font>
<font color="red">1656.             return bool(float(self))</font>
<font color="black">1657. </font>
<font color="red">1658.         __hash__ = base.AbstractSimpleAsn1Item.__hash__</font>
<font color="black">1659. </font>
<font color="green">1660.     def __getitem__(self, idx):</font>
<font color="red">1661.         if self._value in self._inf:</font>
<font color="red">1662.             raise error.PyAsn1Error('Invalid infinite value operation')</font>
<font color="black">1663.         else:</font>
<font color="red">1664.             return self._value[idx]</font>
<font color="black">1665. </font>
<font color="black">1666. </font>
<font color="green">1667. class Enumerated(Integer):</font>
<font color="green">1668.     __doc__ = Integer.__doc__</font>
<font color="black">1669. </font>
<font color="black">1670.     #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects</font>
<font color="green">1671.     tagSet = tag.initTagSet(</font>
<font color="green">1672.         tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x0A)</font>
<font color="black">1673.     )</font>
<font color="green">1674.     baseTagSet = tagSet</font>
<font color="black">1675. </font>
<font color="black">1676.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">1677.     #: object imposing constraints on initialization values.</font>
<font color="green">1678.     subtypeSpec = constraint.ConstraintsIntersection()</font>
<font color="black">1679. </font>
<font color="black">1680.     #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object</font>
<font color="black">1681.     #: representing symbolic aliases for numbers</font>
<font color="green">1682.     namedValues = namedval.NamedValues()</font>
<font color="black">1683. </font>
<font color="black">1684. # &quot;Structured&quot; ASN.1 types</font>
<font color="black">1685. </font>
<font color="green">1686. class SequenceOfAndSetOfBase(base.AbstractConstructedAsn1Item):</font>
<font color="black">1687.     &quot;&quot;&quot;Create |ASN.1| type.</font>
<font color="black">1688. </font>
<font color="black">1689.     |ASN.1| objects are mutable and duck-type Python :class:`list` objects.</font>
<font color="black">1690. </font>
<font color="black">1691.     Parameters</font>
<font color="black">1692.     ----------</font>
<font color="black">1693.     componentType : :py:class:`~pyasn1.type.base.PyAsn1Item` derivative</font>
<font color="black">1694.         A pyasn1 object representing ASN.1 type allowed within |ASN.1| type</font>
<font color="black">1695. </font>
<font color="black">1696.     tagSet: :py:class:`~pyasn1.type.tag.TagSet`</font>
<font color="black">1697.         Object representing non-default ASN.1 tag(s)</font>
<font color="black">1698. </font>
<font color="black">1699.     subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">1700.         Object representing non-default ASN.1 subtype constraint(s)</font>
<font color="black">1701. </font>
<font color="black">1702.     sizeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">1703.         Object representing collection size constraint</font>
<font color="green">1704.      &quot;&quot;&quot;</font>
<font color="black">1705. </font>
<font color="black">1706.     # Python list protocol</font>
<font color="black">1707. </font>
<font color="green">1708.     def clear(self):</font>
<font color="red">1709.         self._componentValues = []</font>
<font color="red">1710.         self._componentValuesSet = 0</font>
<font color="black">1711. </font>
<font color="green">1712.     def append(self, value):</font>
<font color="red">1713.         self[len(self)] = value</font>
<font color="black">1714. </font>
<font color="green">1715.     def count(self, value):</font>
<font color="red">1716.         return self._componentValues.count(value)</font>
<font color="black">1717. </font>
<font color="green">1718.     def extend(self, values):</font>
<font color="red">1719.         for value in values:</font>
<font color="red">1720.             self.append(value)</font>
<font color="black">1721. </font>
<font color="green">1722.     def index(self, value, start=0, stop=None):</font>
<font color="red">1723.         if stop is None:</font>
<font color="red">1724.             stop = len(self)</font>
<font color="red">1725.         return self._componentValues.index(value, start, stop)</font>
<font color="black">1726. </font>
<font color="green">1727.     def reverse(self):</font>
<font color="red">1728.         self._componentValues.reverse()</font>
<font color="black">1729. </font>
<font color="green">1730.     def sort(self, key=None, reverse=False):</font>
<font color="red">1731.         self._componentValues.sort(key=key, reverse=reverse)</font>
<font color="black">1732. </font>
<font color="green">1733.     def __iter__(self):</font>
<font color="red">1734.         return iter(self._componentValues)</font>
<font color="black">1735. </font>
<font color="green">1736.     def _cloneComponentValues(self, myClone, cloneValueFlag):</font>
<font color="red">1737.         for idx, componentValue in enumerate(self._componentValues):</font>
<font color="red">1738.             if componentValue is not None:</font>
<font color="red">1739.                 if isinstance(componentValue, base.AbstractConstructedAsn1Item):</font>
<font color="red">1740.                     myClone.setComponentByPosition(</font>
<font color="red">1741.                         idx, componentValue.clone(cloneValueFlag=cloneValueFlag)</font>
<font color="black">1742.                     )</font>
<font color="black">1743.                 else:</font>
<font color="red">1744.                     myClone.setComponentByPosition(idx, componentValue.clone())</font>
<font color="black">1745. </font>
<font color="green">1746.     def getComponentByPosition(self, idx):</font>
<font color="black">1747.         &quot;&quot;&quot;Return |ASN.1| type component value by position.</font>
<font color="black">1748. </font>
<font color="black">1749.         Equivalent to Python sequence subscription operation (e.g. `[]`).</font>
<font color="black">1750. </font>
<font color="black">1751.         Parameters</font>
<font color="black">1752.         ----------</font>
<font color="black">1753.         idx : :class:`int`</font>
<font color="black">1754.             component index (zero-based)</font>
<font color="black">1755. </font>
<font color="black">1756.         Returns</font>
<font color="black">1757.         -------</font>
<font color="black">1758.         : :py:class:`~pyasn1.type.base.PyAsn1Item`</font>
<font color="black">1759.             a pyasn1 object</font>
<font color="black">1760.         &quot;&quot;&quot;</font>
<font color="red">1761.         return self._componentValues[idx]</font>
<font color="black">1762. </font>
<font color="green">1763.     def setComponentByPosition(self, idx, value=noValue,</font>
<font color="green">1764.                                verifyConstraints=True,</font>
<font color="green">1765.                                matchTags=True,</font>
<font color="green">1766.                                matchConstraints=True):</font>
<font color="black">1767.         &quot;&quot;&quot;Assign |ASN.1| type component by position.</font>
<font color="black">1768. </font>
<font color="black">1769.         Equivalent to Python sequence item assignment operation (e.g. `[]`).</font>
<font color="black">1770. </font>
<font color="black">1771.         Parameters</font>
<font color="black">1772.         ----------</font>
<font color="black">1773.         idx : :class:`int`</font>
<font color="black">1774.             component index (zero-based)</font>
<font color="black">1775. </font>
<font color="black">1776.         value : :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative</font>
<font color="black">1777.             A Python or pyasn1 object to assign or :py:class:`~pyasn1.type.univ.noValue`</font>
<font color="black">1778.             object to instantiate component type.</font>
<font color="black">1779. </font>
<font color="black">1780.         verifyConstraints : :class:`bool`</font>
<font color="black">1781.              If `False`, skip constraints validation</font>
<font color="black">1782. </font>
<font color="black">1783.         matchTags: :class:`bool`</font>
<font color="black">1784.              If `False`, skip component tags matching</font>
<font color="black">1785. </font>
<font color="black">1786.         matchConstraints: :class:`bool`</font>
<font color="black">1787.              If `False`, skip component constraints matching</font>
<font color="black">1788. </font>
<font color="black">1789.         Returns</font>
<font color="black">1790.         -------</font>
<font color="black">1791.         self</font>
<font color="black">1792.         &quot;&quot;&quot;</font>
<font color="red">1793.         componentType = self._componentType</font>
<font color="black">1794. </font>
<font color="red">1795.         componentValuesLength = len(self._componentValues)</font>
<font color="black">1796. </font>
<font color="red">1797.         if idx == componentValuesLength:</font>
<font color="red">1798.             self._componentValues.append(None)</font>
<font color="red">1799.         elif idx &gt;= componentValuesLength:</font>
<font color="red">1800.             self._componentValues.extend([None for x in range((idx - componentValuesLength + 1))])</font>
<font color="black">1801. </font>
<font color="red">1802.         if self.isNoValue(value):</font>
<font color="red">1803.             if self._componentValues[idx] is None:</font>
<font color="red">1804.                 if componentType is None:</font>
<font color="red">1805.                     raise error.PyAsn1Error('Component type not defined')</font>
<font color="red">1806.                 self._componentValues[idx] = componentType.clone()</font>
<font color="red">1807.                 self._componentValuesSet += 1</font>
<font color="red">1808.             return self</font>
<font color="red">1809.         elif not isinstance(value, base.Asn1Item):</font>
<font color="red">1810.             if componentType is None:</font>
<font color="red">1811.                 raise error.PyAsn1Error('Component type not defined')</font>
<font color="red">1812.             if isinstance(componentType, base.AbstractSimpleAsn1Item):</font>
<font color="red">1813.                 value = componentType.clone(value=value)</font>
<font color="black">1814.             else:</font>
<font color="red">1815.                 raise error.PyAsn1Error('%s instance value required' % componentType.__class__.__name__)</font>
<font color="red">1816.         elif componentType is not None:</font>
<font color="red">1817.             if self.strictConstraints:</font>
<font color="red">1818.                 if not componentType.isSameTypeWith(value, matchTags, matchConstraints):</font>
<font color="red">1819.                     raise error.PyAsn1Error('Component value is tag-incompatible: %r vs %r' % (value, componentType))</font>
<font color="black">1820.             else:</font>
<font color="red">1821.                 if not componentType.isSuperTypeOf(value, matchTags, matchConstraints):</font>
<font color="red">1822.                     raise error.PyAsn1Error('Component value is tag-incompatible: %r vs %r' % (value, componentType))</font>
<font color="black">1823. </font>
<font color="red">1824.         if verifyConstraints:</font>
<font color="red">1825.             self._verifySubtypeSpec(value, idx)</font>
<font color="black">1826. </font>
<font color="red">1827.         if self._componentValues[idx] is None:</font>
<font color="red">1828.             self._componentValuesSet += 1</font>
<font color="black">1829. </font>
<font color="red">1830.         self._componentValues[idx] = value</font>
<font color="black">1831. </font>
<font color="red">1832.         return self</font>
<font color="black">1833. </font>
<font color="green">1834.     def getComponentTagMap(self):</font>
<font color="red">1835.         if self._componentType is not None:</font>
<font color="red">1836.             return self._componentType.getTagMap()</font>
<font color="black">1837. </font>
<font color="green">1838.     def prettyPrint(self, scope=0):</font>
<font color="red">1839.         scope += 1</font>
<font color="red">1840.         r = self.__class__.__name__ + ':\n'</font>
<font color="red">1841.         for idx in range(len(self._componentValues)):</font>
<font color="red">1842.             r += ' ' * scope</font>
<font color="red">1843.             if self._componentValues[idx] is None:</font>
<font color="red">1844.                 r += '&lt;empty&gt;'</font>
<font color="black">1845.             else:</font>
<font color="red">1846.                 r = r + self._componentValues[idx].prettyPrint(scope)</font>
<font color="red">1847.         return r</font>
<font color="black">1848. </font>
<font color="green">1849.     def prettyPrintType(self, scope=0):</font>
<font color="red">1850.         scope += 1</font>
<font color="red">1851.         r = '%s -&gt; %s {\n' % (self.getTagSet(), self.__class__.__name__)</font>
<font color="red">1852.         if self._componentType is not None:</font>
<font color="red">1853.             r += ' ' * scope</font>
<font color="red">1854.             r = r + self._componentType.prettyPrintType(scope)</font>
<font color="red">1855.         return r + '\n' + ' ' * (scope - 1) + '}'</font>
<font color="black">1856. </font>
<font color="black">1857. </font>
<font color="green">1858. class SequenceOf(SequenceOfAndSetOfBase):</font>
<font color="green">1859.     __doc__ = SequenceOfAndSetOfBase.__doc__</font>
<font color="black">1860.     #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects</font>
<font color="green">1861.     tagSet = tag.initTagSet(</font>
<font color="green">1862.         tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x10)</font>
<font color="black">1863.     )</font>
<font color="green">1864.     baseTagSet = tagSet</font>
<font color="black">1865. </font>
<font color="black">1866.     #: Default :py:class:`~pyasn1.type.base.PyAsn1Item` derivative</font>
<font color="black">1867.     #: object representing ASN.1 type allowed within |ASN.1| type</font>
<font color="green">1868.     componentType = None</font>
<font color="black">1869. </font>
<font color="black">1870.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">1871.     #: object imposing constraints on |ASN.1| objects</font>
<font color="green">1872.     subtypeSpec = constraint.ConstraintsIntersection()</font>
<font color="black">1873. </font>
<font color="black">1874.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">1875.     #: object imposing size constraint on |ASN.1| objects</font>
<font color="green">1876.     sizeSpec = constraint.ConstraintsIntersection()</font>
<font color="black">1877. </font>
<font color="green">1878.     typeId = 1</font>
<font color="black">1879. </font>
<font color="black">1880. </font>
<font color="green">1881. class SetOf(SequenceOfAndSetOfBase):</font>
<font color="green">1882.     __doc__ = SequenceOfAndSetOfBase.__doc__</font>
<font color="black">1883. </font>
<font color="black">1884.     #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects</font>
<font color="green">1885.     tagSet = tag.initTagSet(</font>
<font color="green">1886.         tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x11)</font>
<font color="black">1887.     )</font>
<font color="green">1888.     baseTagSet = tagSet</font>
<font color="black">1889. </font>
<font color="black">1890.     #: Default :py:class:`~pyasn1.type.base.PyAsn1Item` derivative</font>
<font color="black">1891.     #: object representing ASN.1 type allowed within |ASN.1| type</font>
<font color="green">1892.     componentType = None</font>
<font color="black">1893. </font>
<font color="black">1894.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">1895.     #: object imposing constraints on |ASN.1| objects</font>
<font color="green">1896.     subtypeSpec = constraint.ConstraintsIntersection()</font>
<font color="black">1897. </font>
<font color="black">1898.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">1899.     #: object imposing size constraint on |ASN.1| objects</font>
<font color="green">1900.     sizeSpec = constraint.ConstraintsIntersection()</font>
<font color="black">1901. </font>
<font color="green">1902.     typeId = 2</font>
<font color="black">1903. </font>
<font color="black">1904. </font>
<font color="green">1905. class SequenceAndSetBase(base.AbstractConstructedAsn1Item):</font>
<font color="black">1906.     &quot;&quot;&quot;Create |ASN.1| type.</font>
<font color="black">1907. </font>
<font color="black">1908.     |ASN.1| objects are mutable and duck-type Python :class:`dict` objects.</font>
<font color="black">1909. </font>
<font color="black">1910.     Parameters</font>
<font color="black">1911.     ----------</font>
<font color="black">1912.     componentType : :py:class:`~pyasn1.type.namedtype.NamedType`</font>
<font color="black">1913.         Object holding named ASN.1 types allowed within this collection</font>
<font color="black">1914. </font>
<font color="black">1915.     tagSet: :py:class:`~pyasn1.type.tag.TagSet`</font>
<font color="black">1916.         Object representing non-default ASN.1 tag(s)</font>
<font color="black">1917. </font>
<font color="black">1918.     subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">1919.         Object representing non-default ASN.1 subtype constraint(s)</font>
<font color="black">1920. </font>
<font color="black">1921.     sizeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">1922.         Object representing collection size constraint</font>
<font color="green">1923.     &quot;&quot;&quot;</font>
<font color="black">1924.     #: Default :py:class:`~pyasn1.type.namedtype.NamedTypes`</font>
<font color="black">1925.     #: object representing named ASN.1 types allowed within |ASN.1| type</font>
<font color="green">1926.     componentType = namedtype.NamedTypes()</font>
<font color="black">1927. </font>
<font color="green">1928.     def __init__(self, componentType=None, tagSet=None,</font>
<font color="green">1929.                  subtypeSpec=None, sizeSpec=None):</font>
<font color="green">1930.         if componentType is None:</font>
<font color="green">1931.             componentType = self.componentType</font>
<font color="green">1932.         base.AbstractConstructedAsn1Item.__init__(</font>
<font color="green">1933.             self, componentType, tagSet, subtypeSpec, sizeSpec</font>
<font color="black">1934.         )</font>
<font color="green">1935.         self._componentTypeLen = len(self._componentType)</font>
<font color="black">1936. </font>
<font color="green">1937.     def __getitem__(self, idx):</font>
<font color="red">1938.         if octets.isStringType(idx):</font>
<font color="red">1939.             return self.getComponentByName(idx)</font>
<font color="black">1940.         else:</font>
<font color="red">1941.             return base.AbstractConstructedAsn1Item.__getitem__(self, idx)</font>
<font color="black">1942. </font>
<font color="green">1943.     def __setitem__(self, idx, value):</font>
<font color="red">1944.         if octets.isStringType(idx):</font>
<font color="red">1945.             self.setComponentByName(idx, value)</font>
<font color="black">1946.         else:</font>
<font color="red">1947.             base.AbstractConstructedAsn1Item.__setitem__(self, idx, value)</font>
<font color="black">1948. </font>
<font color="green">1949.     def __contains__(self, key):</font>
<font color="red">1950.         return key in self._componentType</font>
<font color="black">1951. </font>
<font color="green">1952.     def __iter__(self):</font>
<font color="red">1953.         return iter(self._componentType)</font>
<font color="black">1954. </font>
<font color="black">1955.     # Python dict protocol</font>
<font color="black">1956. </font>
<font color="green">1957.     def values(self):</font>
<font color="red">1958.         for idx in range(self._componentTypeLen):</font>
<font color="red">1959.             yield self[idx]</font>
<font color="black">1960. </font>
<font color="green">1961.     def keys(self):</font>
<font color="red">1962.         return iter(self._componentType)</font>
<font color="black">1963. </font>
<font color="green">1964.     def items(self):</font>
<font color="red">1965.         for idx in range(self._componentTypeLen):</font>
<font color="red">1966.             yield self._componentType[idx].getName(), self[idx]</font>
<font color="black">1967. </font>
<font color="green">1968.     def update(self, *iterValue, **mappingValue):</font>
<font color="red">1969.         for k, v in iterValue:</font>
<font color="red">1970.             self[k] = v</font>
<font color="red">1971.         for k in mappingValue:</font>
<font color="red">1972.             self[k] = mappingValue[k]</font>
<font color="black">1973. </font>
<font color="green">1974.     def clear(self):</font>
<font color="red">1975.         self._componentValues = []</font>
<font color="red">1976.         self._componentValuesSet = 0</font>
<font color="black">1977. </font>
<font color="green">1978.     def _cloneComponentValues(self, myClone, cloneValueFlag):</font>
<font color="red">1979.         for idx, componentValue in enumerate(self._componentValues):</font>
<font color="red">1980.             if componentValue is not None:</font>
<font color="red">1981.                 if isinstance(componentValue, base.AbstractConstructedAsn1Item):</font>
<font color="red">1982.                     myClone.setComponentByPosition(</font>
<font color="red">1983.                         idx, componentValue.clone(cloneValueFlag=cloneValueFlag)</font>
<font color="black">1984.                     )</font>
<font color="black">1985.                 else:</font>
<font color="red">1986.                     myClone.setComponentByPosition(idx, componentValue.clone())</font>
<font color="black">1987. </font>
<font color="green">1988.     def getComponentByName(self, name):</font>
<font color="black">1989.         &quot;&quot;&quot;Returns |ASN.1| type component by name.</font>
<font color="black">1990. </font>
<font color="black">1991.         Equivalent to Python :class:`dict` subscription operation (e.g. `[]`).</font>
<font color="black">1992. </font>
<font color="black">1993.         Parameters</font>
<font color="black">1994.         ----------</font>
<font color="black">1995.         name : :class:`str`</font>
<font color="black">1996.             |ASN.1| type component name</font>
<font color="black">1997. </font>
<font color="black">1998.         Returns</font>
<font color="black">1999.         -------</font>
<font color="black">2000.         : :py:class:`~pyasn1.type.base.PyAsn1Item`</font>
<font color="black">2001.             a pyasn1 object</font>
<font color="black">2002.         &quot;&quot;&quot;</font>
<font color="red">2003.         return self.getComponentByPosition(</font>
<font color="red">2004.             self._componentType.getPositionByName(name)</font>
<font color="black">2005.         )</font>
<font color="black">2006. </font>
<font color="green">2007.     def setComponentByName(self, name, value=noValue,</font>
<font color="green">2008.                            verifyConstraints=True,</font>
<font color="green">2009.                            matchTags=True,</font>
<font color="green">2010.                            matchConstraints=True):</font>
<font color="black">2011.         &quot;&quot;&quot;Assign |ASN.1| type component by name.</font>
<font color="black">2012. </font>
<font color="black">2013.         Equivalent to Python :class:`dict` item assignment operation (e.g. `[]`).</font>
<font color="black">2014. </font>
<font color="black">2015.         Parameters</font>
<font color="black">2016.         ----------</font>
<font color="black">2017.         name : :class:`str`</font>
<font color="black">2018.             |ASN.1| type component name</font>
<font color="black">2019. </font>
<font color="black">2020.         value : :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative</font>
<font color="black">2021.             A Python or pyasn1 object to assign</font>
<font color="black">2022. </font>
<font color="black">2023.         verifyConstraints: :class:`bool`</font>
<font color="black">2024.              If `False`, skip constraints validation</font>
<font color="black">2025. </font>
<font color="black">2026.         matchTags: :class:`bool`</font>
<font color="black">2027.              If `False`, skip component tags matching</font>
<font color="black">2028. </font>
<font color="black">2029.         matchConstraints: :class:`bool`</font>
<font color="black">2030.              If `False`, skip component constraints matching</font>
<font color="black">2031. </font>
<font color="black">2032.         Returns</font>
<font color="black">2033.         -------</font>
<font color="black">2034.         self</font>
<font color="black">2035.         &quot;&quot;&quot;</font>
<font color="red">2036.         return self.setComponentByPosition(</font>
<font color="red">2037.             self._componentType.getPositionByName(name), value, verifyConstraints, matchTags, matchConstraints</font>
<font color="black">2038.         )</font>
<font color="black">2039. </font>
<font color="green">2040.     def getComponentByPosition(self, idx):</font>
<font color="black">2041.         &quot;&quot;&quot;Returns |ASN.1| type component by index.</font>
<font color="black">2042. </font>
<font color="black">2043.         Equivalent to Python sequence subscription operation (e.g. `[]`).</font>
<font color="black">2044. </font>
<font color="black">2045.         Parameters</font>
<font color="black">2046.         ----------</font>
<font color="black">2047.         idx : :class:`int`</font>
<font color="black">2048.             component index (zero-based)</font>
<font color="black">2049. </font>
<font color="black">2050.         Returns</font>
<font color="black">2051.         -------</font>
<font color="black">2052.         : :py:class:`~pyasn1.type.base.PyAsn1Item`</font>
<font color="black">2053.             a PyASN1 object</font>
<font color="black">2054.         &quot;&quot;&quot;</font>
<font color="red">2055.         try:</font>
<font color="red">2056.             return self._componentValues[idx]</font>
<font color="red">2057.         except IndexError:</font>
<font color="red">2058.             if idx &lt; self._componentTypeLen:</font>
<font color="red">2059.                 return</font>
<font color="red">2060.             raise</font>
<font color="black">2061. </font>
<font color="green">2062.     def setComponentByPosition(self, idx, value=noValue,</font>
<font color="green">2063.                                verifyConstraints=True,</font>
<font color="green">2064.                                matchTags=True,</font>
<font color="green">2065.                                matchConstraints=True):</font>
<font color="black">2066.         &quot;&quot;&quot;Assign |ASN.1| type component by position.</font>
<font color="black">2067. </font>
<font color="black">2068.         Equivalent to Python sequence item assignment operation (e.g. `[]`).</font>
<font color="black">2069. </font>
<font color="black">2070.         Parameters</font>
<font color="black">2071.         ----------</font>
<font color="black">2072.         idx : :class:`int`</font>
<font color="black">2073.             |ASN.1| type component index (zero-based)</font>
<font color="black">2074. </font>
<font color="black">2075.         value : :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative</font>
<font color="black">2076.             A Python or pyasn1 object to assign</font>
<font color="black">2077. </font>
<font color="black">2078.         verifyConstraints : :class:`bool`</font>
<font color="black">2079.              If `False`, skip constraints validation</font>
<font color="black">2080. </font>
<font color="black">2081.         matchTags: :class:`bool`</font>
<font color="black">2082.              If `False`, skip component tags matching</font>
<font color="black">2083. </font>
<font color="black">2084.         matchConstraints: :class:`bool`</font>
<font color="black">2085.              If `False`, skip component constraints matching</font>
<font color="black">2086. </font>
<font color="black">2087.         Returns</font>
<font color="black">2088.         -------</font>
<font color="black">2089.         self</font>
<font color="black">2090.         &quot;&quot;&quot;</font>
<font color="red">2091.         if self._componentType:</font>
<font color="red">2092.             componentType = self._componentType.getTypeByPosition(idx)</font>
<font color="black">2093.         else:</font>
<font color="red">2094.             componentType = None</font>
<font color="black">2095. </font>
<font color="red">2096.         componentValuesLength = len(self._componentValues)</font>
<font color="black">2097. </font>
<font color="red">2098.         if idx == componentValuesLength:</font>
<font color="red">2099.             self._componentValues.append(None)</font>
<font color="red">2100.         elif idx &gt; componentValuesLength:</font>
<font color="red">2101.             self._componentValues.extend([None for x in range(idx - componentValuesLength + 1)])</font>
<font color="black">2102. </font>
<font color="red">2103.         if self.isNoValue(value):</font>
<font color="red">2104.             if self._componentValues[idx] is None:</font>
<font color="red">2105.                 if componentType is None:</font>
<font color="red">2106.                     raise error.PyAsn1Error('%s instance value required' % componentType.__class__.__name__)</font>
<font color="red">2107.                 self._componentValues[idx] = componentType.clone()</font>
<font color="red">2108.                 self._componentValuesSet += 1</font>
<font color="red">2109.             return self</font>
<font color="red">2110.         elif not isinstance(value, base.Asn1Item):</font>
<font color="red">2111.             if componentType is None:</font>
<font color="red">2112.                 raise error.PyAsn1Error('Component type not defined')</font>
<font color="red">2113.             if isinstance(componentType, base.AbstractSimpleAsn1Item):</font>
<font color="red">2114.                 value = componentType.clone(value=value)</font>
<font color="black">2115.             else:</font>
<font color="red">2116.                 raise error.PyAsn1Error('%s instance value required' % componentType.__class__.__name__)</font>
<font color="red">2117.         elif componentType is not None:</font>
<font color="red">2118.             if self.strictConstraints:</font>
<font color="red">2119.                 if not componentType.isSameTypeWith(value, matchTags, matchConstraints):</font>
<font color="red">2120.                     raise error.PyAsn1Error('Component value is tag-incompatible: %r vs %r' % (value, componentType))</font>
<font color="black">2121.             else:</font>
<font color="red">2122.                 if not componentType.isSuperTypeOf(value, matchTags, matchConstraints):</font>
<font color="red">2123.                     raise error.PyAsn1Error('Component value is tag-incompatible: %r vs %r' % (value, componentType))</font>
<font color="black">2124. </font>
<font color="red">2125.         if verifyConstraints:</font>
<font color="red">2126.             self._verifySubtypeSpec(value, idx)</font>
<font color="black">2127. </font>
<font color="red">2128.         if self._componentValues[idx] is None:</font>
<font color="red">2129.             self._componentValuesSet += 1</font>
<font color="black">2130. </font>
<font color="red">2131.         self._componentValues[idx] = value</font>
<font color="black">2132. </font>
<font color="red">2133.         return self</font>
<font color="black">2134. </font>
<font color="green">2135.     def getNameByPosition(self, idx):</font>
<font color="red">2136.         if self._componentTypeLen:</font>
<font color="red">2137.             return self._componentType.getNameByPosition(idx)</font>
<font color="black">2138. </font>
<font color="green">2139.     def getDefaultComponentByPosition(self, idx):</font>
<font color="red">2140.         if self._componentTypeLen and self._componentType[idx].isDefaulted:</font>
<font color="red">2141.             return self._componentType[idx].getType()</font>
<font color="black">2142. </font>
<font color="green">2143.     def getComponentType(self):</font>
<font color="red">2144.         if self._componentTypeLen:</font>
<font color="red">2145.             return self._componentType</font>
<font color="black">2146. </font>
<font color="green">2147.     def setDefaultComponents(self):</font>
<font color="black">2148.         &quot;&quot;&quot;Assign default values to all defaulted |ASN.1| type components.</font>
<font color="black">2149. </font>
<font color="black">2150.         Returns</font>
<font color="black">2151.         -------</font>
<font color="black">2152.         self</font>
<font color="black">2153.         &quot;&quot;&quot;</font>
<font color="red">2154.         if self._componentTypeLen == self._componentValuesSet:</font>
<font color="red">2155.             return</font>
<font color="red">2156.         idx = self._componentTypeLen</font>
<font color="red">2157.         while idx:</font>
<font color="red">2158.             idx -= 1</font>
<font color="red">2159.             if self._componentType[idx].isDefaulted:</font>
<font color="red">2160.                 if self.getComponentByPosition(idx) is None:</font>
<font color="red">2161.                     self.setComponentByPosition(idx)</font>
<font color="red">2162.             elif not self._componentType[idx].isOptional:</font>
<font color="red">2163.                 if self.getComponentByPosition(idx) is None:</font>
<font color="red">2164.                     raise error.PyAsn1Error(</font>
<font color="red">2165.                         'Uninitialized component #%s at %r' % (idx, self)</font>
<font color="black">2166.                     )</font>
<font color="red">2167.         return self</font>
<font color="black">2168. </font>
<font color="green">2169.     def prettyPrint(self, scope=0):</font>
<font color="black">2170.         &quot;&quot;&quot;Return an object representation string.</font>
<font color="black">2171. </font>
<font color="black">2172.         Returns</font>
<font color="black">2173.         -------</font>
<font color="black">2174.         : :class:`str`</font>
<font color="black">2175.             Human-friendly object representation.</font>
<font color="black">2176.         &quot;&quot;&quot;</font>
<font color="red">2177.         scope += 1</font>
<font color="red">2178.         r = self.__class__.__name__ + ':\n'</font>
<font color="red">2179.         for idx in range(len(self._componentValues)):</font>
<font color="red">2180.             if self._componentValues[idx] is not None:</font>
<font color="red">2181.                 r += ' ' * scope</font>
<font color="red">2182.                 componentType = self.getComponentType()</font>
<font color="red">2183.                 if componentType is None:</font>
<font color="red">2184.                     r += '&lt;no-name&gt;'</font>
<font color="black">2185.                 else:</font>
<font color="red">2186.                     r = r + componentType.getNameByPosition(idx)</font>
<font color="red">2187.                 r = '%s=%s\n' % (</font>
<font color="red">2188.                     r, self._componentValues[idx].prettyPrint(scope)</font>
<font color="black">2189.                 )</font>
<font color="red">2190.         return r</font>
<font color="black">2191. </font>
<font color="green">2192.     def prettyPrintType(self, scope=0):</font>
<font color="red">2193.         scope += 1</font>
<font color="red">2194.         r = '%s -&gt; %s {\n' % (self.getTagSet(), self.__class__.__name__)</font>
<font color="red">2195.         for idx in range(len(self.componentType)):</font>
<font color="red">2196.             r += ' ' * scope</font>
<font color="red">2197.             r += '&quot;%s&quot;' % self.componentType.getNameByPosition(idx)</font>
<font color="red">2198.             r = '%s = %s\n' % (</font>
<font color="red">2199.                 r, self._componentType.getTypeByPosition(idx).prettyPrintType(scope)</font>
<font color="black">2200.             )</font>
<font color="red">2201.         return r + '\n' + ' ' * (scope - 1) + '}'</font>
<font color="black">2202. </font>
<font color="black">2203. </font>
<font color="green">2204. class Sequence(SequenceAndSetBase):</font>
<font color="green">2205.     __doc__ = SequenceAndSetBase.__doc__</font>
<font color="black">2206. </font>
<font color="black">2207.     #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects</font>
<font color="green">2208.     tagSet = tag.initTagSet(</font>
<font color="green">2209.         tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x10)</font>
<font color="black">2210.     )</font>
<font color="green">2211.     baseTagSet = tagSet</font>
<font color="black">2212. </font>
<font color="black">2213.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">2214.     #: object imposing constraints on |ASN.1| objects</font>
<font color="green">2215.     subtypeSpec = constraint.ConstraintsIntersection()</font>
<font color="black">2216. </font>
<font color="black">2217.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">2218.     #: object imposing constraints on |ASN.1| objects</font>
<font color="green">2219.     sizeSpec = constraint.ConstraintsIntersection()</font>
<font color="black">2220. </font>
<font color="black">2221.     #: Default collection of ASN.1 types of component (e.g. :py:class:`~pyasn1.type.namedtype.NamedType`)</font>
<font color="black">2222.     #: object imposing size constraint on |ASN.1| objects</font>
<font color="green">2223.     componentType = namedtype.NamedTypes()</font>
<font color="black">2224. </font>
<font color="green">2225.     typeId = 3</font>
<font color="black">2226. </font>
<font color="green">2227.     def getComponentTagMapNearPosition(self, idx):</font>
<font color="red">2228.         if self._componentType:</font>
<font color="red">2229.             return self._componentType.getTagMapNearPosition(idx)</font>
<font color="black">2230. </font>
<font color="green">2231.     def getComponentPositionNearType(self, tagSet, idx):</font>
<font color="red">2232.         if self._componentType:</font>
<font color="red">2233.             return self._componentType.getPositionNearType(tagSet, idx)</font>
<font color="black">2234.         else:</font>
<font color="red">2235.             return idx</font>
<font color="black">2236. </font>
<font color="black">2237. </font>
<font color="green">2238. class Set(SequenceAndSetBase):</font>
<font color="green">2239.     __doc__ = SequenceAndSetBase.__doc__</font>
<font color="black">2240. </font>
<font color="black">2241.     #: Default :py:class:`~pyasn1.type.tag.TagSet` object for ASN.1</font>
<font color="black">2242.     #: *Set* objects</font>
<font color="green">2243.     tagSet = tag.initTagSet(</font>
<font color="green">2244.         tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x11)</font>
<font color="black">2245.     )</font>
<font color="green">2246.     baseTagSet = tagSet</font>
<font color="black">2247. </font>
<font color="black">2248.     #: Default collection of ASN.1 types of component (e.g. :py:class:`~pyasn1.type.namedtype.NamedType`)</font>
<font color="black">2249.     #: object representing ASN.1 type allowed within |ASN.1| type</font>
<font color="green">2250.     componentType = namedtype.NamedTypes()</font>
<font color="black">2251. </font>
<font color="black">2252.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">2253.     #: object imposing constraints on |ASN.1| objects</font>
<font color="green">2254.     subtypeSpec = constraint.ConstraintsIntersection()</font>
<font color="black">2255. </font>
<font color="black">2256.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">2257.     #: object imposing constraints on |ASN.1| objects</font>
<font color="green">2258.     sizeSpec = constraint.ConstraintsIntersection()</font>
<font color="black">2259. </font>
<font color="green">2260.     typeId = 4</font>
<font color="black">2261. </font>
<font color="green">2262.     def getComponent(self, innerFlag=False):</font>
<font color="red">2263.         return self</font>
<font color="black">2264. </font>
<font color="green">2265.     def getComponentByType(self, tagSet, innerFlag=False):</font>
<font color="black">2266.         &quot;&quot;&quot;Returns |ASN.1| type component by ASN.1 tag.</font>
<font color="black">2267. </font>
<font color="black">2268.         Parameters</font>
<font color="black">2269.         ----------</font>
<font color="black">2270.         tagSet : :py:class:`~pyasn1.type.tag.TagSet`</font>
<font color="black">2271.             Object representing ASN.1 tags</font>
<font color="black">2272. </font>
<font color="black">2273.         Returns</font>
<font color="black">2274.         -------</font>
<font color="black">2275.         : :py:class:`~pyasn1.type.base.PyAsn1Item`</font>
<font color="black">2276.             a pyasn1 object</font>
<font color="black">2277.         &quot;&quot;&quot;</font>
<font color="red">2278.         component = self.getComponentByPosition(</font>
<font color="red">2279.             self._componentType.getPositionByType(tagSet)</font>
<font color="black">2280.         )</font>
<font color="red">2281.         if innerFlag and isinstance(component, Set):</font>
<font color="black">2282.             # get inner component by inner tagSet</font>
<font color="red">2283.             return component.getComponent(innerFlag=True)</font>
<font color="black">2284.         else:</font>
<font color="black">2285.             # get outer component by inner tagSet</font>
<font color="red">2286.             return component</font>
<font color="black">2287. </font>
<font color="green">2288.     def setComponentByType(self, tagSet, value=noValue,</font>
<font color="green">2289.                            verifyConstraints=True,</font>
<font color="green">2290.                            matchTags=True,</font>
<font color="green">2291.                            matchConstraints=True,</font>
<font color="green">2292.                            innerFlag=False):</font>
<font color="black">2293.         &quot;&quot;&quot;Assign |ASN.1| type component by ASN.1 tag.</font>
<font color="black">2294. </font>
<font color="black">2295.         Parameters</font>
<font color="black">2296.         ----------</font>
<font color="black">2297.         tagSet : :py:class:`~pyasn1.type.tag.TagSet`</font>
<font color="black">2298.            Object representing ASN.1 tags</font>
<font color="black">2299. </font>
<font color="black">2300.         value : :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative</font>
<font color="black">2301.             A Python or pyasn1 object to assign</font>
<font color="black">2302. </font>
<font color="black">2303.         verifyConstraints : :class:`bool`</font>
<font color="black">2304.             If `False`, skip constraints validation</font>
<font color="black">2305. </font>
<font color="black">2306.         matchTags: :class:`bool`</font>
<font color="black">2307.             If `False`, skip component tags matching</font>
<font color="black">2308. </font>
<font color="black">2309.         matchConstraints: :class:`bool`</font>
<font color="black">2310.             If `False`, skip component constraints matching</font>
<font color="black">2311. </font>
<font color="black">2312.         innerFlag: :class:`bool`</font>
<font color="black">2313.             If `True`, search for matching *tagSet* recursively.</font>
<font color="black">2314. </font>
<font color="black">2315.         Returns</font>
<font color="black">2316.         -------</font>
<font color="black">2317.         self</font>
<font color="black">2318.         &quot;&quot;&quot;</font>
<font color="red">2319.         idx = self._componentType.getPositionByType(tagSet)</font>
<font color="black">2320. </font>
<font color="red">2321.         componentType = self._componentType.getTypeByPosition(idx)</font>
<font color="black">2322. </font>
<font color="red">2323.         if innerFlag:  # set inner component by inner tagSet</font>
<font color="red">2324.             if componentType.getTagSet():</font>
<font color="red">2325.                 return self.setComponentByPosition(</font>
<font color="red">2326.                     idx, value, verifyConstraints, matchTags, matchConstraints</font>
<font color="black">2327.                 )</font>
<font color="black">2328.             else:</font>
<font color="red">2329.                 componentType = self.setComponentByPosition(idx).getComponentByPosition(idx)</font>
<font color="red">2330.                 return componentType.setComponentByType(</font>
<font color="red">2331.                     tagSet, value, verifyConstraints, matchTags, matchConstraints, innerFlag=innerFlag</font>
<font color="black">2332.                 )</font>
<font color="black">2333.         else:  # set outer component by inner tagSet</font>
<font color="red">2334.             return self.setComponentByPosition(</font>
<font color="red">2335.                 idx, value, verifyConstraints, matchTags, matchConstraints</font>
<font color="black">2336.             )</font>
<font color="black">2337. </font>
<font color="green">2338.     def getComponentTagMap(self):</font>
<font color="red">2339.         if self._componentType:</font>
<font color="red">2340.             return self._componentType.getTagMap(True)</font>
<font color="black">2341. </font>
<font color="green">2342.     def getComponentPositionByType(self, tagSet):</font>
<font color="red">2343.         if self._componentType:</font>
<font color="red">2344.             return self._componentType.getPositionByType(tagSet)</font>
<font color="black">2345. </font>
<font color="black">2346. </font>
<font color="green">2347. class Choice(Set):</font>
<font color="green">2348.     __doc__ = Set.__doc__</font>
<font color="black">2349. </font>
<font color="black">2350.     #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects (untagged by default)</font>
<font color="green">2351.     tagSet = tag.TagSet()  # untagged</font>
<font color="green">2352.     baseTagSet = tagSet</font>
<font color="black">2353. </font>
<font color="black">2354.     #: Default collection of ASN.1 types of component (e.g. :py:class:`~pyasn1.type.namedtype.NamedType`)</font>
<font color="black">2355.     #: object representing ASN.1 type allowed within |ASN.1| type</font>
<font color="green">2356.     componentType = namedtype.NamedTypes()</font>
<font color="black">2357. </font>
<font color="black">2358.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">2359.     #: object imposing size constraint on |ASN.1| objects</font>
<font color="green">2360.     subtypeSpec = constraint.ConstraintsIntersection()</font>
<font color="black">2361. </font>
<font color="black">2362.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">2363.     #: object imposing size constraint on |ASN.1| objects</font>
<font color="green">2364.     sizeSpec = constraint.ConstraintsIntersection(</font>
<font color="green">2365.         constraint.ValueSizeConstraint(1, 1)</font>
<font color="black">2366.     )</font>
<font color="black">2367. </font>
<font color="green">2368.     typeId = 5</font>
<font color="black">2369. </font>
<font color="green">2370.     _currentIdx = None</font>
<font color="black">2371. </font>
<font color="green">2372.     def __eq__(self, other):</font>
<font color="red">2373.         if self._componentValues:</font>
<font color="red">2374.             return self._componentValues[self._currentIdx] == other</font>
<font color="red">2375.         return NotImplemented</font>
<font color="black">2376. </font>
<font color="green">2377.     def __ne__(self, other):</font>
<font color="red">2378.         if self._componentValues:</font>
<font color="red">2379.             return self._componentValues[self._currentIdx] != other</font>
<font color="red">2380.         return NotImplemented</font>
<font color="black">2381. </font>
<font color="green">2382.     def __lt__(self, other):</font>
<font color="red">2383.         if self._componentValues:</font>
<font color="red">2384.             return self._componentValues[self._currentIdx] &lt; other</font>
<font color="red">2385.         return NotImplemented</font>
<font color="black">2386. </font>
<font color="green">2387.     def __le__(self, other):</font>
<font color="red">2388.         if self._componentValues:</font>
<font color="red">2389.             return self._componentValues[self._currentIdx] &lt;= other</font>
<font color="red">2390.         return NotImplemented</font>
<font color="black">2391. </font>
<font color="green">2392.     def __gt__(self, other):</font>
<font color="red">2393.         if self._componentValues:</font>
<font color="red">2394.             return self._componentValues[self._currentIdx] &gt; other</font>
<font color="red">2395.         return NotImplemented</font>
<font color="black">2396. </font>
<font color="green">2397.     def __ge__(self, other):</font>
<font color="red">2398.         if self._componentValues:</font>
<font color="red">2399.             return self._componentValues[self._currentIdx] &gt;= other</font>
<font color="red">2400.         return NotImplemented</font>
<font color="black">2401. </font>
<font color="green">2402.     if sys.version_info[0] &lt;= 2:</font>
<font color="green">2403.         def __nonzero__(self):</font>
<font color="red">2404.             return bool(self._componentValues)</font>
<font color="black">2405.     else:</font>
<font color="red">2406.         def __bool__(self):</font>
<font color="red">2407.             return bool(self._componentValues)</font>
<font color="black">2408. </font>
<font color="green">2409.     def __len__(self):</font>
<font color="red">2410.         return self._currentIdx is not None and 1 or 0</font>
<font color="black">2411. </font>
<font color="green">2412.     def __contains__(self, key):</font>
<font color="red">2413.         if self._currentIdx is None:</font>
<font color="red">2414.             return False</font>
<font color="red">2415.         return key == self._componentType[self._currentIdx].getName()</font>
<font color="black">2416. </font>
<font color="green">2417.     def __iter__(self):</font>
<font color="red">2418.         if self._currentIdx is None:</font>
<font color="red">2419.             raise StopIteration</font>
<font color="red">2420.         yield self._componentType[self._currentIdx].getName()</font>
<font color="black">2421. </font>
<font color="green">2422.     def verifySizeSpec(self):</font>
<font color="red">2423.         if self._currentIdx is None:</font>
<font color="red">2424.             raise error.PyAsn1Error('Component not chosen')</font>
<font color="black">2425. </font>
<font color="green">2426.     def _cloneComponentValues(self, myClone, cloneValueFlag):</font>
<font color="red">2427.         try:</font>
<font color="red">2428.             c = self.getComponent()</font>
<font color="red">2429.         except error.PyAsn1Error:</font>
<font color="red">2430.             pass</font>
<font color="black">2431.         else:</font>
<font color="red">2432.             if isinstance(c, Choice):</font>
<font color="red">2433.                 tagSet = c.getEffectiveTagSet()</font>
<font color="black">2434.             else:</font>
<font color="red">2435.                 tagSet = c.getTagSet()</font>
<font color="red">2436.             if isinstance(c, base.AbstractConstructedAsn1Item):</font>
<font color="red">2437.                 myClone.setComponentByType(</font>
<font color="red">2438.                     tagSet, c.clone(cloneValueFlag=cloneValueFlag)</font>
<font color="black">2439.                 )</font>
<font color="black">2440.             else:</font>
<font color="red">2441.                 myClone.setComponentByType(tagSet, c.clone())</font>
<font color="black">2442. </font>
<font color="green">2443.     def setComponentByPosition(self, idx, value=noValue,</font>
<font color="green">2444.                                verifyConstraints=True,</font>
<font color="green">2445.                                matchTags=True,</font>
<font color="green">2446.                                matchConstraints=True):</font>
<font color="black">2447.         &quot;&quot;&quot;Assign |ASN.1| type component by position.</font>
<font color="black">2448. </font>
<font color="black">2449.         Equivalent to Python sequence item assignment operation (e.g. `[]`).</font>
<font color="black">2450. </font>
<font color="black">2451.         Parameters</font>
<font color="black">2452.         ----------</font>
<font color="black">2453.         idx : :class:`int`</font>
<font color="black">2454.             component index (zero-based)</font>
<font color="black">2455. </font>
<font color="black">2456.         value : :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative</font>
<font color="black">2457.             A Python or pyasn1 object to assign</font>
<font color="black">2458. </font>
<font color="black">2459.         verifyConstraints : :class:`bool`</font>
<font color="black">2460.             If `False`, skip constraints validation</font>
<font color="black">2461. </font>
<font color="black">2462.         matchTags: :class:`bool`</font>
<font color="black">2463.             If `False`, skip component tags matching</font>
<font color="black">2464. </font>
<font color="black">2465.         matchConstraints: :class:`bool`</font>
<font color="black">2466.             If `False`, skip component constraints matching</font>
<font color="black">2467. </font>
<font color="black">2468.         Returns</font>
<font color="black">2469.         -------</font>
<font color="black">2470.         self</font>
<font color="black">2471.         &quot;&quot;&quot;</font>
<font color="red">2472.         componentType = self._componentType.getTypeByPosition(idx)</font>
<font color="black">2473. </font>
<font color="red">2474.         componentValuesLength = len(self._componentValues)</font>
<font color="black">2475. </font>
<font color="red">2476.         if idx == componentValuesLength:</font>
<font color="red">2477.             self._componentValues.append(None)</font>
<font color="red">2478.         elif idx &gt; componentValuesLength:</font>
<font color="red">2479.             self._componentValues.extend([None for x in range(idx - componentValuesLength + 1)])</font>
<font color="black">2480. </font>
<font color="red">2481.         if self._currentIdx is not None:</font>
<font color="red">2482.             self._componentValues[self._currentIdx] = None</font>
<font color="black">2483. </font>
<font color="red">2484.         if self.isNoValue(value):</font>
<font color="red">2485.             if self._componentValues[idx] is None:</font>
<font color="red">2486.                 self._componentValues[idx] = self._componentType.getTypeByPosition(idx).clone()</font>
<font color="red">2487.                 self._componentValuesSet = 1</font>
<font color="red">2488.                 self._currentIdx = idx</font>
<font color="red">2489.             return self</font>
<font color="red">2490.         elif not isinstance(value, base.Asn1Item):</font>
<font color="red">2491.             value = self._componentType.getTypeByPosition(idx).clone(value=value)</font>
<font color="red">2492.         elif self.strictConstraints:</font>
<font color="red">2493.             if not componentType.isSameTypeWith(value, matchTags, matchConstraints):</font>
<font color="red">2494.                 raise error.PyAsn1Error('Component value is tag-incompatible: %r vs %r' % (value, componentType))</font>
<font color="black">2495.         else:</font>
<font color="red">2496.             if not componentType.isSuperTypeOf(value, matchTags, matchConstraints):</font>
<font color="red">2497.                 raise error.PyAsn1Error('Component value is tag-incompatible: %r vs %r' % (value, componentType))</font>
<font color="black">2498. </font>
<font color="red">2499.         if verifyConstraints:</font>
<font color="red">2500.             self._verifySubtypeSpec(value, idx)</font>
<font color="black">2501. </font>
<font color="red">2502.         self._componentValues[idx] = value</font>
<font color="red">2503.         self._currentIdx = idx</font>
<font color="red">2504.         self._componentValuesSet = 1</font>
<font color="black">2505. </font>
<font color="red">2506.         return self</font>
<font color="black">2507. </font>
<font color="green">2508.     def getMinTagSet(self):</font>
<font color="red">2509.         if self._tagSet:</font>
<font color="red">2510.             return self._tagSet</font>
<font color="black">2511.         else:</font>
<font color="red">2512.             return self._componentType.genMinTagSet()</font>
<font color="black">2513. </font>
<font color="green">2514.     def getEffectiveTagSet(self):</font>
<font color="red">2515.         if self._tagSet:</font>
<font color="red">2516.             return self._tagSet</font>
<font color="black">2517.         else:</font>
<font color="red">2518.             c = self.getComponent()</font>
<font color="red">2519.             if isinstance(c, Choice):</font>
<font color="red">2520.                 return c.getEffectiveTagSet()</font>
<font color="black">2521.             else:</font>
<font color="red">2522.                 return c.getTagSet()</font>
<font color="black">2523. </font>
<font color="green">2524.     def getTagMap(self):</font>
<font color="red">2525.         if self._tagSet:</font>
<font color="red">2526.             return Set.getTagMap(self)</font>
<font color="black">2527.         else:</font>
<font color="red">2528.             return Set.getComponentTagMap(self)</font>
<font color="black">2529. </font>
<font color="green">2530.     def getComponent(self, innerFlag=0):</font>
<font color="black">2531.         &quot;&quot;&quot;Return currently assigned component of the |ASN.1| object.</font>
<font color="black">2532. </font>
<font color="black">2533.         Returns</font>
<font color="black">2534.         -------</font>
<font color="black">2535.         : :py:class:`~pyasn1.type.base.PyAsn1Item`</font>
<font color="black">2536.             a PyASN1 object</font>
<font color="black">2537.         &quot;&quot;&quot;</font>
<font color="red">2538.         if self._currentIdx is None:</font>
<font color="red">2539.             raise error.PyAsn1Error('Component not chosen')</font>
<font color="black">2540.         else:</font>
<font color="red">2541.             c = self._componentValues[self._currentIdx]</font>
<font color="red">2542.             if innerFlag and isinstance(c, Choice):</font>
<font color="red">2543.                 return c.getComponent(innerFlag)</font>
<font color="black">2544.             else:</font>
<font color="red">2545.                 return c</font>
<font color="black">2546. </font>
<font color="green">2547.     def getName(self, innerFlag=False):</font>
<font color="black">2548.         &quot;&quot;&quot;Return the name of currently assigned component of the |ASN.1| object.</font>
<font color="black">2549. </font>
<font color="black">2550.         Returns</font>
<font color="black">2551.         -------</font>
<font color="black">2552.         : :py:class:`str`</font>
<font color="black">2553.             |ASN.1| component name</font>
<font color="black">2554.         &quot;&quot;&quot;</font>
<font color="red">2555.         if self._currentIdx is None:</font>
<font color="red">2556.             raise error.PyAsn1Error('Component not chosen')</font>
<font color="black">2557.         else:</font>
<font color="red">2558.             if innerFlag:</font>
<font color="red">2559.                 c = self._componentValues[self._currentIdx]</font>
<font color="red">2560.                 if isinstance(c, Choice):</font>
<font color="red">2561.                     return c.getName(innerFlag)</font>
<font color="red">2562.             return self._componentType.getNameByPosition(self._currentIdx)</font>
<font color="black">2563. </font>
<font color="green">2564.     def setDefaultComponents(self):</font>
<font color="red">2565.         pass</font>
<font color="black">2566. </font>
<font color="black">2567. </font>
<font color="green">2568. class Any(OctetString):</font>
<font color="green">2569.     __doc__ = OctetString.__doc__</font>
<font color="black">2570. </font>
<font color="black">2571.     #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects (untagged by default)</font>
<font color="green">2572.     tagSet = tag.TagSet()  # untagged</font>
<font color="green">2573.     baseTagSet = tagSet</font>
<font color="green">2574.     typeId = 6</font>
<font color="black">2575. </font>
<font color="black">2576.     #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`</font>
<font color="black">2577.     #: object imposing constraints on initialization values.</font>
<font color="green">2578.     subtypeSpec = constraint.ConstraintsIntersection()</font>
<font color="black">2579. </font>
<font color="green">2580.     def getTagMap(self):</font>
<font color="red">2581.         return tagmap.TagMap(</font>
<font color="red">2582.             {self.getTagSet(): self},</font>
<font color="red">2583.             {eoo.endOfOctets.getTagSet(): eoo.endOfOctets},</font>
<font color="red">2584.             self</font>
<font color="black">2585.         )</font>
<font color="black">2586. </font>
<font color="black">2587. # XXX</font>
<font color="black">2588. # coercion rules?</font>
</pre>

