source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/simplejson/encoder.py</b><br>


file stats: <b>446 lines, 85 executed: 19.1% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;Implementation of JSONEncoder</font>
<font color="green">   2. &quot;&quot;&quot;</font>
<font color="green">   3. from __future__ import absolute_import</font>
<font color="green">   4. import re</font>
<font color="green">   5. from operator import itemgetter</font>
<font color="black">   6. # Do not import Decimal directly to avoid reload issues</font>
<font color="green">   7. import decimal</font>
<font color="green">   8. from .compat import u, unichr, binary_type, text_type, string_types, integer_types, PY3</font>
<font color="green">   9. def _import_speedups():</font>
<font color="green">  10.     try:</font>
<font color="green">  11.         from . import _speedups</font>
<font color="green">  12.         return _speedups.encode_basestring_ascii, _speedups.make_encoder</font>
<font color="red">  13.     except ImportError:</font>
<font color="red">  14.         return None, None</font>
<font color="green">  15. c_encode_basestring_ascii, c_make_encoder = _import_speedups()</font>
<font color="black">  16. </font>
<font color="green">  17. from simplejson.decoder import PosInf</font>
<font color="black">  18. </font>
<font color="black">  19. #ESCAPE = re.compile(ur'[\x00-\x1f\\&quot;\b\f\n\r\t\u2028\u2029]')</font>
<font color="black">  20. # This is required because u() will mangle the string and ur'' isn't valid</font>
<font color="black">  21. # python3 syntax</font>
<font color="green">  22. ESCAPE = re.compile(u'[\\x00-\\x1f\\\\&quot;\\b\\f\\n\\r\\t\u2028\u2029]')</font>
<font color="green">  23. ESCAPE_ASCII = re.compile(r'([\\&quot;]|[^\ -~])')</font>
<font color="green">  24. HAS_UTF8 = re.compile(r'[\x80-\xff]')</font>
<font color="green">  25. ESCAPE_DCT = {</font>
<font color="green">  26.     '\\': '\\\\',</font>
<font color="green">  27.     '&quot;': '\\&quot;',</font>
<font color="green">  28.     '\b': '\\b',</font>
<font color="green">  29.     '\f': '\\f',</font>
<font color="green">  30.     '\n': '\\n',</font>
<font color="green">  31.     '\r': '\\r',</font>
<font color="green">  32.     '\t': '\\t',</font>
<font color="black">  33. }</font>
<font color="green">  34. for i in range(0x20):</font>
<font color="black">  35.     #ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))</font>
<font color="green">  36.     ESCAPE_DCT.setdefault(chr(i), '\\u%04x' % (i,))</font>
<font color="green">  37. for i in [0x2028, 0x2029]:</font>
<font color="green">  38.     ESCAPE_DCT.setdefault(unichr(i), '\\u%04x' % (i,))</font>
<font color="black">  39. </font>
<font color="green">  40. FLOAT_REPR = repr</font>
<font color="black">  41. </font>
<font color="green">  42. class RawJSON(object):</font>
<font color="black">  43.     &quot;&quot;&quot;Wrap an encoded JSON document for direct embedding in the output</font>
<font color="black">  44. </font>
<font color="green">  45.     &quot;&quot;&quot;</font>
<font color="green">  46.     def __init__(self, encoded_json):</font>
<font color="red">  47.         self.encoded_json = encoded_json</font>
<font color="black">  48. </font>
<font color="black">  49. </font>
<font color="green">  50. def encode_basestring(s, _PY3=PY3, _q=u('&quot;')):</font>
<font color="black">  51.     &quot;&quot;&quot;Return a JSON representation of a Python string</font>
<font color="black">  52. </font>
<font color="black">  53.     &quot;&quot;&quot;</font>
<font color="red">  54.     if _PY3:</font>
<font color="red">  55.         if isinstance(s, binary_type):</font>
<font color="red">  56.             s = s.decode('utf-8')</font>
<font color="red">  57.         if type(s) is not text_type:</font>
<font color="red">  58.             s = text_type(s)</font>
<font color="black">  59.     else:</font>
<font color="red">  60.         if isinstance(s, str) and HAS_UTF8.search(s) is not None:</font>
<font color="red">  61.             s = s.decode('utf-8')</font>
<font color="red">  62.         if type(s) not in string_types:</font>
<font color="red">  63.             s = text_type(s)</font>
<font color="red">  64.     def replace(match):</font>
<font color="red">  65.         return ESCAPE_DCT[match.group(0)]</font>
<font color="red">  66.     return _q + ESCAPE.sub(replace, s) + _q</font>
<font color="black">  67. </font>
<font color="black">  68. </font>
<font color="green">  69. def py_encode_basestring_ascii(s, _PY3=PY3):</font>
<font color="black">  70.     &quot;&quot;&quot;Return an ASCII-only JSON representation of a Python string</font>
<font color="black">  71. </font>
<font color="black">  72.     &quot;&quot;&quot;</font>
<font color="red">  73.     if _PY3:</font>
<font color="red">  74.         if isinstance(s, binary_type):</font>
<font color="red">  75.             s = s.decode('utf-8')</font>
<font color="red">  76.         if type(s) is not text_type:</font>
<font color="red">  77.             s = text_type(s)</font>
<font color="black">  78.     else:</font>
<font color="red">  79.         if isinstance(s, str) and HAS_UTF8.search(s) is not None:</font>
<font color="red">  80.             s = s.decode('utf-8')</font>
<font color="red">  81.         if type(s) not in string_types:</font>
<font color="red">  82.             s = text_type(s)</font>
<font color="red">  83.     def replace(match):</font>
<font color="red">  84.         s = match.group(0)</font>
<font color="red">  85.         try:</font>
<font color="red">  86.             return ESCAPE_DCT[s]</font>
<font color="red">  87.         except KeyError:</font>
<font color="red">  88.             n = ord(s)</font>
<font color="red">  89.             if n &lt; 0x10000:</font>
<font color="black">  90.                 #return '\\u{0:04x}'.format(n)</font>
<font color="red">  91.                 return '\\u%04x' % (n,)</font>
<font color="black">  92.             else:</font>
<font color="black">  93.                 # surrogate pair</font>
<font color="red">  94.                 n -= 0x10000</font>
<font color="red">  95.                 s1 = 0xd800 | ((n &gt;&gt; 10) &amp; 0x3ff)</font>
<font color="red">  96.                 s2 = 0xdc00 | (n &amp; 0x3ff)</font>
<font color="black">  97.                 #return '\\u{0:04x}\\u{1:04x}'.format(s1, s2)</font>
<font color="red">  98.                 return '\\u%04x\\u%04x' % (s1, s2)</font>
<font color="red">  99.     return '&quot;' + str(ESCAPE_ASCII.sub(replace, s)) + '&quot;'</font>
<font color="black"> 100. </font>
<font color="black"> 101. </font>
<font color="black"> 102. encode_basestring_ascii = (</font>
<font color="green"> 103.     c_encode_basestring_ascii or py_encode_basestring_ascii)</font>
<font color="black"> 104. </font>
<font color="green"> 105. class JSONEncoder(object):</font>
<font color="black"> 106.     &quot;&quot;&quot;Extensible JSON &lt;http://json.org&gt; encoder for Python data structures.</font>
<font color="black"> 107. </font>
<font color="black"> 108.     Supports the following objects and types by default:</font>
<font color="black"> 109. </font>
<font color="black"> 110.     +-------------------+---------------+</font>
<font color="black"> 111.     | Python            | JSON          |</font>
<font color="black"> 112.     +===================+===============+</font>
<font color="black"> 113.     | dict, namedtuple  | object        |</font>
<font color="black"> 114.     +-------------------+---------------+</font>
<font color="black"> 115.     | list, tuple       | array         |</font>
<font color="black"> 116.     +-------------------+---------------+</font>
<font color="black"> 117.     | str, unicode      | string        |</font>
<font color="black"> 118.     +-------------------+---------------+</font>
<font color="black"> 119.     | int, long, float  | number        |</font>
<font color="black"> 120.     +-------------------+---------------+</font>
<font color="black"> 121.     | True              | true          |</font>
<font color="black"> 122.     +-------------------+---------------+</font>
<font color="black"> 123.     | False             | false         |</font>
<font color="black"> 124.     +-------------------+---------------+</font>
<font color="black"> 125.     | None              | null          |</font>
<font color="black"> 126.     +-------------------+---------------+</font>
<font color="black"> 127. </font>
<font color="black"> 128.     To extend this to recognize other objects, subclass and implement a</font>
<font color="black"> 129.     ``.default()`` method with another method that returns a serializable</font>
<font color="black"> 130.     object for ``o`` if possible, otherwise it should call the superclass</font>
<font color="black"> 131.     implementation (to raise ``TypeError``).</font>
<font color="black"> 132. </font>
<font color="green"> 133.     &quot;&quot;&quot;</font>
<font color="green"> 134.     item_separator = ', '</font>
<font color="green"> 135.     key_separator = ': '</font>
<font color="black"> 136. </font>
<font color="green"> 137.     def __init__(self, skipkeys=False, ensure_ascii=True,</font>
<font color="green"> 138.                  check_circular=True, allow_nan=True, sort_keys=False,</font>
<font color="green"> 139.                  indent=None, separators=None, encoding='utf-8', default=None,</font>
<font color="green"> 140.                  use_decimal=True, namedtuple_as_object=True,</font>
<font color="green"> 141.                  tuple_as_array=True, bigint_as_string=False,</font>
<font color="green"> 142.                  item_sort_key=None, for_json=False, ignore_nan=False,</font>
<font color="green"> 143.                  int_as_string_bitcount=None, iterable_as_array=False):</font>
<font color="black"> 144.         &quot;&quot;&quot;Constructor for JSONEncoder, with sensible defaults.</font>
<font color="black"> 145. </font>
<font color="black"> 146.         If skipkeys is false, then it is a TypeError to attempt</font>
<font color="black"> 147.         encoding of keys that are not str, int, long, float or None.  If</font>
<font color="black"> 148.         skipkeys is True, such items are simply skipped.</font>
<font color="black"> 149. </font>
<font color="black"> 150.         If ensure_ascii is true, the output is guaranteed to be str</font>
<font color="black"> 151.         objects with all incoming unicode characters escaped.  If</font>
<font color="black"> 152.         ensure_ascii is false, the output will be unicode object.</font>
<font color="black"> 153. </font>
<font color="black"> 154.         If check_circular is true, then lists, dicts, and custom encoded</font>
<font color="black"> 155.         objects will be checked for circular references during encoding to</font>
<font color="black"> 156.         prevent an infinite recursion (which would cause an OverflowError).</font>
<font color="black"> 157.         Otherwise, no such check takes place.</font>
<font color="black"> 158. </font>
<font color="black"> 159.         If allow_nan is true, then NaN, Infinity, and -Infinity will be</font>
<font color="black"> 160.         encoded as such.  This behavior is not JSON specification compliant,</font>
<font color="black"> 161.         but is consistent with most JavaScript based encoders and decoders.</font>
<font color="black"> 162.         Otherwise, it will be a ValueError to encode such floats.</font>
<font color="black"> 163. </font>
<font color="black"> 164.         If sort_keys is true, then the output of dictionaries will be</font>
<font color="black"> 165.         sorted by key; this is useful for regression tests to ensure</font>
<font color="black"> 166.         that JSON serializations can be compared on a day-to-day basis.</font>
<font color="black"> 167. </font>
<font color="black"> 168.         If indent is a string, then JSON array elements and object members</font>
<font color="black"> 169.         will be pretty-printed with a newline followed by that string repeated</font>
<font color="black"> 170.         for each level of nesting. ``None`` (the default) selects the most compact</font>
<font color="black"> 171.         representation without any newlines. For backwards compatibility with</font>
<font color="black"> 172.         versions of simplejson earlier than 2.1.0, an integer is also accepted</font>
<font color="black"> 173.         and is converted to a string with that many spaces.</font>
<font color="black"> 174. </font>
<font color="black"> 175.         If specified, separators should be an (item_separator, key_separator)</font>
<font color="black"> 176.         tuple.  The default is (', ', ': ') if *indent* is ``None`` and</font>
<font color="black"> 177.         (',', ': ') otherwise.  To get the most compact JSON representation,</font>
<font color="black"> 178.         you should specify (',', ':') to eliminate whitespace.</font>
<font color="black"> 179. </font>
<font color="black"> 180.         If specified, default is a function that gets called for objects</font>
<font color="black"> 181.         that can't otherwise be serialized.  It should return a JSON encodable</font>
<font color="black"> 182.         version of the object or raise a ``TypeError``.</font>
<font color="black"> 183. </font>
<font color="black"> 184.         If encoding is not None, then all input strings will be</font>
<font color="black"> 185.         transformed into unicode using that encoding prior to JSON-encoding.</font>
<font color="black"> 186.         The default is UTF-8.</font>
<font color="black"> 187. </font>
<font color="black"> 188.         If use_decimal is true (not the default), ``decimal.Decimal`` will</font>
<font color="black"> 189.         be supported directly by the encoder. For the inverse, decode JSON</font>
<font color="black"> 190.         with ``parse_float=decimal.Decimal``.</font>
<font color="black"> 191. </font>
<font color="black"> 192.         If namedtuple_as_object is true (the default), objects with</font>
<font color="black"> 193.         ``_asdict()`` methods will be encoded as JSON objects.</font>
<font color="black"> 194. </font>
<font color="black"> 195.         If tuple_as_array is true (the default), tuple (and subclasses) will</font>
<font color="black"> 196.         be encoded as JSON arrays.</font>
<font color="black"> 197. </font>
<font color="black"> 198.         If *iterable_as_array* is true (default: ``False``),</font>
<font color="black"> 199.         any object not in the above table that implements ``__iter__()``</font>
<font color="black"> 200.         will be encoded as a JSON array.</font>
<font color="black"> 201. </font>
<font color="black"> 202.         If bigint_as_string is true (not the default), ints 2**53 and higher</font>
<font color="black"> 203.         or lower than -2**53 will be encoded as strings. This is to avoid the</font>
<font color="black"> 204.         rounding that happens in Javascript otherwise.</font>
<font color="black"> 205. </font>
<font color="black"> 206.         If int_as_string_bitcount is a positive number (n), then int of size</font>
<font color="black"> 207.         greater than or equal to 2**n or lower than or equal to -2**n will be</font>
<font color="black"> 208.         encoded as strings.</font>
<font color="black"> 209. </font>
<font color="black"> 210.         If specified, item_sort_key is a callable used to sort the items in</font>
<font color="black"> 211.         each dictionary. This is useful if you want to sort items other than</font>
<font color="black"> 212.         in alphabetical order by key.</font>
<font color="black"> 213. </font>
<font color="black"> 214.         If for_json is true (not the default), objects with a ``for_json()``</font>
<font color="black"> 215.         method will use the return value of that method for encoding as JSON</font>
<font color="black"> 216.         instead of the object.</font>
<font color="black"> 217. </font>
<font color="black"> 218.         If *ignore_nan* is true (default: ``False``), then out of range</font>
<font color="black"> 219.         :class:`float` values (``nan``, ``inf``, ``-inf``) will be serialized</font>
<font color="black"> 220.         as ``null`` in compliance with the ECMA-262 specification. If true,</font>
<font color="black"> 221.         this will override *allow_nan*.</font>
<font color="black"> 222. </font>
<font color="black"> 223.         &quot;&quot;&quot;</font>
<font color="black"> 224. </font>
<font color="green"> 225.         self.skipkeys = skipkeys</font>
<font color="green"> 226.         self.ensure_ascii = ensure_ascii</font>
<font color="green"> 227.         self.check_circular = check_circular</font>
<font color="green"> 228.         self.allow_nan = allow_nan</font>
<font color="green"> 229.         self.sort_keys = sort_keys</font>
<font color="green"> 230.         self.use_decimal = use_decimal</font>
<font color="green"> 231.         self.namedtuple_as_object = namedtuple_as_object</font>
<font color="green"> 232.         self.tuple_as_array = tuple_as_array</font>
<font color="green"> 233.         self.iterable_as_array = iterable_as_array</font>
<font color="green"> 234.         self.bigint_as_string = bigint_as_string</font>
<font color="green"> 235.         self.item_sort_key = item_sort_key</font>
<font color="green"> 236.         self.for_json = for_json</font>
<font color="green"> 237.         self.ignore_nan = ignore_nan</font>
<font color="green"> 238.         self.int_as_string_bitcount = int_as_string_bitcount</font>
<font color="green"> 239.         if indent is not None and not isinstance(indent, string_types):</font>
<font color="red"> 240.             indent = indent * ' '</font>
<font color="green"> 241.         self.indent = indent</font>
<font color="green"> 242.         if separators is not None:</font>
<font color="red"> 243.             self.item_separator, self.key_separator = separators</font>
<font color="green"> 244.         elif indent is not None:</font>
<font color="red"> 245.             self.item_separator = ','</font>
<font color="green"> 246.         if default is not None:</font>
<font color="red"> 247.             self.default = default</font>
<font color="green"> 248.         self.encoding = encoding</font>
<font color="black"> 249. </font>
<font color="green"> 250.     def default(self, o):</font>
<font color="black"> 251.         &quot;&quot;&quot;Implement this method in a subclass such that it returns</font>
<font color="black"> 252.         a serializable object for ``o``, or calls the base implementation</font>
<font color="black"> 253.         (to raise a ``TypeError``).</font>
<font color="black"> 254. </font>
<font color="black"> 255.         For example, to support arbitrary iterators, you could</font>
<font color="black"> 256.         implement default like this::</font>
<font color="black"> 257. </font>
<font color="black"> 258.             def default(self, o):</font>
<font color="black"> 259.                 try:</font>
<font color="black"> 260.                     iterable = iter(o)</font>
<font color="black"> 261.                 except TypeError:</font>
<font color="black"> 262.                     pass</font>
<font color="black"> 263.                 else:</font>
<font color="black"> 264.                     return list(iterable)</font>
<font color="black"> 265.                 return JSONEncoder.default(self, o)</font>
<font color="black"> 266. </font>
<font color="black"> 267.         &quot;&quot;&quot;</font>
<font color="red"> 268.         raise TypeError(repr(o) + &quot; is not JSON serializable&quot;)</font>
<font color="black"> 269. </font>
<font color="green"> 270.     def encode(self, o):</font>
<font color="black"> 271.         &quot;&quot;&quot;Return a JSON string representation of a Python data structure.</font>
<font color="black"> 272. </font>
<font color="black"> 273.         &gt;&gt;&gt; from simplejson import JSONEncoder</font>
<font color="black"> 274.         &gt;&gt;&gt; JSONEncoder().encode({&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]})</font>
<font color="black"> 275.         '{&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]}'</font>
<font color="black"> 276. </font>
<font color="black"> 277.         &quot;&quot;&quot;</font>
<font color="black"> 278.         # This is for extremely simple cases and benchmarks.</font>
<font color="red"> 279.         if isinstance(o, binary_type):</font>
<font color="red"> 280.             _encoding = self.encoding</font>
<font color="red"> 281.             if (_encoding is not None and not (_encoding == 'utf-8')):</font>
<font color="red"> 282.                 o = o.decode(_encoding)</font>
<font color="red"> 283.         if isinstance(o, string_types):</font>
<font color="red"> 284.             if self.ensure_ascii:</font>
<font color="red"> 285.                 return encode_basestring_ascii(o)</font>
<font color="black"> 286.             else:</font>
<font color="red"> 287.                 return encode_basestring(o)</font>
<font color="black"> 288.         # This doesn't pass the iterator directly to ''.join() because the</font>
<font color="black"> 289.         # exceptions aren't as detailed.  The list call should be roughly</font>
<font color="black"> 290.         # equivalent to the PySequence_Fast that ''.join() would do.</font>
<font color="red"> 291.         chunks = self.iterencode(o, _one_shot=True)</font>
<font color="red"> 292.         if not isinstance(chunks, (list, tuple)):</font>
<font color="red"> 293.             chunks = list(chunks)</font>
<font color="red"> 294.         if self.ensure_ascii:</font>
<font color="red"> 295.             return ''.join(chunks)</font>
<font color="black"> 296.         else:</font>
<font color="red"> 297.             return u''.join(chunks)</font>
<font color="black"> 298. </font>
<font color="green"> 299.     def iterencode(self, o, _one_shot=False):</font>
<font color="black"> 300.         &quot;&quot;&quot;Encode the given object and yield each string</font>
<font color="black"> 301.         representation as available.</font>
<font color="black"> 302. </font>
<font color="black"> 303.         For example::</font>
<font color="black"> 304. </font>
<font color="black"> 305.             for chunk in JSONEncoder().iterencode(bigobject):</font>
<font color="black"> 306.                 mysocket.write(chunk)</font>
<font color="black"> 307. </font>
<font color="black"> 308.         &quot;&quot;&quot;</font>
<font color="red"> 309.         if self.check_circular:</font>
<font color="red"> 310.             markers = {}</font>
<font color="black"> 311.         else:</font>
<font color="red"> 312.             markers = None</font>
<font color="red"> 313.         if self.ensure_ascii:</font>
<font color="red"> 314.             _encoder = encode_basestring_ascii</font>
<font color="black"> 315.         else:</font>
<font color="red"> 316.             _encoder = encode_basestring</font>
<font color="red"> 317.         if self.encoding != 'utf-8':</font>
<font color="red"> 318.             def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):</font>
<font color="red"> 319.                 if isinstance(o, binary_type):</font>
<font color="red"> 320.                     o = o.decode(_encoding)</font>
<font color="red"> 321.                 return _orig_encoder(o)</font>
<font color="black"> 322. </font>
<font color="red"> 323.         def floatstr(o, allow_nan=self.allow_nan, ignore_nan=self.ignore_nan,</font>
<font color="red"> 324.                 _repr=FLOAT_REPR, _inf=PosInf, _neginf=-PosInf):</font>
<font color="black"> 325.             # Check for specials. Note that this type of test is processor</font>
<font color="black"> 326.             # and/or platform-specific, so do tests which don't depend on</font>
<font color="black"> 327.             # the internals.</font>
<font color="black"> 328. </font>
<font color="red"> 329.             if o != o:</font>
<font color="red"> 330.                 text = 'NaN'</font>
<font color="red"> 331.             elif o == _inf:</font>
<font color="red"> 332.                 text = 'Infinity'</font>
<font color="red"> 333.             elif o == _neginf:</font>
<font color="red"> 334.                 text = '-Infinity'</font>
<font color="black"> 335.             else:</font>
<font color="red"> 336.                 if type(o) != float:</font>
<font color="black"> 337.                     # See #118, do not trust custom str/repr</font>
<font color="red"> 338.                     o = float(o)</font>
<font color="red"> 339.                 return _repr(o)</font>
<font color="black"> 340. </font>
<font color="red"> 341.             if ignore_nan:</font>
<font color="red"> 342.                 text = 'null'</font>
<font color="red"> 343.             elif not allow_nan:</font>
<font color="red"> 344.                 raise ValueError(</font>
<font color="red"> 345.                     &quot;Out of range float values are not JSON compliant: &quot; +</font>
<font color="red"> 346.                     repr(o))</font>
<font color="black"> 347. </font>
<font color="red"> 348.             return text</font>
<font color="black"> 349. </font>
<font color="red"> 350.         key_memo = {}</font>
<font color="black"> 351.         int_as_string_bitcount = (</font>
<font color="red"> 352.             53 if self.bigint_as_string else self.int_as_string_bitcount)</font>
<font color="red"> 353.         if (_one_shot and c_make_encoder is not None</font>
<font color="red"> 354.                 and self.indent is None):</font>
<font color="red"> 355.             _iterencode = c_make_encoder(</font>
<font color="red"> 356.                 markers, self.default, _encoder, self.indent,</font>
<font color="red"> 357.                 self.key_separator, self.item_separator, self.sort_keys,</font>
<font color="red"> 358.                 self.skipkeys, self.allow_nan, key_memo, self.use_decimal,</font>
<font color="red"> 359.                 self.namedtuple_as_object, self.tuple_as_array,</font>
<font color="red"> 360.                 int_as_string_bitcount,</font>
<font color="red"> 361.                 self.item_sort_key, self.encoding, self.for_json,</font>
<font color="red"> 362.                 self.ignore_nan, decimal.Decimal, self.iterable_as_array)</font>
<font color="black"> 363.         else:</font>
<font color="red"> 364.             _iterencode = _make_iterencode(</font>
<font color="red"> 365.                 markers, self.default, _encoder, self.indent, floatstr,</font>
<font color="red"> 366.                 self.key_separator, self.item_separator, self.sort_keys,</font>
<font color="red"> 367.                 self.skipkeys, _one_shot, self.use_decimal,</font>
<font color="red"> 368.                 self.namedtuple_as_object, self.tuple_as_array,</font>
<font color="red"> 369.                 int_as_string_bitcount,</font>
<font color="red"> 370.                 self.item_sort_key, self.encoding, self.for_json,</font>
<font color="red"> 371.                 self.iterable_as_array, Decimal=decimal.Decimal)</font>
<font color="red"> 372.         try:</font>
<font color="red"> 373.             return _iterencode(o, 0)</font>
<font color="black"> 374.         finally:</font>
<font color="red"> 375.             key_memo.clear()</font>
<font color="black"> 376. </font>
<font color="black"> 377. </font>
<font color="green"> 378. class JSONEncoderForHTML(JSONEncoder):</font>
<font color="black"> 379.     &quot;&quot;&quot;An encoder that produces JSON safe to embed in HTML.</font>
<font color="black"> 380. </font>
<font color="black"> 381.     To embed JSON content in, say, a script tag on a web page, the</font>
<font color="black"> 382.     characters &amp;, &lt; and &gt; should be escaped. They cannot be escaped</font>
<font color="black"> 383.     with the usual entities (e.g. &amp;amp;) because they are not expanded</font>
<font color="black"> 384.     within &lt;script&gt; tags.</font>
<font color="green"> 385.     &quot;&quot;&quot;</font>
<font color="black"> 386. </font>
<font color="green"> 387.     def encode(self, o):</font>
<font color="black"> 388.         # Override JSONEncoder.encode because it has hacks for</font>
<font color="black"> 389.         # performance that make things more complicated.</font>
<font color="red"> 390.         chunks = self.iterencode(o, True)</font>
<font color="red"> 391.         if self.ensure_ascii:</font>
<font color="red"> 392.             return ''.join(chunks)</font>
<font color="black"> 393.         else:</font>
<font color="red"> 394.             return u''.join(chunks)</font>
<font color="black"> 395. </font>
<font color="green"> 396.     def iterencode(self, o, _one_shot=False):</font>
<font color="red"> 397.         chunks = super(JSONEncoderForHTML, self).iterencode(o, _one_shot)</font>
<font color="red"> 398.         for chunk in chunks:</font>
<font color="red"> 399.             chunk = chunk.replace('&amp;', '\\u0026')</font>
<font color="red"> 400.             chunk = chunk.replace('&lt;', '\\u003c')</font>
<font color="red"> 401.             chunk = chunk.replace('&gt;', '\\u003e')</font>
<font color="red"> 402.             yield chunk</font>
<font color="black"> 403. </font>
<font color="black"> 404. </font>
<font color="black"> 405. def _make_iterencode(markers, _default, _encoder, _indent, _floatstr,</font>
<font color="black"> 406.         _key_separator, _item_separator, _sort_keys, _skipkeys, _one_shot,</font>
<font color="black"> 407.         _use_decimal, _namedtuple_as_object, _tuple_as_array,</font>
<font color="black"> 408.         _int_as_string_bitcount, _item_sort_key,</font>
<font color="black"> 409.         _encoding,_for_json,</font>
<font color="black"> 410.         _iterable_as_array,</font>
<font color="black"> 411.         ## HACK: hand-optimized bytecode; turn globals into locals</font>
<font color="green"> 412.         _PY3=PY3,</font>
<font color="green"> 413.         ValueError=ValueError,</font>
<font color="green"> 414.         string_types=string_types,</font>
<font color="green"> 415.         Decimal=None,</font>
<font color="green"> 416.         dict=dict,</font>
<font color="green"> 417.         float=float,</font>
<font color="green"> 418.         id=id,</font>
<font color="green"> 419.         integer_types=integer_types,</font>
<font color="green"> 420.         isinstance=isinstance,</font>
<font color="green"> 421.         list=list,</font>
<font color="green"> 422.         str=str,</font>
<font color="green"> 423.         tuple=tuple,</font>
<font color="green"> 424.         iter=iter,</font>
<font color="black"> 425.     ):</font>
<font color="red"> 426.     if _use_decimal and Decimal is None:</font>
<font color="red"> 427.         Decimal = decimal.Decimal</font>
<font color="red"> 428.     if _item_sort_key and not callable(_item_sort_key):</font>
<font color="red"> 429.         raise TypeError(&quot;item_sort_key must be None or callable&quot;)</font>
<font color="red"> 430.     elif _sort_keys and not _item_sort_key:</font>
<font color="red"> 431.         _item_sort_key = itemgetter(0)</font>
<font color="black"> 432. </font>
<font color="red"> 433.     if (_int_as_string_bitcount is not None and</font>
<font color="red"> 434.         (_int_as_string_bitcount &lt;= 0 or</font>
<font color="red"> 435.          not isinstance(_int_as_string_bitcount, integer_types))):</font>
<font color="red"> 436.         raise TypeError(&quot;int_as_string_bitcount must be a positive integer&quot;)</font>
<font color="black"> 437. </font>
<font color="red"> 438.     def _encode_int(value):</font>
<font color="black"> 439.         skip_quoting = (</font>
<font color="red"> 440.             _int_as_string_bitcount is None</font>
<font color="black"> 441.             or</font>
<font color="red"> 442.             _int_as_string_bitcount &lt; 1</font>
<font color="black"> 443.         )</font>
<font color="red"> 444.         if type(value) not in integer_types:</font>
<font color="black"> 445.             # See #118, do not trust custom str/repr</font>
<font color="red"> 446.             value = int(value)</font>
<font color="black"> 447.         if (</font>
<font color="red"> 448.             skip_quoting or</font>
<font color="red"> 449.             (-1 &lt;&lt; _int_as_string_bitcount)</font>
<font color="red"> 450.             &lt; value &lt;</font>
<font color="red"> 451.             (1 &lt;&lt; _int_as_string_bitcount)</font>
<font color="black"> 452.         ):</font>
<font color="red"> 453.             return str(value)</font>
<font color="red"> 454.         return '&quot;' + str(value) + '&quot;'</font>
<font color="black"> 455. </font>
<font color="red"> 456.     def _iterencode_list(lst, _current_indent_level):</font>
<font color="red"> 457.         if not lst:</font>
<font color="red"> 458.             yield '[]'</font>
<font color="red"> 459.             return</font>
<font color="red"> 460.         if markers is not None:</font>
<font color="red"> 461.             markerid = id(lst)</font>
<font color="red"> 462.             if markerid in markers:</font>
<font color="red"> 463.                 raise ValueError(&quot;Circular reference detected&quot;)</font>
<font color="red"> 464.             markers[markerid] = lst</font>
<font color="red"> 465.         buf = '['</font>
<font color="red"> 466.         if _indent is not None:</font>
<font color="red"> 467.             _current_indent_level += 1</font>
<font color="red"> 468.             newline_indent = '\n' + (_indent * _current_indent_level)</font>
<font color="red"> 469.             separator = _item_separator + newline_indent</font>
<font color="red"> 470.             buf += newline_indent</font>
<font color="black"> 471.         else:</font>
<font color="red"> 472.             newline_indent = None</font>
<font color="red"> 473.             separator = _item_separator</font>
<font color="red"> 474.         first = True</font>
<font color="red"> 475.         for value in lst:</font>
<font color="red"> 476.             if first:</font>
<font color="red"> 477.                 first = False</font>
<font color="black"> 478.             else:</font>
<font color="red"> 479.                 buf = separator</font>
<font color="red"> 480.             if (isinstance(value, string_types) or</font>
<font color="red"> 481.                 (_PY3 and isinstance(value, binary_type))):</font>
<font color="red"> 482.                 yield buf + _encoder(value)</font>
<font color="red"> 483.             elif isinstance(value, RawJSON):</font>
<font color="red"> 484.                 yield buf + value.encoded_json</font>
<font color="red"> 485.             elif value is None:</font>
<font color="red"> 486.                 yield buf + 'null'</font>
<font color="red"> 487.             elif value is True:</font>
<font color="red"> 488.                 yield buf + 'true'</font>
<font color="red"> 489.             elif value is False:</font>
<font color="red"> 490.                 yield buf + 'false'</font>
<font color="red"> 491.             elif isinstance(value, integer_types):</font>
<font color="red"> 492.                 yield buf + _encode_int(value)</font>
<font color="red"> 493.             elif isinstance(value, float):</font>
<font color="red"> 494.                 yield buf + _floatstr(value)</font>
<font color="red"> 495.             elif _use_decimal and isinstance(value, Decimal):</font>
<font color="red"> 496.                 yield buf + str(value)</font>
<font color="black"> 497.             else:</font>
<font color="red"> 498.                 yield buf</font>
<font color="red"> 499.                 for_json = _for_json and getattr(value, 'for_json', None)</font>
<font color="red"> 500.                 if for_json and callable(for_json):</font>
<font color="red"> 501.                     chunks = _iterencode(for_json(), _current_indent_level)</font>
<font color="red"> 502.                 elif isinstance(value, list):</font>
<font color="red"> 503.                     chunks = _iterencode_list(value, _current_indent_level)</font>
<font color="black"> 504.                 else:</font>
<font color="red"> 505.                     _asdict = _namedtuple_as_object and getattr(value, '_asdict', None)</font>
<font color="red"> 506.                     if _asdict and callable(_asdict):</font>
<font color="red"> 507.                         chunks = _iterencode_dict(_asdict(),</font>
<font color="red"> 508.                                                   _current_indent_level)</font>
<font color="red"> 509.                     elif _tuple_as_array and isinstance(value, tuple):</font>
<font color="red"> 510.                         chunks = _iterencode_list(value, _current_indent_level)</font>
<font color="red"> 511.                     elif isinstance(value, dict):</font>
<font color="red"> 512.                         chunks = _iterencode_dict(value, _current_indent_level)</font>
<font color="black"> 513.                     else:</font>
<font color="red"> 514.                         chunks = _iterencode(value, _current_indent_level)</font>
<font color="red"> 515.                 for chunk in chunks:</font>
<font color="red"> 516.                     yield chunk</font>
<font color="red"> 517.         if first:</font>
<font color="black"> 518.             # iterable_as_array misses the fast path at the top</font>
<font color="red"> 519.             yield '[]'</font>
<font color="black"> 520.         else:</font>
<font color="red"> 521.             if newline_indent is not None:</font>
<font color="red"> 522.                 _current_indent_level -= 1</font>
<font color="red"> 523.                 yield '\n' + (_indent * _current_indent_level)</font>
<font color="red"> 524.             yield ']'</font>
<font color="red"> 525.         if markers is not None:</font>
<font color="red"> 526.             del markers[markerid]</font>
<font color="black"> 527. </font>
<font color="red"> 528.     def _stringify_key(key):</font>
<font color="red"> 529.         if isinstance(key, string_types): # pragma: no cover</font>
<font color="red"> 530.             pass</font>
<font color="red"> 531.         elif isinstance(key, binary_type):</font>
<font color="red"> 532.             key = key.decode(_encoding)</font>
<font color="red"> 533.         elif isinstance(key, float):</font>
<font color="red"> 534.             key = _floatstr(key)</font>
<font color="red"> 535.         elif key is True:</font>
<font color="red"> 536.             key = 'true'</font>
<font color="red"> 537.         elif key is False:</font>
<font color="red"> 538.             key = 'false'</font>
<font color="red"> 539.         elif key is None:</font>
<font color="red"> 540.             key = 'null'</font>
<font color="red"> 541.         elif isinstance(key, integer_types):</font>
<font color="red"> 542.             if type(key) not in integer_types:</font>
<font color="black"> 543.                 # See #118, do not trust custom str/repr</font>
<font color="red"> 544.                 key = int(key)</font>
<font color="red"> 545.             key = str(key)</font>
<font color="red"> 546.         elif _use_decimal and isinstance(key, Decimal):</font>
<font color="red"> 547.             key = str(key)</font>
<font color="red"> 548.         elif _skipkeys:</font>
<font color="red"> 549.             key = None</font>
<font color="black"> 550.         else:</font>
<font color="red"> 551.             raise TypeError(&quot;key &quot; + repr(key) + &quot; is not a string&quot;)</font>
<font color="red"> 552.         return key</font>
<font color="black"> 553. </font>
<font color="red"> 554.     def _iterencode_dict(dct, _current_indent_level):</font>
<font color="red"> 555.         if not dct:</font>
<font color="red"> 556.             yield '{}'</font>
<font color="red"> 557.             return</font>
<font color="red"> 558.         if markers is not None:</font>
<font color="red"> 559.             markerid = id(dct)</font>
<font color="red"> 560.             if markerid in markers:</font>
<font color="red"> 561.                 raise ValueError(&quot;Circular reference detected&quot;)</font>
<font color="red"> 562.             markers[markerid] = dct</font>
<font color="red"> 563.         yield '{'</font>
<font color="red"> 564.         if _indent is not None:</font>
<font color="red"> 565.             _current_indent_level += 1</font>
<font color="red"> 566.             newline_indent = '\n' + (_indent * _current_indent_level)</font>
<font color="red"> 567.             item_separator = _item_separator + newline_indent</font>
<font color="red"> 568.             yield newline_indent</font>
<font color="black"> 569.         else:</font>
<font color="red"> 570.             newline_indent = None</font>
<font color="red"> 571.             item_separator = _item_separator</font>
<font color="red"> 572.         first = True</font>
<font color="red"> 573.         if _PY3:</font>
<font color="red"> 574.             iteritems = dct.items()</font>
<font color="black"> 575.         else:</font>
<font color="red"> 576.             iteritems = dct.iteritems()</font>
<font color="red"> 577.         if _item_sort_key:</font>
<font color="red"> 578.             items = []</font>
<font color="red"> 579.             for k, v in dct.items():</font>
<font color="red"> 580.                 if not isinstance(k, string_types):</font>
<font color="red"> 581.                     k = _stringify_key(k)</font>
<font color="red"> 582.                     if k is None:</font>
<font color="red"> 583.                         continue</font>
<font color="red"> 584.                 items.append((k, v))</font>
<font color="red"> 585.             items.sort(key=_item_sort_key)</font>
<font color="black"> 586.         else:</font>
<font color="red"> 587.             items = iteritems</font>
<font color="red"> 588.         for key, value in items:</font>
<font color="red"> 589.             if not (_item_sort_key or isinstance(key, string_types)):</font>
<font color="red"> 590.                 key = _stringify_key(key)</font>
<font color="red"> 591.                 if key is None:</font>
<font color="black"> 592.                     # _skipkeys must be True</font>
<font color="red"> 593.                     continue</font>
<font color="red"> 594.             if first:</font>
<font color="red"> 595.                 first = False</font>
<font color="black"> 596.             else:</font>
<font color="red"> 597.                 yield item_separator</font>
<font color="red"> 598.             yield _encoder(key)</font>
<font color="red"> 599.             yield _key_separator</font>
<font color="red"> 600.             if (isinstance(value, string_types) or</font>
<font color="red"> 601.                 (_PY3 and isinstance(value, binary_type))):</font>
<font color="red"> 602.                 yield _encoder(value)</font>
<font color="red"> 603.             elif isinstance(value, RawJSON):</font>
<font color="red"> 604.                 yield value.encoded_json</font>
<font color="red"> 605.             elif value is None:</font>
<font color="red"> 606.                 yield 'null'</font>
<font color="red"> 607.             elif value is True:</font>
<font color="red"> 608.                 yield 'true'</font>
<font color="red"> 609.             elif value is False:</font>
<font color="red"> 610.                 yield 'false'</font>
<font color="red"> 611.             elif isinstance(value, integer_types):</font>
<font color="red"> 612.                 yield _encode_int(value)</font>
<font color="red"> 613.             elif isinstance(value, float):</font>
<font color="red"> 614.                 yield _floatstr(value)</font>
<font color="red"> 615.             elif _use_decimal and isinstance(value, Decimal):</font>
<font color="red"> 616.                 yield str(value)</font>
<font color="black"> 617.             else:</font>
<font color="red"> 618.                 for_json = _for_json and getattr(value, 'for_json', None)</font>
<font color="red"> 619.                 if for_json and callable(for_json):</font>
<font color="red"> 620.                     chunks = _iterencode(for_json(), _current_indent_level)</font>
<font color="red"> 621.                 elif isinstance(value, list):</font>
<font color="red"> 622.                     chunks = _iterencode_list(value, _current_indent_level)</font>
<font color="black"> 623.                 else:</font>
<font color="red"> 624.                     _asdict = _namedtuple_as_object and getattr(value, '_asdict', None)</font>
<font color="red"> 625.                     if _asdict and callable(_asdict):</font>
<font color="red"> 626.                         chunks = _iterencode_dict(_asdict(),</font>
<font color="red"> 627.                                                   _current_indent_level)</font>
<font color="red"> 628.                     elif _tuple_as_array and isinstance(value, tuple):</font>
<font color="red"> 629.                         chunks = _iterencode_list(value, _current_indent_level)</font>
<font color="red"> 630.                     elif isinstance(value, dict):</font>
<font color="red"> 631.                         chunks = _iterencode_dict(value, _current_indent_level)</font>
<font color="black"> 632.                     else:</font>
<font color="red"> 633.                         chunks = _iterencode(value, _current_indent_level)</font>
<font color="red"> 634.                 for chunk in chunks:</font>
<font color="red"> 635.                     yield chunk</font>
<font color="red"> 636.         if newline_indent is not None:</font>
<font color="red"> 637.             _current_indent_level -= 1</font>
<font color="red"> 638.             yield '\n' + (_indent * _current_indent_level)</font>
<font color="red"> 639.         yield '}'</font>
<font color="red"> 640.         if markers is not None:</font>
<font color="red"> 641.             del markers[markerid]</font>
<font color="black"> 642. </font>
<font color="red"> 643.     def _iterencode(o, _current_indent_level):</font>
<font color="red"> 644.         if (isinstance(o, string_types) or</font>
<font color="red"> 645.             (_PY3 and isinstance(o, binary_type))):</font>
<font color="red"> 646.             yield _encoder(o)</font>
<font color="red"> 647.         elif isinstance(o, RawJSON):</font>
<font color="red"> 648.             yield o.encoded_json</font>
<font color="red"> 649.         elif o is None:</font>
<font color="red"> 650.             yield 'null'</font>
<font color="red"> 651.         elif o is True:</font>
<font color="red"> 652.             yield 'true'</font>
<font color="red"> 653.         elif o is False:</font>
<font color="red"> 654.             yield 'false'</font>
<font color="red"> 655.         elif isinstance(o, integer_types):</font>
<font color="red"> 656.             yield _encode_int(o)</font>
<font color="red"> 657.         elif isinstance(o, float):</font>
<font color="red"> 658.             yield _floatstr(o)</font>
<font color="black"> 659.         else:</font>
<font color="red"> 660.             for_json = _for_json and getattr(o, 'for_json', None)</font>
<font color="red"> 661.             if for_json and callable(for_json):</font>
<font color="red"> 662.                 for chunk in _iterencode(for_json(), _current_indent_level):</font>
<font color="red"> 663.                     yield chunk</font>
<font color="red"> 664.             elif isinstance(o, list):</font>
<font color="red"> 665.                 for chunk in _iterencode_list(o, _current_indent_level):</font>
<font color="red"> 666.                     yield chunk</font>
<font color="black"> 667.             else:</font>
<font color="red"> 668.                 _asdict = _namedtuple_as_object and getattr(o, '_asdict', None)</font>
<font color="red"> 669.                 if _asdict and callable(_asdict):</font>
<font color="red"> 670.                     for chunk in _iterencode_dict(_asdict(),</font>
<font color="red"> 671.                             _current_indent_level):</font>
<font color="red"> 672.                         yield chunk</font>
<font color="red"> 673.                 elif (_tuple_as_array and isinstance(o, tuple)):</font>
<font color="red"> 674.                     for chunk in _iterencode_list(o, _current_indent_level):</font>
<font color="red"> 675.                         yield chunk</font>
<font color="red"> 676.                 elif isinstance(o, dict):</font>
<font color="red"> 677.                     for chunk in _iterencode_dict(o, _current_indent_level):</font>
<font color="red"> 678.                         yield chunk</font>
<font color="red"> 679.                 elif _use_decimal and isinstance(o, Decimal):</font>
<font color="red"> 680.                     yield str(o)</font>
<font color="black"> 681.                 else:</font>
<font color="red"> 682.                     while _iterable_as_array:</font>
<font color="black"> 683.                         # Markers are not checked here because it is valid for</font>
<font color="black"> 684.                         # an iterable to return self.</font>
<font color="red"> 685.                         try:</font>
<font color="red"> 686.                             o = iter(o)</font>
<font color="red"> 687.                         except TypeError:</font>
<font color="red"> 688.                             break</font>
<font color="red"> 689.                         for chunk in _iterencode_list(o, _current_indent_level):</font>
<font color="red"> 690.                             yield chunk</font>
<font color="red"> 691.                         return</font>
<font color="red"> 692.                     if markers is not None:</font>
<font color="red"> 693.                         markerid = id(o)</font>
<font color="red"> 694.                         if markerid in markers:</font>
<font color="red"> 695.                             raise ValueError(&quot;Circular reference detected&quot;)</font>
<font color="red"> 696.                         markers[markerid] = o</font>
<font color="red"> 697.                     o = _default(o)</font>
<font color="red"> 698.                     for chunk in _iterencode(o, _current_indent_level):</font>
<font color="red"> 699.                         yield chunk</font>
<font color="red"> 700.                     if markers is not None:</font>
<font color="red"> 701.                         del markers[markerid]</font>
<font color="black"> 702. </font>
<font color="red"> 703.     return _iterencode</font>
</pre>

