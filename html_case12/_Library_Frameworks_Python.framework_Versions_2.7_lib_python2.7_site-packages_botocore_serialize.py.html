source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/serialize.py</b><br>


file stats: <b>360 lines, 173 executed: 48.1% covered</b>
<pre>
<font color="black">   1. # Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="black">  13. &quot;&quot;&quot;Protocol input serializes.</font>
<font color="black">  14. </font>
<font color="black">  15. This module contains classes that implement input serialization</font>
<font color="black">  16. for the various AWS protocol types.</font>
<font color="black">  17. </font>
<font color="black">  18. These classes essentially take user input, a model object that</font>
<font color="black">  19. represents what the expected input should look like, and it returns</font>
<font color="black">  20. a dictionary that contains the various parts of a request.  A few</font>
<font color="black">  21. high level design decisions:</font>
<font color="black">  22. </font>
<font color="black">  23. </font>
<font color="black">  24. * Each protocol type maps to a separate class, all inherit from</font>
<font color="black">  25.   ``Serializer``.</font>
<font color="black">  26. * The return value for ``serialize_to_request`` (the main entry</font>
<font color="black">  27.   point) returns a dictionary that represents a request.  This</font>
<font color="black">  28.   will have keys like ``url_path``, ``query_string``, etc.  This</font>
<font color="black">  29.   is done so that it's a) easy to test and b) not tied to a</font>
<font color="black">  30.   particular HTTP library.  See the ``serialize_to_request`` docstring</font>
<font color="black">  31.   for more details.</font>
<font color="black">  32. </font>
<font color="black">  33. Unicode</font>
<font color="black">  34. -------</font>
<font color="black">  35. </font>
<font color="black">  36. The input to the serializers should be text (str/unicode), not bytes,</font>
<font color="black">  37. with the exception of blob types.  Those are assumed to be binary,</font>
<font color="black">  38. and if a str/unicode type is passed in, it will be encoded as utf-8.</font>
<font color="green">  39. &quot;&quot;&quot;</font>
<font color="green">  40. import re</font>
<font color="green">  41. import base64</font>
<font color="green">  42. from xml.etree import ElementTree</font>
<font color="green">  43. import calendar</font>
<font color="black">  44. </font>
<font color="green">  45. from botocore.compat import six</font>
<font color="black">  46. </font>
<font color="green">  47. from botocore.compat import json, formatdate</font>
<font color="green">  48. from botocore.utils import parse_to_aware_datetime</font>
<font color="green">  49. from botocore.utils import percent_encode</font>
<font color="green">  50. from botocore.utils import is_json_value_header</font>
<font color="green">  51. from botocore import validate</font>
<font color="black">  52. </font>
<font color="black">  53. </font>
<font color="black">  54. # From the spec, the default timestamp format if not specified is iso8601.</font>
<font color="green">  55. DEFAULT_TIMESTAMP_FORMAT = 'iso8601'</font>
<font color="green">  56. ISO8601 = '%Y-%m-%dT%H:%M:%SZ'</font>
<font color="black">  57. # Same as ISO8601, but with microsecond precision.</font>
<font color="green">  58. ISO8601_MICRO = '%Y-%m-%dT%H:%M:%S.%fZ'</font>
<font color="black">  59. </font>
<font color="black">  60. </font>
<font color="green">  61. def create_serializer(protocol_name, include_validation=True):</font>
<font color="black">  62.     # TODO: Unknown protocols.</font>
<font color="green">  63.     serializer = SERIALIZERS[protocol_name]()</font>
<font color="green">  64.     if include_validation:</font>
<font color="green">  65.         validator = validate.ParamValidator()</font>
<font color="green">  66.         serializer = validate.ParamValidationDecorator(validator, serializer)</font>
<font color="green">  67.     return serializer</font>
<font color="black">  68. </font>
<font color="black">  69. </font>
<font color="green">  70. class Serializer(object):</font>
<font color="green">  71.     DEFAULT_METHOD = 'POST'</font>
<font color="black">  72.     # Clients can change this to a different MutableMapping</font>
<font color="black">  73.     # (i.e OrderedDict) if they want.  This is used in the</font>
<font color="black">  74.     # compliance test to match the hash ordering used in the</font>
<font color="black">  75.     # tests.</font>
<font color="green">  76.     MAP_TYPE = dict</font>
<font color="green">  77.     DEFAULT_ENCODING = 'utf-8'</font>
<font color="black">  78. </font>
<font color="green">  79.     def serialize_to_request(self, parameters, operation_model):</font>
<font color="black">  80.         &quot;&quot;&quot;Serialize parameters into an HTTP request.</font>
<font color="black">  81. </font>
<font color="black">  82.         This method takes user provided parameters and a shape</font>
<font color="black">  83.         model and serializes the parameters to an HTTP request.</font>
<font color="black">  84.         More specifically, this method returns information about</font>
<font color="black">  85.         parts of the HTTP request, it does not enforce a particular</font>
<font color="black">  86.         interface or standard for an HTTP request.  It instead returns</font>
<font color="black">  87.         a dictionary of:</font>
<font color="black">  88. </font>
<font color="black">  89.             * 'url_path'</font>
<font color="black">  90.             * 'query_string'</font>
<font color="black">  91.             * 'headers'</font>
<font color="black">  92.             * 'body'</font>
<font color="black">  93.             * 'method'</font>
<font color="black">  94. </font>
<font color="black">  95.         It is then up to consumers to decide how to map this to a Request</font>
<font color="black">  96.         object of their HTTP library of choice.  Below is an example</font>
<font color="black">  97.         return value::</font>
<font color="black">  98. </font>
<font color="black">  99.             {'body': {'Action': 'OperationName',</font>
<font color="black"> 100.                       'Bar': 'val2',</font>
<font color="black"> 101.                       'Foo': 'val1',</font>
<font color="black"> 102.                       'Version': '2014-01-01'},</font>
<font color="black"> 103.              'headers': {},</font>
<font color="black"> 104.              'method': 'POST',</font>
<font color="black"> 105.              'query_string': '',</font>
<font color="black"> 106.              'url_path': '/'}</font>
<font color="black"> 107. </font>
<font color="black"> 108.         :param parameters: The dictionary input parameters for the</font>
<font color="black"> 109.             operation (i.e the user input).</font>
<font color="black"> 110.         :param operation_model: The OperationModel object that describes</font>
<font color="black"> 111.             the operation.</font>
<font color="black"> 112.         &quot;&quot;&quot;</font>
<font color="red"> 113.         raise NotImplementedError(&quot;serialize_to_request&quot;)</font>
<font color="black"> 114. </font>
<font color="green"> 115.     def _create_default_request(self):</font>
<font color="black"> 116.         # Creates a boilerplate default request dict that subclasses</font>
<font color="black"> 117.         # can use as a starting point.</font>
<font color="green"> 118.         serialized = {</font>
<font color="green"> 119.             'url_path': '/',</font>
<font color="green"> 120.             'query_string': '',</font>
<font color="green"> 121.             'method': self.DEFAULT_METHOD,</font>
<font color="green"> 122.             'headers': {},</font>
<font color="black"> 123.             # An empty body is represented as an empty byte string.</font>
<font color="green"> 124.             'body': b''</font>
<font color="black"> 125.         }</font>
<font color="green"> 126.         return serialized</font>
<font color="black"> 127. </font>
<font color="black"> 128.     # Some extra utility methods subclasses can use.</font>
<font color="black"> 129. </font>
<font color="green"> 130.     def _timestamp_iso8601(self, value):</font>
<font color="red"> 131.         if value.microsecond &gt; 0:</font>
<font color="red"> 132.             timestamp_format = ISO8601_MICRO</font>
<font color="black"> 133.         else:</font>
<font color="red"> 134.             timestamp_format = ISO8601</font>
<font color="red"> 135.         return value.strftime(timestamp_format)</font>
<font color="black"> 136. </font>
<font color="green"> 137.     def _timestamp_unixtimestamp(self, value):</font>
<font color="red"> 138.         return int(calendar.timegm(value.timetuple()))</font>
<font color="black"> 139. </font>
<font color="green"> 140.     def _timestamp_rfc822(self, value):</font>
<font color="red"> 141.         return formatdate(value, usegmt=True)</font>
<font color="black"> 142. </font>
<font color="green"> 143.     def _convert_timestamp_to_str(self, value):</font>
<font color="red"> 144.         datetime_obj = parse_to_aware_datetime(value)</font>
<font color="red"> 145.         converter = getattr(</font>
<font color="red"> 146.             self, '_timestamp_%s' % self.TIMESTAMP_FORMAT.lower())</font>
<font color="red"> 147.         final_value = converter(datetime_obj)</font>
<font color="red"> 148.         return final_value</font>
<font color="black"> 149. </font>
<font color="green"> 150.     def _get_serialized_name(self, shape, default_name):</font>
<font color="black"> 151.         # Returns the serialized name for the shape if it exists.</font>
<font color="black"> 152.         # Otherwise it will return the passed in default_name.</font>
<font color="red"> 153.         return shape.serialization.get('name', default_name)</font>
<font color="black"> 154. </font>
<font color="green"> 155.     def _get_base64(self, value):</font>
<font color="black"> 156.         # Returns the base64-encoded version of value, handling</font>
<font color="black"> 157.         # both strings and bytes. The returned value is a string</font>
<font color="black"> 158.         # via the default encoding.</font>
<font color="red"> 159.         if isinstance(value, six.text_type):</font>
<font color="red"> 160.             value = value.encode(self.DEFAULT_ENCODING)</font>
<font color="red"> 161.         return base64.b64encode(value).strip().decode(</font>
<font color="red"> 162.             self.DEFAULT_ENCODING)</font>
<font color="black"> 163. </font>
<font color="black"> 164. </font>
<font color="green"> 165. class QuerySerializer(Serializer):</font>
<font color="black"> 166. </font>
<font color="green"> 167.     TIMESTAMP_FORMAT = 'iso8601'</font>
<font color="black"> 168. </font>
<font color="green"> 169.     def serialize_to_request(self, parameters, operation_model):</font>
<font color="red"> 170.         shape = operation_model.input_shape</font>
<font color="red"> 171.         serialized = self._create_default_request()</font>
<font color="red"> 172.         serialized['method'] = operation_model.http.get('method',</font>
<font color="red"> 173.                                                         self.DEFAULT_METHOD)</font>
<font color="red"> 174.         serialized['headers'] = {</font>
<font color="red"> 175.             'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8'</font>
<font color="black"> 176.         }</font>
<font color="black"> 177.         # The query serializer only deals with body params so</font>
<font color="black"> 178.         # that's what we hand off the _serialize_* methods.</font>
<font color="red"> 179.         body_params = self.MAP_TYPE()</font>
<font color="red"> 180.         body_params['Action'] = operation_model.name</font>
<font color="red"> 181.         body_params['Version'] = operation_model.metadata['apiVersion']</font>
<font color="red"> 182.         if shape is not None:</font>
<font color="red"> 183.             self._serialize(body_params, parameters, shape)</font>
<font color="red"> 184.         serialized['body'] = body_params</font>
<font color="red"> 185.         return serialized</font>
<font color="black"> 186. </font>
<font color="green"> 187.     def _serialize(self, serialized, value, shape, prefix=''):</font>
<font color="black"> 188.         # serialized: The dict that is incrementally added to with the</font>
<font color="black"> 189.         #             final serialized parameters.</font>
<font color="black"> 190.         # value: The current user input value.</font>
<font color="black"> 191.         # shape: The shape object that describes the structure of the</font>
<font color="black"> 192.         #        input.</font>
<font color="black"> 193.         # prefix: The incrementally built up prefix for the serialized</font>
<font color="black"> 194.         #         key (i.e Foo.bar.members.1).</font>
<font color="red"> 195.         method = getattr(self, '_serialize_type_%s' % shape.type_name,</font>
<font color="red"> 196.                          self._default_serialize)</font>
<font color="red"> 197.         method(serialized, value, shape, prefix=prefix)</font>
<font color="black"> 198. </font>
<font color="green"> 199.     def _serialize_type_structure(self, serialized, value, shape, prefix=''):</font>
<font color="red"> 200.         members = shape.members</font>
<font color="red"> 201.         for key, value in value.items():</font>
<font color="red"> 202.             member_shape = members[key]</font>
<font color="red"> 203.             member_prefix = self._get_serialized_name(member_shape, key)</font>
<font color="red"> 204.             if prefix:</font>
<font color="red"> 205.                 member_prefix = '%s.%s' % (prefix, member_prefix)</font>
<font color="red"> 206.             self._serialize(serialized, value, member_shape, member_prefix)</font>
<font color="black"> 207. </font>
<font color="green"> 208.     def _serialize_type_list(self, serialized, value, shape, prefix=''):</font>
<font color="red"> 209.         if not value:</font>
<font color="black"> 210.             # The query protocol serializes empty lists.</font>
<font color="red"> 211.             serialized[prefix] = ''</font>
<font color="red"> 212.             return</font>
<font color="red"> 213.         if self._is_shape_flattened(shape):</font>
<font color="red"> 214.             list_prefix = prefix</font>
<font color="red"> 215.             if shape.member.serialization.get('name'):</font>
<font color="red"> 216.                 name = self._get_serialized_name(shape.member, default_name='')</font>
<font color="black"> 217.                 # Replace '.Original' with '.{name}'.</font>
<font color="red"> 218.                 list_prefix = '.'.join(prefix.split('.')[:-1] + [name])</font>
<font color="black"> 219.         else:</font>
<font color="red"> 220.             list_name = shape.member.serialization.get('name', 'member')</font>
<font color="red"> 221.             list_prefix = '%s.%s' % (prefix, list_name)</font>
<font color="red"> 222.         for i, element in enumerate(value, 1):</font>
<font color="red"> 223.             element_prefix = '%s.%s' % (list_prefix, i)</font>
<font color="red"> 224.             element_shape = shape.member</font>
<font color="red"> 225.             self._serialize(serialized, element, element_shape, element_prefix)</font>
<font color="black"> 226. </font>
<font color="green"> 227.     def _serialize_type_map(self, serialized, value, shape, prefix=''):</font>
<font color="red"> 228.         if self._is_shape_flattened(shape):</font>
<font color="red"> 229.             full_prefix = prefix</font>
<font color="black"> 230.         else:</font>
<font color="red"> 231.             full_prefix = '%s.entry' % prefix</font>
<font color="red"> 232.         template = full_prefix + '.{i}.{suffix}'</font>
<font color="red"> 233.         key_shape = shape.key</font>
<font color="red"> 234.         value_shape = shape.value</font>
<font color="red"> 235.         key_suffix = self._get_serialized_name(key_shape, default_name='key')</font>
<font color="red"> 236.         value_suffix = self._get_serialized_name(value_shape, 'value')</font>
<font color="red"> 237.         for i, key in enumerate(value, 1):</font>
<font color="red"> 238.             key_prefix = template.format(i=i, suffix=key_suffix)</font>
<font color="red"> 239.             value_prefix = template.format(i=i, suffix=value_suffix)</font>
<font color="red"> 240.             self._serialize(serialized, key, key_shape, key_prefix)</font>
<font color="red"> 241.             self._serialize(serialized, value[key], value_shape, value_prefix)</font>
<font color="black"> 242. </font>
<font color="green"> 243.     def _serialize_type_blob(self, serialized, value, shape, prefix=''):</font>
<font color="black"> 244.         # Blob args must be base64 encoded.</font>
<font color="red"> 245.         serialized[prefix] = self._get_base64(value)</font>
<font color="black"> 246. </font>
<font color="green"> 247.     def _serialize_type_timestamp(self, serialized, value, shape, prefix=''):</font>
<font color="red"> 248.         serialized[prefix] = self._convert_timestamp_to_str(value)</font>
<font color="black"> 249. </font>
<font color="green"> 250.     def _serialize_type_boolean(self, serialized, value, shape, prefix=''):</font>
<font color="red"> 251.         if value:</font>
<font color="red"> 252.             serialized[prefix] = 'true'</font>
<font color="black"> 253.         else:</font>
<font color="red"> 254.             serialized[prefix] = 'false'</font>
<font color="black"> 255. </font>
<font color="green"> 256.     def _default_serialize(self, serialized, value, shape, prefix=''):</font>
<font color="red"> 257.         serialized[prefix] = value</font>
<font color="black"> 258. </font>
<font color="green"> 259.     def _is_shape_flattened(self, shape):</font>
<font color="red"> 260.         return shape.serialization.get('flattened')</font>
<font color="black"> 261. </font>
<font color="black"> 262. </font>
<font color="green"> 263. class EC2Serializer(QuerySerializer):</font>
<font color="black"> 264.     &quot;&quot;&quot;EC2 specific customizations to the query protocol serializers.</font>
<font color="black"> 265. </font>
<font color="black"> 266.     The EC2 model is almost, but not exactly, similar to the query protocol</font>
<font color="black"> 267.     serializer.  This class encapsulates those differences.  The model</font>
<font color="black"> 268.     will have be marked with a ``protocol`` of ``ec2``, so you don't need</font>
<font color="black"> 269.     to worry about wiring this class up correctly.</font>
<font color="black"> 270. </font>
<font color="green"> 271.     &quot;&quot;&quot;</font>
<font color="black"> 272. </font>
<font color="green"> 273.     def _get_serialized_name(self, shape, default_name):</font>
<font color="black"> 274.         # Returns the serialized name for the shape if it exists.</font>
<font color="black"> 275.         # Otherwise it will return the passed in default_name.</font>
<font color="red"> 276.         if 'queryName' in shape.serialization:</font>
<font color="red"> 277.             return shape.serialization['queryName']</font>
<font color="red"> 278.         elif 'name' in shape.serialization:</font>
<font color="black"> 279.             # A locationName is always capitalized</font>
<font color="black"> 280.             # on input for the ec2 protocol.</font>
<font color="red"> 281.             name = shape.serialization['name']</font>
<font color="red"> 282.             return name[0].upper() + name[1:]</font>
<font color="black"> 283.         else:</font>
<font color="red"> 284.             return default_name</font>
<font color="black"> 285. </font>
<font color="green"> 286.     def _serialize_type_list(self, serialized, value, shape, prefix=''):</font>
<font color="red"> 287.         for i, element in enumerate(value, 1):</font>
<font color="red"> 288.             element_prefix = '%s.%s' % (prefix, i)</font>
<font color="red"> 289.             element_shape = shape.member</font>
<font color="red"> 290.             self._serialize(serialized, element, element_shape, element_prefix)</font>
<font color="black"> 291. </font>
<font color="black"> 292. </font>
<font color="green"> 293. class JSONSerializer(Serializer):</font>
<font color="green"> 294.     TIMESTAMP_FORMAT = 'unixtimestamp'</font>
<font color="black"> 295. </font>
<font color="green"> 296.     def serialize_to_request(self, parameters, operation_model):</font>
<font color="red"> 297.         target = '%s.%s' % (operation_model.metadata['targetPrefix'],</font>
<font color="red"> 298.                             operation_model.name)</font>
<font color="red"> 299.         json_version = operation_model.metadata['jsonVersion']</font>
<font color="red"> 300.         serialized = self._create_default_request()</font>
<font color="red"> 301.         serialized['method'] = operation_model.http.get('method',</font>
<font color="red"> 302.                                                         self.DEFAULT_METHOD)</font>
<font color="red"> 303.         serialized['headers'] = {</font>
<font color="red"> 304.             'X-Amz-Target': target,</font>
<font color="red"> 305.             'Content-Type': 'application/x-amz-json-%s' % json_version,</font>
<font color="black"> 306.         }</font>
<font color="red"> 307.         body = {}</font>
<font color="red"> 308.         input_shape = operation_model.input_shape</font>
<font color="red"> 309.         if input_shape is not None:</font>
<font color="red"> 310.             self._serialize(body, parameters, input_shape)</font>
<font color="red"> 311.         serialized['body'] = json.dumps(body).encode(self.DEFAULT_ENCODING)</font>
<font color="red"> 312.         return serialized</font>
<font color="black"> 313. </font>
<font color="green"> 314.     def _serialize(self, serialized, value, shape, key=None):</font>
<font color="red"> 315.         method = getattr(self, '_serialize_type_%s' % shape.type_name,</font>
<font color="red"> 316.                          self._default_serialize)</font>
<font color="red"> 317.         method(serialized, value, shape, key)</font>
<font color="black"> 318. </font>
<font color="green"> 319.     def _serialize_type_structure(self, serialized, value, shape, key):</font>
<font color="red"> 320.         if key is not None:</font>
<font color="black"> 321.             # If a key is provided, this is a result of a recursive</font>
<font color="black"> 322.             # call so we need to add a new child dict as the value</font>
<font color="black"> 323.             # of the passed in serialized dict.  We'll then add</font>
<font color="black"> 324.             # all the structure members as key/vals in the new serialized</font>
<font color="black"> 325.             # dictionary we just created.</font>
<font color="red"> 326.             new_serialized = self.MAP_TYPE()</font>
<font color="red"> 327.             serialized[key] = new_serialized</font>
<font color="red"> 328.             serialized = new_serialized</font>
<font color="red"> 329.         members = shape.members</font>
<font color="red"> 330.         for member_key, member_value in value.items():</font>
<font color="red"> 331.             member_shape = members[member_key]</font>
<font color="red"> 332.             if 'name' in member_shape.serialization:</font>
<font color="red"> 333.                 member_key = member_shape.serialization['name']</font>
<font color="red"> 334.             self._serialize(serialized, member_value, member_shape, member_key)</font>
<font color="black"> 335. </font>
<font color="green"> 336.     def _serialize_type_map(self, serialized, value, shape, key):</font>
<font color="red"> 337.         map_obj = self.MAP_TYPE()</font>
<font color="red"> 338.         serialized[key] = map_obj</font>
<font color="red"> 339.         for sub_key, sub_value in value.items():</font>
<font color="red"> 340.             self._serialize(map_obj, sub_value, shape.value, sub_key)</font>
<font color="black"> 341. </font>
<font color="green"> 342.     def _serialize_type_list(self, serialized, value, shape, key):</font>
<font color="red"> 343.         list_obj = []</font>
<font color="red"> 344.         serialized[key] = list_obj</font>
<font color="red"> 345.         for list_item in value:</font>
<font color="red"> 346.             wrapper = {}</font>
<font color="black"> 347.             # The JSON list serialization is the only case where we aren't</font>
<font color="black"> 348.             # setting a key on a dict.  We handle this by using</font>
<font color="black"> 349.             # a __current__ key on a wrapper dict to serialize each</font>
<font color="black"> 350.             # list item before appending it to the serialized list.</font>
<font color="red"> 351.             self._serialize(wrapper, list_item, shape.member, &quot;__current__&quot;)</font>
<font color="red"> 352.             list_obj.append(wrapper[&quot;__current__&quot;])</font>
<font color="black"> 353. </font>
<font color="green"> 354.     def _default_serialize(self, serialized, value, shape, key):</font>
<font color="red"> 355.         serialized[key] = value</font>
<font color="black"> 356. </font>
<font color="green"> 357.     def _serialize_type_timestamp(self, serialized, value, shape, key):</font>
<font color="red"> 358.         serialized[key] = self._convert_timestamp_to_str(value)</font>
<font color="black"> 359. </font>
<font color="green"> 360.     def _serialize_type_blob(self, serialized, value, shape, key):</font>
<font color="red"> 361.         serialized[key] = self._get_base64(value)</font>
<font color="black"> 362. </font>
<font color="black"> 363. </font>
<font color="green"> 364. class BaseRestSerializer(Serializer):</font>
<font color="black"> 365.     &quot;&quot;&quot;Base class for rest protocols.</font>
<font color="black"> 366. </font>
<font color="black"> 367.     The only variance between the various rest protocols is the</font>
<font color="black"> 368.     way that the body is serialized.  All other aspects (headers, uri, etc.)</font>
<font color="black"> 369.     are the same and logic for serializing those aspects lives here.</font>
<font color="black"> 370. </font>
<font color="black"> 371.     Subclasses must implement the ``_serialize_body_params`` method.</font>
<font color="black"> 372. </font>
<font color="green"> 373.     &quot;&quot;&quot;</font>
<font color="black"> 374.     # This is a list of known values for the &quot;location&quot; key in the</font>
<font color="black"> 375.     # serialization dict.  The location key tells us where on the request</font>
<font color="black"> 376.     # to put the serialized value.</font>
<font color="green"> 377.     KNOWN_LOCATIONS = ['uri', 'querystring', 'header', 'headers']</font>
<font color="black"> 378. </font>
<font color="green"> 379.     def serialize_to_request(self, parameters, operation_model):</font>
<font color="green"> 380.         serialized = self._create_default_request()</font>
<font color="green"> 381.         serialized['method'] = operation_model.http.get('method',</font>
<font color="green"> 382.                                                         self.DEFAULT_METHOD)</font>
<font color="green"> 383.         shape = operation_model.input_shape</font>
<font color="green"> 384.         if shape is None:</font>
<font color="green"> 385.             serialized['url_path'] = operation_model.http['requestUri']</font>
<font color="green"> 386.             return serialized</font>
<font color="green"> 387.         shape_members = shape.members</font>
<font color="black"> 388.         # While the ``serialized`` key holds the final serialized request</font>
<font color="black"> 389.         # data, we need interim dicts for the various locations of the</font>
<font color="black"> 390.         # request.  We need this for the uri_path_kwargs and the</font>
<font color="black"> 391.         # query_string_kwargs because they are templated, so we need</font>
<font color="black"> 392.         # to gather all the needed data for the string template,</font>
<font color="black"> 393.         # then we render the template.  The body_kwargs is needed</font>
<font color="black"> 394.         # because once we've collected them all, we run them through</font>
<font color="black"> 395.         # _serialize_body_params, which for rest-json, creates JSON,</font>
<font color="black"> 396.         # and for rest-xml, will create XML.  This is what the</font>
<font color="black"> 397.         # ``partitioned`` dict below is for.</font>
<font color="green"> 398.         partitioned = {</font>
<font color="green"> 399.             'uri_path_kwargs': self.MAP_TYPE(),</font>
<font color="green"> 400.             'query_string_kwargs': self.MAP_TYPE(),</font>
<font color="green"> 401.             'body_kwargs': self.MAP_TYPE(),</font>
<font color="green"> 402.             'headers': self.MAP_TYPE(),</font>
<font color="black"> 403.         }</font>
<font color="green"> 404.         for param_name, param_value in parameters.items():</font>
<font color="green"> 405.             if param_value is None:</font>
<font color="black"> 406.                 # Don't serialize any parameter with a None value.</font>
<font color="red"> 407.                 continue</font>
<font color="green"> 408.             self._partition_parameters(partitioned, param_name, param_value,</font>
<font color="green"> 409.                                        shape_members)</font>
<font color="green"> 410.         serialized['url_path'] = self._render_uri_template(</font>
<font color="green"> 411.             operation_model.http['requestUri'],</font>
<font color="green"> 412.             partitioned['uri_path_kwargs'])</font>
<font color="black"> 413.         # Note that we lean on the http implementation to handle the case</font>
<font color="black"> 414.         # where the requestUri path already has query parameters.</font>
<font color="black"> 415.         # The bundled http client, requests, already supports this.</font>
<font color="green"> 416.         serialized['query_string'] = partitioned['query_string_kwargs']</font>
<font color="green"> 417.         if partitioned['headers']:</font>
<font color="red"> 418.             serialized['headers'] = partitioned['headers']</font>
<font color="green"> 419.         self._serialize_payload(partitioned, parameters,</font>
<font color="green"> 420.                                 serialized, shape, shape_members)</font>
<font color="green"> 421.         return serialized</font>
<font color="black"> 422. </font>
<font color="green"> 423.     def _render_uri_template(self, uri_template, params):</font>
<font color="black"> 424.         # We need to handle two cases::</font>
<font color="black"> 425.         #</font>
<font color="black"> 426.         # /{Bucket}/foo</font>
<font color="black"> 427.         # /{Key+}/bar</font>
<font color="black"> 428.         # A label ending with '+' is greedy.  There can only</font>
<font color="black"> 429.         # be one greedy key.</font>
<font color="green"> 430.         encoded_params = {}</font>
<font color="green"> 431.         for template_param in re.findall(r'{(.*?)}', uri_template):</font>
<font color="green"> 432.             if template_param.endswith('+'):</font>
<font color="red"> 433.                 encoded_params[template_param] = percent_encode(</font>
<font color="red"> 434.                     params[template_param[:-1]], safe='/~')</font>
<font color="black"> 435.             else:</font>
<font color="green"> 436.                 encoded_params[template_param] = percent_encode(</font>
<font color="green"> 437.                     params[template_param])</font>
<font color="green"> 438.         return uri_template.format(**encoded_params)</font>
<font color="black"> 439. </font>
<font color="green"> 440.     def _serialize_payload(self, partitioned, parameters,</font>
<font color="black"> 441.                            serialized, shape, shape_members):</font>
<font color="black"> 442.         # partitioned - The user input params partitioned by location.</font>
<font color="black"> 443.         # parameters - The user input params.</font>
<font color="black"> 444.         # serialized - The final serialized request dict.</font>
<font color="black"> 445.         # shape - Describes the expected input shape</font>
<font color="black"> 446.         # shape_members - The members of the input struct shape</font>
<font color="green"> 447.         payload_member = shape.serialization.get('payload')</font>
<font color="green"> 448.         if payload_member is not None and \</font>
<font color="green"> 449.                 shape_members[payload_member].type_name in ['blob', 'string']:</font>
<font color="black"> 450.             # If it's streaming, then the body is just the</font>
<font color="black"> 451.             # value of the payload.</font>
<font color="red"> 452.             body_payload = parameters.get(payload_member, b'')</font>
<font color="red"> 453.             body_payload = self._encode_payload(body_payload)</font>
<font color="red"> 454.             serialized['body'] = body_payload</font>
<font color="green"> 455.         elif payload_member is not None:</font>
<font color="black"> 456.             # If there's a payload member, we serialized that</font>
<font color="black"> 457.             # member to they body.</font>
<font color="green"> 458.             body_params = parameters.get(payload_member)</font>
<font color="green"> 459.             if body_params is not None:</font>
<font color="green"> 460.                 serialized['body'] = self._serialize_body_params(</font>
<font color="green"> 461.                     body_params,</font>
<font color="green"> 462.                     shape_members[payload_member])</font>
<font color="green"> 463.         elif partitioned['body_kwargs']:</font>
<font color="red"> 464.             serialized['body'] = self._serialize_body_params(</font>
<font color="red"> 465.                 partitioned['body_kwargs'], shape)</font>
<font color="black"> 466. </font>
<font color="green"> 467.     def _encode_payload(self, body):</font>
<font color="red"> 468.         if isinstance(body, six.text_type):</font>
<font color="red"> 469.             return body.encode(self.DEFAULT_ENCODING)</font>
<font color="red"> 470.         return body</font>
<font color="black"> 471. </font>
<font color="green"> 472.     def _partition_parameters(self, partitioned, param_name,</font>
<font color="black"> 473.                               param_value, shape_members):</font>
<font color="black"> 474.         # This takes the user provided input parameter (``param``)</font>
<font color="black"> 475.         # and figures out where they go in the request dict.</font>
<font color="black"> 476.         # Some params are HTTP headers, some are used in the URI, some</font>
<font color="black"> 477.         # are in the request body.  This method deals with this.</font>
<font color="green"> 478.         member = shape_members[param_name]</font>
<font color="green"> 479.         location = member.serialization.get('location')</font>
<font color="green"> 480.         key_name = member.serialization.get('name', param_name)</font>
<font color="green"> 481.         if location == 'uri':</font>
<font color="green"> 482.             partitioned['uri_path_kwargs'][key_name] = param_value</font>
<font color="green"> 483.         elif location == 'querystring':</font>
<font color="red"> 484.             if isinstance(param_value, dict):</font>
<font color="red"> 485.                 partitioned['query_string_kwargs'].update(param_value)</font>
<font color="red"> 486.             elif isinstance(param_value, bool):</font>
<font color="black"> 487.                 partitioned['query_string_kwargs'][</font>
<font color="red"> 488.                     key_name] = str(param_value).lower()</font>
<font color="black"> 489.             else:</font>
<font color="red"> 490.                 partitioned['query_string_kwargs'][key_name] = param_value</font>
<font color="green"> 491.         elif location == 'header':</font>
<font color="red"> 492.             shape = shape_members[param_name]</font>
<font color="red"> 493.             value = self._convert_header_value(shape, param_value)</font>
<font color="red"> 494.             partitioned['headers'][key_name] = str(value)</font>
<font color="green"> 495.         elif location == 'headers':</font>
<font color="black"> 496.             # 'headers' is a bit of an oddball.  The ``key_name``</font>
<font color="black"> 497.             # is actually really a prefix for the header names:</font>
<font color="red"> 498.             header_prefix = key_name</font>
<font color="black"> 499.             # The value provided by the user is a dict so we'll be</font>
<font color="black"> 500.             # creating multiple header key/val pairs.  The key</font>
<font color="black"> 501.             # name to use for each header is the header_prefix (``key_name``)</font>
<font color="black"> 502.             # plus the key provided by the user.</font>
<font color="red"> 503.             self._do_serialize_header_map(header_prefix,</font>
<font color="red"> 504.                                           partitioned['headers'],</font>
<font color="red"> 505.                                           param_value)</font>
<font color="black"> 506.         else:</font>
<font color="green"> 507.             partitioned['body_kwargs'][param_name] = param_value</font>
<font color="black"> 508. </font>
<font color="green"> 509.     def _do_serialize_header_map(self, header_prefix, headers, user_input):</font>
<font color="red"> 510.         for key, val in user_input.items():</font>
<font color="red"> 511.             full_key = header_prefix + key</font>
<font color="red"> 512.             headers[full_key] = val</font>
<font color="black"> 513. </font>
<font color="green"> 514.     def _serialize_body_params(self, params, shape):</font>
<font color="red"> 515.         raise NotImplementedError('_serialize_body_params')</font>
<font color="black"> 516. </font>
<font color="green"> 517.     def _convert_header_value(self, shape, value):</font>
<font color="red"> 518.         if shape.type_name == 'timestamp':</font>
<font color="red"> 519.             datetime_obj = parse_to_aware_datetime(value)</font>
<font color="red"> 520.             timestamp = calendar.timegm(datetime_obj.utctimetuple())</font>
<font color="red"> 521.             return self._timestamp_rfc822(timestamp)</font>
<font color="red"> 522.         elif is_json_value_header(shape):</font>
<font color="black"> 523.             # Serialize with no spaces after separators to save space in</font>
<font color="black"> 524.             # the header.</font>
<font color="red"> 525.             return self._get_base64(json.dumps(value, separators=(',', ':')))</font>
<font color="black"> 526.         else:</font>
<font color="red"> 527.             return value</font>
<font color="black"> 528. </font>
<font color="black"> 529. </font>
<font color="green"> 530. class RestJSONSerializer(BaseRestSerializer, JSONSerializer):</font>
<font color="black"> 531. </font>
<font color="green"> 532.     def _serialize_body_params(self, params, shape):</font>
<font color="red"> 533.         serialized_body = self.MAP_TYPE()</font>
<font color="red"> 534.         self._serialize(serialized_body, params, shape)</font>
<font color="red"> 535.         return json.dumps(serialized_body).encode(self.DEFAULT_ENCODING)</font>
<font color="black"> 536. </font>
<font color="black"> 537. </font>
<font color="green"> 538. class RestXMLSerializer(BaseRestSerializer):</font>
<font color="green"> 539.     TIMESTAMP_FORMAT = 'iso8601'</font>
<font color="black"> 540. </font>
<font color="green"> 541.     def _serialize_body_params(self, params, shape):</font>
<font color="green"> 542.         root_name = shape.serialization['name']</font>
<font color="green"> 543.         pseudo_root = ElementTree.Element('')</font>
<font color="green"> 544.         self._serialize(shape, params, pseudo_root, root_name)</font>
<font color="green"> 545.         real_root = list(pseudo_root)[0]</font>
<font color="green"> 546.         return ElementTree.tostring(real_root, encoding=self.DEFAULT_ENCODING)</font>
<font color="black"> 547. </font>
<font color="green"> 548.     def _serialize(self, shape, params, xmlnode, name):</font>
<font color="green"> 549.         method = getattr(self, '_serialize_type_%s' % shape.type_name,</font>
<font color="green"> 550.                          self._default_serialize)</font>
<font color="green"> 551.         method(xmlnode, params, shape, name)</font>
<font color="black"> 552. </font>
<font color="green"> 553.     def _serialize_type_structure(self, xmlnode, params, shape, name):</font>
<font color="green"> 554.         structure_node = ElementTree.SubElement(xmlnode, name)</font>
<font color="black"> 555. </font>
<font color="green"> 556.         if 'xmlNamespace' in shape.serialization:</font>
<font color="green"> 557.             namespace_metadata = shape.serialization['xmlNamespace']</font>
<font color="green"> 558.             attribute_name = 'xmlns'</font>
<font color="green"> 559.             if namespace_metadata.get('prefix'):</font>
<font color="red"> 560.                 attribute_name += ':%s' % namespace_metadata['prefix']</font>
<font color="green"> 561.             structure_node.attrib[attribute_name] = namespace_metadata['uri']</font>
<font color="green"> 562.         for key, value in params.items():</font>
<font color="green"> 563.             member_shape = shape.members[key]</font>
<font color="green"> 564.             member_name = member_shape.serialization.get('name', key)</font>
<font color="black"> 565.             # We need to special case member shapes that are marked as an</font>
<font color="black"> 566.             # xmlAttribute.  Rather than serializing into an XML child node,</font>
<font color="black"> 567.             # we instead serialize the shape to an XML attribute of the</font>
<font color="black"> 568.             # *current* node.</font>
<font color="green"> 569.             if value is None:</font>
<font color="black"> 570.                 # Don't serialize any param whose value is None.</font>
<font color="red"> 571.                 return</font>
<font color="green"> 572.             if member_shape.serialization.get('xmlAttribute'):</font>
<font color="black"> 573.                 # xmlAttributes must have a serialization name.</font>
<font color="red"> 574.                 xml_attribute_name = member_shape.serialization['name']</font>
<font color="red"> 575.                 structure_node.attrib[xml_attribute_name] = value</font>
<font color="red"> 576.                 continue</font>
<font color="green"> 577.             self._serialize(member_shape, value, structure_node, member_name)</font>
<font color="black"> 578. </font>
<font color="green"> 579.     def _serialize_type_list(self, xmlnode, params, shape, name):</font>
<font color="green"> 580.         member_shape = shape.member</font>
<font color="green"> 581.         if shape.serialization.get('flattened'):</font>
<font color="green"> 582.             element_name = name</font>
<font color="green"> 583.             list_node = xmlnode</font>
<font color="black"> 584.         else:</font>
<font color="red"> 585.             element_name = member_shape.serialization.get('name', 'member')</font>
<font color="red"> 586.             list_node = ElementTree.SubElement(xmlnode, name)</font>
<font color="green"> 587.         for item in params:</font>
<font color="green"> 588.             self._serialize(member_shape, item, list_node, element_name)</font>
<font color="black"> 589. </font>
<font color="green"> 590.     def _serialize_type_map(self, xmlnode, params, shape, name):</font>
<font color="black"> 591.         # Given the ``name`` of MyMap, and input of {&quot;key1&quot;: &quot;val1&quot;}</font>
<font color="black"> 592.         # we serialize this as:</font>
<font color="black"> 593.         #   &lt;MyMap&gt;</font>
<font color="black"> 594.         #     &lt;entry&gt;</font>
<font color="black"> 595.         #       &lt;key&gt;key1&lt;/key&gt;</font>
<font color="black"> 596.         #       &lt;value&gt;val1&lt;/value&gt;</font>
<font color="black"> 597.         #     &lt;/entry&gt;</font>
<font color="black"> 598.         #  &lt;/MyMap&gt;</font>
<font color="red"> 599.         node = ElementTree.SubElement(xmlnode, name)</font>
<font color="black"> 600.         # TODO: handle flattened maps.</font>
<font color="red"> 601.         for key, value in params.items():</font>
<font color="red"> 602.             entry_node = ElementTree.SubElement(node, 'entry')</font>
<font color="red"> 603.             key_name = self._get_serialized_name(shape.key, default_name='key')</font>
<font color="red"> 604.             val_name = self._get_serialized_name(shape.value,</font>
<font color="red"> 605.                                                  default_name='value')</font>
<font color="red"> 606.             self._serialize(shape.key, key, entry_node, key_name)</font>
<font color="red"> 607.             self._serialize(shape.value, value, entry_node, val_name)</font>
<font color="black"> 608. </font>
<font color="green"> 609.     def _serialize_type_boolean(self, xmlnode, params, shape, name):</font>
<font color="black"> 610.         # For scalar types, the 'params' attr is actually just a scalar</font>
<font color="black"> 611.         # value representing the data we need to serialize as a boolean.</font>
<font color="black"> 612.         # It will either be 'true' or 'false'</font>
<font color="red"> 613.         node = ElementTree.SubElement(xmlnode, name)</font>
<font color="red"> 614.         if params:</font>
<font color="red"> 615.             str_value = 'true'</font>
<font color="black"> 616.         else:</font>
<font color="red"> 617.             str_value = 'false'</font>
<font color="red"> 618.         node.text = str_value</font>
<font color="black"> 619. </font>
<font color="green"> 620.     def _serialize_type_blob(self, xmlnode, params, shape, name):</font>
<font color="red"> 621.         node = ElementTree.SubElement(xmlnode, name)</font>
<font color="red"> 622.         node.text = self._get_base64(params)</font>
<font color="black"> 623. </font>
<font color="green"> 624.     def _serialize_type_timestamp(self, xmlnode, params, shape, name):</font>
<font color="red"> 625.         node = ElementTree.SubElement(xmlnode, name)</font>
<font color="red"> 626.         node.text = self._convert_timestamp_to_str(params)</font>
<font color="black"> 627. </font>
<font color="green"> 628.     def _default_serialize(self, xmlnode, params, shape, name):</font>
<font color="green"> 629.         node = ElementTree.SubElement(xmlnode, name)</font>
<font color="green"> 630.         node.text = six.text_type(params)</font>
<font color="black"> 631. </font>
<font color="black"> 632. </font>
<font color="green"> 633. SERIALIZERS = {</font>
<font color="green"> 634.     'ec2': EC2Serializer,</font>
<font color="green"> 635.     'query': QuerySerializer,</font>
<font color="green"> 636.     'json': JSONSerializer,</font>
<font color="green"> 637.     'rest-json': RestJSONSerializer,</font>
<font color="green"> 638.     'rest-xml': RestXMLSerializer,</font>
<font color="black"> 639. }</font>
</pre>

