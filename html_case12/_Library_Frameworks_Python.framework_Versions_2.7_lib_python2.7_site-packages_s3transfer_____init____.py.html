source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/s3transfer/__init__.py</b><br>


file stats: <b>401 lines, 121 executed: 30.2% covered</b>
<pre>
<font color="black">   1. # Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="black">  13. &quot;&quot;&quot;Abstractions over S3's upload/download operations.</font>
<font color="black">  14. </font>
<font color="black">  15. This module provides high level abstractions for efficient</font>
<font color="black">  16. uploads/downloads.  It handles several things for the user:</font>
<font color="black">  17. </font>
<font color="black">  18. * Automatically switching to multipart transfers when</font>
<font color="black">  19.   a file is over a specific size threshold</font>
<font color="black">  20. * Uploading/downloading a file in parallel</font>
<font color="black">  21. * Throttling based on max bandwidth</font>
<font color="black">  22. * Progress callbacks to monitor transfers</font>
<font color="black">  23. * Retries.  While botocore handles retries for streaming uploads,</font>
<font color="black">  24.   it is not possible for it to handle retries for streaming</font>
<font color="black">  25.   downloads.  This module handles retries for both cases so</font>
<font color="black">  26.   you don't need to implement any retry logic yourself.</font>
<font color="black">  27. </font>
<font color="black">  28. This module has a reasonable set of defaults.  It also allows you</font>
<font color="black">  29. to configure many aspects of the transfer process including:</font>
<font color="black">  30. </font>
<font color="black">  31. * Multipart threshold size</font>
<font color="black">  32. * Max parallel downloads</font>
<font color="black">  33. * Max bandwidth</font>
<font color="black">  34. * Socket timeouts</font>
<font color="black">  35. * Retry amounts</font>
<font color="black">  36. </font>
<font color="black">  37. There is no support for s3-&gt;s3 multipart copies at this</font>
<font color="black">  38. time.</font>
<font color="black">  39. </font>
<font color="black">  40. </font>
<font color="black">  41. .. _ref_s3transfer_usage:</font>
<font color="black">  42. </font>
<font color="black">  43. Usage</font>
<font color="black">  44. =====</font>
<font color="black">  45. </font>
<font color="black">  46. The simplest way to use this module is:</font>
<font color="black">  47. </font>
<font color="black">  48. .. code-block:: python</font>
<font color="black">  49. </font>
<font color="black">  50.     client = boto3.client('s3', 'us-west-2')</font>
<font color="black">  51.     transfer = S3Transfer(client)</font>
<font color="black">  52.     # Upload /tmp/myfile to s3://bucket/key</font>
<font color="black">  53.     transfer.upload_file('/tmp/myfile', 'bucket', 'key')</font>
<font color="black">  54. </font>
<font color="black">  55.     # Download s3://bucket/key to /tmp/myfile</font>
<font color="black">  56.     transfer.download_file('bucket', 'key', '/tmp/myfile')</font>
<font color="black">  57. </font>
<font color="black">  58. The ``upload_file`` and ``download_file`` methods also accept</font>
<font color="black">  59. ``**kwargs``, which will be forwarded through to the corresponding</font>
<font color="black">  60. client operation.  Here are a few examples using ``upload_file``::</font>
<font color="black">  61. </font>
<font color="black">  62.     # Making the object public</font>
<font color="black">  63.     transfer.upload_file('/tmp/myfile', 'bucket', 'key',</font>
<font color="black">  64.                          extra_args={'ACL': 'public-read'})</font>
<font color="black">  65. </font>
<font color="black">  66.     # Setting metadata</font>
<font color="black">  67.     transfer.upload_file('/tmp/myfile', 'bucket', 'key',</font>
<font color="black">  68.                          extra_args={'Metadata': {'a': 'b', 'c': 'd'}})</font>
<font color="black">  69. </font>
<font color="black">  70.     # Setting content type</font>
<font color="black">  71.     transfer.upload_file('/tmp/myfile.json', 'bucket', 'key',</font>
<font color="black">  72.                          extra_args={'ContentType': &quot;application/json&quot;})</font>
<font color="black">  73. </font>
<font color="black">  74. </font>
<font color="black">  75. The ``S3Transfer`` clas also supports progress callbacks so you can</font>
<font color="black">  76. provide transfer progress to users.  Both the ``upload_file`` and</font>
<font color="black">  77. ``download_file`` methods take an optional ``callback`` parameter.</font>
<font color="black">  78. Here's an example of how to print a simple progress percentage</font>
<font color="black">  79. to the user:</font>
<font color="black">  80. </font>
<font color="black">  81. .. code-block:: python</font>
<font color="black">  82. </font>
<font color="black">  83.     class ProgressPercentage(object):</font>
<font color="black">  84.         def __init__(self, filename):</font>
<font color="black">  85.             self._filename = filename</font>
<font color="black">  86.             self._size = float(os.path.getsize(filename))</font>
<font color="black">  87.             self._seen_so_far = 0</font>
<font color="black">  88.             self._lock = threading.Lock()</font>
<font color="black">  89. </font>
<font color="black">  90.         def __call__(self, bytes_amount):</font>
<font color="black">  91.             # To simplify we'll assume this is hooked up</font>
<font color="black">  92.             # to a single filename.</font>
<font color="black">  93.             with self._lock:</font>
<font color="black">  94.                 self._seen_so_far += bytes_amount</font>
<font color="black">  95.                 percentage = (self._seen_so_far / self._size) * 100</font>
<font color="black">  96.                 sys.stdout.write(</font>
<font color="black">  97.                     &quot;\r%s  %s / %s  (%.2f%%)&quot; % (self._filename, self._seen_so_far,</font>
<font color="black">  98.                                                  self._size, percentage))</font>
<font color="black">  99.                 sys.stdout.flush()</font>
<font color="black"> 100. </font>
<font color="black"> 101. </font>
<font color="black"> 102.     transfer = S3Transfer(boto3.client('s3', 'us-west-2'))</font>
<font color="black"> 103.     # Upload /tmp/myfile to s3://bucket/key and print upload progress.</font>
<font color="black"> 104.     transfer.upload_file('/tmp/myfile', 'bucket', 'key',</font>
<font color="black"> 105.                          callback=ProgressPercentage('/tmp/myfile'))</font>
<font color="black"> 106. </font>
<font color="black"> 107. </font>
<font color="black"> 108. </font>
<font color="black"> 109. You can also provide a TransferConfig object to the S3Transfer</font>
<font color="black"> 110. object that gives you more fine grained control over the</font>
<font color="black"> 111. transfer.  For example:</font>
<font color="black"> 112. </font>
<font color="black"> 113. .. code-block:: python</font>
<font color="black"> 114. </font>
<font color="black"> 115.     client = boto3.client('s3', 'us-west-2')</font>
<font color="black"> 116.     config = TransferConfig(</font>
<font color="black"> 117.         multipart_threshold=8 * 1024 * 1024,</font>
<font color="black"> 118.         max_concurrency=10,</font>
<font color="black"> 119.         num_download_attempts=10,</font>
<font color="black"> 120.     )</font>
<font color="black"> 121.     transfer = S3Transfer(client, config)</font>
<font color="black"> 122.     transfer.upload_file('/tmp/foo', 'bucket', 'key')</font>
<font color="black"> 123. </font>
<font color="black"> 124. </font>
<font color="green"> 125. &quot;&quot;&quot;</font>
<font color="green"> 126. import os</font>
<font color="green"> 127. import math</font>
<font color="green"> 128. import functools</font>
<font color="green"> 129. import logging</font>
<font color="green"> 130. import socket</font>
<font color="green"> 131. import threading</font>
<font color="green"> 132. import random</font>
<font color="green"> 133. import string</font>
<font color="green"> 134. import concurrent.futures</font>
<font color="black"> 135. </font>
<font color="green"> 136. from botocore.compat import six</font>
<font color="green"> 137. from botocore.vendored.requests.packages.urllib3.exceptions import \</font>
<font color="black"> 138.     ReadTimeoutError</font>
<font color="green"> 139. from botocore.exceptions import IncompleteReadError</font>
<font color="black"> 140. </font>
<font color="green"> 141. import s3transfer.compat</font>
<font color="green"> 142. from s3transfer.exceptions import RetriesExceededError, S3UploadFailedError</font>
<font color="black"> 143. </font>
<font color="black"> 144. </font>
<font color="green"> 145. __author__ = 'Amazon Web Services'</font>
<font color="green"> 146. __version__ = '0.1.13'</font>
<font color="black"> 147. </font>
<font color="black"> 148. </font>
<font color="green"> 149. class NullHandler(logging.Handler):</font>
<font color="green"> 150.     def emit(self, record):</font>
<font color="red"> 151.         pass</font>
<font color="black"> 152. </font>
<font color="black"> 153. </font>
<font color="green"> 154. logger = logging.getLogger(__name__)</font>
<font color="green"> 155. logger.addHandler(NullHandler())</font>
<font color="black"> 156. </font>
<font color="green"> 157. queue = six.moves.queue</font>
<font color="black"> 158. </font>
<font color="green"> 159. MB = 1024 * 1024</font>
<font color="green"> 160. SHUTDOWN_SENTINEL = object()</font>
<font color="black"> 161. </font>
<font color="black"> 162. </font>
<font color="green"> 163. def random_file_extension(num_digits=8):</font>
<font color="red"> 164.     return ''.join(random.choice(string.hexdigits) for _ in range(num_digits))</font>
<font color="black"> 165. </font>
<font color="black"> 166. </font>
<font color="green"> 167. def disable_upload_callbacks(request, operation_name, **kwargs):</font>
<font color="red"> 168.     if operation_name in ['PutObject', 'UploadPart'] and \</font>
<font color="red"> 169.             hasattr(request.body, 'disable_callback'):</font>
<font color="red"> 170.         request.body.disable_callback()</font>
<font color="black"> 171. </font>
<font color="black"> 172. </font>
<font color="green"> 173. def enable_upload_callbacks(request, operation_name, **kwargs):</font>
<font color="red"> 174.     if operation_name in ['PutObject', 'UploadPart'] and \</font>
<font color="red"> 175.             hasattr(request.body, 'enable_callback'):</font>
<font color="red"> 176.         request.body.enable_callback()</font>
<font color="black"> 177. </font>
<font color="black"> 178. </font>
<font color="green"> 179. class QueueShutdownError(Exception):</font>
<font color="green"> 180.     pass</font>
<font color="black"> 181. </font>
<font color="black"> 182. </font>
<font color="green"> 183. class ReadFileChunk(object):</font>
<font color="black"> 184.     def __init__(self, fileobj, start_byte, chunk_size, full_file_size,</font>
<font color="green"> 185.                  callback=None, enable_callback=True):</font>
<font color="black"> 186.         &quot;&quot;&quot;</font>
<font color="black"> 187. </font>
<font color="black"> 188.         Given a file object shown below:</font>
<font color="black"> 189. </font>
<font color="black"> 190.             |___________________________________________________|</font>
<font color="black"> 191.             0          |                 |                 full_file_size</font>
<font color="black"> 192.                        |----chunk_size---|</font>
<font color="black"> 193.                  start_byte</font>
<font color="black"> 194. </font>
<font color="black"> 195.         :type fileobj: file</font>
<font color="black"> 196.         :param fileobj: File like object</font>
<font color="black"> 197. </font>
<font color="black"> 198.         :type start_byte: int</font>
<font color="black"> 199.         :param start_byte: The first byte from which to start reading.</font>
<font color="black"> 200. </font>
<font color="black"> 201.         :type chunk_size: int</font>
<font color="black"> 202.         :param chunk_size: The max chunk size to read.  Trying to read</font>
<font color="black"> 203.             pass the end of the chunk size will behave like you've</font>
<font color="black"> 204.             reached the end of the file.</font>
<font color="black"> 205. </font>
<font color="black"> 206.         :type full_file_size: int</font>
<font color="black"> 207.         :param full_file_size: The entire content length associated</font>
<font color="black"> 208.             with ``fileobj``.</font>
<font color="black"> 209. </font>
<font color="black"> 210.         :type callback: function(amount_read)</font>
<font color="black"> 211.         :param callback: Called whenever data is read from this object.</font>
<font color="black"> 212. </font>
<font color="black"> 213.         &quot;&quot;&quot;</font>
<font color="red"> 214.         self._fileobj = fileobj</font>
<font color="red"> 215.         self._start_byte = start_byte</font>
<font color="red"> 216.         self._size = self._calculate_file_size(</font>
<font color="red"> 217.             self._fileobj, requested_size=chunk_size,</font>
<font color="red"> 218.             start_byte=start_byte, actual_file_size=full_file_size)</font>
<font color="red"> 219.         self._fileobj.seek(self._start_byte)</font>
<font color="red"> 220.         self._amount_read = 0</font>
<font color="red"> 221.         self._callback = callback</font>
<font color="red"> 222.         self._callback_enabled = enable_callback</font>
<font color="black"> 223. </font>
<font color="green"> 224.     @classmethod</font>
<font color="green"> 225.     def from_filename(cls, filename, start_byte, chunk_size, callback=None,</font>
<font color="green"> 226.                       enable_callback=True):</font>
<font color="black"> 227.         &quot;&quot;&quot;Convenience factory function to create from a filename.</font>
<font color="black"> 228. </font>
<font color="black"> 229.         :type start_byte: int</font>
<font color="black"> 230.         :param start_byte: The first byte from which to start reading.</font>
<font color="black"> 231. </font>
<font color="black"> 232.         :type chunk_size: int</font>
<font color="black"> 233.         :param chunk_size: The max chunk size to read.  Trying to read</font>
<font color="black"> 234.             pass the end of the chunk size will behave like you've</font>
<font color="black"> 235.             reached the end of the file.</font>
<font color="black"> 236. </font>
<font color="black"> 237.         :type full_file_size: int</font>
<font color="black"> 238.         :param full_file_size: The entire content length associated</font>
<font color="black"> 239.             with ``fileobj``.</font>
<font color="black"> 240. </font>
<font color="black"> 241.         :type callback: function(amount_read)</font>
<font color="black"> 242.         :param callback: Called whenever data is read from this object.</font>
<font color="black"> 243. </font>
<font color="black"> 244.         :type enable_callback: bool</font>
<font color="black"> 245.         :param enable_callback: Indicate whether to invoke callback</font>
<font color="black"> 246.             during read() calls.</font>
<font color="black"> 247. </font>
<font color="black"> 248.         :rtype: ``ReadFileChunk``</font>
<font color="black"> 249.         :return: A new instance of ``ReadFileChunk``</font>
<font color="black"> 250. </font>
<font color="black"> 251.         &quot;&quot;&quot;</font>
<font color="red"> 252.         f = open(filename, 'rb')</font>
<font color="red"> 253.         file_size = os.fstat(f.fileno()).st_size</font>
<font color="red"> 254.         return cls(f, start_byte, chunk_size, file_size, callback,</font>
<font color="red"> 255.                    enable_callback)</font>
<font color="black"> 256. </font>
<font color="green"> 257.     def _calculate_file_size(self, fileobj, requested_size, start_byte,</font>
<font color="black"> 258.                              actual_file_size):</font>
<font color="red"> 259.         max_chunk_size = actual_file_size - start_byte</font>
<font color="red"> 260.         return min(max_chunk_size, requested_size)</font>
<font color="black"> 261. </font>
<font color="green"> 262.     def read(self, amount=None):</font>
<font color="red"> 263.         if amount is None:</font>
<font color="red"> 264.             amount_to_read = self._size - self._amount_read</font>
<font color="black"> 265.         else:</font>
<font color="red"> 266.             amount_to_read = min(self._size - self._amount_read, amount)</font>
<font color="red"> 267.         data = self._fileobj.read(amount_to_read)</font>
<font color="red"> 268.         self._amount_read += len(data)</font>
<font color="red"> 269.         if self._callback is not None and self._callback_enabled:</font>
<font color="red"> 270.             self._callback(len(data))</font>
<font color="red"> 271.         return data</font>
<font color="black"> 272. </font>
<font color="green"> 273.     def enable_callback(self):</font>
<font color="red"> 274.         self._callback_enabled = True</font>
<font color="black"> 275. </font>
<font color="green"> 276.     def disable_callback(self):</font>
<font color="red"> 277.         self._callback_enabled = False</font>
<font color="black"> 278. </font>
<font color="green"> 279.     def seek(self, where):</font>
<font color="red"> 280.         self._fileobj.seek(self._start_byte + where)</font>
<font color="red"> 281.         if self._callback is not None and self._callback_enabled:</font>
<font color="black"> 282.             # To also rewind the callback() for an accurate progress report</font>
<font color="red"> 283.             self._callback(where - self._amount_read)</font>
<font color="red"> 284.         self._amount_read = where</font>
<font color="black"> 285. </font>
<font color="green"> 286.     def close(self):</font>
<font color="red"> 287.         self._fileobj.close()</font>
<font color="black"> 288. </font>
<font color="green"> 289.     def tell(self):</font>
<font color="red"> 290.         return self._amount_read</font>
<font color="black"> 291. </font>
<font color="green"> 292.     def __len__(self):</font>
<font color="black"> 293.         # __len__ is defined because requests will try to determine the length</font>
<font color="black"> 294.         # of the stream to set a content length.  In the normal case</font>
<font color="black"> 295.         # of the file it will just stat the file, but we need to change that</font>
<font color="black"> 296.         # behavior.  By providing a __len__, requests will use that instead</font>
<font color="black"> 297.         # of stat'ing the file.</font>
<font color="red"> 298.         return self._size</font>
<font color="black"> 299. </font>
<font color="green"> 300.     def __enter__(self):</font>
<font color="red"> 301.         return self</font>
<font color="black"> 302. </font>
<font color="green"> 303.     def __exit__(self, *args, **kwargs):</font>
<font color="red"> 304.         self.close()</font>
<font color="black"> 305. </font>
<font color="green"> 306.     def __iter__(self):</font>
<font color="black"> 307.         # This is a workaround for http://bugs.python.org/issue17575</font>
<font color="black"> 308.         # Basically httplib will try to iterate over the contents, even</font>
<font color="black"> 309.         # if its a file like object.  This wasn't noticed because we've</font>
<font color="black"> 310.         # already exhausted the stream so iterating over the file immediately</font>
<font color="black"> 311.         # stops, which is what we're simulating here.</font>
<font color="red"> 312.         return iter([])</font>
<font color="black"> 313. </font>
<font color="black"> 314. </font>
<font color="green"> 315. class StreamReaderProgress(object):</font>
<font color="green"> 316.     &quot;&quot;&quot;Wrapper for a read only stream that adds progress callbacks.&quot;&quot;&quot;</font>
<font color="green"> 317.     def __init__(self, stream, callback=None):</font>
<font color="red"> 318.         self._stream = stream</font>
<font color="red"> 319.         self._callback = callback</font>
<font color="black"> 320. </font>
<font color="green"> 321.     def read(self, *args, **kwargs):</font>
<font color="red"> 322.         value = self._stream.read(*args, **kwargs)</font>
<font color="red"> 323.         if self._callback is not None:</font>
<font color="red"> 324.             self._callback(len(value))</font>
<font color="red"> 325.         return value</font>
<font color="black"> 326. </font>
<font color="black"> 327. </font>
<font color="green"> 328. class OSUtils(object):</font>
<font color="green"> 329.     def get_file_size(self, filename):</font>
<font color="red"> 330.         return os.path.getsize(filename)</font>
<font color="black"> 331. </font>
<font color="green"> 332.     def open_file_chunk_reader(self, filename, start_byte, size, callback):</font>
<font color="red"> 333.         return ReadFileChunk.from_filename(filename, start_byte,</font>
<font color="red"> 334.                                            size, callback,</font>
<font color="red"> 335.                                            enable_callback=False)</font>
<font color="black"> 336. </font>
<font color="green"> 337.     def open(self, filename, mode):</font>
<font color="red"> 338.         return open(filename, mode)</font>
<font color="black"> 339. </font>
<font color="green"> 340.     def remove_file(self, filename):</font>
<font color="black"> 341.         &quot;&quot;&quot;Remove a file, noop if file does not exist.&quot;&quot;&quot;</font>
<font color="black"> 342.         # Unlike os.remove, if the file does not exist,</font>
<font color="black"> 343.         # then this method does nothing.</font>
<font color="red"> 344.         try:</font>
<font color="red"> 345.             os.remove(filename)</font>
<font color="red"> 346.         except OSError:</font>
<font color="red"> 347.             pass</font>
<font color="black"> 348. </font>
<font color="green"> 349.     def rename_file(self, current_filename, new_filename):</font>
<font color="red"> 350.         s3transfer.compat.rename_file(current_filename, new_filename)</font>
<font color="black"> 351. </font>
<font color="black"> 352. </font>
<font color="green"> 353. class MultipartUploader(object):</font>
<font color="black"> 354.     # These are the extra_args that need to be forwarded onto</font>
<font color="black"> 355.     # subsequent upload_parts.</font>
<font color="black"> 356.     UPLOAD_PART_ARGS = [</font>
<font color="green"> 357.         'SSECustomerKey',</font>
<font color="green"> 358.         'SSECustomerAlgorithm',</font>
<font color="green"> 359.         'SSECustomerKeyMD5',</font>
<font color="green"> 360.         'RequestPayer',</font>
<font color="black"> 361.     ]</font>
<font color="black"> 362. </font>
<font color="black"> 363.     def __init__(self, client, config, osutil,</font>
<font color="green"> 364.                  executor_cls=concurrent.futures.ThreadPoolExecutor):</font>
<font color="red"> 365.         self._client = client</font>
<font color="red"> 366.         self._config = config</font>
<font color="red"> 367.         self._os = osutil</font>
<font color="red"> 368.         self._executor_cls = executor_cls</font>
<font color="black"> 369. </font>
<font color="green"> 370.     def _extra_upload_part_args(self, extra_args):</font>
<font color="black"> 371.         # Only the args in UPLOAD_PART_ARGS actually need to be passed</font>
<font color="black"> 372.         # onto the upload_part calls.</font>
<font color="red"> 373.         upload_parts_args = {}</font>
<font color="red"> 374.         for key, value in extra_args.items():</font>
<font color="red"> 375.             if key in self.UPLOAD_PART_ARGS:</font>
<font color="red"> 376.                 upload_parts_args[key] = value</font>
<font color="red"> 377.         return upload_parts_args</font>
<font color="black"> 378. </font>
<font color="green"> 379.     def upload_file(self, filename, bucket, key, callback, extra_args):</font>
<font color="red"> 380.         response = self._client.create_multipart_upload(Bucket=bucket,</font>
<font color="red"> 381.                                                         Key=key, **extra_args)</font>
<font color="red"> 382.         upload_id = response['UploadId']</font>
<font color="red"> 383.         try:</font>
<font color="red"> 384.             parts = self._upload_parts(upload_id, filename, bucket, key,</font>
<font color="red"> 385.                                        callback, extra_args)</font>
<font color="red"> 386.         except Exception as e:</font>
<font color="red"> 387.             logger.debug(&quot;Exception raised while uploading parts, &quot;</font>
<font color="red"> 388.                          &quot;aborting multipart upload.&quot;, exc_info=True)</font>
<font color="red"> 389.             self._client.abort_multipart_upload(</font>
<font color="red"> 390.                 Bucket=bucket, Key=key, UploadId=upload_id)</font>
<font color="red"> 391.             raise S3UploadFailedError(</font>
<font color="red"> 392.                 &quot;Failed to upload %s to %s: %s&quot; % (</font>
<font color="red"> 393.                     filename, '/'.join([bucket, key]), e))</font>
<font color="red"> 394.         self._client.complete_multipart_upload(</font>
<font color="red"> 395.             Bucket=bucket, Key=key, UploadId=upload_id,</font>
<font color="red"> 396.             MultipartUpload={'Parts': parts})</font>
<font color="black"> 397. </font>
<font color="green"> 398.     def _upload_parts(self, upload_id, filename, bucket, key, callback,</font>
<font color="black"> 399.                       extra_args):</font>
<font color="red"> 400.         upload_parts_extra_args = self._extra_upload_part_args(extra_args)</font>
<font color="red"> 401.         parts = []</font>
<font color="red"> 402.         part_size = self._config.multipart_chunksize</font>
<font color="red"> 403.         num_parts = int(</font>
<font color="red"> 404.             math.ceil(self._os.get_file_size(filename) / float(part_size)))</font>
<font color="red"> 405.         max_workers = self._config.max_concurrency</font>
<font color="red"> 406.         with self._executor_cls(max_workers=max_workers) as executor:</font>
<font color="red"> 407.             upload_partial = functools.partial(</font>
<font color="red"> 408.                 self._upload_one_part, filename, bucket, key, upload_id,</font>
<font color="red"> 409.                 part_size, upload_parts_extra_args, callback)</font>
<font color="red"> 410.             for part in executor.map(upload_partial, range(1, num_parts + 1)):</font>
<font color="red"> 411.                 parts.append(part)</font>
<font color="red"> 412.         return parts</font>
<font color="black"> 413. </font>
<font color="green"> 414.     def _upload_one_part(self, filename, bucket, key,</font>
<font color="black"> 415.                          upload_id, part_size, extra_args,</font>
<font color="black"> 416.                          callback, part_number):</font>
<font color="red"> 417.         open_chunk_reader = self._os.open_file_chunk_reader</font>
<font color="red"> 418.         with open_chunk_reader(filename, part_size * (part_number - 1),</font>
<font color="red"> 419.                                part_size, callback) as body:</font>
<font color="red"> 420.             response = self._client.upload_part(</font>
<font color="red"> 421.                 Bucket=bucket, Key=key,</font>
<font color="red"> 422.                 UploadId=upload_id, PartNumber=part_number, Body=body,</font>
<font color="red"> 423.                 **extra_args)</font>
<font color="red"> 424.             etag = response['ETag']</font>
<font color="red"> 425.             return {'ETag': etag, 'PartNumber': part_number}</font>
<font color="black"> 426. </font>
<font color="black"> 427. </font>
<font color="green"> 428. class ShutdownQueue(queue.Queue):</font>
<font color="black"> 429.     &quot;&quot;&quot;A queue implementation that can be shutdown.</font>
<font color="black"> 430. </font>
<font color="black"> 431.     Shutting down a queue means that this class adds a</font>
<font color="black"> 432.     trigger_shutdown method that will trigger all subsequent</font>
<font color="black"> 433.     calls to put() to fail with a ``QueueShutdownError``.</font>
<font color="black"> 434. </font>
<font color="black"> 435.     It purposefully deviates from queue.Queue, and is *not* meant</font>
<font color="black"> 436.     to be a drop in replacement for ``queue.Queue``.</font>
<font color="black"> 437. </font>
<font color="green"> 438.     &quot;&quot;&quot;</font>
<font color="green"> 439.     def _init(self, maxsize):</font>
<font color="red"> 440.         self._shutdown = False</font>
<font color="red"> 441.         self._shutdown_lock = threading.Lock()</font>
<font color="black"> 442.         # queue.Queue is an old style class so we don't use super().</font>
<font color="red"> 443.         return queue.Queue._init(self, maxsize)</font>
<font color="black"> 444. </font>
<font color="green"> 445.     def trigger_shutdown(self):</font>
<font color="red"> 446.         with self._shutdown_lock:</font>
<font color="red"> 447.             self._shutdown = True</font>
<font color="red"> 448.             logger.debug(&quot;The IO queue is now shutdown.&quot;)</font>
<font color="black"> 449. </font>
<font color="green"> 450.     def put(self, item):</font>
<font color="black"> 451.         # Note: this is not sufficient, it's still possible to deadlock!</font>
<font color="black"> 452.         # Need to hook into the condition vars used by this class.</font>
<font color="red"> 453.         with self._shutdown_lock:</font>
<font color="red"> 454.             if self._shutdown:</font>
<font color="red"> 455.                 raise QueueShutdownError(&quot;Cannot put item to queue when &quot;</font>
<font color="black"> 456.                                          &quot;queue has been shutdown.&quot;)</font>
<font color="red"> 457.         return queue.Queue.put(self, item)</font>
<font color="black"> 458. </font>
<font color="black"> 459. </font>
<font color="green"> 460. class MultipartDownloader(object):</font>
<font color="black"> 461.     def __init__(self, client, config, osutil,</font>
<font color="green"> 462.                  executor_cls=concurrent.futures.ThreadPoolExecutor):</font>
<font color="red"> 463.         self._client = client</font>
<font color="red"> 464.         self._config = config</font>
<font color="red"> 465.         self._os = osutil</font>
<font color="red"> 466.         self._executor_cls = executor_cls</font>
<font color="red"> 467.         self._ioqueue = ShutdownQueue(self._config.max_io_queue)</font>
<font color="black"> 468. </font>
<font color="black"> 469.     def download_file(self, bucket, key, filename, object_size,</font>
<font color="green"> 470.                       extra_args, callback=None):</font>
<font color="red"> 471.         with self._executor_cls(max_workers=2) as controller:</font>
<font color="black"> 472.             # 1 thread for the future that manages the uploading of files</font>
<font color="black"> 473.             # 1 thread for the future that manages IO writes.</font>
<font color="red"> 474.             download_parts_handler = functools.partial(</font>
<font color="red"> 475.                 self._download_file_as_future,</font>
<font color="red"> 476.                 bucket, key, filename, object_size, callback)</font>
<font color="red"> 477.             parts_future = controller.submit(download_parts_handler)</font>
<font color="black"> 478. </font>
<font color="red"> 479.             io_writes_handler = functools.partial(</font>
<font color="red"> 480.                 self._perform_io_writes, filename)</font>
<font color="red"> 481.             io_future = controller.submit(io_writes_handler)</font>
<font color="red"> 482.             results = concurrent.futures.wait(</font>
<font color="red"> 483.                 [parts_future, io_future],</font>
<font color="red"> 484.                 return_when=concurrent.futures.FIRST_EXCEPTION)</font>
<font color="red"> 485.             self._process_future_results(results)</font>
<font color="black"> 486. </font>
<font color="green"> 487.     def _process_future_results(self, futures):</font>
<font color="red"> 488.         finished, unfinished = futures</font>
<font color="red"> 489.         for future in finished:</font>
<font color="red"> 490.             future.result()</font>
<font color="black"> 491. </font>
<font color="green"> 492.     def _download_file_as_future(self, bucket, key, filename, object_size,</font>
<font color="black"> 493.                                  callback):</font>
<font color="red"> 494.         part_size = self._config.multipart_chunksize</font>
<font color="red"> 495.         num_parts = int(math.ceil(object_size / float(part_size)))</font>
<font color="red"> 496.         max_workers = self._config.max_concurrency</font>
<font color="red"> 497.         download_partial = functools.partial(</font>
<font color="red"> 498.             self._download_range, bucket, key, filename,</font>
<font color="red"> 499.             part_size, num_parts, callback)</font>
<font color="red"> 500.         try:</font>
<font color="red"> 501.             with self._executor_cls(max_workers=max_workers) as executor:</font>
<font color="red"> 502.                 list(executor.map(download_partial, range(num_parts)))</font>
<font color="black"> 503.         finally:</font>
<font color="red"> 504.             self._ioqueue.put(SHUTDOWN_SENTINEL)</font>
<font color="black"> 505. </font>
<font color="green"> 506.     def _calculate_range_param(self, part_size, part_index, num_parts):</font>
<font color="red"> 507.         start_range = part_index * part_size</font>
<font color="red"> 508.         if part_index == num_parts - 1:</font>
<font color="red"> 509.             end_range = ''</font>
<font color="black"> 510.         else:</font>
<font color="red"> 511.             end_range = start_range + part_size - 1</font>
<font color="red"> 512.         range_param = 'bytes=%s-%s' % (start_range, end_range)</font>
<font color="red"> 513.         return range_param</font>
<font color="black"> 514. </font>
<font color="green"> 515.     def _download_range(self, bucket, key, filename,</font>
<font color="black"> 516.                         part_size, num_parts, callback, part_index):</font>
<font color="red"> 517.         try:</font>
<font color="red"> 518.             range_param = self._calculate_range_param(</font>
<font color="red"> 519.                 part_size, part_index, num_parts)</font>
<font color="black"> 520. </font>
<font color="red"> 521.             max_attempts = self._config.num_download_attempts</font>
<font color="red"> 522.             last_exception = None</font>
<font color="red"> 523.             for i in range(max_attempts):</font>
<font color="red"> 524.                 try:</font>
<font color="red"> 525.                     logger.debug(&quot;Making get_object call.&quot;)</font>
<font color="red"> 526.                     response = self._client.get_object(</font>
<font color="red"> 527.                         Bucket=bucket, Key=key, Range=range_param)</font>
<font color="red"> 528.                     streaming_body = StreamReaderProgress(</font>
<font color="red"> 529.                         response['Body'], callback)</font>
<font color="red"> 530.                     buffer_size = 1024 * 16</font>
<font color="red"> 531.                     current_index = part_size * part_index</font>
<font color="red"> 532.                     for chunk in iter(lambda: streaming_body.read(buffer_size),</font>
<font color="red"> 533.                                       b''):</font>
<font color="red"> 534.                         self._ioqueue.put((current_index, chunk))</font>
<font color="red"> 535.                         current_index += len(chunk)</font>
<font color="red"> 536.                     return</font>
<font color="red"> 537.                 except (socket.timeout, socket.error,</font>
<font color="red"> 538.                         ReadTimeoutError, IncompleteReadError) as e:</font>
<font color="red"> 539.                     logger.debug(&quot;Retrying exception caught (%s), &quot;</font>
<font color="red"> 540.                                  &quot;retrying request, (attempt %s / %s)&quot;, e, i,</font>
<font color="red"> 541.                                  max_attempts, exc_info=True)</font>
<font color="red"> 542.                     last_exception = e</font>
<font color="red"> 543.                     continue</font>
<font color="red"> 544.             raise RetriesExceededError(last_exception)</font>
<font color="black"> 545.         finally:</font>
<font color="red"> 546.             logger.debug(&quot;EXITING _download_range for part: %s&quot;, part_index)</font>
<font color="black"> 547. </font>
<font color="green"> 548.     def _perform_io_writes(self, filename):</font>
<font color="red"> 549.         with self._os.open(filename, 'wb') as f:</font>
<font color="red"> 550.             while True:</font>
<font color="red"> 551.                 task = self._ioqueue.get()</font>
<font color="red"> 552.                 if task is SHUTDOWN_SENTINEL:</font>
<font color="red"> 553.                     logger.debug(&quot;Shutdown sentinel received in IO handler, &quot;</font>
<font color="black"> 554.                                  &quot;shutting down IO handler.&quot;)</font>
<font color="red"> 555.                     return</font>
<font color="black"> 556.                 else:</font>
<font color="red"> 557.                     try:</font>
<font color="red"> 558.                         offset, data = task</font>
<font color="red"> 559.                         f.seek(offset)</font>
<font color="red"> 560.                         f.write(data)</font>
<font color="red"> 561.                     except Exception as e:</font>
<font color="red"> 562.                         logger.debug(&quot;Caught exception in IO thread: %s&quot;,</font>
<font color="red"> 563.                                      e, exc_info=True)</font>
<font color="red"> 564.                         self._ioqueue.trigger_shutdown()</font>
<font color="red"> 565.                         raise</font>
<font color="black"> 566. </font>
<font color="black"> 567. </font>
<font color="green"> 568. class TransferConfig(object):</font>
<font color="black"> 569.     def __init__(self,</font>
<font color="green"> 570.                  multipart_threshold=8 * MB,</font>
<font color="green"> 571.                  max_concurrency=10,</font>
<font color="green"> 572.                  multipart_chunksize=8 * MB,</font>
<font color="green"> 573.                  num_download_attempts=5,</font>
<font color="green"> 574.                  max_io_queue=100):</font>
<font color="red"> 575.         self.multipart_threshold = multipart_threshold</font>
<font color="red"> 576.         self.max_concurrency = max_concurrency</font>
<font color="red"> 577.         self.multipart_chunksize = multipart_chunksize</font>
<font color="red"> 578.         self.num_download_attempts = num_download_attempts</font>
<font color="red"> 579.         self.max_io_queue = max_io_queue</font>
<font color="black"> 580. </font>
<font color="black"> 581. </font>
<font color="green"> 582. class S3Transfer(object):</font>
<font color="black"> 583. </font>
<font color="black"> 584.     ALLOWED_DOWNLOAD_ARGS = [</font>
<font color="green"> 585.         'VersionId',</font>
<font color="green"> 586.         'SSECustomerAlgorithm',</font>
<font color="green"> 587.         'SSECustomerKey',</font>
<font color="green"> 588.         'SSECustomerKeyMD5',</font>
<font color="green"> 589.         'RequestPayer',</font>
<font color="black"> 590.     ]</font>
<font color="black"> 591. </font>
<font color="black"> 592.     ALLOWED_UPLOAD_ARGS = [</font>
<font color="green"> 593.         'ACL',</font>
<font color="green"> 594.         'CacheControl',</font>
<font color="green"> 595.         'ContentDisposition',</font>
<font color="green"> 596.         'ContentEncoding',</font>
<font color="green"> 597.         'ContentLanguage',</font>
<font color="green"> 598.         'ContentType',</font>
<font color="green"> 599.         'Expires',</font>
<font color="green"> 600.         'GrantFullControl',</font>
<font color="green"> 601.         'GrantRead',</font>
<font color="green"> 602.         'GrantReadACP',</font>
<font color="green"> 603.         'GrantWriteACL',</font>
<font color="green"> 604.         'Metadata',</font>
<font color="green"> 605.         'RequestPayer',</font>
<font color="green"> 606.         'ServerSideEncryption',</font>
<font color="green"> 607.         'StorageClass',</font>
<font color="green"> 608.         'SSECustomerAlgorithm',</font>
<font color="green"> 609.         'SSECustomerKey',</font>
<font color="green"> 610.         'SSECustomerKeyMD5',</font>
<font color="green"> 611.         'SSEKMSKeyId',</font>
<font color="black"> 612.     ]</font>
<font color="black"> 613. </font>
<font color="green"> 614.     def __init__(self, client, config=None, osutil=None):</font>
<font color="red"> 615.         self._client = client</font>
<font color="red"> 616.         if config is None:</font>
<font color="red"> 617.             config = TransferConfig()</font>
<font color="red"> 618.         self._config = config</font>
<font color="red"> 619.         if osutil is None:</font>
<font color="red"> 620.             osutil = OSUtils()</font>
<font color="red"> 621.         self._osutil = osutil</font>
<font color="black"> 622. </font>
<font color="black"> 623.     def upload_file(self, filename, bucket, key,</font>
<font color="green"> 624.                     callback=None, extra_args=None):</font>
<font color="black"> 625.         &quot;&quot;&quot;Upload a file to an S3 object.</font>
<font color="black"> 626. </font>
<font color="black"> 627.         Variants have also been injected into S3 client, Bucket and Object.</font>
<font color="black"> 628.         You don't have to use S3Transfer.upload_file() directly.</font>
<font color="black"> 629.         &quot;&quot;&quot;</font>
<font color="red"> 630.         if extra_args is None:</font>
<font color="red"> 631.             extra_args = {}</font>
<font color="red"> 632.         self._validate_all_known_args(extra_args, self.ALLOWED_UPLOAD_ARGS)</font>
<font color="red"> 633.         events = self._client.meta.events</font>
<font color="red"> 634.         events.register_first('request-created.s3',</font>
<font color="red"> 635.                               disable_upload_callbacks,</font>
<font color="red"> 636.                               unique_id='s3upload-callback-disable')</font>
<font color="red"> 637.         events.register_last('request-created.s3',</font>
<font color="red"> 638.                              enable_upload_callbacks,</font>
<font color="red"> 639.                              unique_id='s3upload-callback-enable')</font>
<font color="red"> 640.         if self._osutil.get_file_size(filename) &gt;= \</font>
<font color="red"> 641.                 self._config.multipart_threshold:</font>
<font color="red"> 642.             self._multipart_upload(filename, bucket, key, callback, extra_args)</font>
<font color="black"> 643.         else:</font>
<font color="red"> 644.             self._put_object(filename, bucket, key, callback, extra_args)</font>
<font color="black"> 645. </font>
<font color="green"> 646.     def _put_object(self, filename, bucket, key, callback, extra_args):</font>
<font color="black"> 647.         # We're using open_file_chunk_reader so we can take advantage of the</font>
<font color="black"> 648.         # progress callback functionality.</font>
<font color="red"> 649.         open_chunk_reader = self._osutil.open_file_chunk_reader</font>
<font color="red"> 650.         with open_chunk_reader(filename, 0,</font>
<font color="red"> 651.                                self._osutil.get_file_size(filename),</font>
<font color="red"> 652.                                callback=callback) as body:</font>
<font color="red"> 653.             self._client.put_object(Bucket=bucket, Key=key, Body=body,</font>
<font color="red"> 654.                                     **extra_args)</font>
<font color="black"> 655. </font>
<font color="green"> 656.     def download_file(self, bucket, key, filename, extra_args=None,</font>
<font color="green"> 657.                       callback=None):</font>
<font color="black"> 658.         &quot;&quot;&quot;Download an S3 object to a file.</font>
<font color="black"> 659. </font>
<font color="black"> 660.         Variants have also been injected into S3 client, Bucket and Object.</font>
<font color="black"> 661.         You don't have to use S3Transfer.download_file() directly.</font>
<font color="black"> 662.         &quot;&quot;&quot;</font>
<font color="black"> 663.         # This method will issue a ``head_object`` request to determine</font>
<font color="black"> 664.         # the size of the S3 object.  This is used to determine if the</font>
<font color="black"> 665.         # object is downloaded in parallel.</font>
<font color="red"> 666.         if extra_args is None:</font>
<font color="red"> 667.             extra_args = {}</font>
<font color="red"> 668.         self._validate_all_known_args(extra_args, self.ALLOWED_DOWNLOAD_ARGS)</font>
<font color="red"> 669.         object_size = self._object_size(bucket, key, extra_args)</font>
<font color="red"> 670.         temp_filename = filename + os.extsep + random_file_extension()</font>
<font color="red"> 671.         try:</font>
<font color="red"> 672.             self._download_file(bucket, key, temp_filename, object_size,</font>
<font color="red"> 673.                                 extra_args, callback)</font>
<font color="red"> 674.         except Exception:</font>
<font color="red"> 675.             logger.debug(&quot;Exception caught in download_file, removing partial &quot;</font>
<font color="red"> 676.                          &quot;file: %s&quot;, temp_filename, exc_info=True)</font>
<font color="red"> 677.             self._osutil.remove_file(temp_filename)</font>
<font color="red"> 678.             raise</font>
<font color="black"> 679.         else:</font>
<font color="red"> 680.             self._osutil.rename_file(temp_filename, filename)</font>
<font color="black"> 681. </font>
<font color="green"> 682.     def _download_file(self, bucket, key, filename, object_size,</font>
<font color="black"> 683.                        extra_args, callback):</font>
<font color="red"> 684.         if object_size &gt;= self._config.multipart_threshold:</font>
<font color="red"> 685.             self._ranged_download(bucket, key, filename, object_size,</font>
<font color="red"> 686.                                   extra_args, callback)</font>
<font color="black"> 687.         else:</font>
<font color="red"> 688.             self._get_object(bucket, key, filename, extra_args, callback)</font>
<font color="black"> 689. </font>
<font color="green"> 690.     def _validate_all_known_args(self, actual, allowed):</font>
<font color="red"> 691.         for kwarg in actual:</font>
<font color="red"> 692.             if kwarg not in allowed:</font>
<font color="red"> 693.                 raise ValueError(</font>
<font color="red"> 694.                     &quot;Invalid extra_args key '%s', &quot;</font>
<font color="black"> 695.                     &quot;must be one of: %s&quot; % (</font>
<font color="red"> 696.                         kwarg, ', '.join(allowed)))</font>
<font color="black"> 697. </font>
<font color="green"> 698.     def _ranged_download(self, bucket, key, filename, object_size,</font>
<font color="black"> 699.                          extra_args, callback):</font>
<font color="red"> 700.         downloader = MultipartDownloader(self._client, self._config,</font>
<font color="red"> 701.                                          self._osutil)</font>
<font color="red"> 702.         downloader.download_file(bucket, key, filename, object_size,</font>
<font color="red"> 703.                                  extra_args, callback)</font>
<font color="black"> 704. </font>
<font color="green"> 705.     def _get_object(self, bucket, key, filename, extra_args, callback):</font>
<font color="black"> 706.         # precondition: num_download_attempts &gt; 0</font>
<font color="red"> 707.         max_attempts = self._config.num_download_attempts</font>
<font color="red"> 708.         last_exception = None</font>
<font color="red"> 709.         for i in range(max_attempts):</font>
<font color="red"> 710.             try:</font>
<font color="red"> 711.                 return self._do_get_object(bucket, key, filename,</font>
<font color="red"> 712.                                            extra_args, callback)</font>
<font color="red"> 713.             except (socket.timeout, socket.error,</font>
<font color="red"> 714.                     ReadTimeoutError, IncompleteReadError) as e:</font>
<font color="black"> 715.                 # TODO: we need a way to reset the callback if the</font>
<font color="black"> 716.                 # download failed.</font>
<font color="red"> 717.                 logger.debug(&quot;Retrying exception caught (%s), &quot;</font>
<font color="red"> 718.                              &quot;retrying request, (attempt %s / %s)&quot;, e, i,</font>
<font color="red"> 719.                              max_attempts, exc_info=True)</font>
<font color="red"> 720.                 last_exception = e</font>
<font color="red"> 721.                 continue</font>
<font color="red"> 722.         raise RetriesExceededError(last_exception)</font>
<font color="black"> 723. </font>
<font color="green"> 724.     def _do_get_object(self, bucket, key, filename, extra_args, callback):</font>
<font color="red"> 725.         response = self._client.get_object(Bucket=bucket, Key=key,</font>
<font color="red"> 726.                                            **extra_args)</font>
<font color="red"> 727.         streaming_body = StreamReaderProgress(</font>
<font color="red"> 728.             response['Body'], callback)</font>
<font color="red"> 729.         with self._osutil.open(filename, 'wb') as f:</font>
<font color="red"> 730.             for chunk in iter(lambda: streaming_body.read(8192), b''):</font>
<font color="red"> 731.                 f.write(chunk)</font>
<font color="black"> 732. </font>
<font color="green"> 733.     def _object_size(self, bucket, key, extra_args):</font>
<font color="red"> 734.         return self._client.head_object(</font>
<font color="red"> 735.             Bucket=bucket, Key=key, **extra_args)['ContentLength']</font>
<font color="black"> 736. </font>
<font color="green"> 737.     def _multipart_upload(self, filename, bucket, key, callback, extra_args):</font>
<font color="red"> 738.         uploader = MultipartUploader(self._client, self._config, self._osutil)</font>
<font color="red"> 739.         uploader.upload_file(filename, bucket, key, callback, extra_args)</font>
</pre>

