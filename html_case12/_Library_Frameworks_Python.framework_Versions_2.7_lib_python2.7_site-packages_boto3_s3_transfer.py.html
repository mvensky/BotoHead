source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/boto3/s3/transfer.py</b><br>


file stats: <b>96 lines, 39 executed: 40.6% covered</b>
<pre>
<font color="black">   1. # Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="black">  13. &quot;&quot;&quot;Abstractions over S3's upload/download operations.</font>
<font color="black">  14. </font>
<font color="black">  15. This module provides high level abstractions for efficient</font>
<font color="black">  16. uploads/downloads.  It handles several things for the user:</font>
<font color="black">  17. </font>
<font color="black">  18. * Automatically switching to multipart transfers when</font>
<font color="black">  19.   a file is over a specific size threshold</font>
<font color="black">  20. * Uploading/downloading a file in parallel</font>
<font color="black">  21. * Progress callbacks to monitor transfers</font>
<font color="black">  22. * Retries.  While botocore handles retries for streaming uploads,</font>
<font color="black">  23.   it is not possible for it to handle retries for streaming</font>
<font color="black">  24.   downloads.  This module handles retries for both cases so</font>
<font color="black">  25.   you don't need to implement any retry logic yourself.</font>
<font color="black">  26. </font>
<font color="black">  27. This module has a reasonable set of defaults.  It also allows you</font>
<font color="black">  28. to configure many aspects of the transfer process including:</font>
<font color="black">  29. </font>
<font color="black">  30. * Multipart threshold size</font>
<font color="black">  31. * Max parallel downloads</font>
<font color="black">  32. * Socket timeouts</font>
<font color="black">  33. * Retry amounts</font>
<font color="black">  34. </font>
<font color="black">  35. There is no support for s3-&gt;s3 multipart copies at this</font>
<font color="black">  36. time.</font>
<font color="black">  37. </font>
<font color="black">  38. </font>
<font color="black">  39. .. _ref_s3transfer_usage:</font>
<font color="black">  40. </font>
<font color="black">  41. Usage</font>
<font color="black">  42. =====</font>
<font color="black">  43. </font>
<font color="black">  44. The simplest way to use this module is:</font>
<font color="black">  45. </font>
<font color="black">  46. .. code-block:: python</font>
<font color="black">  47. </font>
<font color="black">  48.     client = boto3.client('s3', 'us-west-2')</font>
<font color="black">  49.     transfer = S3Transfer(client)</font>
<font color="black">  50.     # Upload /tmp/myfile to s3://bucket/key</font>
<font color="black">  51.     transfer.upload_file('/tmp/myfile', 'bucket', 'key')</font>
<font color="black">  52. </font>
<font color="black">  53.     # Download s3://bucket/key to /tmp/myfile</font>
<font color="black">  54.     transfer.download_file('bucket', 'key', '/tmp/myfile')</font>
<font color="black">  55. </font>
<font color="black">  56. The ``upload_file`` and ``download_file`` methods also accept</font>
<font color="black">  57. ``**kwargs``, which will be forwarded through to the corresponding</font>
<font color="black">  58. client operation.  Here are a few examples using ``upload_file``::</font>
<font color="black">  59. </font>
<font color="black">  60.     # Making the object public</font>
<font color="black">  61.     transfer.upload_file('/tmp/myfile', 'bucket', 'key',</font>
<font color="black">  62.                          extra_args={'ACL': 'public-read'})</font>
<font color="black">  63. </font>
<font color="black">  64.     # Setting metadata</font>
<font color="black">  65.     transfer.upload_file('/tmp/myfile', 'bucket', 'key',</font>
<font color="black">  66.                          extra_args={'Metadata': {'a': 'b', 'c': 'd'}})</font>
<font color="black">  67. </font>
<font color="black">  68.     # Setting content type</font>
<font color="black">  69.     transfer.upload_file('/tmp/myfile.json', 'bucket', 'key',</font>
<font color="black">  70.                          extra_args={'ContentType': &quot;application/json&quot;})</font>
<font color="black">  71. </font>
<font color="black">  72. </font>
<font color="black">  73. The ``S3Transfer`` class also supports progress callbacks so you can</font>
<font color="black">  74. provide transfer progress to users.  Both the ``upload_file`` and</font>
<font color="black">  75. ``download_file`` methods take an optional ``callback`` parameter.</font>
<font color="black">  76. Here's an example of how to print a simple progress percentage</font>
<font color="black">  77. to the user:</font>
<font color="black">  78. </font>
<font color="black">  79. .. code-block:: python</font>
<font color="black">  80. </font>
<font color="black">  81.     class ProgressPercentage(object):</font>
<font color="black">  82.         def __init__(self, filename):</font>
<font color="black">  83.             self._filename = filename</font>
<font color="black">  84.             self._size = float(os.path.getsize(filename))</font>
<font color="black">  85.             self._seen_so_far = 0</font>
<font color="black">  86.             self._lock = threading.Lock()</font>
<font color="black">  87. </font>
<font color="black">  88.         def __call__(self, bytes_amount):</font>
<font color="black">  89.             # To simplify we'll assume this is hooked up</font>
<font color="black">  90.             # to a single filename.</font>
<font color="black">  91.             with self._lock:</font>
<font color="black">  92.                 self._seen_so_far += bytes_amount</font>
<font color="black">  93.                 percentage = (self._seen_so_far / self._size) * 100</font>
<font color="black">  94.                 sys.stdout.write(</font>
<font color="black">  95.                     &quot;\r%s  %s / %s  (%.2f%%)&quot; % (</font>
<font color="black">  96.                         self._filename, self._seen_so_far, self._size,</font>
<font color="black">  97.                         percentage))</font>
<font color="black">  98.                 sys.stdout.flush()</font>
<font color="black">  99. </font>
<font color="black"> 100. </font>
<font color="black"> 101.     transfer = S3Transfer(boto3.client('s3', 'us-west-2'))</font>
<font color="black"> 102.     # Upload /tmp/myfile to s3://bucket/key and print upload progress.</font>
<font color="black"> 103.     transfer.upload_file('/tmp/myfile', 'bucket', 'key',</font>
<font color="black"> 104.                          callback=ProgressPercentage('/tmp/myfile'))</font>
<font color="black"> 105. </font>
<font color="black"> 106. </font>
<font color="black"> 107. </font>
<font color="black"> 108. You can also provide a TransferConfig object to the S3Transfer</font>
<font color="black"> 109. object that gives you more fine grained control over the</font>
<font color="black"> 110. transfer.  For example:</font>
<font color="black"> 111. </font>
<font color="black"> 112. .. code-block:: python</font>
<font color="black"> 113. </font>
<font color="black"> 114.     client = boto3.client('s3', 'us-west-2')</font>
<font color="black"> 115.     config = TransferConfig(</font>
<font color="black"> 116.         multipart_threshold=8 * 1024 * 1024,</font>
<font color="black"> 117.         max_concurrency=10,</font>
<font color="black"> 118.         num_download_attempts=10,</font>
<font color="black"> 119.     )</font>
<font color="black"> 120.     transfer = S3Transfer(client, config)</font>
<font color="black"> 121.     transfer.upload_file('/tmp/foo', 'bucket', 'key')</font>
<font color="black"> 122. </font>
<font color="black"> 123. </font>
<font color="green"> 124. &quot;&quot;&quot;</font>
<font color="green"> 125. from botocore.exceptions import ClientError</font>
<font color="green"> 126. from botocore.compat import six</font>
<font color="green"> 127. from s3transfer.exceptions import RetriesExceededError as \</font>
<font color="black"> 128.     S3TransferRetriesExceededError</font>
<font color="green"> 129. from s3transfer.manager import TransferConfig as S3TransferConfig</font>
<font color="green"> 130. from s3transfer.manager import TransferManager</font>
<font color="green"> 131. from s3transfer.futures import NonThreadedExecutor</font>
<font color="green"> 132. from s3transfer.subscribers import BaseSubscriber</font>
<font color="green"> 133. from s3transfer.utils import OSUtils</font>
<font color="black"> 134. </font>
<font color="green"> 135. from boto3.exceptions import RetriesExceededError, S3UploadFailedError</font>
<font color="black"> 136. </font>
<font color="black"> 137. </font>
<font color="green"> 138. KB = 1024</font>
<font color="green"> 139. MB = KB * KB</font>
<font color="black"> 140. </font>
<font color="black"> 141. </font>
<font color="green"> 142. def create_transfer_manager(client, config, osutil=None):</font>
<font color="black"> 143.     &quot;&quot;&quot;Creates a transfer manager based on configuration</font>
<font color="black"> 144. </font>
<font color="black"> 145.     :type client: boto3.client</font>
<font color="black"> 146.     :param client: The S3 client to use</font>
<font color="black"> 147. </font>
<font color="black"> 148.     :type config: boto3.s3.transfer.TransferConfig</font>
<font color="black"> 149.     :param config: The transfer config to use</font>
<font color="black"> 150. </font>
<font color="black"> 151.     :type osutil: s3transfer.utils.OSUtils</font>
<font color="black"> 152.     :param osutil: The os utility to use</font>
<font color="black"> 153. </font>
<font color="black"> 154.     :rtype: s3transfer.manager.TransferManager</font>
<font color="black"> 155.     :returns: A transfer manager based on parameters provided</font>
<font color="black"> 156.     &quot;&quot;&quot;</font>
<font color="red"> 157.     executor_cls = None</font>
<font color="red"> 158.     if not config.use_threads:</font>
<font color="red"> 159.         executor_cls = NonThreadedExecutor</font>
<font color="red"> 160.     return TransferManager(client, config, osutil, executor_cls)</font>
<font color="black"> 161. </font>
<font color="black"> 162. </font>
<font color="green"> 163. class TransferConfig(S3TransferConfig):</font>
<font color="green"> 164.     ALIAS = {</font>
<font color="green"> 165.         'max_concurrency': 'max_request_concurrency',</font>
<font color="green"> 166.         'max_io_queue': 'max_io_queue_size'</font>
<font color="black"> 167.     }</font>
<font color="black"> 168. </font>
<font color="black"> 169.     def __init__(self,</font>
<font color="green"> 170.                  multipart_threshold=8 * MB,</font>
<font color="green"> 171.                  max_concurrency=10,</font>
<font color="green"> 172.                  multipart_chunksize=8 * MB,</font>
<font color="green"> 173.                  num_download_attempts=5,</font>
<font color="green"> 174.                  max_io_queue=100,</font>
<font color="green"> 175.                  io_chunksize=256 * KB,</font>
<font color="green"> 176.                  use_threads=True):</font>
<font color="black"> 177.         &quot;&quot;&quot;Configuration object for managed S3 transfers</font>
<font color="black"> 178. </font>
<font color="black"> 179.         :param multipart_threshold: The transfer size threshold for which</font>
<font color="black"> 180.             multipart uploads, downloads, and copies will automatically be</font>
<font color="black"> 181.             triggered.</font>
<font color="black"> 182. </font>
<font color="black"> 183.         :param max_concurrency: The maximum number of threads that will be</font>
<font color="black"> 184.             making requests to perform a transfer. If ``use_threads`` is</font>
<font color="black"> 185.             set to ``False``, the value provided is ignored as the transfer</font>
<font color="black"> 186.             will only ever use the main thread.</font>
<font color="black"> 187. </font>
<font color="black"> 188.         :param multipart_chunksize: The partition size of each part for a</font>
<font color="black"> 189.             multipart transfer.</font>
<font color="black"> 190. </font>
<font color="black"> 191.         :param num_download_attempts: The number of download attempts that</font>
<font color="black"> 192.             will be retried upon errors with downloading an object in S3.</font>
<font color="black"> 193.             Note that these retries account for errors that occur when</font>
<font color="black"> 194.             streaming  down the data from s3 (i.e. socket errors and read</font>
<font color="black"> 195.             timeouts that occur after recieving an OK response from s3).</font>
<font color="black"> 196.             Other retryable exceptions such as throttling errors and 5xx</font>
<font color="black"> 197.             errors are already retried by botocore (this default is 5). This</font>
<font color="black"> 198.             does not take into account the number of exceptions retried by</font>
<font color="black"> 199.             botocore.</font>
<font color="black"> 200. </font>
<font color="black"> 201.         :param max_io_queue: The maximum amount of read parts that can be</font>
<font color="black"> 202.             queued in memory to be written for a download. The size of each</font>
<font color="black"> 203.             of these read parts is at most the size of ``io_chunksize``.</font>
<font color="black"> 204. </font>
<font color="black"> 205.         :param io_chunksize: The max size of each chunk in the io queue.</font>
<font color="black"> 206.             Currently, this is size used when ``read`` is called on the</font>
<font color="black"> 207.             downloaded stream as well.</font>
<font color="black"> 208. </font>
<font color="black"> 209.         :param use_threads: If True, threads will be used when performing</font>
<font color="black"> 210.             S3 transfers. If False, no threads will be used in</font>
<font color="black"> 211.             performing transfers: all logic will be ran in the main thread.</font>
<font color="black"> 212.         &quot;&quot;&quot;</font>
<font color="red"> 213.         super(TransferConfig, self).__init__(</font>
<font color="red"> 214.             multipart_threshold=multipart_threshold,</font>
<font color="red"> 215.             max_request_concurrency=max_concurrency,</font>
<font color="red"> 216.             multipart_chunksize=multipart_chunksize,</font>
<font color="red"> 217.             num_download_attempts=num_download_attempts,</font>
<font color="red"> 218.             max_io_queue_size=max_io_queue,</font>
<font color="red"> 219.             io_chunksize=io_chunksize,</font>
<font color="black"> 220.         )</font>
<font color="black"> 221.         # Some of the argument names are not the same as the inherited</font>
<font color="black"> 222.         # S3TransferConfig so we add aliases so you can still access the</font>
<font color="black"> 223.         # old version of the names.</font>
<font color="red"> 224.         for alias in self.ALIAS:</font>
<font color="red"> 225.             setattr(self, alias, getattr(self, self.ALIAS[alias]))</font>
<font color="red"> 226.         self.use_threads = use_threads</font>
<font color="black"> 227. </font>
<font color="green"> 228.     def __setattr__(self, name, value):</font>
<font color="black"> 229.         # If the alias name is used, make sure we set the name that it points</font>
<font color="black"> 230.         # to as that is what actually is used in governing the TransferManager.</font>
<font color="red"> 231.         if name in self.ALIAS:</font>
<font color="red"> 232.             super(TransferConfig, self).__setattr__(self.ALIAS[name], value)</font>
<font color="black"> 233.         # Always set the value of the actual name provided.</font>
<font color="red"> 234.         super(TransferConfig, self).__setattr__(name, value)</font>
<font color="black"> 235. </font>
<font color="black"> 236. </font>
<font color="green"> 237. class S3Transfer(object):</font>
<font color="green"> 238.     ALLOWED_DOWNLOAD_ARGS = TransferManager.ALLOWED_DOWNLOAD_ARGS</font>
<font color="green"> 239.     ALLOWED_UPLOAD_ARGS = TransferManager.ALLOWED_UPLOAD_ARGS</font>
<font color="black"> 240. </font>
<font color="green"> 241.     def __init__(self, client=None, config=None, osutil=None, manager=None):</font>
<font color="red"> 242.         if not client and not manager:</font>
<font color="red"> 243.             raise ValueError(</font>
<font color="red"> 244.                 'Either a boto3.Client or s3transfer.manager.TransferManager '</font>
<font color="black"> 245.                 'must be provided'</font>
<font color="black"> 246.             )</font>
<font color="red"> 247.         if manager and any([client, config, osutil]):</font>
<font color="red"> 248.             raise ValueError(</font>
<font color="red"> 249.                 'Manager cannot be provided with client, config, '</font>
<font color="black"> 250.                 'nor osutil. These parameters are mutually exclusive.'</font>
<font color="black"> 251.             )</font>
<font color="red"> 252.         if config is None:</font>
<font color="red"> 253.             config = TransferConfig()</font>
<font color="red"> 254.         if osutil is None:</font>
<font color="red"> 255.             osutil = OSUtils()</font>
<font color="red"> 256.         if manager:</font>
<font color="red"> 257.             self._manager = manager</font>
<font color="black"> 258.         else:</font>
<font color="red"> 259.             self._manager = create_transfer_manager(client, config, osutil)</font>
<font color="black"> 260. </font>
<font color="black"> 261.     def upload_file(self, filename, bucket, key,</font>
<font color="green"> 262.                     callback=None, extra_args=None):</font>
<font color="black"> 263.         &quot;&quot;&quot;Upload a file to an S3 object.</font>
<font color="black"> 264. </font>
<font color="black"> 265.         Variants have also been injected into S3 client, Bucket and Object.</font>
<font color="black"> 266.         You don't have to use S3Transfer.upload_file() directly.</font>
<font color="black"> 267. </font>
<font color="black"> 268.         .. seealso::</font>
<font color="black"> 269.             :py:meth:`S3.Client.upload_file`</font>
<font color="black"> 270.             :py:meth:`S3.Client.upload_fileobj`</font>
<font color="black"> 271.         &quot;&quot;&quot;</font>
<font color="red"> 272.         if not isinstance(filename, six.string_types):</font>
<font color="red"> 273.             raise ValueError('Filename must be a string')</font>
<font color="black"> 274. </font>
<font color="red"> 275.         subscribers = self._get_subscribers(callback)</font>
<font color="red"> 276.         future = self._manager.upload(</font>
<font color="red"> 277.             filename, bucket, key, extra_args, subscribers)</font>
<font color="red"> 278.         try:</font>
<font color="red"> 279.             future.result()</font>
<font color="black"> 280.         # If a client error was raised, add the backwards compatibility layer</font>
<font color="black"> 281.         # that raises a S3UploadFailedError. These specific errors were only</font>
<font color="black"> 282.         # ever thrown for upload_parts but now can be thrown for any related</font>
<font color="black"> 283.         # client error.</font>
<font color="red"> 284.         except ClientError as e:</font>
<font color="red"> 285.             raise S3UploadFailedError(</font>
<font color="red"> 286.                 &quot;Failed to upload %s to %s: %s&quot; % (</font>
<font color="red"> 287.                     filename, '/'.join([bucket, key]), e))</font>
<font color="black"> 288. </font>
<font color="green"> 289.     def download_file(self, bucket, key, filename, extra_args=None,</font>
<font color="green"> 290.                       callback=None):</font>
<font color="black"> 291.         &quot;&quot;&quot;Download an S3 object to a file.</font>
<font color="black"> 292. </font>
<font color="black"> 293.         Variants have also been injected into S3 client, Bucket and Object.</font>
<font color="black"> 294.         You don't have to use S3Transfer.download_file() directly.</font>
<font color="black"> 295. </font>
<font color="black"> 296.         .. seealso::</font>
<font color="black"> 297.             :py:meth:`S3.Client.download_file`</font>
<font color="black"> 298.             :py:meth:`S3.Client.download_fileobj`</font>
<font color="black"> 299.         &quot;&quot;&quot;</font>
<font color="red"> 300.         if not isinstance(filename, six.string_types):</font>
<font color="red"> 301.             raise ValueError('Filename must be a string')</font>
<font color="black"> 302. </font>
<font color="red"> 303.         subscribers = self._get_subscribers(callback)</font>
<font color="red"> 304.         future = self._manager.download(</font>
<font color="red"> 305.             bucket, key, filename, extra_args, subscribers)</font>
<font color="red"> 306.         try:</font>
<font color="red"> 307.             future.result()</font>
<font color="black"> 308.         # This is for backwards compatibility where when retries are</font>
<font color="black"> 309.         # exceeded we need to throw the same error from boto3 instead of</font>
<font color="black"> 310.         # s3transfer's built in RetriesExceededError as current users are</font>
<font color="black"> 311.         # catching the boto3 one instead of the s3transfer exception to do</font>
<font color="black"> 312.         # their own retries.</font>
<font color="red"> 313.         except S3TransferRetriesExceededError as e:</font>
<font color="red"> 314.             raise RetriesExceededError(e.last_exception)</font>
<font color="black"> 315. </font>
<font color="green"> 316.     def _get_subscribers(self, callback):</font>
<font color="red"> 317.         if not callback:</font>
<font color="red"> 318.             return None</font>
<font color="red"> 319.         return [ProgressCallbackInvoker(callback)]</font>
<font color="black"> 320. </font>
<font color="green"> 321.     def __enter__(self):</font>
<font color="red"> 322.         return self</font>
<font color="black"> 323. </font>
<font color="green"> 324.     def __exit__(self, *args):</font>
<font color="red"> 325.         self._manager.__exit__(*args)</font>
<font color="black"> 326. </font>
<font color="black"> 327. </font>
<font color="green"> 328. class ProgressCallbackInvoker(BaseSubscriber):</font>
<font color="black"> 329.     &quot;&quot;&quot;A back-compat wrapper to invoke a provided callback via a subscriber</font>
<font color="black"> 330. </font>
<font color="black"> 331.     :param callback: A callable that takes a single positional argument for</font>
<font color="black"> 332.         how many bytes were transferred.</font>
<font color="green"> 333.     &quot;&quot;&quot;</font>
<font color="green"> 334.     def __init__(self, callback):</font>
<font color="red"> 335.         self._callback = callback</font>
<font color="black"> 336. </font>
<font color="green"> 337.     def on_progress(self, bytes_transferred, **kwargs):</font>
<font color="red"> 338.         self._callback(bytes_transferred)</font>
</pre>

