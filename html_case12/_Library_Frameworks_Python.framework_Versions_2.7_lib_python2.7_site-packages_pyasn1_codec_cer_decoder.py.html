source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/pyasn1/codec/cer/decoder.py</b><br>


file stats: <b>31 lines, 21 executed: 67.7% covered</b>
<pre>
<font color="black">   1. #</font>
<font color="black">   2. # This file is part of pyasn1 software.</font>
<font color="black">   3. #</font>
<font color="black">   4. # Copyright (c) 2005-2017, Ilya Etingof &lt;etingof@gmail.com&gt;</font>
<font color="black">   5. # License: http://pyasn1.sf.net/license.html</font>
<font color="black">   6. #</font>
<font color="green">   7. from pyasn1.type import univ</font>
<font color="green">   8. from pyasn1.codec.ber import decoder</font>
<font color="green">   9. from pyasn1.compat.octets import oct2int</font>
<font color="green">  10. from pyasn1 import error</font>
<font color="black">  11. </font>
<font color="green">  12. __all__ = ['decode']</font>
<font color="black">  13. </font>
<font color="black">  14. </font>
<font color="green">  15. class BooleanDecoder(decoder.AbstractSimpleDecoder):</font>
<font color="green">  16.     protoComponent = univ.Boolean(0)</font>
<font color="black">  17. </font>
<font color="green">  18.     def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet, length,</font>
<font color="black">  19.                      state, decodeFun, substrateFun):</font>
<font color="red">  20.         head, tail = substrate[:length], substrate[length:]</font>
<font color="red">  21.         if not head or length != 1:</font>
<font color="red">  22.             raise error.PyAsn1Error('Not single-octet Boolean payload')</font>
<font color="red">  23.         byte = oct2int(head[0])</font>
<font color="black">  24.         # CER/DER specifies encoding of TRUE as 0xFF and FALSE as 0x0, while</font>
<font color="black">  25.         # BER allows any non-zero value as TRUE; cf. sections 8.2.2. and 11.1</font>
<font color="black">  26.         # in http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf</font>
<font color="red">  27.         if byte == 0xff:</font>
<font color="red">  28.             value = 1</font>
<font color="red">  29.         elif byte == 0x00:</font>
<font color="red">  30.             value = 0</font>
<font color="black">  31.         else:</font>
<font color="red">  32.             raise error.PyAsn1Error('Unexpected Boolean payload: %s' % byte)</font>
<font color="red">  33.         return self._createComponent(asn1Spec, tagSet, value), tail</font>
<font color="black">  34. </font>
<font color="black">  35. # TODO: prohibit non-canonical encoding</font>
<font color="green">  36. BitStringDecoder = decoder.BitStringDecoder</font>
<font color="green">  37. OctetStringDecoder = decoder.OctetStringDecoder</font>
<font color="green">  38. RealDecoder = decoder.RealDecoder</font>
<font color="black">  39. </font>
<font color="green">  40. tagMap = decoder.tagMap.copy()</font>
<font color="green">  41. tagMap.update(</font>
<font color="green">  42.     {univ.Boolean.tagSet: BooleanDecoder(),</font>
<font color="green">  43.      univ.BitString.tagSet: BitStringDecoder(),</font>
<font color="green">  44.      univ.OctetString.tagSet: OctetStringDecoder(),</font>
<font color="green">  45.      univ.Real.tagSet: RealDecoder()}</font>
<font color="black">  46. )</font>
<font color="black">  47. </font>
<font color="green">  48. typeMap = decoder.typeMap</font>
<font color="black">  49. </font>
<font color="black">  50. </font>
<font color="green">  51. class Decoder(decoder.Decoder):</font>
<font color="green">  52.     pass</font>
<font color="black">  53. </font>
<font color="black">  54. </font>
<font color="black">  55. #: Turns CER octet stream into an ASN.1 object.</font>
<font color="black">  56. #:</font>
<font color="black">  57. #: Takes CER octetstream and decode it into an ASN.1 object</font>
<font color="black">  58. #: (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which</font>
<font color="black">  59. #: may be a scalar or an arbitrary nested structure.</font>
<font color="black">  60. #:</font>
<font color="black">  61. #: Parameters</font>
<font color="black">  62. #: ----------</font>
<font color="black">  63. #: substrate: :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)</font>
<font color="black">  64. #:     CER octetstream</font>
<font color="black">  65. #:</font>
<font color="black">  66. #: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative</font>
<font color="black">  67. #:     A pyasn1 type object to act as a template guiding the decoder. Depending on the ASN.1 structure</font>
<font color="black">  68. #:     being decoded, *asn1Spec* may or may not be required. Most common reason for</font>
<font color="black">  69. #:     it to require is that ASN.1 structure is encoded in *IMPLICIT* tagging mode.</font>
<font color="black">  70. #:</font>
<font color="black">  71. #: Returns</font>
<font color="black">  72. #: -------</font>
<font color="black">  73. #: : :py:class:`tuple`</font>
<font color="black">  74. #:     A tuple of pyasn1 object recovered from CER substrate (:py:class:`~pyasn1.type.base.PyAsn1Item` derivative)</font>
<font color="black">  75. #:     and the unprocessed trailing portion of the *substrate* (may be empty)</font>
<font color="black">  76. #:</font>
<font color="black">  77. #: Raises</font>
<font color="black">  78. #: ------</font>
<font color="black">  79. #: : :py:class:`pyasn1.error.PyAsn1Error`</font>
<font color="black">  80. #:     On decoding errors</font>
<font color="green">  81. decode = Decoder(tagMap, decoder.typeMap)</font>
</pre>

