source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/hooks.py</b><br>


file stats: <b>230 lines, 164 executed: 71.3% covered</b>
<pre>
<font color="black">   1. # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="green">  13. import copy</font>
<font color="green">  14. import logging</font>
<font color="green">  15. from collections import defaultdict, deque, namedtuple</font>
<font color="green">  16. from botocore.compat import accepts_kwargs, six</font>
<font color="black">  17. </font>
<font color="green">  18. logger = logging.getLogger(__name__)</font>
<font color="black">  19. </font>
<font color="black">  20. </font>
<font color="green">  21. _NodeList = namedtuple('NodeList', ['first', 'middle', 'last'])</font>
<font color="green">  22. _FIRST = 0</font>
<font color="green">  23. _MIDDLE = 1</font>
<font color="green">  24. _LAST = 2</font>
<font color="black">  25. </font>
<font color="black">  26. </font>
<font color="green">  27. class NodeList(_NodeList):</font>
<font color="black">  28. </font>
<font color="green">  29.     def __copy__(self):</font>
<font color="green">  30.         first_copy = copy.copy(self.first)</font>
<font color="green">  31.         middle_copy = copy.copy(self.middle)</font>
<font color="green">  32.         last_copy = copy.copy(self.last)</font>
<font color="green">  33.         copied = NodeList(first_copy, middle_copy, last_copy)</font>
<font color="green">  34.         return copied</font>
<font color="black">  35. </font>
<font color="black">  36. </font>
<font color="green">  37. def first_non_none_response(responses, default=None):</font>
<font color="black">  38.     &quot;&quot;&quot;Find first non None response in a list of tuples.</font>
<font color="black">  39. </font>
<font color="black">  40.     This function can be used to find the first non None response from</font>
<font color="black">  41.     handlers connected to an event.  This is useful if you are interested</font>
<font color="black">  42.     in the returned responses from event handlers. Example usage::</font>
<font color="black">  43. </font>
<font color="black">  44.         print(first_non_none_response([(func1, None), (func2, 'foo'),</font>
<font color="black">  45.                                        (func3, 'bar')]))</font>
<font color="black">  46.         # This will print 'foo'</font>
<font color="black">  47. </font>
<font color="black">  48.     :type responses: list of tuples</font>
<font color="black">  49.     :param responses: The responses from the ``EventHooks.emit`` method.</font>
<font color="black">  50.         This is a list of tuples, and each tuple is</font>
<font color="black">  51.         (handler, handler_response).</font>
<font color="black">  52. </font>
<font color="black">  53.     :param default: If no non-None responses are found, then this default</font>
<font color="black">  54.         value will be returned.</font>
<font color="black">  55. </font>
<font color="black">  56.     :return: The first non-None response in the list of tuples.</font>
<font color="black">  57. </font>
<font color="black">  58.     &quot;&quot;&quot;</font>
<font color="green">  59.     for response in responses:</font>
<font color="green">  60.         if response[1] is not None:</font>
<font color="green">  61.             return response[1]</font>
<font color="green">  62.     return default</font>
<font color="black">  63. </font>
<font color="black">  64. </font>
<font color="green">  65. class BaseEventHooks(object):</font>
<font color="green">  66.     def emit(self, event_name, **kwargs):</font>
<font color="black">  67.         &quot;&quot;&quot;Call all handlers subscribed to an event.</font>
<font color="black">  68. </font>
<font color="black">  69.         :type event_name: str</font>
<font color="black">  70.         :param event_name: The name of the event to emit.</font>
<font color="black">  71. </font>
<font color="black">  72.         :type **kwargs: dict</font>
<font color="black">  73.         :param **kwargs: Arbitrary kwargs to pass through to the</font>
<font color="black">  74.             subscribed handlers.  The ``event_name`` will be injected</font>
<font color="black">  75.             into the kwargs so it's not necesary to add this to **kwargs.</font>
<font color="black">  76. </font>
<font color="black">  77.         :rtype: list of tuples</font>
<font color="black">  78.         :return: A list of ``(handler_func, handler_func_return_value)``</font>
<font color="black">  79. </font>
<font color="black">  80.         &quot;&quot;&quot;</font>
<font color="red">  81.         return []</font>
<font color="black">  82. </font>
<font color="green">  83.     def register(self, event_name, handler, unique_id=None,</font>
<font color="green">  84.                  unique_id_uses_count=False):</font>
<font color="black">  85.         &quot;&quot;&quot;Register an event handler for a given event.</font>
<font color="black">  86. </font>
<font color="black">  87.         If a ``unique_id`` is given, the handler will not be registered</font>
<font color="black">  88.         if a handler with the ``unique_id`` has already been registered.</font>
<font color="black">  89. </font>
<font color="black">  90.         Handlers are called in the order they have been registered.</font>
<font color="black">  91.         Note handlers can also be registered with ``register_first()``</font>
<font color="black">  92.         and ``register_last()``.  All handlers registered with</font>
<font color="black">  93.         ``register_first()`` are called before handlers registered</font>
<font color="black">  94.         with ``register()`` which are called before handlers registered</font>
<font color="black">  95.         with ``register_last()``.</font>
<font color="black">  96. </font>
<font color="black">  97.         &quot;&quot;&quot;</font>
<font color="green">  98.         self._verify_and_register(event_name, handler, unique_id,</font>
<font color="green">  99.                                   register_method=self._register,</font>
<font color="green"> 100.                                   unique_id_uses_count=unique_id_uses_count)</font>
<font color="black"> 101. </font>
<font color="green"> 102.     def register_first(self, event_name, handler, unique_id=None,</font>
<font color="green"> 103.                        unique_id_uses_count=False):</font>
<font color="black"> 104.         &quot;&quot;&quot;Register an event handler to be called first for an event.</font>
<font color="black"> 105. </font>
<font color="black"> 106.         All event handlers registered with ``register_first()`` will</font>
<font color="black"> 107.         be called before handlers registered with ``register()`` and</font>
<font color="black"> 108.         ``register_last()``.</font>
<font color="black"> 109. </font>
<font color="black"> 110.         &quot;&quot;&quot;</font>
<font color="green"> 111.         self._verify_and_register(event_name, handler, unique_id,</font>
<font color="green"> 112.                                   register_method=self._register_first,</font>
<font color="green"> 113.                                   unique_id_uses_count=unique_id_uses_count)</font>
<font color="black"> 114. </font>
<font color="green"> 115.     def register_last(self, event_name, handler, unique_id=None,</font>
<font color="green"> 116.                       unique_id_uses_count=False):</font>
<font color="black"> 117.         &quot;&quot;&quot;Register an event handler to be called last for an event.</font>
<font color="black"> 118. </font>
<font color="black"> 119.         All event handlers registered with ``register_last()`` will be called</font>
<font color="black"> 120.         after handlers registered with ``register_first()`` and ``register()``.</font>
<font color="black"> 121. </font>
<font color="black"> 122.         &quot;&quot;&quot;</font>
<font color="green"> 123.         self._verify_and_register(event_name, handler, unique_id,</font>
<font color="green"> 124.                                   register_method=self._register_last,</font>
<font color="green"> 125.                                   unique_id_uses_count=unique_id_uses_count)</font>
<font color="black"> 126. </font>
<font color="green"> 127.     def _verify_and_register(self, event_name, handler, unique_id,</font>
<font color="black"> 128.                              register_method, unique_id_uses_count):</font>
<font color="green"> 129.         self._verify_is_callable(handler)</font>
<font color="green"> 130.         self._verify_accept_kwargs(handler)</font>
<font color="green"> 131.         register_method(event_name, handler, unique_id, unique_id_uses_count)</font>
<font color="black"> 132. </font>
<font color="green"> 133.     def unregister(self, event_name, handler=None, unique_id=None,</font>
<font color="green"> 134.                    unique_id_uses_count=False):</font>
<font color="black"> 135.         &quot;&quot;&quot;Unregister an event handler for a given event.</font>
<font color="black"> 136. </font>
<font color="black"> 137.         If no ``unique_id`` was given during registration, then the</font>
<font color="black"> 138.         first instance of the event handler is removed (if the event</font>
<font color="black"> 139.         handler has been registered multiple times).</font>
<font color="black"> 140. </font>
<font color="black"> 141.         &quot;&quot;&quot;</font>
<font color="red"> 142.         pass</font>
<font color="black"> 143. </font>
<font color="green"> 144.     def _verify_is_callable(self, func):</font>
<font color="green"> 145.         if not six.callable(func):</font>
<font color="red"> 146.             raise ValueError(&quot;Event handler %s must be callable.&quot; % func)</font>
<font color="black"> 147. </font>
<font color="green"> 148.     def _verify_accept_kwargs(self, func):</font>
<font color="black"> 149.         &quot;&quot;&quot;Verifies a callable accepts kwargs</font>
<font color="black"> 150. </font>
<font color="black"> 151.         :type func: callable</font>
<font color="black"> 152.         :param func: A callable object.</font>
<font color="black"> 153. </font>
<font color="black"> 154.         :returns: True, if ``func`` accepts kwargs, otherwise False.</font>
<font color="black"> 155. </font>
<font color="black"> 156.         &quot;&quot;&quot;</font>
<font color="green"> 157.         try:</font>
<font color="green"> 158.             if not accepts_kwargs(func):</font>
<font color="red"> 159.                 raise ValueError(&quot;Event handler %s must accept keyword &quot;</font>
<font color="red"> 160.                                  &quot;arguments (**kwargs)&quot; % func)</font>
<font color="green"> 161.         except TypeError:</font>
<font color="green"> 162.             return False</font>
<font color="black"> 163. </font>
<font color="black"> 164. </font>
<font color="green"> 165. class HierarchicalEmitter(BaseEventHooks):</font>
<font color="green"> 166.     def __init__(self):</font>
<font color="black"> 167.         # We keep a reference to the handlers for quick</font>
<font color="black"> 168.         # read only access (we never modify self._handlers).</font>
<font color="black"> 169.         # A cache of event name to handler list.</font>
<font color="green"> 170.         self._lookup_cache = {}</font>
<font color="green"> 171.         self._handlers = _PrefixTrie()</font>
<font color="black"> 172.         # This is used to ensure that unique_id's are only</font>
<font color="black"> 173.         # registered once.</font>
<font color="green"> 174.         self._unique_id_handlers = {}</font>
<font color="black"> 175. </font>
<font color="green"> 176.     def _emit(self, event_name, kwargs, stop_on_response=False):</font>
<font color="black"> 177.         &quot;&quot;&quot;</font>
<font color="black"> 178.         Emit an event with optional keyword arguments.</font>
<font color="black"> 179. </font>
<font color="black"> 180.         :type event_name: string</font>
<font color="black"> 181.         :param event_name: Name of the event</font>
<font color="black"> 182.         :type kwargs: dict</font>
<font color="black"> 183.         :param kwargs: Arguments to be passed to the handler functions.</font>
<font color="black"> 184.         :type stop_on_response: boolean</font>
<font color="black"> 185.         :param stop_on_response: Whether to stop on the first non-None</font>
<font color="black"> 186.                                 response. If False, then all handlers</font>
<font color="black"> 187.                                 will be called. This is especially useful</font>
<font color="black"> 188.                                 to handlers which mutate data and then</font>
<font color="black"> 189.                                 want to stop propagation of the event.</font>
<font color="black"> 190.         :rtype: list</font>
<font color="black"> 191.         :return: List of (handler, response) tuples from all processed</font>
<font color="black"> 192.                  handlers.</font>
<font color="black"> 193.         &quot;&quot;&quot;</font>
<font color="green"> 194.         responses = []</font>
<font color="black"> 195.         # Invoke the event handlers from most specific</font>
<font color="black"> 196.         # to least specific, each time stripping off a dot.</font>
<font color="green"> 197.         handlers_to_call = self._lookup_cache.get(event_name)</font>
<font color="green"> 198.         if handlers_to_call is None:</font>
<font color="green"> 199.             handlers_to_call = self._handlers.prefix_search(event_name)</font>
<font color="green"> 200.             self._lookup_cache[event_name] = handlers_to_call</font>
<font color="green"> 201.         elif not handlers_to_call:</font>
<font color="black"> 202.             # Short circuit and return an empty response is we have</font>
<font color="black"> 203.             # no handlers to call.  This is the common case where</font>
<font color="black"> 204.             # for the majority of signals, nothing is listening.</font>
<font color="green"> 205.             return []</font>
<font color="green"> 206.         kwargs['event_name'] = event_name</font>
<font color="green"> 207.         responses = []</font>
<font color="green"> 208.         for handler in handlers_to_call:</font>
<font color="green"> 209.             logger.debug('Event %s: calling handler %s', event_name, handler)</font>
<font color="green"> 210.             response = handler(**kwargs)</font>
<font color="green"> 211.             responses.append((handler, response))</font>
<font color="green"> 212.             if stop_on_response and response is not None:</font>
<font color="red"> 213.                 return responses</font>
<font color="green"> 214.         return responses</font>
<font color="black"> 215. </font>
<font color="green"> 216.     def emit(self, event_name, **kwargs):</font>
<font color="black"> 217.         &quot;&quot;&quot;</font>
<font color="black"> 218.         Emit an event by name with arguments passed as keyword args.</font>
<font color="black"> 219. </font>
<font color="black"> 220.             &gt;&gt;&gt; responses = emitter.emit(</font>
<font color="black"> 221.             ...     'my-event.service.operation', arg1='one', arg2='two')</font>
<font color="black"> 222. </font>
<font color="black"> 223.         :rtype: list</font>
<font color="black"> 224.         :return: List of (handler, response) tuples from all processed</font>
<font color="black"> 225.                  handlers.</font>
<font color="black"> 226.         &quot;&quot;&quot;</font>
<font color="green"> 227.         return self._emit(event_name, kwargs)</font>
<font color="black"> 228. </font>
<font color="green"> 229.     def emit_until_response(self, event_name, **kwargs):</font>
<font color="black"> 230.         &quot;&quot;&quot;</font>
<font color="black"> 231.         Emit an event by name with arguments passed as keyword args,</font>
<font color="black"> 232.         until the first non-``None`` response is received. This</font>
<font color="black"> 233.         method prevents subsequent handlers from being invoked.</font>
<font color="black"> 234. </font>
<font color="black"> 235.             &gt;&gt;&gt; handler, response = emitter.emit_until_response(</font>
<font color="black"> 236.                 'my-event.service.operation', arg1='one', arg2='two')</font>
<font color="black"> 237. </font>
<font color="black"> 238.         :rtype: tuple</font>
<font color="black"> 239.         :return: The first (handler, response) tuple where the response</font>
<font color="black"> 240.                  is not ``None``, otherwise (``None``, ``None``).</font>
<font color="black"> 241.         &quot;&quot;&quot;</font>
<font color="green"> 242.         responses = self._emit(event_name, kwargs, stop_on_response=True)</font>
<font color="green"> 243.         if responses:</font>
<font color="green"> 244.             return responses[-1]</font>
<font color="black"> 245.         else:</font>
<font color="red"> 246.             return (None, None)</font>
<font color="black"> 247. </font>
<font color="green"> 248.     def _register(self, event_name, handler, unique_id=None,</font>
<font color="green"> 249.                   unique_id_uses_count=False):</font>
<font color="green"> 250.         self._register_section(event_name, handler, unique_id,</font>
<font color="green"> 251.                                unique_id_uses_count, section=_MIDDLE)</font>
<font color="black"> 252. </font>
<font color="green"> 253.     def _register_first(self, event_name, handler, unique_id=None,</font>
<font color="green"> 254.                         unique_id_uses_count=False):</font>
<font color="green"> 255.         self._register_section(event_name, handler, unique_id,</font>
<font color="green"> 256.                                unique_id_uses_count, section=_FIRST)</font>
<font color="black"> 257. </font>
<font color="black"> 258.     def _register_last(self, event_name, handler, unique_id,</font>
<font color="green"> 259.                        unique_id_uses_count=False):</font>
<font color="green"> 260.         self._register_section(event_name, handler, unique_id,</font>
<font color="green"> 261.                                unique_id_uses_count, section=_LAST)</font>
<font color="black"> 262. </font>
<font color="green"> 263.     def _register_section(self, event_name, handler, unique_id,</font>
<font color="black"> 264.                           unique_id_uses_count, section):</font>
<font color="green"> 265.         if unique_id is not None:</font>
<font color="green"> 266.             if unique_id in self._unique_id_handlers:</font>
<font color="black"> 267.                 # We've already registered a handler using this unique_id</font>
<font color="black"> 268.                 # so we don't need to register it again.</font>
<font color="red"> 269.                 count = self._unique_id_handlers[unique_id].get('count', None)</font>
<font color="red"> 270.                 if unique_id_uses_count:</font>
<font color="red"> 271.                     if not count:</font>
<font color="red"> 272.                         raise ValueError(</font>
<font color="red"> 273.                             &quot;Initial registration of  unique id %s was &quot;</font>
<font color="black"> 274.                             &quot;specified to use a counter. Subsequent register &quot;</font>
<font color="black"> 275.                             &quot;calls to unique id must specify use of a counter &quot;</font>
<font color="red"> 276.                             &quot;as well.&quot; % unique_id)</font>
<font color="black"> 277.                     else:</font>
<font color="red"> 278.                         self._unique_id_handlers[unique_id]['count'] += 1</font>
<font color="black"> 279.                 else:</font>
<font color="red"> 280.                     if count:</font>
<font color="red"> 281.                         raise ValueError(</font>
<font color="red"> 282.                             &quot;Initial registration of unique id %s was &quot;</font>
<font color="black"> 283.                             &quot;specified to not use a counter. Subsequent &quot;</font>
<font color="black"> 284.                             &quot;register calls to unique id must specify not to &quot;</font>
<font color="red"> 285.                             &quot;use a counter as well.&quot; % unique_id)</font>
<font color="red"> 286.                 return</font>
<font color="black"> 287.             else:</font>
<font color="black"> 288.                 # Note that the trie knows nothing about the unique</font>
<font color="black"> 289.                 # id.  We track uniqueness in this class via the</font>
<font color="black"> 290.                 # _unique_id_handlers.</font>
<font color="green"> 291.                 self._handlers.append_item(event_name, handler,</font>
<font color="green"> 292.                                            section=section)</font>
<font color="green"> 293.                 unique_id_handler_item = {'handler': handler}</font>
<font color="green"> 294.                 if unique_id_uses_count:</font>
<font color="red"> 295.                     unique_id_handler_item['count'] = 1</font>
<font color="green"> 296.                 self._unique_id_handlers[unique_id] = unique_id_handler_item</font>
<font color="black"> 297.         else:</font>
<font color="green"> 298.             self._handlers.append_item(event_name, handler, section=section)</font>
<font color="black"> 299.         # Super simple caching strategy for now, if we change the registrations</font>
<font color="black"> 300.         # clear the cache.  This has the opportunity for smarter invalidations.</font>
<font color="green"> 301.         self._lookup_cache = {}</font>
<font color="black"> 302. </font>
<font color="green"> 303.     def unregister(self, event_name, handler=None, unique_id=None,</font>
<font color="green"> 304.                    unique_id_uses_count=False):</font>
<font color="red"> 305.         if unique_id is not None:</font>
<font color="red"> 306.             try:</font>
<font color="red"> 307.                 count = self._unique_id_handlers[unique_id].get('count', None)</font>
<font color="red"> 308.             except KeyError:</font>
<font color="black"> 309.                 # There's no handler matching that unique_id so we have</font>
<font color="black"> 310.                 # nothing to unregister.</font>
<font color="red"> 311.                 return</font>
<font color="red"> 312.             if unique_id_uses_count:</font>
<font color="red"> 313.                 if count is None:</font>
<font color="red"> 314.                     raise ValueError(</font>
<font color="red"> 315.                         &quot;Initial registration of unique id %s was specified to &quot;</font>
<font color="black"> 316.                         &quot;use a counter. Subsequent unregister calls to unique &quot;</font>
<font color="red"> 317.                         &quot;id must specify use of a counter as well.&quot; % unique_id)</font>
<font color="red"> 318.                 elif count == 1:</font>
<font color="red"> 319.                     handler = self._unique_id_handlers.pop(unique_id)['handler']</font>
<font color="black"> 320.                 else:</font>
<font color="red"> 321.                     self._unique_id_handlers[unique_id]['count'] -= 1</font>
<font color="red"> 322.                     return</font>
<font color="black"> 323.             else:</font>
<font color="red"> 324.                 if count:</font>
<font color="red"> 325.                     raise ValueError(</font>
<font color="red"> 326.                         &quot;Initial registration of unique id %s was specified &quot;</font>
<font color="black"> 327.                         &quot;to not use a counter. Subsequent unregister calls &quot;</font>
<font color="black"> 328.                         &quot;to unique id must specify not to use a counter as &quot;</font>
<font color="red"> 329.                         &quot;well.&quot; % unique_id)</font>
<font color="red"> 330.                 handler = self._unique_id_handlers.pop(unique_id)['handler']</font>
<font color="red"> 331.         try:</font>
<font color="red"> 332.             self._handlers.remove_item(event_name, handler)</font>
<font color="red"> 333.             self._lookup_cache = {}</font>
<font color="red"> 334.         except ValueError:</font>
<font color="red"> 335.             pass</font>
<font color="black"> 336. </font>
<font color="green"> 337.     def __copy__(self):</font>
<font color="green"> 338.         new_instance = self.__class__()</font>
<font color="green"> 339.         new_state = self.__dict__.copy()</font>
<font color="green"> 340.         new_state['_handlers'] = copy.copy(self._handlers)</font>
<font color="green"> 341.         new_state['_unique_id_handlers'] = copy.copy(self._unique_id_handlers)</font>
<font color="green"> 342.         new_instance.__dict__ = new_state</font>
<font color="green"> 343.         return new_instance</font>
<font color="black"> 344. </font>
<font color="black"> 345. </font>
<font color="green"> 346. class _PrefixTrie(object):</font>
<font color="black"> 347.     &quot;&quot;&quot;Specialized prefix trie that handles wildcards.</font>
<font color="black"> 348. </font>
<font color="black"> 349.     The prefixes in this case are based on dot separated</font>
<font color="black"> 350.     names so 'foo.bar.baz' is::</font>
<font color="black"> 351. </font>
<font color="black"> 352.         foo -&gt; bar -&gt; baz</font>
<font color="black"> 353. </font>
<font color="black"> 354.     Wildcard support just means that having a key such as 'foo.bar.*.baz' will</font>
<font color="black"> 355.     be matched with a call to ``get_items(key='foo.bar.ANYTHING.baz')``.</font>
<font color="black"> 356. </font>
<font color="black"> 357.     You can think of this prefix trie as the equivalent as defaultdict(list),</font>
<font color="black"> 358.     except that it can do prefix searches:</font>
<font color="black"> 359. </font>
<font color="black"> 360.         foo.bar.baz -&gt; A</font>
<font color="black"> 361.         foo.bar -&gt; B</font>
<font color="black"> 362.         foo -&gt; C</font>
<font color="black"> 363. </font>
<font color="black"> 364.     Calling ``get_items('foo.bar.baz')`` will return [A + B + C], from</font>
<font color="black"> 365.     most specific to least specific.</font>
<font color="black"> 366. </font>
<font color="green"> 367.     &quot;&quot;&quot;</font>
<font color="green"> 368.     def __init__(self):</font>
<font color="black"> 369.         # Each dictionary can be though of as a node, where a node</font>
<font color="black"> 370.         # has values associated with the node, and children is a link</font>
<font color="black"> 371.         # to more nodes.  So 'foo.bar' would have a 'foo' node with</font>
<font color="black"> 372.         # a 'bar' node as a child of foo.</font>
<font color="black"> 373.         # {'foo': {'children': {'bar': {...}}}}.</font>
<font color="green"> 374.         self._root = {'chunk': None, 'children': {}, 'values': None}</font>
<font color="black"> 375. </font>
<font color="green"> 376.     def append_item(self, key, value, section=_MIDDLE):</font>
<font color="black"> 377.         &quot;&quot;&quot;Add an item to a key.</font>
<font color="black"> 378. </font>
<font color="black"> 379.         If a value is already associated with that key, the new</font>
<font color="black"> 380.         value is appended to the list for the key.</font>
<font color="black"> 381.         &quot;&quot;&quot;</font>
<font color="green"> 382.         key_parts = key.split('.')</font>
<font color="green"> 383.         current = self._root</font>
<font color="green"> 384.         for part in key_parts:</font>
<font color="green"> 385.             if part not in current['children']:</font>
<font color="green"> 386.                 new_child = {'chunk': part, 'values': None, 'children': {}}</font>
<font color="green"> 387.                 current['children'][part] = new_child</font>
<font color="green"> 388.                 current = new_child</font>
<font color="black"> 389.             else:</font>
<font color="green"> 390.                 current = current['children'][part]</font>
<font color="green"> 391.         if current['values'] is None:</font>
<font color="green"> 392.             current['values'] = NodeList([], [], [])</font>
<font color="green"> 393.         current['values'][section].append(value)</font>
<font color="black"> 394. </font>
<font color="green"> 395.     def prefix_search(self, key):</font>
<font color="black"> 396.         &quot;&quot;&quot;Collect all items that are prefixes of key.</font>
<font color="black"> 397. </font>
<font color="black"> 398.         Prefix in this case are delineated by '.' characters so</font>
<font color="black"> 399.         'foo.bar.baz' is a 3 chunk sequence of 3 &quot;prefixes&quot; (</font>
<font color="black"> 400.         &quot;foo&quot;, &quot;bar&quot;, and &quot;baz&quot;).</font>
<font color="black"> 401. </font>
<font color="black"> 402.         &quot;&quot;&quot;</font>
<font color="green"> 403.         collected = deque()</font>
<font color="green"> 404.         key_parts = key.split('.')</font>
<font color="green"> 405.         current = self._root</font>
<font color="green"> 406.         self._get_items(current, key_parts, collected, 0)</font>
<font color="green"> 407.         return collected</font>
<font color="black"> 408. </font>
<font color="green"> 409.     def _get_items(self, starting_node, key_parts, collected, starting_index):</font>
<font color="green"> 410.         stack = [(starting_node, starting_index)]</font>
<font color="green"> 411.         key_parts_len = len(key_parts)</font>
<font color="black"> 412.         # Traverse down the nodes, where at each level we add the</font>
<font color="black"> 413.         # next part from key_parts as well as the wildcard element '*'.</font>
<font color="black"> 414.         # This means for each node we see we potentially add two more</font>
<font color="black"> 415.         # elements to our stack.</font>
<font color="green"> 416.         while stack:</font>
<font color="green"> 417.             current_node, index = stack.pop()</font>
<font color="green"> 418.             if current_node['values']:</font>
<font color="black"> 419.                 # We're using extendleft because we want</font>
<font color="black"> 420.                 # the values associated with the node furthest</font>
<font color="black"> 421.                 # from the root to come before nodes closer</font>
<font color="black"> 422.                 # to the root.  extendleft() also adds its items</font>
<font color="black"> 423.                 # in right-left order so .extendleft([1, 2, 3])</font>
<font color="black"> 424.                 # will result in final_list = [3, 2, 1], which is</font>
<font color="black"> 425.                 # why we reverse the lists.</font>
<font color="green"> 426.                 node_list = current_node['values']</font>
<font color="green"> 427.                 complete_order = (node_list.first + node_list.middle +</font>
<font color="green"> 428.                                   node_list.last)</font>
<font color="green"> 429.                 collected.extendleft(reversed(complete_order))</font>
<font color="green"> 430.             if not index == key_parts_len:</font>
<font color="green"> 431.                 children = current_node['children']</font>
<font color="green"> 432.                 directs = children.get(key_parts[index])</font>
<font color="green"> 433.                 wildcard = children.get('*')</font>
<font color="green"> 434.                 next_index = index + 1</font>
<font color="green"> 435.                 if wildcard is not None:</font>
<font color="red"> 436.                     stack.append((wildcard, next_index))</font>
<font color="green"> 437.                 if directs is not None:</font>
<font color="green"> 438.                     stack.append((directs, next_index))</font>
<font color="black"> 439. </font>
<font color="green"> 440.     def remove_item(self, key, value):</font>
<font color="black"> 441.         &quot;&quot;&quot;Remove an item associated with a key.</font>
<font color="black"> 442. </font>
<font color="black"> 443.         If the value is not associated with the key a ``ValueError``</font>
<font color="black"> 444.         will be raised.  If the key does not exist in the trie, a</font>
<font color="black"> 445.         ``ValueError`` will be raised.</font>
<font color="black"> 446. </font>
<font color="black"> 447.         &quot;&quot;&quot;</font>
<font color="red"> 448.         key_parts = key.split('.')</font>
<font color="red"> 449.         current = self._root</font>
<font color="red"> 450.         self._remove_item(current, key_parts, value, index=0)</font>
<font color="black"> 451. </font>
<font color="green"> 452.     def _remove_item(self, current_node, key_parts, value, index):</font>
<font color="red"> 453.         if current_node is None:</font>
<font color="red"> 454.             return</font>
<font color="red"> 455.         elif index &lt; len(key_parts):</font>
<font color="red"> 456.             next_node = current_node['children'].get(key_parts[index])</font>
<font color="red"> 457.             if next_node is not None:</font>
<font color="red"> 458.                 self._remove_item(next_node, key_parts, value, index + 1)</font>
<font color="red"> 459.                 if index == len(key_parts) - 1:</font>
<font color="red"> 460.                     node_list = next_node['values']</font>
<font color="red"> 461.                     if value in node_list.first:</font>
<font color="red"> 462.                         node_list.first.remove(value)</font>
<font color="red"> 463.                     elif value in node_list.middle:</font>
<font color="red"> 464.                         node_list.middle.remove(value)</font>
<font color="red"> 465.                     elif value in node_list.last:</font>
<font color="red"> 466.                         node_list.last.remove(value)</font>
<font color="red"> 467.                 if not next_node['children'] and not next_node['values']:</font>
<font color="black"> 468.                     # Then this is a leaf node with no values so</font>
<font color="black"> 469.                     # we can just delete this link from the parent node.</font>
<font color="black"> 470.                     # This makes subsequent search faster in the case</font>
<font color="black"> 471.                     # where a key does not exist.</font>
<font color="red"> 472.                     del current_node['children'][key_parts[index]]</font>
<font color="black"> 473.             else:</font>
<font color="red"> 474.                 raise ValueError(</font>
<font color="red"> 475.                     &quot;key is not in trie: %s&quot; % '.'.join(key_parts))</font>
<font color="black"> 476. </font>
<font color="green"> 477.     def __copy__(self):</font>
<font color="black"> 478.         # The fact that we're using a nested dict under the covers</font>
<font color="black"> 479.         # is an implementation detail, and the user shouldn't have</font>
<font color="black"> 480.         # to know that they'd normally need a deepcopy so we expose</font>
<font color="black"> 481.         # __copy__ instead of __deepcopy__.</font>
<font color="green"> 482.         new_copy = self.__class__()</font>
<font color="green"> 483.         copied_attrs = self._recursive_copy(self.__dict__)</font>
<font color="green"> 484.         new_copy.__dict__ = copied_attrs</font>
<font color="green"> 485.         return new_copy</font>
<font color="black"> 486. </font>
<font color="green"> 487.     def _recursive_copy(self, node):</font>
<font color="black"> 488.         # We can't use copy.deepcopy because we actually only want to copy</font>
<font color="black"> 489.         # the structure of the trie, not the handlers themselves.</font>
<font color="black"> 490.         # Each node has a chunk, children, and values.</font>
<font color="green"> 491.         copied_node = {}</font>
<font color="green"> 492.         for key, value in node.items():</font>
<font color="green"> 493.             if isinstance(value, NodeList):</font>
<font color="green"> 494.                 copied_node[key] = copy.copy(value)</font>
<font color="green"> 495.             elif isinstance(value, dict):</font>
<font color="green"> 496.                 copied_node[key] = self._recursive_copy(value)</font>
<font color="black"> 497.             else:</font>
<font color="green"> 498.                 copied_node[key] = value</font>
<font color="green"> 499.         return copied_node</font>
</pre>

