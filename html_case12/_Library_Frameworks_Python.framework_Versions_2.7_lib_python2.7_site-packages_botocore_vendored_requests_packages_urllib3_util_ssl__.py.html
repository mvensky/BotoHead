source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/packages/urllib3/util/ssl_.py</b><br>


file stats: <b>130 lines, 56 executed: 43.1% covered</b>
<pre>
<font color="green">   1. from binascii import hexlify, unhexlify</font>
<font color="green">   2. from hashlib import md5, sha1, sha256</font>
<font color="black">   3. </font>
<font color="green">   4. from ..exceptions import SSLError, InsecurePlatformWarning</font>
<font color="black">   5. </font>
<font color="black">   6. </font>
<font color="green">   7. SSLContext = None</font>
<font color="green">   8. HAS_SNI = False</font>
<font color="green">   9. create_default_context = None</font>
<font color="black">  10. </font>
<font color="green">  11. import errno</font>
<font color="green">  12. import warnings</font>
<font color="black">  13. </font>
<font color="green">  14. try:  # Test for SSL features</font>
<font color="green">  15.     import ssl</font>
<font color="green">  16.     from ssl import wrap_socket, CERT_NONE, PROTOCOL_SSLv23</font>
<font color="green">  17.     from ssl import HAS_SNI  # Has SNI?</font>
<font color="red">  18. except ImportError:</font>
<font color="red">  19.     pass</font>
<font color="black">  20. </font>
<font color="black">  21. </font>
<font color="green">  22. try:</font>
<font color="green">  23.     from ssl import OP_NO_SSLv2, OP_NO_SSLv3, OP_NO_COMPRESSION</font>
<font color="red">  24. except ImportError:</font>
<font color="red">  25.     OP_NO_SSLv2, OP_NO_SSLv3 = 0x1000000, 0x2000000</font>
<font color="red">  26.     OP_NO_COMPRESSION = 0x20000</font>
<font color="black">  27. </font>
<font color="black">  28. # A secure default.</font>
<font color="black">  29. # Sources for more information on TLS ciphers:</font>
<font color="black">  30. #</font>
<font color="black">  31. # - https://wiki.mozilla.org/Security/Server_Side_TLS</font>
<font color="black">  32. # - https://www.ssllabs.com/projects/best-practices/index.html</font>
<font color="black">  33. # - https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/</font>
<font color="black">  34. #</font>
<font color="black">  35. # The general intent is:</font>
<font color="black">  36. # - Prefer cipher suites that offer perfect forward secrecy (DHE/ECDHE),</font>
<font color="black">  37. # - prefer ECDHE over DHE for better performance,</font>
<font color="black">  38. # - prefer any AES-GCM over any AES-CBC for better performance and security,</font>
<font color="black">  39. # - use 3DES as fallback which is secure but slow,</font>
<font color="black">  40. # - disable NULL authentication, MD5 MACs and DSS for security reasons.</font>
<font color="black">  41. DEFAULT_CIPHERS = (</font>
<font color="green">  42.     'ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+HIGH:'</font>
<font color="black">  43.     'DH+HIGH:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+HIGH:RSA+3DES:!aNULL:'</font>
<font color="black">  44.     '!eNULL:!MD5'</font>
<font color="black">  45. )</font>
<font color="black">  46. </font>
<font color="green">  47. try:</font>
<font color="green">  48.     from ssl import SSLContext  # Modern SSL?</font>
<font color="red">  49. except ImportError:</font>
<font color="red">  50.     import sys</font>
<font color="black">  51. </font>
<font color="red">  52.     class SSLContext(object):  # Platform-specific: Python 2 &amp; 3.1</font>
<font color="red">  53.         supports_set_ciphers = ((2, 7) &lt;= sys.version_info &lt; (3,) or</font>
<font color="red">  54.                                 (3, 2) &lt;= sys.version_info)</font>
<font color="black">  55. </font>
<font color="red">  56.         def __init__(self, protocol_version):</font>
<font color="red">  57.             self.protocol = protocol_version</font>
<font color="black">  58.             # Use default values from a real SSLContext</font>
<font color="red">  59.             self.check_hostname = False</font>
<font color="red">  60.             self.verify_mode = ssl.CERT_NONE</font>
<font color="red">  61.             self.ca_certs = None</font>
<font color="red">  62.             self.options = 0</font>
<font color="red">  63.             self.certfile = None</font>
<font color="red">  64.             self.keyfile = None</font>
<font color="red">  65.             self.ciphers = None</font>
<font color="black">  66. </font>
<font color="red">  67.         def load_cert_chain(self, certfile, keyfile):</font>
<font color="red">  68.             self.certfile = certfile</font>
<font color="red">  69.             self.keyfile = keyfile</font>
<font color="black">  70. </font>
<font color="red">  71.         def load_verify_locations(self, location):</font>
<font color="red">  72.             self.ca_certs = location</font>
<font color="black">  73. </font>
<font color="red">  74.         def set_ciphers(self, cipher_suite):</font>
<font color="red">  75.             if not self.supports_set_ciphers:</font>
<font color="red">  76.                 raise TypeError(</font>
<font color="red">  77.                     'Your version of Python does not support setting '</font>
<font color="black">  78.                     'a custom cipher suite. Please upgrade to Python '</font>
<font color="black">  79.                     '2.7, 3.2, or later if you need this functionality.'</font>
<font color="black">  80.                 )</font>
<font color="red">  81.             self.ciphers = cipher_suite</font>
<font color="black">  82. </font>
<font color="red">  83.         def wrap_socket(self, socket, server_hostname=None):</font>
<font color="red">  84.             warnings.warn(</font>
<font color="red">  85.                 'A true SSLContext object is not available. This prevents '</font>
<font color="black">  86.                 'urllib3 from configuring SSL appropriately and may cause '</font>
<font color="black">  87.                 'certain SSL connections to fail. For more information, see '</font>
<font color="black">  88.                 'https://urllib3.readthedocs.org/en/latest/security.html'</font>
<font color="black">  89.                 '#insecureplatformwarning.',</font>
<font color="red">  90.                 InsecurePlatformWarning</font>
<font color="black">  91.             )</font>
<font color="red">  92.             kwargs = {</font>
<font color="red">  93.                 'keyfile': self.keyfile,</font>
<font color="red">  94.                 'certfile': self.certfile,</font>
<font color="red">  95.                 'ca_certs': self.ca_certs,</font>
<font color="red">  96.                 'cert_reqs': self.verify_mode,</font>
<font color="red">  97.                 'ssl_version': self.protocol,</font>
<font color="black">  98.             }</font>
<font color="red">  99.             if self.supports_set_ciphers:  # Platform-specific: Python 2.7+</font>
<font color="red"> 100.                 return wrap_socket(socket, ciphers=self.ciphers, **kwargs)</font>
<font color="black"> 101.             else:  # Platform-specific: Python 2.6</font>
<font color="red"> 102.                 return wrap_socket(socket, **kwargs)</font>
<font color="black"> 103. </font>
<font color="black"> 104. </font>
<font color="green"> 105. def assert_fingerprint(cert, fingerprint):</font>
<font color="black"> 106.     &quot;&quot;&quot;</font>
<font color="black"> 107.     Checks if given fingerprint matches the supplied certificate.</font>
<font color="black"> 108. </font>
<font color="black"> 109.     :param cert:</font>
<font color="black"> 110.         Certificate as bytes object.</font>
<font color="black"> 111.     :param fingerprint:</font>
<font color="black"> 112.         Fingerprint as string of hexdigits, can be interspersed by colons.</font>
<font color="black"> 113.     &quot;&quot;&quot;</font>
<font color="black"> 114. </font>
<font color="black"> 115.     # Maps the length of a digest to a possible hash function producing</font>
<font color="black"> 116.     # this digest.</font>
<font color="red"> 117.     hashfunc_map = {</font>
<font color="red"> 118.         16: md5,</font>
<font color="red"> 119.         20: sha1,</font>
<font color="red"> 120.         32: sha256,</font>
<font color="black"> 121.     }</font>
<font color="black"> 122. </font>
<font color="red"> 123.     fingerprint = fingerprint.replace(':', '').lower()</font>
<font color="red"> 124.     digest_length, odd = divmod(len(fingerprint), 2)</font>
<font color="black"> 125. </font>
<font color="red"> 126.     if odd or digest_length not in hashfunc_map:</font>
<font color="red"> 127.         raise SSLError('Fingerprint is of invalid length.')</font>
<font color="black"> 128. </font>
<font color="black"> 129.     # We need encode() here for py32; works on py2 and p33.</font>
<font color="red"> 130.     fingerprint_bytes = unhexlify(fingerprint.encode())</font>
<font color="black"> 131. </font>
<font color="red"> 132.     hashfunc = hashfunc_map[digest_length]</font>
<font color="black"> 133. </font>
<font color="red"> 134.     cert_digest = hashfunc(cert).digest()</font>
<font color="black"> 135. </font>
<font color="red"> 136.     if not cert_digest == fingerprint_bytes:</font>
<font color="red"> 137.         raise SSLError('Fingerprints did not match. Expected &quot;{0}&quot;, got &quot;{1}&quot;.'</font>
<font color="red"> 138.                        .format(hexlify(fingerprint_bytes),</font>
<font color="red"> 139.                                hexlify(cert_digest)))</font>
<font color="black"> 140. </font>
<font color="black"> 141. </font>
<font color="green"> 142. def resolve_cert_reqs(candidate):</font>
<font color="black"> 143.     &quot;&quot;&quot;</font>
<font color="black"> 144.     Resolves the argument to a numeric constant, which can be passed to</font>
<font color="black"> 145.     the wrap_socket function/method from the ssl module.</font>
<font color="black"> 146.     Defaults to :data:`ssl.CERT_NONE`.</font>
<font color="black"> 147.     If given a string it is assumed to be the name of the constant in the</font>
<font color="black"> 148.     :mod:`ssl` module or its abbrevation.</font>
<font color="black"> 149.     (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.</font>
<font color="black"> 150.     If it's neither `None` nor a string we assume it is already the numeric</font>
<font color="black"> 151.     constant which can directly be passed to wrap_socket.</font>
<font color="black"> 152.     &quot;&quot;&quot;</font>
<font color="green"> 153.     if candidate is None:</font>
<font color="red"> 154.         return CERT_NONE</font>
<font color="black"> 155. </font>
<font color="green"> 156.     if isinstance(candidate, str):</font>
<font color="green"> 157.         res = getattr(ssl, candidate, None)</font>
<font color="green"> 158.         if res is None:</font>
<font color="red"> 159.             res = getattr(ssl, 'CERT_' + candidate)</font>
<font color="green"> 160.         return res</font>
<font color="black"> 161. </font>
<font color="red"> 162.     return candidate</font>
<font color="black"> 163. </font>
<font color="black"> 164. </font>
<font color="green"> 165. def resolve_ssl_version(candidate):</font>
<font color="black"> 166.     &quot;&quot;&quot;</font>
<font color="black"> 167.     like resolve_cert_reqs</font>
<font color="black"> 168.     &quot;&quot;&quot;</font>
<font color="green"> 169.     if candidate is None:</font>
<font color="green"> 170.         return PROTOCOL_SSLv23</font>
<font color="black"> 171. </font>
<font color="red"> 172.     if isinstance(candidate, str):</font>
<font color="red"> 173.         res = getattr(ssl, candidate, None)</font>
<font color="red"> 174.         if res is None:</font>
<font color="red"> 175.             res = getattr(ssl, 'PROTOCOL_' + candidate)</font>
<font color="red"> 176.         return res</font>
<font color="black"> 177. </font>
<font color="red"> 178.     return candidate</font>
<font color="black"> 179. </font>
<font color="black"> 180. </font>
<font color="green"> 181. def create_urllib3_context(ssl_version=None, cert_reqs=None,</font>
<font color="green"> 182.                            options=None, ciphers=None):</font>
<font color="black"> 183.     &quot;&quot;&quot;All arguments have the same meaning as ``ssl_wrap_socket``.</font>
<font color="black"> 184. </font>
<font color="black"> 185.     By default, this function does a lot of the same work that</font>
<font color="black"> 186.     ``ssl.create_default_context`` does on Python 3.4+. It:</font>
<font color="black"> 187. </font>
<font color="black"> 188.     - Disables SSLv2, SSLv3, and compression</font>
<font color="black"> 189.     - Sets a restricted set of server ciphers</font>
<font color="black"> 190. </font>
<font color="black"> 191.     If you wish to enable SSLv3, you can do::</font>
<font color="black"> 192. </font>
<font color="black"> 193.         from urllib3.util import ssl_</font>
<font color="black"> 194.         context = ssl_.create_urllib3_context()</font>
<font color="black"> 195.         context.options &amp;= ~ssl_.OP_NO_SSLv3</font>
<font color="black"> 196. </font>
<font color="black"> 197.     You can do the same to enable compression (substituting ``COMPRESSION``</font>
<font color="black"> 198.     for ``SSLv3`` in the last line above).</font>
<font color="black"> 199. </font>
<font color="black"> 200.     :param ssl_version:</font>
<font color="black"> 201.         The desired protocol version to use. This will default to</font>
<font color="black"> 202.         PROTOCOL_SSLv23 which will negotiate the highest protocol that both</font>
<font color="black"> 203.         the server and your installation of OpenSSL support.</font>
<font color="black"> 204.     :param cert_reqs:</font>
<font color="black"> 205.         Whether to require the certificate verification. This defaults to</font>
<font color="black"> 206.         ``ssl.CERT_REQUIRED``.</font>
<font color="black"> 207.     :param options:</font>
<font color="black"> 208.         Specific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``,</font>
<font color="black"> 209.         ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``.</font>
<font color="black"> 210.     :param ciphers:</font>
<font color="black"> 211.         Which cipher suites to allow the server to select.</font>
<font color="black"> 212.     :returns:</font>
<font color="black"> 213.         Constructed SSLContext object with specified options</font>
<font color="black"> 214.     :rtype: SSLContext</font>
<font color="black"> 215.     &quot;&quot;&quot;</font>
<font color="green"> 216.     context = SSLContext(ssl_version or ssl.PROTOCOL_SSLv23)</font>
<font color="black"> 217. </font>
<font color="black"> 218.     # Setting the default here, as we may have no ssl module on import</font>
<font color="green"> 219.     cert_reqs = ssl.CERT_REQUIRED if cert_reqs is None else cert_reqs</font>
<font color="black"> 220. </font>
<font color="green"> 221.     if options is None:</font>
<font color="green"> 222.         options = 0</font>
<font color="black"> 223.         # SSLv2 is easily broken and is considered harmful and dangerous</font>
<font color="green"> 224.         options |= OP_NO_SSLv2</font>
<font color="black"> 225.         # SSLv3 has several problems and is now dangerous</font>
<font color="green"> 226.         options |= OP_NO_SSLv3</font>
<font color="black"> 227.         # Disable compression to prevent CRIME attacks for OpenSSL 1.0+</font>
<font color="black"> 228.         # (issue #309)</font>
<font color="green"> 229.         options |= OP_NO_COMPRESSION</font>
<font color="black"> 230. </font>
<font color="green"> 231.     context.options |= options</font>
<font color="black"> 232. </font>
<font color="green"> 233.     if getattr(context, 'supports_set_ciphers', True):  # Platform-specific: Python 2.6</font>
<font color="green"> 234.         context.set_ciphers(ciphers or DEFAULT_CIPHERS)</font>
<font color="black"> 235. </font>
<font color="green"> 236.     context.verify_mode = cert_reqs</font>
<font color="green"> 237.     if getattr(context, 'check_hostname', None) is not None:  # Platform-specific: Python 3.2</font>
<font color="black"> 238.         # We do our own verification, including fingerprints and alternative</font>
<font color="black"> 239.         # hostnames. So disable it here</font>
<font color="green"> 240.         context.check_hostname = False</font>
<font color="green"> 241.     return context</font>
<font color="black"> 242. </font>
<font color="black"> 243. </font>
<font color="green"> 244. def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,</font>
<font color="green"> 245.                     ca_certs=None, server_hostname=None,</font>
<font color="green"> 246.                     ssl_version=None, ciphers=None, ssl_context=None):</font>
<font color="black"> 247.     &quot;&quot;&quot;</font>
<font color="black"> 248.     All arguments except for server_hostname and ssl_context have the same</font>
<font color="black"> 249.     meaning as they do when using :func:`ssl.wrap_socket`.</font>
<font color="black"> 250. </font>
<font color="black"> 251.     :param server_hostname:</font>
<font color="black"> 252.         When SNI is supported, the expected hostname of the certificate</font>
<font color="black"> 253.     :param ssl_context:</font>
<font color="black"> 254.         A pre-made :class:`SSLContext` object. If none is provided, one will</font>
<font color="black"> 255.         be created using :func:`create_urllib3_context`.</font>
<font color="black"> 256.     :param ciphers:</font>
<font color="black"> 257.         A string of ciphers we wish the client to support. This is not</font>
<font color="black"> 258.         supported on Python 2.6 as the ssl module does not support it.</font>
<font color="black"> 259.     &quot;&quot;&quot;</font>
<font color="green"> 260.     context = ssl_context</font>
<font color="green"> 261.     if context is None:</font>
<font color="green"> 262.         context = create_urllib3_context(ssl_version, cert_reqs,</font>
<font color="green"> 263.                                          ciphers=ciphers)</font>
<font color="black"> 264. </font>
<font color="green"> 265.     if ca_certs:</font>
<font color="green"> 266.         try:</font>
<font color="green"> 267.             context.load_verify_locations(ca_certs)</font>
<font color="red"> 268.         except IOError as e:  # Platform-specific: Python 2.6, 2.7, 3.2</font>
<font color="red"> 269.             raise SSLError(e)</font>
<font color="black"> 270.         # Py33 raises FileNotFoundError which subclasses OSError</font>
<font color="black"> 271.         # These are not equivalent unless we check the errno attribute</font>
<font color="red"> 272.         except OSError as e:  # Platform-specific: Python 3.3 and beyond</font>
<font color="red"> 273.             if e.errno == errno.ENOENT:</font>
<font color="red"> 274.                 raise SSLError(e)</font>
<font color="red"> 275.             raise</font>
<font color="green"> 276.     if certfile:</font>
<font color="red"> 277.         context.load_cert_chain(certfile, keyfile)</font>
<font color="green"> 278.     if HAS_SNI:  # Platform-specific: OpenSSL with enabled SNI</font>
<font color="green"> 279.         return context.wrap_socket(sock, server_hostname=server_hostname)</font>
<font color="red"> 280.     return context.wrap_socket(sock)</font>
</pre>

