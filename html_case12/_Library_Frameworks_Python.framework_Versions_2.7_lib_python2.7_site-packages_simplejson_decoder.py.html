source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/simplejson/decoder.py</b><br>


file stats: <b>251 lines, 59 executed: 23.5% covered</b>
<pre>
<font color="black">   1. &quot;&quot;&quot;Implementation of JSONDecoder</font>
<font color="green">   2. &quot;&quot;&quot;</font>
<font color="green">   3. from __future__ import absolute_import</font>
<font color="green">   4. import re</font>
<font color="green">   5. import sys</font>
<font color="green">   6. import struct</font>
<font color="green">   7. from .compat import b, u, text_type, binary_type, PY3, unichr</font>
<font color="green">   8. from .scanner import make_scanner, JSONDecodeError</font>
<font color="black">   9. </font>
<font color="green">  10. def _import_c_scanstring():</font>
<font color="green">  11.     try:</font>
<font color="green">  12.         from ._speedups import scanstring</font>
<font color="green">  13.         return scanstring</font>
<font color="red">  14.     except ImportError:</font>
<font color="red">  15.         return None</font>
<font color="green">  16. c_scanstring = _import_c_scanstring()</font>
<font color="black">  17. </font>
<font color="black">  18. # NOTE (3.1.0): JSONDecodeError may still be imported from this module for</font>
<font color="black">  19. # compatibility, but it was never in the __all__</font>
<font color="green">  20. __all__ = ['JSONDecoder']</font>
<font color="black">  21. </font>
<font color="green">  22. FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL</font>
<font color="black">  23. </font>
<font color="green">  24. def _floatconstants():</font>
<font color="green">  25.     if sys.version_info &lt; (2, 6):</font>
<font color="red">  26.         _BYTES = '7FF80000000000007FF0000000000000'.decode('hex')</font>
<font color="black">  27.         # The struct module in Python 2.4 would get frexp() out of range here</font>
<font color="black">  28.         # when an endian is specified in the format string. Fixed in Python 2.5+</font>
<font color="red">  29.         if sys.byteorder != 'big':</font>
<font color="red">  30.             _BYTES = _BYTES[:8][::-1] + _BYTES[8:][::-1]</font>
<font color="red">  31.         nan, inf = struct.unpack('dd', _BYTES)</font>
<font color="black">  32.     else:</font>
<font color="green">  33.         nan = float('nan')</font>
<font color="green">  34.         inf = float('inf')</font>
<font color="green">  35.     return nan, inf, -inf</font>
<font color="black">  36. </font>
<font color="green">  37. NaN, PosInf, NegInf = _floatconstants()</font>
<font color="black">  38. </font>
<font color="green">  39. _CONSTANTS = {</font>
<font color="green">  40.     '-Infinity': NegInf,</font>
<font color="green">  41.     'Infinity': PosInf,</font>
<font color="green">  42.     'NaN': NaN,</font>
<font color="black">  43. }</font>
<font color="black">  44. </font>
<font color="green">  45. STRINGCHUNK = re.compile(r'(.*?)([&quot;\\\x00-\x1f])', FLAGS)</font>
<font color="green">  46. BACKSLASH = {</font>
<font color="green">  47.     '&quot;': u('&quot;'), '\\': u('\u005c'), '/': u('/'),</font>
<font color="green">  48.     'b': u('\b'), 'f': u('\f'), 'n': u('\n'), 'r': u('\r'), 't': u('\t'),</font>
<font color="black">  49. }</font>
<font color="black">  50. </font>
<font color="green">  51. DEFAULT_ENCODING = &quot;utf-8&quot;</font>
<font color="black">  52. </font>
<font color="green">  53. def py_scanstring(s, end, encoding=None, strict=True,</font>
<font color="green">  54.         _b=BACKSLASH, _m=STRINGCHUNK.match, _join=u('').join,</font>
<font color="green">  55.         _PY3=PY3, _maxunicode=sys.maxunicode):</font>
<font color="black">  56.     &quot;&quot;&quot;Scan the string s for a JSON string. End is the index of the</font>
<font color="black">  57.     character in s after the quote that started the JSON string.</font>
<font color="black">  58.     Unescapes all valid JSON string escape sequences and raises ValueError</font>
<font color="black">  59.     on attempt to decode an invalid string. If strict is False then literal</font>
<font color="black">  60.     control characters are allowed in the string.</font>
<font color="black">  61. </font>
<font color="black">  62.     Returns a tuple of the decoded string and the index of the character in s</font>
<font color="black">  63.     after the end quote.&quot;&quot;&quot;</font>
<font color="red">  64.     if encoding is None:</font>
<font color="red">  65.         encoding = DEFAULT_ENCODING</font>
<font color="red">  66.     chunks = []</font>
<font color="red">  67.     _append = chunks.append</font>
<font color="red">  68.     begin = end - 1</font>
<font color="red">  69.     while 1:</font>
<font color="red">  70.         chunk = _m(s, end)</font>
<font color="red">  71.         if chunk is None:</font>
<font color="red">  72.             raise JSONDecodeError(</font>
<font color="red">  73.                 &quot;Unterminated string starting at&quot;, s, begin)</font>
<font color="red">  74.         end = chunk.end()</font>
<font color="red">  75.         content, terminator = chunk.groups()</font>
<font color="black">  76.         # Content is contains zero or more unescaped string characters</font>
<font color="red">  77.         if content:</font>
<font color="red">  78.             if not _PY3 and not isinstance(content, text_type):</font>
<font color="red">  79.                 content = text_type(content, encoding)</font>
<font color="red">  80.             _append(content)</font>
<font color="black">  81.         # Terminator is the end of string, a literal control character,</font>
<font color="black">  82.         # or a backslash denoting that an escape sequence follows</font>
<font color="red">  83.         if terminator == '&quot;':</font>
<font color="red">  84.             break</font>
<font color="red">  85.         elif terminator != '\\':</font>
<font color="red">  86.             if strict:</font>
<font color="red">  87.                 msg = &quot;Invalid control character %r at&quot;</font>
<font color="red">  88.                 raise JSONDecodeError(msg, s, end)</font>
<font color="black">  89.             else:</font>
<font color="red">  90.                 _append(terminator)</font>
<font color="red">  91.                 continue</font>
<font color="red">  92.         try:</font>
<font color="red">  93.             esc = s[end]</font>
<font color="red">  94.         except IndexError:</font>
<font color="red">  95.             raise JSONDecodeError(</font>
<font color="red">  96.                 &quot;Unterminated string starting at&quot;, s, begin)</font>
<font color="black">  97.         # If not a unicode escape sequence, must be in the lookup table</font>
<font color="red">  98.         if esc != 'u':</font>
<font color="red">  99.             try:</font>
<font color="red"> 100.                 char = _b[esc]</font>
<font color="red"> 101.             except KeyError:</font>
<font color="red"> 102.                 msg = &quot;Invalid \\X escape sequence %r&quot;</font>
<font color="red"> 103.                 raise JSONDecodeError(msg, s, end)</font>
<font color="red"> 104.             end += 1</font>
<font color="black"> 105.         else:</font>
<font color="black"> 106.             # Unicode escape sequence</font>
<font color="red"> 107.             msg = &quot;Invalid \\uXXXX escape sequence&quot;</font>
<font color="red"> 108.             esc = s[end + 1:end + 5]</font>
<font color="red"> 109.             escX = esc[1:2]</font>
<font color="red"> 110.             if len(esc) != 4 or escX == 'x' or escX == 'X':</font>
<font color="red"> 111.                 raise JSONDecodeError(msg, s, end - 1)</font>
<font color="red"> 112.             try:</font>
<font color="red"> 113.                 uni = int(esc, 16)</font>
<font color="red"> 114.             except ValueError:</font>
<font color="red"> 115.                 raise JSONDecodeError(msg, s, end - 1)</font>
<font color="red"> 116.             end += 5</font>
<font color="black"> 117.             # Check for surrogate pair on UCS-4 systems</font>
<font color="black"> 118.             # Note that this will join high/low surrogate pairs</font>
<font color="black"> 119.             # but will also pass unpaired surrogates through</font>
<font color="red"> 120.             if (_maxunicode &gt; 65535 and</font>
<font color="red"> 121.                 uni &amp; 0xfc00 == 0xd800 and</font>
<font color="red"> 122.                 s[end:end + 2] == '\\u'):</font>
<font color="red"> 123.                 esc2 = s[end + 2:end + 6]</font>
<font color="red"> 124.                 escX = esc2[1:2]</font>
<font color="red"> 125.                 if len(esc2) == 4 and not (escX == 'x' or escX == 'X'):</font>
<font color="red"> 126.                     try:</font>
<font color="red"> 127.                         uni2 = int(esc2, 16)</font>
<font color="red"> 128.                     except ValueError:</font>
<font color="red"> 129.                         raise JSONDecodeError(msg, s, end)</font>
<font color="red"> 130.                     if uni2 &amp; 0xfc00 == 0xdc00:</font>
<font color="red"> 131.                         uni = 0x10000 + (((uni - 0xd800) &lt;&lt; 10) |</font>
<font color="red"> 132.                                          (uni2 - 0xdc00))</font>
<font color="red"> 133.                         end += 6</font>
<font color="red"> 134.             char = unichr(uni)</font>
<font color="black"> 135.         # Append the unescaped character</font>
<font color="red"> 136.         _append(char)</font>
<font color="red"> 137.     return _join(chunks), end</font>
<font color="black"> 138. </font>
<font color="black"> 139. </font>
<font color="black"> 140. # Use speedup if available</font>
<font color="green"> 141. scanstring = c_scanstring or py_scanstring</font>
<font color="black"> 142. </font>
<font color="green"> 143. WHITESPACE = re.compile(r'[ \t\n\r]*', FLAGS)</font>
<font color="green"> 144. WHITESPACE_STR = ' \t\n\r'</font>
<font color="black"> 145. </font>
<font color="black"> 146. def JSONObject(state, encoding, strict, scan_once, object_hook,</font>
<font color="green"> 147.         object_pairs_hook, memo=None,</font>
<font color="green"> 148.         _w=WHITESPACE.match, _ws=WHITESPACE_STR):</font>
<font color="red"> 149.     (s, end) = state</font>
<font color="black"> 150.     # Backwards compatibility</font>
<font color="red"> 151.     if memo is None:</font>
<font color="red"> 152.         memo = {}</font>
<font color="red"> 153.     memo_get = memo.setdefault</font>
<font color="red"> 154.     pairs = []</font>
<font color="black"> 155.     # Use a slice to prevent IndexError from being raised, the following</font>
<font color="black"> 156.     # check will raise a more specific ValueError if the string is empty</font>
<font color="red"> 157.     nextchar = s[end:end + 1]</font>
<font color="black"> 158.     # Normally we expect nextchar == '&quot;'</font>
<font color="red"> 159.     if nextchar != '&quot;':</font>
<font color="red"> 160.         if nextchar in _ws:</font>
<font color="red"> 161.             end = _w(s, end).end()</font>
<font color="red"> 162.             nextchar = s[end:end + 1]</font>
<font color="black"> 163.         # Trivial empty object</font>
<font color="red"> 164.         if nextchar == '}':</font>
<font color="red"> 165.             if object_pairs_hook is not None:</font>
<font color="red"> 166.                 result = object_pairs_hook(pairs)</font>
<font color="red"> 167.                 return result, end + 1</font>
<font color="red"> 168.             pairs = {}</font>
<font color="red"> 169.             if object_hook is not None:</font>
<font color="red"> 170.                 pairs = object_hook(pairs)</font>
<font color="red"> 171.             return pairs, end + 1</font>
<font color="red"> 172.         elif nextchar != '&quot;':</font>
<font color="red"> 173.             raise JSONDecodeError(</font>
<font color="red"> 174.                 &quot;Expecting property name enclosed in double quotes&quot;,</font>
<font color="red"> 175.                 s, end)</font>
<font color="red"> 176.     end += 1</font>
<font color="red"> 177.     while True:</font>
<font color="red"> 178.         key, end = scanstring(s, end, encoding, strict)</font>
<font color="red"> 179.         key = memo_get(key, key)</font>
<font color="black"> 180. </font>
<font color="black"> 181.         # To skip some function call overhead we optimize the fast paths where</font>
<font color="black"> 182.         # the JSON key separator is &quot;: &quot; or just &quot;:&quot;.</font>
<font color="red"> 183.         if s[end:end + 1] != ':':</font>
<font color="red"> 184.             end = _w(s, end).end()</font>
<font color="red"> 185.             if s[end:end + 1] != ':':</font>
<font color="red"> 186.                 raise JSONDecodeError(&quot;Expecting ':' delimiter&quot;, s, end)</font>
<font color="black"> 187. </font>
<font color="red"> 188.         end += 1</font>
<font color="black"> 189. </font>
<font color="red"> 190.         try:</font>
<font color="red"> 191.             if s[end] in _ws:</font>
<font color="red"> 192.                 end += 1</font>
<font color="red"> 193.                 if s[end] in _ws:</font>
<font color="red"> 194.                     end = _w(s, end + 1).end()</font>
<font color="red"> 195.         except IndexError:</font>
<font color="red"> 196.             pass</font>
<font color="black"> 197. </font>
<font color="red"> 198.         value, end = scan_once(s, end)</font>
<font color="red"> 199.         pairs.append((key, value))</font>
<font color="black"> 200. </font>
<font color="red"> 201.         try:</font>
<font color="red"> 202.             nextchar = s[end]</font>
<font color="red"> 203.             if nextchar in _ws:</font>
<font color="red"> 204.                 end = _w(s, end + 1).end()</font>
<font color="red"> 205.                 nextchar = s[end]</font>
<font color="red"> 206.         except IndexError:</font>
<font color="red"> 207.             nextchar = ''</font>
<font color="red"> 208.         end += 1</font>
<font color="black"> 209. </font>
<font color="red"> 210.         if nextchar == '}':</font>
<font color="red"> 211.             break</font>
<font color="red"> 212.         elif nextchar != ',':</font>
<font color="red"> 213.             raise JSONDecodeError(&quot;Expecting ',' delimiter or '}'&quot;, s, end - 1)</font>
<font color="black"> 214. </font>
<font color="red"> 215.         try:</font>
<font color="red"> 216.             nextchar = s[end]</font>
<font color="red"> 217.             if nextchar in _ws:</font>
<font color="red"> 218.                 end += 1</font>
<font color="red"> 219.                 nextchar = s[end]</font>
<font color="red"> 220.                 if nextchar in _ws:</font>
<font color="red"> 221.                     end = _w(s, end + 1).end()</font>
<font color="red"> 222.                     nextchar = s[end]</font>
<font color="red"> 223.         except IndexError:</font>
<font color="red"> 224.             nextchar = ''</font>
<font color="black"> 225. </font>
<font color="red"> 226.         end += 1</font>
<font color="red"> 227.         if nextchar != '&quot;':</font>
<font color="red"> 228.             raise JSONDecodeError(</font>
<font color="red"> 229.                 &quot;Expecting property name enclosed in double quotes&quot;,</font>
<font color="red"> 230.                 s, end - 1)</font>
<font color="black"> 231. </font>
<font color="red"> 232.     if object_pairs_hook is not None:</font>
<font color="red"> 233.         result = object_pairs_hook(pairs)</font>
<font color="red"> 234.         return result, end</font>
<font color="red"> 235.     pairs = dict(pairs)</font>
<font color="red"> 236.     if object_hook is not None:</font>
<font color="red"> 237.         pairs = object_hook(pairs)</font>
<font color="red"> 238.     return pairs, end</font>
<font color="black"> 239. </font>
<font color="green"> 240. def JSONArray(state, scan_once, _w=WHITESPACE.match, _ws=WHITESPACE_STR):</font>
<font color="red"> 241.     (s, end) = state</font>
<font color="red"> 242.     values = []</font>
<font color="red"> 243.     nextchar = s[end:end + 1]</font>
<font color="red"> 244.     if nextchar in _ws:</font>
<font color="red"> 245.         end = _w(s, end + 1).end()</font>
<font color="red"> 246.         nextchar = s[end:end + 1]</font>
<font color="black"> 247.     # Look-ahead for trivial empty array</font>
<font color="red"> 248.     if nextchar == ']':</font>
<font color="red"> 249.         return values, end + 1</font>
<font color="red"> 250.     elif nextchar == '':</font>
<font color="red"> 251.         raise JSONDecodeError(&quot;Expecting value or ']'&quot;, s, end)</font>
<font color="red"> 252.     _append = values.append</font>
<font color="red"> 253.     while True:</font>
<font color="red"> 254.         value, end = scan_once(s, end)</font>
<font color="red"> 255.         _append(value)</font>
<font color="red"> 256.         nextchar = s[end:end + 1]</font>
<font color="red"> 257.         if nextchar in _ws:</font>
<font color="red"> 258.             end = _w(s, end + 1).end()</font>
<font color="red"> 259.             nextchar = s[end:end + 1]</font>
<font color="red"> 260.         end += 1</font>
<font color="red"> 261.         if nextchar == ']':</font>
<font color="red"> 262.             break</font>
<font color="red"> 263.         elif nextchar != ',':</font>
<font color="red"> 264.             raise JSONDecodeError(&quot;Expecting ',' delimiter or ']'&quot;, s, end - 1)</font>
<font color="black"> 265. </font>
<font color="red"> 266.         try:</font>
<font color="red"> 267.             if s[end] in _ws:</font>
<font color="red"> 268.                 end += 1</font>
<font color="red"> 269.                 if s[end] in _ws:</font>
<font color="red"> 270.                     end = _w(s, end + 1).end()</font>
<font color="red"> 271.         except IndexError:</font>
<font color="red"> 272.             pass</font>
<font color="black"> 273. </font>
<font color="red"> 274.     return values, end</font>
<font color="black"> 275. </font>
<font color="green"> 276. class JSONDecoder(object):</font>
<font color="black"> 277.     &quot;&quot;&quot;Simple JSON &lt;http://json.org&gt; decoder</font>
<font color="black"> 278. </font>
<font color="black"> 279.     Performs the following translations in decoding by default:</font>
<font color="black"> 280. </font>
<font color="black"> 281.     +---------------+-------------------+</font>
<font color="black"> 282.     | JSON          | Python            |</font>
<font color="black"> 283.     +===============+===================+</font>
<font color="black"> 284.     | object        | dict              |</font>
<font color="black"> 285.     +---------------+-------------------+</font>
<font color="black"> 286.     | array         | list              |</font>
<font color="black"> 287.     +---------------+-------------------+</font>
<font color="black"> 288.     | string        | str, unicode      |</font>
<font color="black"> 289.     +---------------+-------------------+</font>
<font color="black"> 290.     | number (int)  | int, long         |</font>
<font color="black"> 291.     +---------------+-------------------+</font>
<font color="black"> 292.     | number (real) | float             |</font>
<font color="black"> 293.     +---------------+-------------------+</font>
<font color="black"> 294.     | true          | True              |</font>
<font color="black"> 295.     +---------------+-------------------+</font>
<font color="black"> 296.     | false         | False             |</font>
<font color="black"> 297.     +---------------+-------------------+</font>
<font color="black"> 298.     | null          | None              |</font>
<font color="black"> 299.     +---------------+-------------------+</font>
<font color="black"> 300. </font>
<font color="black"> 301.     It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as</font>
<font color="black"> 302.     their corresponding ``float`` values, which is outside the JSON spec.</font>
<font color="black"> 303. </font>
<font color="green"> 304.     &quot;&quot;&quot;</font>
<font color="black"> 305. </font>
<font color="green"> 306.     def __init__(self, encoding=None, object_hook=None, parse_float=None,</font>
<font color="green"> 307.             parse_int=None, parse_constant=None, strict=True,</font>
<font color="green"> 308.             object_pairs_hook=None):</font>
<font color="black"> 309.         &quot;&quot;&quot;</font>
<font color="black"> 310.         *encoding* determines the encoding used to interpret any</font>
<font color="black"> 311.         :class:`str` objects decoded by this instance (``'utf-8'`` by</font>
<font color="black"> 312.         default).  It has no effect when decoding :class:`unicode` objects.</font>
<font color="black"> 313. </font>
<font color="black"> 314.         Note that currently only encodings that are a superset of ASCII work,</font>
<font color="black"> 315.         strings of other encodings should be passed in as :class:`unicode`.</font>
<font color="black"> 316. </font>
<font color="black"> 317.         *object_hook*, if specified, will be called with the result of every</font>
<font color="black"> 318.         JSON object decoded and its return value will be used in place of the</font>
<font color="black"> 319.         given :class:`dict`.  This can be used to provide custom</font>
<font color="black"> 320.         deserializations (e.g. to support JSON-RPC class hinting).</font>
<font color="black"> 321. </font>
<font color="black"> 322.         *object_pairs_hook* is an optional function that will be called with</font>
<font color="black"> 323.         the result of any object literal decode with an ordered list of pairs.</font>
<font color="black"> 324.         The return value of *object_pairs_hook* will be used instead of the</font>
<font color="black"> 325.         :class:`dict`.  This feature can be used to implement custom decoders</font>
<font color="black"> 326.         that rely on the order that the key and value pairs are decoded (for</font>
<font color="black"> 327.         example, :func:`collections.OrderedDict` will remember the order of</font>
<font color="black"> 328.         insertion). If *object_hook* is also defined, the *object_pairs_hook*</font>
<font color="black"> 329.         takes priority.</font>
<font color="black"> 330. </font>
<font color="black"> 331.         *parse_float*, if specified, will be called with the string of every</font>
<font color="black"> 332.         JSON float to be decoded.  By default, this is equivalent to</font>
<font color="black"> 333.         ``float(num_str)``. This can be used to use another datatype or parser</font>
<font color="black"> 334.         for JSON floats (e.g. :class:`decimal.Decimal`).</font>
<font color="black"> 335. </font>
<font color="black"> 336.         *parse_int*, if specified, will be called with the string of every</font>
<font color="black"> 337.         JSON int to be decoded.  By default, this is equivalent to</font>
<font color="black"> 338.         ``int(num_str)``.  This can be used to use another datatype or parser</font>
<font color="black"> 339.         for JSON integers (e.g. :class:`float`).</font>
<font color="black"> 340. </font>
<font color="black"> 341.         *parse_constant*, if specified, will be called with one of the</font>
<font color="black"> 342.         following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This</font>
<font color="black"> 343.         can be used to raise an exception if invalid JSON numbers are</font>
<font color="black"> 344.         encountered.</font>
<font color="black"> 345. </font>
<font color="black"> 346.         *strict* controls the parser's behavior when it encounters an</font>
<font color="black"> 347.         invalid control character in a string. The default setting of</font>
<font color="black"> 348.         ``True`` means that unescaped control characters are parse errors, if</font>
<font color="black"> 349.         ``False`` then control characters will be allowed in strings.</font>
<font color="black"> 350. </font>
<font color="black"> 351.         &quot;&quot;&quot;</font>
<font color="green"> 352.         if encoding is None:</font>
<font color="green"> 353.             encoding = DEFAULT_ENCODING</font>
<font color="green"> 354.         self.encoding = encoding</font>
<font color="green"> 355.         self.object_hook = object_hook</font>
<font color="green"> 356.         self.object_pairs_hook = object_pairs_hook</font>
<font color="green"> 357.         self.parse_float = parse_float or float</font>
<font color="green"> 358.         self.parse_int = parse_int or int</font>
<font color="green"> 359.         self.parse_constant = parse_constant or _CONSTANTS.__getitem__</font>
<font color="green"> 360.         self.strict = strict</font>
<font color="green"> 361.         self.parse_object = JSONObject</font>
<font color="green"> 362.         self.parse_array = JSONArray</font>
<font color="green"> 363.         self.parse_string = scanstring</font>
<font color="green"> 364.         self.memo = {}</font>
<font color="green"> 365.         self.scan_once = make_scanner(self)</font>
<font color="black"> 366. </font>
<font color="green"> 367.     def decode(self, s, _w=WHITESPACE.match, _PY3=PY3):</font>
<font color="black"> 368.         &quot;&quot;&quot;Return the Python representation of ``s`` (a ``str`` or ``unicode``</font>
<font color="black"> 369.         instance containing a JSON document)</font>
<font color="black"> 370. </font>
<font color="black"> 371.         &quot;&quot;&quot;</font>
<font color="red"> 372.         if _PY3 and isinstance(s, binary_type):</font>
<font color="red"> 373.             s = s.decode(self.encoding)</font>
<font color="red"> 374.         obj, end = self.raw_decode(s)</font>
<font color="red"> 375.         end = _w(s, end).end()</font>
<font color="red"> 376.         if end != len(s):</font>
<font color="red"> 377.             raise JSONDecodeError(&quot;Extra data&quot;, s, end, len(s))</font>
<font color="red"> 378.         return obj</font>
<font color="black"> 379. </font>
<font color="green"> 380.     def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):</font>
<font color="black"> 381.         &quot;&quot;&quot;Decode a JSON document from ``s`` (a ``str`` or ``unicode``</font>
<font color="black"> 382.         beginning with a JSON document) and return a 2-tuple of the Python</font>
<font color="black"> 383.         representation and the index in ``s`` where the document ended.</font>
<font color="black"> 384.         Optionally, ``idx`` can be used to specify an offset in ``s`` where</font>
<font color="black"> 385.         the JSON document begins.</font>
<font color="black"> 386. </font>
<font color="black"> 387.         This can be used to decode a JSON document from a string that may</font>
<font color="black"> 388.         have extraneous data at the end.</font>
<font color="black"> 389. </font>
<font color="black"> 390.         &quot;&quot;&quot;</font>
<font color="red"> 391.         if idx &lt; 0:</font>
<font color="black"> 392.             # Ensure that raw_decode bails on negative indexes, the regex</font>
<font color="black"> 393.             # would otherwise mask this behavior. #98</font>
<font color="red"> 394.             raise JSONDecodeError('Expecting value', s, idx)</font>
<font color="red"> 395.         if _PY3 and not isinstance(s, text_type):</font>
<font color="red"> 396.             raise TypeError(&quot;Input string must be text, not bytes&quot;)</font>
<font color="black"> 397.         # strip UTF-8 bom</font>
<font color="red"> 398.         if len(s) &gt; idx:</font>
<font color="red"> 399.             ord0 = ord(s[idx])</font>
<font color="red"> 400.             if ord0 == 0xfeff:</font>
<font color="red"> 401.                 idx += 1</font>
<font color="red"> 402.             elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':</font>
<font color="red"> 403.                 idx += 3</font>
<font color="red"> 404.         return self.scan_once(s, idx=_w(s, idx).end())</font>
</pre>

