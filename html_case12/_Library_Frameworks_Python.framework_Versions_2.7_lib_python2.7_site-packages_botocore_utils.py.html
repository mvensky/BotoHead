source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/utils.py</b><br>


file stats: <b>573 lines, 221 executed: 38.6% covered</b>
<pre>
<font color="black">   1. # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="green">  13. import re</font>
<font color="green">  14. import time</font>
<font color="green">  15. import logging</font>
<font color="green">  16. import datetime</font>
<font color="green">  17. import hashlib</font>
<font color="green">  18. import binascii</font>
<font color="green">  19. import functools</font>
<font color="green">  20. import weakref</font>
<font color="green">  21. import random</font>
<font color="green">  22. import os</font>
<font color="black">  23. </font>
<font color="green">  24. import dateutil.parser</font>
<font color="green">  25. from dateutil.tz import tzlocal, tzutc</font>
<font color="black">  26. </font>
<font color="green">  27. import botocore</font>
<font color="green">  28. from botocore.exceptions import InvalidExpressionError, ConfigNotFound</font>
<font color="green">  29. from botocore.exceptions import InvalidDNSNameError, ClientError</font>
<font color="green">  30. from botocore.exceptions import MetadataRetrievalError</font>
<font color="green">  31. from botocore.compat import json, quote, zip_longest, urlsplit, urlunsplit</font>
<font color="green">  32. from botocore.vendored import requests</font>
<font color="green">  33. from botocore.compat import OrderedDict, six</font>
<font color="black">  34. </font>
<font color="black">  35. </font>
<font color="green">  36. logger = logging.getLogger(__name__)</font>
<font color="green">  37. DEFAULT_METADATA_SERVICE_TIMEOUT = 1</font>
<font color="black">  38. METADATA_SECURITY_CREDENTIALS_URL = (</font>
<font color="green">  39.     'http://169.254.169.254/latest/meta-data/iam/security-credentials/'</font>
<font color="black">  40. )</font>
<font color="black">  41. # These are chars that do not need to be urlencoded.</font>
<font color="black">  42. # Based on rfc2986, section 2.3</font>
<font color="green">  43. SAFE_CHARS = '-._~'</font>
<font color="green">  44. LABEL_RE = re.compile(r'[a-z0-9][a-z0-9\-]*[a-z0-9]')</font>
<font color="green">  45. RETRYABLE_HTTP_ERRORS = (requests.Timeout, requests.ConnectionError)</font>
<font color="green">  46. S3_ACCELERATE_WHITELIST = ['dualstack']</font>
<font color="black">  47. </font>
<font color="black">  48. </font>
<font color="green">  49. class _RetriesExceededError(Exception):</font>
<font color="green">  50.     &quot;&quot;&quot;Internal exception used when the number of retries are exceeded.&quot;&quot;&quot;</font>
<font color="green">  51.     pass</font>
<font color="black">  52. </font>
<font color="black">  53. </font>
<font color="green">  54. def is_json_value_header(shape):</font>
<font color="black">  55.     &quot;&quot;&quot;Determines if the provided shape is the special header type jsonvalue.</font>
<font color="black">  56. </font>
<font color="black">  57.     :type shape: botocore.shape</font>
<font color="black">  58.     :param shape: Shape to be inspected for the jsonvalue trait.</font>
<font color="black">  59. </font>
<font color="black">  60.     :return: True if this type is a jsonvalue, False otherwise</font>
<font color="black">  61.     :rtype: Bool</font>
<font color="black">  62.     &quot;&quot;&quot;</font>
<font color="green">  63.     return (hasattr(shape, 'serialization') and</font>
<font color="green">  64.             shape.serialization.get('jsonvalue', False) and</font>
<font color="red">  65.             shape.serialization.get('location') == 'header' and</font>
<font color="red">  66.             shape.type_name == 'string')</font>
<font color="black">  67. </font>
<font color="black">  68. </font>
<font color="green">  69. def get_service_module_name(service_model):</font>
<font color="black">  70.     &quot;&quot;&quot;Returns the module name for a service</font>
<font color="black">  71. </font>
<font color="black">  72.     This is the value used in both the documentation and client class name</font>
<font color="black">  73.     &quot;&quot;&quot;</font>
<font color="green">  74.     name = service_model.metadata.get(</font>
<font color="green">  75.         'serviceAbbreviation',</font>
<font color="green">  76.         service_model.metadata.get(</font>
<font color="green">  77.             'serviceFullName', service_model.service_name))</font>
<font color="green">  78.     name = name.replace('Amazon', '')</font>
<font color="green">  79.     name = name.replace('AWS', '')</font>
<font color="green">  80.     name = re.sub(r'\W+', '', name)</font>
<font color="green">  81.     return name</font>
<font color="black">  82. </font>
<font color="black">  83. </font>
<font color="green">  84. def normalize_url_path(path):</font>
<font color="red">  85.     if not path:</font>
<font color="red">  86.         return '/'</font>
<font color="red">  87.     return remove_dot_segments(path)</font>
<font color="black">  88. </font>
<font color="black">  89. </font>
<font color="green">  90. def remove_dot_segments(url):</font>
<font color="black">  91.     # RFC 3986, section 5.2.4 &quot;Remove Dot Segments&quot;</font>
<font color="black">  92.     # Also, AWS services require consecutive slashes to be removed,</font>
<font color="black">  93.     # so that's done here as well</font>
<font color="red">  94.     if not url:</font>
<font color="red">  95.         return ''</font>
<font color="red">  96.     input_url = url.split('/')</font>
<font color="red">  97.     output_list = []</font>
<font color="red">  98.     for x in input_url:</font>
<font color="red">  99.         if x and x != '.':</font>
<font color="red"> 100.             if x == '..':</font>
<font color="red"> 101.                 if output_list:</font>
<font color="red"> 102.                     output_list.pop()</font>
<font color="black"> 103.             else:</font>
<font color="red"> 104.                 output_list.append(x)</font>
<font color="black"> 105. </font>
<font color="red"> 106.     if url[0] == '/':</font>
<font color="red"> 107.         first = '/'</font>
<font color="black"> 108.     else:</font>
<font color="red"> 109.         first = ''</font>
<font color="red"> 110.     if url[-1] == '/' and output_list:</font>
<font color="red"> 111.         last = '/'</font>
<font color="black"> 112.     else:</font>
<font color="red"> 113.         last = ''</font>
<font color="red"> 114.     return first + '/'.join(output_list) + last</font>
<font color="black"> 115. </font>
<font color="black"> 116. </font>
<font color="green"> 117. def validate_jmespath_for_set(expression):</font>
<font color="black"> 118.     # Validates a limited jmespath expression to determine if we can set a</font>
<font color="black"> 119.     # value based on it. Only works with dotted paths.</font>
<font color="red"> 120.     if not expression or expression == '.':</font>
<font color="red"> 121.         raise InvalidExpressionError(expression=expression)</font>
<font color="black"> 122. </font>
<font color="red"> 123.     for invalid in ['[', ']', '*']:</font>
<font color="red"> 124.         if invalid in expression:</font>
<font color="red"> 125.             raise InvalidExpressionError(expression=expression)</font>
<font color="black"> 126. </font>
<font color="black"> 127. </font>
<font color="green"> 128. def set_value_from_jmespath(source, expression, value, is_first=True):</font>
<font color="black"> 129.     # This takes a (limited) jmespath-like expression &amp; can set a value based</font>
<font color="black"> 130.     # on it.</font>
<font color="black"> 131.     # Limitations:</font>
<font color="black"> 132.     # * Only handles dotted lookups</font>
<font color="black"> 133.     # * No offsets/wildcards/slices/etc.</font>
<font color="red"> 134.     if is_first:</font>
<font color="red"> 135.         validate_jmespath_for_set(expression)</font>
<font color="black"> 136. </font>
<font color="red"> 137.     bits = expression.split('.', 1)</font>
<font color="red"> 138.     current_key, remainder = bits[0], bits[1] if len(bits) &gt; 1 else ''</font>
<font color="black"> 139. </font>
<font color="red"> 140.     if not current_key:</font>
<font color="red"> 141.         raise InvalidExpressionError(expression=expression)</font>
<font color="black"> 142. </font>
<font color="red"> 143.     if remainder:</font>
<font color="red"> 144.         if current_key not in source:</font>
<font color="black"> 145.             # We've got something in the expression that's not present in the</font>
<font color="black"> 146.             # source (new key). If there's any more bits, we'll set the key</font>
<font color="black"> 147.             # with an empty dictionary.</font>
<font color="red"> 148.             source[current_key] = {}</font>
<font color="black"> 149. </font>
<font color="red"> 150.         return set_value_from_jmespath(</font>
<font color="red"> 151.             source[current_key],</font>
<font color="red"> 152.             remainder,</font>
<font color="red"> 153.             value,</font>
<font color="red"> 154.             is_first=False</font>
<font color="black"> 155.         )</font>
<font color="black"> 156. </font>
<font color="black"> 157.     # If we're down to a single key, set it.</font>
<font color="red"> 158.     source[current_key] = value</font>
<font color="black"> 159. </font>
<font color="black"> 160. </font>
<font color="green"> 161. class InstanceMetadataFetcher(object):</font>
<font color="green"> 162.     def __init__(self, timeout=DEFAULT_METADATA_SERVICE_TIMEOUT,</font>
<font color="green"> 163.                  num_attempts=1, url=METADATA_SECURITY_CREDENTIALS_URL,</font>
<font color="green"> 164.                  env=None):</font>
<font color="green"> 165.         self._timeout = timeout</font>
<font color="green"> 166.         self._num_attempts = num_attempts</font>
<font color="green"> 167.         self._url = url</font>
<font color="green"> 168.         if env is None:</font>
<font color="green"> 169.             env = os.environ.copy()</font>
<font color="green"> 170.         self._disabled = env.get('AWS_EC2_METADATA_DISABLED', 'false').lower()</font>
<font color="green"> 171.         self._disabled = self._disabled == 'true'</font>
<font color="black"> 172. </font>
<font color="green"> 173.     def _get_request(self, url, timeout, num_attempts=1):</font>
<font color="red"> 174.         if self._disabled:</font>
<font color="red"> 175.             logger.debug(&quot;Access to EC2 metadata has been disabled.&quot;)</font>
<font color="red"> 176.             raise _RetriesExceededError()</font>
<font color="black"> 177. </font>
<font color="red"> 178.         for i in range(num_attempts):</font>
<font color="red"> 179.             try:</font>
<font color="red"> 180.                 response = requests.get(url, timeout=timeout)</font>
<font color="red"> 181.             except RETRYABLE_HTTP_ERRORS as e:</font>
<font color="red"> 182.                 logger.debug(&quot;Caught exception while trying to retrieve &quot;</font>
<font color="red"> 183.                              &quot;credentials: %s&quot;, e, exc_info=True)</font>
<font color="black"> 184.             else:</font>
<font color="red"> 185.                 if response.status_code == 200:</font>
<font color="red"> 186.                     return response</font>
<font color="red"> 187.         raise _RetriesExceededError()</font>
<font color="black"> 188. </font>
<font color="green"> 189.     def retrieve_iam_role_credentials(self):</font>
<font color="red"> 190.         data = {}</font>
<font color="red"> 191.         url = self._url</font>
<font color="red"> 192.         timeout = self._timeout</font>
<font color="red"> 193.         num_attempts = self._num_attempts</font>
<font color="red"> 194.         try:</font>
<font color="red"> 195.             r = self._get_request(url, timeout, num_attempts)</font>
<font color="red"> 196.             if r.content:</font>
<font color="red"> 197.                 fields = r.content.decode('utf-8').split('\n')</font>
<font color="red"> 198.                 for field in fields:</font>
<font color="red"> 199.                     if field.endswith('/'):</font>
<font color="red"> 200.                         data[field[0:-1]] = self.retrieve_iam_role_credentials(</font>
<font color="red"> 201.                             url + field, timeout, num_attempts)</font>
<font color="black"> 202.                     else:</font>
<font color="red"> 203.                         val = self._get_request(</font>
<font color="red"> 204.                             url + field,</font>
<font color="red"> 205.                             timeout=timeout,</font>
<font color="red"> 206.                             num_attempts=num_attempts,</font>
<font color="red"> 207.                         ).content.decode('utf-8')</font>
<font color="red"> 208.                         if val[0] == '{':</font>
<font color="red"> 209.                             val = json.loads(val)</font>
<font color="red"> 210.                         data[field] = val</font>
<font color="black"> 211.             else:</font>
<font color="red"> 212.                 logger.debug(&quot;Metadata service returned non 200 status code &quot;</font>
<font color="black"> 213.                              &quot;of %s for url: %s, content body: %s&quot;,</font>
<font color="red"> 214.                              r.status_code, url, r.content)</font>
<font color="red"> 215.         except _RetriesExceededError:</font>
<font color="red"> 216.             logger.debug(&quot;Max number of attempts exceeded (%s) when &quot;</font>
<font color="black"> 217.                          &quot;attempting to retrieve data from metadata service.&quot;,</font>
<font color="red"> 218.                          num_attempts)</font>
<font color="black"> 219.         # We sort for stable ordering. In practice, this should only consist</font>
<font color="black"> 220.         # of one role, but may need revisiting if this expands in the future.</font>
<font color="red"> 221.         final_data = {}</font>
<font color="red"> 222.         for role_name in sorted(data):</font>
<font color="red"> 223.             final_data = {</font>
<font color="red"> 224.                 'role_name': role_name,</font>
<font color="red"> 225.                 'access_key': data[role_name]['AccessKeyId'],</font>
<font color="red"> 226.                 'secret_key': data[role_name]['SecretAccessKey'],</font>
<font color="red"> 227.                 'token': data[role_name]['Token'],</font>
<font color="red"> 228.                 'expiry_time': data[role_name]['Expiration'],</font>
<font color="black"> 229.             }</font>
<font color="red"> 230.         return final_data</font>
<font color="black"> 231. </font>
<font color="black"> 232. </font>
<font color="green"> 233. def merge_dicts(dict1, dict2, append_lists=False):</font>
<font color="black"> 234.     &quot;&quot;&quot;Given two dict, merge the second dict into the first.</font>
<font color="black"> 235. </font>
<font color="black"> 236.     The dicts can have arbitrary nesting.</font>
<font color="black"> 237. </font>
<font color="black"> 238.     :param append_lists: If true, instead of clobbering a list with the new</font>
<font color="black"> 239.         value, append all of the new values onto the original list.</font>
<font color="black"> 240.     &quot;&quot;&quot;</font>
<font color="green"> 241.     for key in dict2:</font>
<font color="green"> 242.         if isinstance(dict2[key], dict):</font>
<font color="green"> 243.             if key in dict1 and key in dict2:</font>
<font color="green"> 244.                 merge_dicts(dict1[key], dict2[key])</font>
<font color="black"> 245.             else:</font>
<font color="green"> 246.                 dict1[key] = dict2[key]</font>
<font color="black"> 247.         # If the value is a list and the ``append_lists`` flag is set,</font>
<font color="black"> 248.         # append the new values onto the original list</font>
<font color="red"> 249.         elif isinstance(dict2[key], list) and append_lists:</font>
<font color="black"> 250.             # The value in dict1 must be a list in order to append new</font>
<font color="black"> 251.             # values onto it.</font>
<font color="red"> 252.             if key in dict1 and isinstance(dict1[key], list):</font>
<font color="red"> 253.                 dict1[key].extend(dict2[key])</font>
<font color="black"> 254.             else:</font>
<font color="red"> 255.                 dict1[key] = dict2[key]</font>
<font color="black"> 256.         else:</font>
<font color="black"> 257.             # At scalar types, we iterate and merge the</font>
<font color="black"> 258.             # current dict that we're on.</font>
<font color="red"> 259.             dict1[key] = dict2[key]</font>
<font color="black"> 260. </font>
<font color="black"> 261. </font>
<font color="green"> 262. def parse_key_val_file(filename, _open=open):</font>
<font color="red"> 263.     try:</font>
<font color="red"> 264.         with _open(filename) as f:</font>
<font color="red"> 265.             contents = f.read()</font>
<font color="red"> 266.             return parse_key_val_file_contents(contents)</font>
<font color="red"> 267.     except OSError:</font>
<font color="red"> 268.         raise ConfigNotFound(path=filename)</font>
<font color="black"> 269. </font>
<font color="black"> 270. </font>
<font color="green"> 271. def parse_key_val_file_contents(contents):</font>
<font color="black"> 272.     # This was originally extracted from the EC2 credential provider, which was</font>
<font color="black"> 273.     # fairly lenient in its parsing.  We only try to parse key/val pairs if</font>
<font color="black"> 274.     # there's a '=' in the line.</font>
<font color="red"> 275.     final = {}</font>
<font color="red"> 276.     for line in contents.splitlines():</font>
<font color="red"> 277.         if '=' not in line:</font>
<font color="red"> 278.             continue</font>
<font color="red"> 279.         key, val = line.split('=', 1)</font>
<font color="red"> 280.         key = key.strip()</font>
<font color="red"> 281.         val = val.strip()</font>
<font color="red"> 282.         final[key] = val</font>
<font color="red"> 283.     return final</font>
<font color="black"> 284. </font>
<font color="black"> 285. </font>
<font color="green"> 286. def percent_encode_sequence(mapping, safe=SAFE_CHARS):</font>
<font color="black"> 287.     &quot;&quot;&quot;Urlencode a dict or list into a string.</font>
<font color="black"> 288. </font>
<font color="black"> 289.     This is similar to urllib.urlencode except that:</font>
<font color="black"> 290. </font>
<font color="black"> 291.     * It uses quote, and not quote_plus</font>
<font color="black"> 292.     * It has a default list of safe chars that don't need</font>
<font color="black"> 293.       to be encoded, which matches what AWS services expect.</font>
<font color="black"> 294. </font>
<font color="black"> 295.     If any value in the input ``mapping`` is a list type,</font>
<font color="black"> 296.     then each list element wil be serialized.  This is the equivalent</font>
<font color="black"> 297.     to ``urlencode``'s ``doseq=True`` argument.</font>
<font color="black"> 298. </font>
<font color="black"> 299.     This function should be preferred over the stdlib</font>
<font color="black"> 300.     ``urlencode()`` function.</font>
<font color="black"> 301. </font>
<font color="black"> 302.     :param mapping: Either a dict to urlencode or a list of</font>
<font color="black"> 303.         ``(key, value)`` pairs.</font>
<font color="black"> 304. </font>
<font color="black"> 305.     &quot;&quot;&quot;</font>
<font color="red"> 306.     encoded_pairs = []</font>
<font color="red"> 307.     if hasattr(mapping, 'items'):</font>
<font color="red"> 308.         pairs = mapping.items()</font>
<font color="black"> 309.     else:</font>
<font color="red"> 310.         pairs = mapping</font>
<font color="red"> 311.     for key, value in pairs:</font>
<font color="red"> 312.         if isinstance(value, list):</font>
<font color="red"> 313.             for element in value:</font>
<font color="red"> 314.                 encoded_pairs.append('%s=%s' % (percent_encode(key),</font>
<font color="red"> 315.                                                 percent_encode(element)))</font>
<font color="black"> 316.         else:</font>
<font color="red"> 317.             encoded_pairs.append('%s=%s' % (percent_encode(key),</font>
<font color="red"> 318.                                             percent_encode(value)))</font>
<font color="red"> 319.     return '&amp;'.join(encoded_pairs)</font>
<font color="black"> 320. </font>
<font color="black"> 321. </font>
<font color="green"> 322. def percent_encode(input_str, safe=SAFE_CHARS):</font>
<font color="black"> 323.     &quot;&quot;&quot;Urlencodes a string.</font>
<font color="black"> 324. </font>
<font color="black"> 325.     Whereas percent_encode_sequence handles taking a dict/sequence and</font>
<font color="black"> 326.     producing a percent encoded string, this function deals only with</font>
<font color="black"> 327.     taking a string (not a dict/sequence) and percent encoding it.</font>
<font color="black"> 328. </font>
<font color="black"> 329.     If given the binary type, will simply URL encode it. If given the</font>
<font color="black"> 330.     text type, will produce the binary type by UTF-8 encoding the</font>
<font color="black"> 331.     text. If given something else, will convert it to the the text type</font>
<font color="black"> 332.     first.</font>
<font color="black"> 333.     &quot;&quot;&quot;</font>
<font color="black"> 334.     # If its not a binary or text string, make it a text string.</font>
<font color="green"> 335.     if not isinstance(input_str, (six.binary_type, six.text_type)):</font>
<font color="red"> 336.         input_str = six.text_type(input_str)</font>
<font color="black"> 337.     # If it's not bytes, make it bytes by UTF-8 encoding it.</font>
<font color="green"> 338.     if not isinstance(input_str, six.binary_type):</font>
<font color="red"> 339.         input_str = input_str.encode('utf-8')</font>
<font color="green"> 340.     return quote(input_str, safe=safe)</font>
<font color="black"> 341. </font>
<font color="black"> 342. </font>
<font color="green"> 343. def parse_timestamp(value):</font>
<font color="black"> 344.     &quot;&quot;&quot;Parse a timestamp into a datetime object.</font>
<font color="black"> 345. </font>
<font color="black"> 346.     Supported formats:</font>
<font color="black"> 347. </font>
<font color="black"> 348.         * iso8601</font>
<font color="black"> 349.         * rfc822</font>
<font color="black"> 350.         * epoch (value is an integer)</font>
<font color="black"> 351. </font>
<font color="black"> 352.     This will return a ``datetime.datetime`` object.</font>
<font color="black"> 353. </font>
<font color="black"> 354.     &quot;&quot;&quot;</font>
<font color="green"> 355.     if isinstance(value, (int, float)):</font>
<font color="black"> 356.         # Possibly an epoch time.</font>
<font color="red"> 357.         return datetime.datetime.fromtimestamp(value, tzlocal())</font>
<font color="black"> 358.     else:</font>
<font color="green"> 359.         try:</font>
<font color="green"> 360.             return datetime.datetime.fromtimestamp(float(value), tzlocal())</font>
<font color="green"> 361.         except (TypeError, ValueError):</font>
<font color="green"> 362.             pass</font>
<font color="green"> 363.     try:</font>
<font color="black"> 364.         # In certain cases, a timestamp marked with GMT can be parsed into a</font>
<font color="black"> 365.         # different time zone, so here we provide a context which will</font>
<font color="black"> 366.         # enforce that GMT == UTC.</font>
<font color="green"> 367.         return dateutil.parser.parse(value, tzinfos={'GMT': tzutc()})</font>
<font color="red"> 368.     except (TypeError, ValueError) as e:</font>
<font color="red"> 369.         raise ValueError('Invalid timestamp &quot;%s&quot;: %s' % (value, e))</font>
<font color="black"> 370. </font>
<font color="black"> 371. </font>
<font color="green"> 372. def parse_to_aware_datetime(value):</font>
<font color="black"> 373.     &quot;&quot;&quot;Converted the passed in value to a datetime object with tzinfo.</font>
<font color="black"> 374. </font>
<font color="black"> 375.     This function can be used to normalize all timestamp inputs.  This</font>
<font color="black"> 376.     function accepts a number of different types of inputs, but</font>
<font color="black"> 377.     will always return a datetime.datetime object with time zone</font>
<font color="black"> 378.     information.</font>
<font color="black"> 379. </font>
<font color="black"> 380.     The input param ``value`` can be one of several types:</font>
<font color="black"> 381. </font>
<font color="black"> 382.         * A datetime object (both naive and aware)</font>
<font color="black"> 383.         * An integer representing the epoch time (can also be a string</font>
<font color="black"> 384.           of the integer, i.e '0', instead of 0).  The epoch time is</font>
<font color="black"> 385.           considered to be UTC.</font>
<font color="black"> 386.         * An iso8601 formatted timestamp.  This does not need to be</font>
<font color="black"> 387.           a complete timestamp, it can contain just the date portion</font>
<font color="black"> 388.           without the time component.</font>
<font color="black"> 389. </font>
<font color="black"> 390.     The returned value will be a datetime object that will have tzinfo.</font>
<font color="black"> 391.     If no timezone info was provided in the input value, then UTC is</font>
<font color="black"> 392.     assumed, not local time.</font>
<font color="black"> 393. </font>
<font color="black"> 394.     &quot;&quot;&quot;</font>
<font color="black"> 395.     # This is a general purpose method that handles several cases of</font>
<font color="black"> 396.     # converting the provided value to a string timestamp suitable to be</font>
<font color="black"> 397.     # serialized to an http request. It can handle:</font>
<font color="black"> 398.     # 1) A datetime.datetime object.</font>
<font color="red"> 399.     if isinstance(value, datetime.datetime):</font>
<font color="red"> 400.         datetime_obj = value</font>
<font color="black"> 401.     else:</font>
<font color="black"> 402.         # 2) A string object that's formatted as a timestamp.</font>
<font color="black"> 403.         #    We document this as being an iso8601 timestamp, although</font>
<font color="black"> 404.         #    parse_timestamp is a bit more flexible.</font>
<font color="red"> 405.         datetime_obj = parse_timestamp(value)</font>
<font color="red"> 406.     if datetime_obj.tzinfo is None:</font>
<font color="black"> 407.         # I think a case would be made that if no time zone is provided,</font>
<font color="black"> 408.         # we should use the local time.  However, to restore backwards</font>
<font color="black"> 409.         # compat, the previous behavior was to assume UTC, which is</font>
<font color="black"> 410.         # what we're going to do here.</font>
<font color="red"> 411.         datetime_obj = datetime_obj.replace(tzinfo=tzutc())</font>
<font color="black"> 412.     else:</font>
<font color="red"> 413.         datetime_obj = datetime_obj.astimezone(tzutc())</font>
<font color="red"> 414.     return datetime_obj</font>
<font color="black"> 415. </font>
<font color="black"> 416. </font>
<font color="green"> 417. def datetime2timestamp(dt, default_timezone=None):</font>
<font color="black"> 418.     &quot;&quot;&quot;Calculate the timestamp based on the given datetime instance.</font>
<font color="black"> 419. </font>
<font color="black"> 420.     :type dt: datetime</font>
<font color="black"> 421.     :param dt: A datetime object to be converted into timestamp</font>
<font color="black"> 422.     :type default_timezone: tzinfo</font>
<font color="black"> 423.     :param default_timezone: If it is provided as None, we treat it as tzutc().</font>
<font color="black"> 424.                              But it is only used when dt is a naive datetime.</font>
<font color="black"> 425.     :returns: The timestamp</font>
<font color="black"> 426.     &quot;&quot;&quot;</font>
<font color="red"> 427.     epoch = datetime.datetime(1970, 1, 1)</font>
<font color="red"> 428.     if dt.tzinfo is None:</font>
<font color="red"> 429.         if default_timezone is None:</font>
<font color="red"> 430.             default_timezone = tzutc()</font>
<font color="red"> 431.         dt = dt.replace(tzinfo=default_timezone)</font>
<font color="red"> 432.     d = dt.replace(tzinfo=None) - dt.utcoffset() - epoch</font>
<font color="red"> 433.     if hasattr(d, &quot;total_seconds&quot;):</font>
<font color="red"> 434.         return d.total_seconds()  # Works in Python 2.7+</font>
<font color="red"> 435.     return (d.microseconds + (d.seconds + d.days * 24 * 3600) * 10**6) / 10**6</font>
<font color="black"> 436. </font>
<font color="black"> 437. </font>
<font color="green"> 438. def calculate_sha256(body, as_hex=False):</font>
<font color="black"> 439.     &quot;&quot;&quot;Calculate a sha256 checksum.</font>
<font color="black"> 440. </font>
<font color="black"> 441.     This method will calculate the sha256 checksum of a file like</font>
<font color="black"> 442.     object.  Note that this method will iterate through the entire</font>
<font color="black"> 443.     file contents.  The caller is responsible for ensuring the proper</font>
<font color="black"> 444.     starting position of the file and ``seek()``'ing the file back</font>
<font color="black"> 445.     to its starting location if other consumers need to read from</font>
<font color="black"> 446.     the file like object.</font>
<font color="black"> 447. </font>
<font color="black"> 448.     :param body: Any file like object.  The file must be opened</font>
<font color="black"> 449.         in binary mode such that a ``.read()`` call returns bytes.</font>
<font color="black"> 450.     :param as_hex: If True, then the hex digest is returned.</font>
<font color="black"> 451.         If False, then the digest (as binary bytes) is returned.</font>
<font color="black"> 452. </font>
<font color="black"> 453.     :returns: The sha256 checksum</font>
<font color="black"> 454. </font>
<font color="black"> 455.     &quot;&quot;&quot;</font>
<font color="red"> 456.     checksum = hashlib.sha256()</font>
<font color="red"> 457.     for chunk in iter(lambda: body.read(1024 * 1024), b''):</font>
<font color="red"> 458.         checksum.update(chunk)</font>
<font color="red"> 459.     if as_hex:</font>
<font color="red"> 460.         return checksum.hexdigest()</font>
<font color="black"> 461.     else:</font>
<font color="red"> 462.         return checksum.digest()</font>
<font color="black"> 463. </font>
<font color="black"> 464. </font>
<font color="green"> 465. def calculate_tree_hash(body):</font>
<font color="black"> 466.     &quot;&quot;&quot;Calculate a tree hash checksum.</font>
<font color="black"> 467. </font>
<font color="black"> 468.     For more information see:</font>
<font color="black"> 469. </font>
<font color="black"> 470.     http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html</font>
<font color="black"> 471. </font>
<font color="black"> 472.     :param body: Any file like object.  This has the same constraints as</font>
<font color="black"> 473.         the ``body`` param in calculate_sha256</font>
<font color="black"> 474. </font>
<font color="black"> 475.     :rtype: str</font>
<font color="black"> 476.     :returns: The hex version of the calculated tree hash</font>
<font color="black"> 477. </font>
<font color="black"> 478.     &quot;&quot;&quot;</font>
<font color="red"> 479.     chunks = []</font>
<font color="red"> 480.     required_chunk_size = 1024 * 1024</font>
<font color="red"> 481.     sha256 = hashlib.sha256</font>
<font color="red"> 482.     for chunk in iter(lambda: body.read(required_chunk_size), b''):</font>
<font color="red"> 483.         chunks.append(sha256(chunk).digest())</font>
<font color="red"> 484.     if not chunks:</font>
<font color="red"> 485.         return sha256(b'').hexdigest()</font>
<font color="red"> 486.     while len(chunks) &gt; 1:</font>
<font color="red"> 487.         new_chunks = []</font>
<font color="red"> 488.         for first, second in _in_pairs(chunks):</font>
<font color="red"> 489.             if second is not None:</font>
<font color="red"> 490.                 new_chunks.append(sha256(first + second).digest())</font>
<font color="black"> 491.             else:</font>
<font color="black"> 492.                 # We're at the end of the list and there's no pair left.</font>
<font color="red"> 493.                 new_chunks.append(first)</font>
<font color="red"> 494.         chunks = new_chunks</font>
<font color="red"> 495.     return binascii.hexlify(chunks[0]).decode('ascii')</font>
<font color="black"> 496. </font>
<font color="black"> 497. </font>
<font color="green"> 498. def _in_pairs(iterable):</font>
<font color="black"> 499.     # Creates iterator that iterates over the list in pairs:</font>
<font color="black"> 500.     # for a, b in _in_pairs([0, 1, 2, 3, 4]):</font>
<font color="black"> 501.     #     print(a, b)</font>
<font color="black"> 502.     #</font>
<font color="black"> 503.     # will print:</font>
<font color="black"> 504.     # 0, 1</font>
<font color="black"> 505.     # 2, 3</font>
<font color="black"> 506.     # 4, None</font>
<font color="red"> 507.     shared_iter = iter(iterable)</font>
<font color="black"> 508.     # Note that zip_longest is a compat import that uses</font>
<font color="black"> 509.     # the itertools izip_longest.  This creates an iterator,</font>
<font color="black"> 510.     # this call below does _not_ immediately create the list</font>
<font color="black"> 511.     # of pairs.</font>
<font color="red"> 512.     return zip_longest(shared_iter, shared_iter)</font>
<font color="black"> 513. </font>
<font color="black"> 514. </font>
<font color="green"> 515. class CachedProperty(object):</font>
<font color="black"> 516.     &quot;&quot;&quot;A read only property that caches the initially computed value.</font>
<font color="black"> 517. </font>
<font color="black"> 518.     This descriptor will only call the provided ``fget`` function once.</font>
<font color="black"> 519.     Subsequent access to this property will return the cached value.</font>
<font color="black"> 520. </font>
<font color="green"> 521.     &quot;&quot;&quot;</font>
<font color="black"> 522. </font>
<font color="green"> 523.     def __init__(self, fget):</font>
<font color="green"> 524.         self._fget = fget</font>
<font color="black"> 525. </font>
<font color="green"> 526.     def __get__(self, obj, cls):</font>
<font color="green"> 527.         if obj is None:</font>
<font color="red"> 528.             return self</font>
<font color="black"> 529.         else:</font>
<font color="green"> 530.             computed_value = self._fget(obj)</font>
<font color="green"> 531.             obj.__dict__[self._fget.__name__] = computed_value</font>
<font color="green"> 532.             return computed_value</font>
<font color="black"> 533. </font>
<font color="black"> 534. </font>
<font color="green"> 535. class ArgumentGenerator(object):</font>
<font color="black"> 536.     &quot;&quot;&quot;Generate sample input based on a shape model.</font>
<font color="black"> 537. </font>
<font color="black"> 538.     This class contains a ``generate_skeleton`` method that will take</font>
<font color="black"> 539.     an input/output shape (created from ``botocore.model``) and generate</font>
<font color="black"> 540.     a sample dictionary corresponding to the input/output shape.</font>
<font color="black"> 541. </font>
<font color="black"> 542.     The specific values used are place holder values. For strings either an</font>
<font color="black"> 543.     empty string or the member name can be used, for numbers 0 or 0.0 is used.</font>
<font color="black"> 544.     The intended usage of this class is to generate the *shape* of the input</font>
<font color="black"> 545.     structure.</font>
<font color="black"> 546. </font>
<font color="black"> 547.     This can be useful for operations that have complex input shapes.</font>
<font color="black"> 548.     This allows a user to just fill in the necessary data instead of</font>
<font color="black"> 549.     worrying about the specific structure of the input arguments.</font>
<font color="black"> 550. </font>
<font color="black"> 551.     Example usage::</font>
<font color="black"> 552. </font>
<font color="black"> 553.         s = botocore.session.get_session()</font>
<font color="black"> 554.         ddb = s.get_service_model('dynamodb')</font>
<font color="black"> 555.         arg_gen = ArgumentGenerator()</font>
<font color="black"> 556.         sample_input = arg_gen.generate_skeleton(</font>
<font color="black"> 557.             ddb.operation_model('CreateTable').input_shape)</font>
<font color="black"> 558.         print(&quot;Sample input for dynamodb.CreateTable: %s&quot; % sample_input)</font>
<font color="black"> 559. </font>
<font color="green"> 560.     &quot;&quot;&quot;</font>
<font color="green"> 561.     def __init__(self, use_member_names=False):</font>
<font color="red"> 562.         self._use_member_names = use_member_names</font>
<font color="black"> 563. </font>
<font color="green"> 564.     def generate_skeleton(self, shape):</font>
<font color="black"> 565.         &quot;&quot;&quot;Generate a sample input.</font>
<font color="black"> 566. </font>
<font color="black"> 567.         :type shape: ``botocore.model.Shape``</font>
<font color="black"> 568.         :param shape: The input shape.</font>
<font color="black"> 569. </font>
<font color="black"> 570.         :return: The generated skeleton input corresponding to the</font>
<font color="black"> 571.             provided input shape.</font>
<font color="black"> 572. </font>
<font color="black"> 573.         &quot;&quot;&quot;</font>
<font color="red"> 574.         stack = []</font>
<font color="red"> 575.         return self._generate_skeleton(shape, stack)</font>
<font color="black"> 576. </font>
<font color="green"> 577.     def _generate_skeleton(self, shape, stack, name=''):</font>
<font color="red"> 578.         stack.append(shape.name)</font>
<font color="red"> 579.         try:</font>
<font color="red"> 580.             if shape.type_name == 'structure':</font>
<font color="red"> 581.                 return self._generate_type_structure(shape, stack)</font>
<font color="red"> 582.             elif shape.type_name == 'list':</font>
<font color="red"> 583.                 return self._generate_type_list(shape, stack)</font>
<font color="red"> 584.             elif shape.type_name == 'map':</font>
<font color="red"> 585.                 return self._generate_type_map(shape, stack)</font>
<font color="red"> 586.             elif shape.type_name == 'string':</font>
<font color="red"> 587.                 if self._use_member_names:</font>
<font color="red"> 588.                     return name</font>
<font color="red"> 589.                 if shape.enum:</font>
<font color="red"> 590.                     return random.choice(shape.enum)</font>
<font color="red"> 591.                 return ''</font>
<font color="red"> 592.             elif shape.type_name in ['integer', 'long']:</font>
<font color="red"> 593.                 return 0</font>
<font color="red"> 594.             elif shape.type_name == 'float':</font>
<font color="red"> 595.                 return 0.0</font>
<font color="red"> 596.             elif shape.type_name == 'boolean':</font>
<font color="red"> 597.                 return True</font>
<font color="red"> 598.             elif shape.type_name == 'timestamp':</font>
<font color="red"> 599.                 return datetime.datetime(1970, 1, 1, 0, 0, 0)</font>
<font color="black"> 600.         finally:</font>
<font color="red"> 601.             stack.pop()</font>
<font color="black"> 602. </font>
<font color="green"> 603.     def _generate_type_structure(self, shape, stack):</font>
<font color="red"> 604.         if stack.count(shape.name) &gt; 1:</font>
<font color="red"> 605.             return {}</font>
<font color="red"> 606.         skeleton = OrderedDict()</font>
<font color="red"> 607.         for member_name, member_shape in shape.members.items():</font>
<font color="red"> 608.             skeleton[member_name] = self._generate_skeleton(</font>
<font color="red"> 609.                 member_shape, stack, name=member_name)</font>
<font color="red"> 610.         return skeleton</font>
<font color="black"> 611. </font>
<font color="green"> 612.     def _generate_type_list(self, shape, stack):</font>
<font color="black"> 613.         # For list elements we've arbitrarily decided to</font>
<font color="black"> 614.         # return two elements for the skeleton list.</font>
<font color="red"> 615.         name = ''</font>
<font color="red"> 616.         if self._use_member_names:</font>
<font color="red"> 617.             name = shape.member.name</font>
<font color="black"> 618.         return [</font>
<font color="red"> 619.             self._generate_skeleton(shape.member, stack, name),</font>
<font color="black"> 620.         ]</font>
<font color="black"> 621. </font>
<font color="green"> 622.     def _generate_type_map(self, shape, stack):</font>
<font color="red"> 623.         key_shape = shape.key</font>
<font color="red"> 624.         value_shape = shape.value</font>
<font color="red"> 625.         assert key_shape.type_name == 'string'</font>
<font color="red"> 626.         return OrderedDict([</font>
<font color="red"> 627.             ('KeyName', self._generate_skeleton(value_shape, stack)),</font>
<font color="black"> 628.         ])</font>
<font color="black"> 629. </font>
<font color="black"> 630. </font>
<font color="green"> 631. def is_valid_endpoint_url(endpoint_url):</font>
<font color="black"> 632.     &quot;&quot;&quot;Verify the endpoint_url is valid.</font>
<font color="black"> 633. </font>
<font color="black"> 634.     :type endpoint_url: string</font>
<font color="black"> 635.     :param endpoint_url: An endpoint_url.  Must have at least a scheme</font>
<font color="black"> 636.         and a hostname.</font>
<font color="black"> 637. </font>
<font color="black"> 638.     :return: True if the endpoint url is valid. False otherwise.</font>
<font color="black"> 639. </font>
<font color="black"> 640.     &quot;&quot;&quot;</font>
<font color="green"> 641.     parts = urlsplit(endpoint_url)</font>
<font color="green"> 642.     hostname = parts.hostname</font>
<font color="green"> 643.     if hostname is None:</font>
<font color="red"> 644.         return False</font>
<font color="green"> 645.     if len(hostname) &gt; 255:</font>
<font color="red"> 646.         return False</font>
<font color="green"> 647.     if hostname[-1] == &quot;.&quot;:</font>
<font color="red"> 648.         hostname = hostname[:-1]</font>
<font color="green"> 649.     allowed = re.compile(</font>
<font color="green"> 650.         r&quot;^((?!-)[A-Z\d-]{1,63}(?&lt;!-)\.)*((?!-)[A-Z\d-]{1,63}(?&lt;!-))$&quot;,</font>
<font color="green"> 651.         re.IGNORECASE)</font>
<font color="green"> 652.     return allowed.match(hostname)</font>
<font color="black"> 653. </font>
<font color="black"> 654. </font>
<font color="green"> 655. def check_dns_name(bucket_name):</font>
<font color="black"> 656.     &quot;&quot;&quot;</font>
<font color="black"> 657.     Check to see if the ``bucket_name`` complies with the</font>
<font color="black"> 658.     restricted DNS naming conventions necessary to allow</font>
<font color="black"> 659.     access via virtual-hosting style.</font>
<font color="black"> 660. </font>
<font color="black"> 661.     Even though &quot;.&quot; characters are perfectly valid in this DNS</font>
<font color="black"> 662.     naming scheme, we are going to punt on any name containing a</font>
<font color="black"> 663.     &quot;.&quot; character because these will cause SSL cert validation</font>
<font color="black"> 664.     problems if we try to use virtual-hosting style addressing.</font>
<font color="black"> 665.     &quot;&quot;&quot;</font>
<font color="green"> 666.     if '.' in bucket_name:</font>
<font color="red"> 667.         return False</font>
<font color="green"> 668.     n = len(bucket_name)</font>
<font color="green"> 669.     if n &lt; 3 or n &gt; 63:</font>
<font color="black"> 670.         # Wrong length</font>
<font color="red"> 671.         return False</font>
<font color="green"> 672.     if n == 1:</font>
<font color="red"> 673.         if not bucket_name.isalnum():</font>
<font color="red"> 674.             return False</font>
<font color="green"> 675.     match = LABEL_RE.match(bucket_name)</font>
<font color="green"> 676.     if match is None or match.end() != len(bucket_name):</font>
<font color="red"> 677.         return False</font>
<font color="green"> 678.     return True</font>
<font color="black"> 679. </font>
<font color="black"> 680. </font>
<font color="black"> 681. def fix_s3_host(request, signature_version, region_name,</font>
<font color="green"> 682.                 default_endpoint_url=None, **kwargs):</font>
<font color="black"> 683.     &quot;&quot;&quot;</font>
<font color="black"> 684.     This handler looks at S3 requests just before they are signed.</font>
<font color="black"> 685.     If there is a bucket name on the path (true for everything except</font>
<font color="black"> 686.     ListAllBuckets) it checks to see if that bucket name conforms to</font>
<font color="black"> 687.     the DNS naming conventions.  If it does, it alters the request to</font>
<font color="black"> 688.     use ``virtual hosting`` style addressing rather than ``path-style``</font>
<font color="black"> 689.     addressing.</font>
<font color="black"> 690. </font>
<font color="black"> 691.     &quot;&quot;&quot;</font>
<font color="green"> 692.     if request.context.get('use_global_endpoint', False):</font>
<font color="red"> 693.         default_endpoint_url = 's3.amazonaws.com'</font>
<font color="green"> 694.     try:</font>
<font color="green"> 695.         switch_to_virtual_host_style(</font>
<font color="green"> 696.             request, signature_version, default_endpoint_url)</font>
<font color="red"> 697.     except InvalidDNSNameError as e:</font>
<font color="red"> 698.         bucket_name = e.kwargs['bucket_name']</font>
<font color="red"> 699.         logger.debug('Not changing URI, bucket is not DNS compatible: %s',</font>
<font color="red"> 700.                      bucket_name)</font>
<font color="black"> 701. </font>
<font color="black"> 702. </font>
<font color="black"> 703. def switch_to_virtual_host_style(request, signature_version,</font>
<font color="green"> 704.                                  default_endpoint_url=None, **kwargs):</font>
<font color="black"> 705.     &quot;&quot;&quot;</font>
<font color="black"> 706.     This is a handler to force virtual host style s3 addressing no matter</font>
<font color="black"> 707.     the signature version (which is taken in consideration for the default</font>
<font color="black"> 708.     case). If the bucket is not DNS compatible an InvalidDNSName is thrown.</font>
<font color="black"> 709. </font>
<font color="black"> 710.     :param request: A AWSRequest object that is about to be sent.</font>
<font color="black"> 711.     :param signature_version: The signature version to sign with</font>
<font color="black"> 712.     :param default_endpoint_url: The endpoint to use when switching to a</font>
<font color="black"> 713.         virtual style. If None is supplied, the virtual host will be</font>
<font color="black"> 714.         constructed from the url of the request.</font>
<font color="black"> 715.     &quot;&quot;&quot;</font>
<font color="green"> 716.     if request.auth_path is not None:</font>
<font color="black"> 717.         # The auth_path has already been applied (this may be a</font>
<font color="black"> 718.         # retried request).  We don't need to perform this</font>
<font color="black"> 719.         # customization again.</font>
<font color="red"> 720.         return</font>
<font color="green"> 721.     elif _is_get_bucket_location_request(request):</font>
<font color="black"> 722.         # For the GetBucketLocation response, we should not be using</font>
<font color="black"> 723.         # the virtual host style addressing so we can avoid any sigv4</font>
<font color="black"> 724.         # issues.</font>
<font color="red"> 725.         logger.debug(&quot;Request is GetBucketLocation operation, not checking &quot;</font>
<font color="black"> 726.                      &quot;for DNS compatibility.&quot;)</font>
<font color="red"> 727.         return</font>
<font color="green"> 728.     parts = urlsplit(request.url)</font>
<font color="green"> 729.     request.auth_path = parts.path</font>
<font color="green"> 730.     path_parts = parts.path.split('/')</font>
<font color="black"> 731. </font>
<font color="black"> 732.     # Retrieve what the endpoint we will be prepending the bucket name to.</font>
<font color="green"> 733.     if default_endpoint_url is None:</font>
<font color="green"> 734.         default_endpoint_url = parts.netloc</font>
<font color="black"> 735. </font>
<font color="green"> 736.     if len(path_parts) &gt; 1:</font>
<font color="green"> 737.         bucket_name = path_parts[1]</font>
<font color="green"> 738.         if not bucket_name:</font>
<font color="black"> 739.             # If the bucket name is empty we should not be checking for</font>
<font color="black"> 740.             # dns compatibility.</font>
<font color="green"> 741.             return</font>
<font color="green"> 742.         logger.debug('Checking for DNS compatible bucket for: %s',</font>
<font color="green"> 743.                      request.url)</font>
<font color="green"> 744.         if check_dns_name(bucket_name):</font>
<font color="black"> 745.             # If the operation is on a bucket, the auth_path must be</font>
<font color="black"> 746.             # terminated with a '/' character.</font>
<font color="green"> 747.             if len(path_parts) == 2:</font>
<font color="green"> 748.                 if request.auth_path[-1] != '/':</font>
<font color="green"> 749.                     request.auth_path += '/'</font>
<font color="green"> 750.             path_parts.remove(bucket_name)</font>
<font color="black"> 751.             # At the very least the path must be a '/', such as with the</font>
<font color="black"> 752.             # CreateBucket operation when DNS style is being used. If this</font>
<font color="black"> 753.             # is not used you will get an empty path which is incorrect.</font>
<font color="green"> 754.             path = '/'.join(path_parts) or '/'</font>
<font color="green"> 755.             global_endpoint = default_endpoint_url</font>
<font color="green"> 756.             host = bucket_name + '.' + global_endpoint</font>
<font color="green"> 757.             new_tuple = (parts.scheme, host, path,</font>
<font color="green"> 758.                          parts.query, '')</font>
<font color="green"> 759.             new_uri = urlunsplit(new_tuple)</font>
<font color="green"> 760.             request.url = new_uri</font>
<font color="green"> 761.             logger.debug('URI updated to: %s', new_uri)</font>
<font color="black"> 762.         else:</font>
<font color="red"> 763.             raise InvalidDNSNameError(bucket_name=bucket_name)</font>
<font color="black"> 764. </font>
<font color="black"> 765. </font>
<font color="green"> 766. def _is_get_bucket_location_request(request):</font>
<font color="green"> 767.     return request.url.endswith('?location')</font>
<font color="black"> 768. </font>
<font color="black"> 769. </font>
<font color="green"> 770. def instance_cache(func):</font>
<font color="black"> 771.     &quot;&quot;&quot;Method decorator for caching method calls to a single instance.</font>
<font color="black"> 772. </font>
<font color="black"> 773.     **This is not a general purpose caching decorator.**</font>
<font color="black"> 774. </font>
<font color="black"> 775.     In order to use this, you *must* provide an ``_instance_cache``</font>
<font color="black"> 776.     attribute on the instance.</font>
<font color="black"> 777. </font>
<font color="black"> 778.     This decorator is used to cache method calls.  The cache is only</font>
<font color="black"> 779.     scoped to a single instance though such that multiple instances</font>
<font color="black"> 780.     will maintain their own cache.  In order to keep things simple,</font>
<font color="black"> 781.     this decorator requires that you provide an ``_instance_cache``</font>
<font color="black"> 782.     attribute on your instance.</font>
<font color="black"> 783. </font>
<font color="black"> 784.     &quot;&quot;&quot;</font>
<font color="green"> 785.     func_name = func.__name__</font>
<font color="black"> 786. </font>
<font color="green"> 787.     @functools.wraps(func)</font>
<font color="black"> 788.     def _cache_guard(self, *args, **kwargs):</font>
<font color="green"> 789.         cache_key = (func_name, args)</font>
<font color="green"> 790.         if kwargs:</font>
<font color="red"> 791.             kwarg_items = tuple(sorted(kwargs.items()))</font>
<font color="red"> 792.             cache_key = (func_name, args, kwarg_items)</font>
<font color="green"> 793.         result = self._instance_cache.get(cache_key)</font>
<font color="green"> 794.         if result is not None:</font>
<font color="green"> 795.             return result</font>
<font color="green"> 796.         result = func(self, *args, **kwargs)</font>
<font color="green"> 797.         self._instance_cache[cache_key] = result</font>
<font color="green"> 798.         return result</font>
<font color="green"> 799.     return _cache_guard</font>
<font color="black"> 800. </font>
<font color="black"> 801. </font>
<font color="green"> 802. def switch_host_s3_accelerate(request, operation_name, **kwargs):</font>
<font color="black"> 803.     &quot;&quot;&quot;Switches the current s3 endpoint with an S3 Accelerate endpoint&quot;&quot;&quot;</font>
<font color="black"> 804. </font>
<font color="black"> 805.     # Note that when registered the switching of the s3 host happens</font>
<font color="black"> 806.     # before it gets changed to virtual. So we are not concerned with ensuring</font>
<font color="black"> 807.     # that the bucket name is translated to the virtual style here and we</font>
<font color="black"> 808.     # can hard code the Accelerate endpoint.</font>
<font color="red"> 809.     parts = urlsplit(request.url).netloc.split('.')</font>
<font color="red"> 810.     parts = [p for p in parts if p in S3_ACCELERATE_WHITELIST]</font>
<font color="red"> 811.     endpoint = 'https://s3-accelerate.'</font>
<font color="red"> 812.     if len(parts) &gt; 0:</font>
<font color="red"> 813.         endpoint += '.'.join(parts) + '.'</font>
<font color="red"> 814.     endpoint += 'amazonaws.com'</font>
<font color="black"> 815. </font>
<font color="red"> 816.     if operation_name in ['ListBuckets', 'CreateBucket', 'DeleteBucket']:</font>
<font color="red"> 817.         return</font>
<font color="red"> 818.     _switch_hosts(request, endpoint,  use_new_scheme=False)</font>
<font color="black"> 819. </font>
<font color="black"> 820. </font>
<font color="green"> 821. def switch_host_with_param(request, param_name):</font>
<font color="black"> 822.     &quot;&quot;&quot;Switches the host using a parameter value from a JSON request body&quot;&quot;&quot;</font>
<font color="red"> 823.     request_json = json.loads(request.data.decode('utf-8'))</font>
<font color="red"> 824.     if request_json.get(param_name):</font>
<font color="red"> 825.         new_endpoint = request_json[param_name]</font>
<font color="red"> 826.         _switch_hosts(request, new_endpoint)</font>
<font color="black"> 827. </font>
<font color="black"> 828. </font>
<font color="green"> 829. def _switch_hosts(request, new_endpoint, use_new_scheme=True):</font>
<font color="red"> 830.     final_endpoint = _get_new_endpoint(</font>
<font color="red"> 831.         request.url, new_endpoint, use_new_scheme)</font>
<font color="red"> 832.     request.url = final_endpoint</font>
<font color="black"> 833. </font>
<font color="black"> 834. </font>
<font color="green"> 835. def _get_new_endpoint(original_endpoint, new_endpoint, use_new_scheme=True):</font>
<font color="red"> 836.     new_endpoint_components = urlsplit(new_endpoint)</font>
<font color="red"> 837.     original_endpoint_components = urlsplit(original_endpoint)</font>
<font color="red"> 838.     scheme = original_endpoint_components.scheme</font>
<font color="red"> 839.     if use_new_scheme:</font>
<font color="red"> 840.         scheme = new_endpoint_components.scheme</font>
<font color="black"> 841.     final_endpoint_components = (</font>
<font color="red"> 842.         scheme,</font>
<font color="red"> 843.         new_endpoint_components.netloc,</font>
<font color="red"> 844.         original_endpoint_components.path,</font>
<font color="red"> 845.         original_endpoint_components.query,</font>
<font color="red"> 846.         ''</font>
<font color="black"> 847.     )</font>
<font color="red"> 848.     final_endpoint = urlunsplit(final_endpoint_components)</font>
<font color="red"> 849.     logger.debug('Updating URI from %s to %s' % (</font>
<font color="red"> 850.         original_endpoint, final_endpoint))</font>
<font color="red"> 851.     return final_endpoint</font>
<font color="black"> 852. </font>
<font color="black"> 853. </font>
<font color="green"> 854. def deep_merge(base, extra):</font>
<font color="black"> 855.     &quot;&quot;&quot;Deeply two dictionaries, overriding existing keys in the base.</font>
<font color="black"> 856. </font>
<font color="black"> 857.     :param base: The base dictionary which will be merged into.</font>
<font color="black"> 858.     :param extra: The dictionary to merge into the base. Keys from this</font>
<font color="black"> 859.         dictionary will take precedence.</font>
<font color="black"> 860.     &quot;&quot;&quot;</font>
<font color="red"> 861.     for key in extra:</font>
<font color="black"> 862.         # If the key represents a dict on both given dicts, merge the sub-dicts</font>
<font color="red"> 863.         if key in base and isinstance(base[key], dict)\</font>
<font color="red"> 864.                 and isinstance(extra[key], dict):</font>
<font color="red"> 865.             deep_merge(base[key], extra[key])</font>
<font color="red"> 866.             continue</font>
<font color="black"> 867. </font>
<font color="black"> 868.         # Otherwise, set the key on the base to be the value of the extra.</font>
<font color="red"> 869.         base[key] = extra[key]</font>
<font color="black"> 870. </font>
<font color="black"> 871. </font>
<font color="green"> 872. class S3RegionRedirector(object):</font>
<font color="green"> 873.     def __init__(self, endpoint_bridge, client, cache=None):</font>
<font color="green"> 874.         self._endpoint_resolver = endpoint_bridge</font>
<font color="green"> 875.         self._cache = cache</font>
<font color="green"> 876.         if self._cache is None:</font>
<font color="green"> 877.             self._cache = {}</font>
<font color="black"> 878. </font>
<font color="black"> 879.         # This needs to be a weak ref in order to prevent memory leaks on</font>
<font color="black"> 880.         # python 2.6</font>
<font color="green"> 881.         self._client = weakref.proxy(client)</font>
<font color="black"> 882. </font>
<font color="green"> 883.     def register(self, event_emitter=None):</font>
<font color="green"> 884.         emitter = event_emitter or self._client.meta.events</font>
<font color="green"> 885.         emitter.register('needs-retry.s3', self.redirect_from_error)</font>
<font color="green"> 886.         emitter.register('before-call.s3', self.set_request_url)</font>
<font color="green"> 887.         emitter.register('before-parameter-build.s3',</font>
<font color="green"> 888.                          self.redirect_from_cache)</font>
<font color="black"> 889. </font>
<font color="green"> 890.     def redirect_from_error(self, request_dict, response, operation, **kwargs):</font>
<font color="black"> 891.         &quot;&quot;&quot;</font>
<font color="black"> 892.         An S3 request sent to the wrong region will return an error that</font>
<font color="black"> 893.         contains the endpoint the request should be sent to. This handler</font>
<font color="black"> 894.         will add the redirect information to the signing context and then</font>
<font color="black"> 895.         redirect the request.</font>
<font color="black"> 896.         &quot;&quot;&quot;</font>
<font color="green"> 897.         if response is None:</font>
<font color="black"> 898.             # This could be none if there was a ConnectionError or other</font>
<font color="black"> 899.             # transport error.</font>
<font color="red"> 900.             return</font>
<font color="black"> 901. </font>
<font color="green"> 902.         if request_dict.get('context', {}).get('s3_redirected'):</font>
<font color="red"> 903.             logger.debug(</font>
<font color="red"> 904.                 'S3 request was previously redirected, not redirecting.')</font>
<font color="red"> 905.             return</font>
<font color="black"> 906. </font>
<font color="green"> 907.         error = response[1].get('Error', {})</font>
<font color="green"> 908.         error_code = error.get('Code')</font>
<font color="black"> 909. </font>
<font color="black"> 910.         # We have to account for 400 responses because</font>
<font color="black"> 911.         # if we sign a Head* request with the wrong region,</font>
<font color="black"> 912.         # we'll get a 400 Bad Request but we won't get a</font>
<font color="black"> 913.         # body saying it's an &quot;AuthorizationHeaderMalformed&quot;.</font>
<font color="black"> 914.         is_special_head_object = (</font>
<font color="green"> 915.             error_code in ['301', '400'] and</font>
<font color="red"> 916.             operation.name in ['HeadObject', 'HeadBucket']</font>
<font color="black"> 917.         )</font>
<font color="black"> 918.         is_wrong_signing_region = (</font>
<font color="green"> 919.             error_code == 'AuthorizationHeaderMalformed' and</font>
<font color="red"> 920.             'Region' in error</font>
<font color="black"> 921.         )</font>
<font color="green"> 922.         is_permanent_redirect = error_code == 'PermanentRedirect'</font>
<font color="green"> 923.         if not any([is_special_head_object, is_wrong_signing_region,</font>
<font color="green"> 924.                     is_permanent_redirect]):</font>
<font color="green"> 925.             return</font>
<font color="black"> 926. </font>
<font color="red"> 927.         bucket = request_dict['context']['signing']['bucket']</font>
<font color="red"> 928.         client_region = request_dict['context'].get('client_region')</font>
<font color="red"> 929.         new_region = self.get_bucket_region(bucket, response)</font>
<font color="black"> 930. </font>
<font color="red"> 931.         if new_region is None:</font>
<font color="red"> 932.             logger.debug(</font>
<font color="red"> 933.                 &quot;S3 client configured for region %s but the bucket %s is not &quot;</font>
<font color="black"> 934.                 &quot;in that region and the proper region could not be &quot;</font>
<font color="red"> 935.                 &quot;automatically determined.&quot; % (client_region, bucket))</font>
<font color="red"> 936.             return</font>
<font color="black"> 937. </font>
<font color="red"> 938.         logger.debug(</font>
<font color="red"> 939.             &quot;S3 client configured for region %s but the bucket %s is in region&quot;</font>
<font color="black"> 940.             &quot; %s; Please configure the proper region to avoid multiple &quot;</font>
<font color="black"> 941.             &quot;unnecessary redirects and signing attempts.&quot; % (</font>
<font color="red"> 942.                 client_region, bucket, new_region))</font>
<font color="red"> 943.         endpoint = self._endpoint_resolver.resolve('s3', new_region)</font>
<font color="red"> 944.         endpoint = endpoint['endpoint_url']</font>
<font color="black"> 945. </font>
<font color="red"> 946.         signing_context = {</font>
<font color="red"> 947.             'region': new_region,</font>
<font color="red"> 948.             'bucket': bucket,</font>
<font color="red"> 949.             'endpoint': endpoint</font>
<font color="black"> 950.         }</font>
<font color="red"> 951.         request_dict['context']['signing'] = signing_context</font>
<font color="black"> 952. </font>
<font color="red"> 953.         self._cache[bucket] = signing_context</font>
<font color="red"> 954.         self.set_request_url(request_dict, request_dict['context'])</font>
<font color="black"> 955. </font>
<font color="red"> 956.         request_dict['context']['s3_redirected'] = True</font>
<font color="black"> 957. </font>
<font color="black"> 958.         # Return 0 so it doesn't wait to retry</font>
<font color="red"> 959.         return 0</font>
<font color="black"> 960. </font>
<font color="green"> 961.     def get_bucket_region(self, bucket, response):</font>
<font color="black"> 962.         &quot;&quot;&quot;</font>
<font color="black"> 963.         There are multiple potential sources for the new region to redirect to,</font>
<font color="black"> 964.         but they aren't all universally available for use. This will try to</font>
<font color="black"> 965.         find region from response elements, but will fall back to calling</font>
<font color="black"> 966.         HEAD on the bucket if all else fails.</font>
<font color="black"> 967. </font>
<font color="black"> 968.         :param bucket: The bucket to find the region for. This is necessary if</font>
<font color="black"> 969.             the region is not available in the error response.</font>
<font color="black"> 970.         :param response: A response representing a service request that failed</font>
<font color="black"> 971.             due to incorrect region configuration.</font>
<font color="black"> 972.         &quot;&quot;&quot;</font>
<font color="black"> 973.         # First try to source the region from the headers.</font>
<font color="red"> 974.         service_response = response[1]</font>
<font color="red"> 975.         response_headers = service_response['ResponseMetadata']['HTTPHeaders']</font>
<font color="red"> 976.         if 'x-amz-bucket-region' in response_headers:</font>
<font color="red"> 977.             return response_headers['x-amz-bucket-region']</font>
<font color="black"> 978. </font>
<font color="black"> 979.         # Next, check the error body</font>
<font color="red"> 980.         region = service_response.get('Error', {}).get('Region', None)</font>
<font color="red"> 981.         if region is not None:</font>
<font color="red"> 982.             return region</font>
<font color="black"> 983. </font>
<font color="black"> 984.         # Finally, HEAD the bucket. No other choice sadly.</font>
<font color="red"> 985.         try:</font>
<font color="red"> 986.             response = self._client.head_bucket(Bucket=bucket)</font>
<font color="red"> 987.             headers = response['ResponseMetadata']['HTTPHeaders']</font>
<font color="red"> 988.         except ClientError as e:</font>
<font color="red"> 989.             headers = e.response['ResponseMetadata']['HTTPHeaders']</font>
<font color="black"> 990. </font>
<font color="red"> 991.         region = headers.get('x-amz-bucket-region', None)</font>
<font color="red"> 992.         return region</font>
<font color="black"> 993. </font>
<font color="green"> 994.     def set_request_url(self, params, context, **kwargs):</font>
<font color="green"> 995.         endpoint = context.get('signing', {}).get('endpoint', None)</font>
<font color="green"> 996.         if endpoint is not None:</font>
<font color="red"> 997.             params['url'] = _get_new_endpoint(params['url'], endpoint, False)</font>
<font color="black"> 998. </font>
<font color="green"> 999.     def redirect_from_cache(self, params, context, **kwargs):</font>
<font color="black">1000.         &quot;&quot;&quot;</font>
<font color="black">1001.         This handler retrieves a given bucket's signing context from the cache</font>
<font color="black">1002.         and adds it into the request context.</font>
<font color="black">1003.         &quot;&quot;&quot;</font>
<font color="green">1004.         bucket = params.get('Bucket')</font>
<font color="green">1005.         signing_context = self._cache.get(bucket)</font>
<font color="green">1006.         if signing_context is not None:</font>
<font color="red">1007.             context['signing'] = signing_context</font>
<font color="black">1008.         else:</font>
<font color="green">1009.             context['signing'] = {'bucket': bucket}</font>
<font color="black">1010. </font>
<font color="black">1011. </font>
<font color="green">1012. class ContainerMetadataFetcher(object):</font>
<font color="black">1013. </font>
<font color="green">1014.     TIMEOUT_SECONDS = 2</font>
<font color="green">1015.     RETRY_ATTEMPTS = 3</font>
<font color="green">1016.     SLEEP_TIME = 1</font>
<font color="green">1017.     IP_ADDRESS = '169.254.170.2'</font>
<font color="green">1018.     _ALLOWED_HOSTS = [IP_ADDRESS, 'localhost', '127.0.0.1']</font>
<font color="black">1019. </font>
<font color="green">1020.     def __init__(self, session=None, sleep=time.sleep):</font>
<font color="green">1021.         if session is None:</font>
<font color="green">1022.             session = requests.Session()</font>
<font color="green">1023.         self._session = session</font>
<font color="green">1024.         self._sleep = sleep</font>
<font color="black">1025. </font>
<font color="green">1026.     def retrieve_full_uri(self, full_url, headers=None):</font>
<font color="black">1027.         &quot;&quot;&quot;Retrieve JSON metadata from container metadata.</font>
<font color="black">1028. </font>
<font color="black">1029.         :type full_url: str</font>
<font color="black">1030.         :param full_url: The full URL of the metadata service.</font>
<font color="black">1031.             This should include the scheme as well, e.g</font>
<font color="black">1032.             &quot;http://localhost:123/foo&quot;</font>
<font color="black">1033. </font>
<font color="black">1034.         &quot;&quot;&quot;</font>
<font color="red">1035.         self._validate_allowed_url(full_url)</font>
<font color="red">1036.         return self._retrieve_credentials(full_url, headers)</font>
<font color="black">1037. </font>
<font color="green">1038.     def _validate_allowed_url(self, full_url):</font>
<font color="red">1039.         parsed = botocore.compat.urlparse(full_url)</font>
<font color="red">1040.         is_whitelisted_host = self._check_if_whitelisted_host(</font>
<font color="red">1041.             parsed.hostname)</font>
<font color="red">1042.         if not is_whitelisted_host:</font>
<font color="red">1043.             raise ValueError(</font>
<font color="red">1044.                 &quot;Unsupported host '%s'.  Can only &quot;</font>
<font color="black">1045.                 &quot;retrieve metadata from these hosts: %s&quot; %</font>
<font color="red">1046.                 (parsed.hostname, ', '.join(self._ALLOWED_HOSTS)))</font>
<font color="black">1047. </font>
<font color="green">1048.     def _check_if_whitelisted_host(self, host):</font>
<font color="red">1049.         if host in self._ALLOWED_HOSTS:</font>
<font color="red">1050.             return True</font>
<font color="red">1051.         return False</font>
<font color="black">1052. </font>
<font color="green">1053.     def retrieve_uri(self, relative_uri):</font>
<font color="black">1054.         &quot;&quot;&quot;Retrieve JSON metadata from ECS metadata.</font>
<font color="black">1055. </font>
<font color="black">1056.         :type relative_uri: str</font>
<font color="black">1057.         :param relative_uri: A relative URI, e.g &quot;/foo/bar?id=123&quot;</font>
<font color="black">1058. </font>
<font color="black">1059.         :return: The parsed JSON response.</font>
<font color="black">1060. </font>
<font color="black">1061.         &quot;&quot;&quot;</font>
<font color="red">1062.         full_url = self.full_url(relative_uri)</font>
<font color="red">1063.         return self._retrieve_credentials(full_url)</font>
<font color="black">1064. </font>
<font color="green">1065.     def _retrieve_credentials(self, full_url, extra_headers=None):</font>
<font color="red">1066.         headers = {'Accept': 'application/json'}</font>
<font color="red">1067.         if extra_headers is not None:</font>
<font color="red">1068.             headers.update(extra_headers)</font>
<font color="red">1069.         attempts = 0</font>
<font color="red">1070.         while True:</font>
<font color="red">1071.             try:</font>
<font color="red">1072.                 return self._get_response(full_url, headers, self.TIMEOUT_SECONDS)</font>
<font color="red">1073.             except MetadataRetrievalError as e:</font>
<font color="red">1074.                 logger.debug(&quot;Received error when attempting to retrieve &quot;</font>
<font color="red">1075.                              &quot;container metadata: %s&quot;, e, exc_info=True)</font>
<font color="red">1076.                 self._sleep(self.SLEEP_TIME)</font>
<font color="red">1077.                 attempts += 1</font>
<font color="red">1078.                 if attempts &gt;= self.RETRY_ATTEMPTS:</font>
<font color="red">1079.                     raise</font>
<font color="black">1080. </font>
<font color="green">1081.     def _get_response(self, full_url, headers, timeout):</font>
<font color="red">1082.         try:</font>
<font color="red">1083.             response = self._session.get(full_url, headers=headers,</font>
<font color="red">1084.                                          timeout=timeout)</font>
<font color="red">1085.             if response.status_code != 200:</font>
<font color="red">1086.                 raise MetadataRetrievalError(</font>
<font color="red">1087.                     error_msg=&quot;Received non 200 response (%s) from ECS metadata: %s&quot;</font>
<font color="red">1088.                     % (response.status_code, response.text))</font>
<font color="red">1089.             try:</font>
<font color="red">1090.                 return json.loads(response.text)</font>
<font color="red">1091.             except ValueError:</font>
<font color="red">1092.                 raise MetadataRetrievalError(</font>
<font color="red">1093.                     error_msg=(&quot;Unable to parse JSON returned from &quot;</font>
<font color="red">1094.                                &quot;ECS metadata: %s&quot; % response.text))</font>
<font color="red">1095.         except RETRYABLE_HTTP_ERRORS as e:</font>
<font color="red">1096.             error_msg = (&quot;Received error when attempting to retrieve &quot;</font>
<font color="red">1097.                          &quot;ECS metadata: %s&quot; % e)</font>
<font color="red">1098.             raise MetadataRetrievalError(error_msg=error_msg)</font>
<font color="black">1099. </font>
<font color="green">1100.     def full_url(self, relative_uri):</font>
<font color="red">1101.         return 'http://%s%s' % (self.IP_ADDRESS, relative_uri)</font>
</pre>

