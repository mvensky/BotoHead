source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/regions.py</b><br>


file stats: <b>97 lines, 65 executed: 67.0% covered</b>
<pre>
<font color="black">   1. # Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="black">  13. &quot;&quot;&quot;Resolves regions and endpoints.</font>
<font color="black">  14. </font>
<font color="black">  15. This module implements endpoint resolution, including resolving endpoints for a</font>
<font color="black">  16. given service and region and resolving the available endpoints for a service</font>
<font color="black">  17. in a specific AWS partition.</font>
<font color="green">  18. &quot;&quot;&quot;</font>
<font color="green">  19. import logging</font>
<font color="green">  20. import re</font>
<font color="black">  21. </font>
<font color="green">  22. from botocore.exceptions import NoRegionError</font>
<font color="black">  23. </font>
<font color="green">  24. LOG = logging.getLogger(__name__)</font>
<font color="green">  25. DEFAULT_URI_TEMPLATE = '{service}.{region}.{dnsSuffix}'</font>
<font color="green">  26. DEFAULT_SERVICE_DATA = {'endpoints': {}}</font>
<font color="black">  27. </font>
<font color="black">  28. </font>
<font color="green">  29. class BaseEndpointResolver(object):</font>
<font color="green">  30.     &quot;&quot;&quot;Resolves regions and endpoints. Must be subclassed.&quot;&quot;&quot;</font>
<font color="green">  31.     def construct_endpoint(self, service_name, region_name=None):</font>
<font color="black">  32.         &quot;&quot;&quot;Resolves an endpoint for a service and region combination.</font>
<font color="black">  33. </font>
<font color="black">  34.         :type service_name: string</font>
<font color="black">  35.         :param service_name: Name of the service to resolve an endpoint for</font>
<font color="black">  36.             (e.g., s3)</font>
<font color="black">  37. </font>
<font color="black">  38.         :type region_name: string</font>
<font color="black">  39.         :param region_name: Region/endpoint name to resolve (e.g., us-east-1)</font>
<font color="black">  40.             if no region is provided, the first found partition-wide endpoint</font>
<font color="black">  41.             will be used if available.</font>
<font color="black">  42. </font>
<font color="black">  43.         :rtype: dict</font>
<font color="black">  44.         :return: Returns a dict containing the following keys:</font>
<font color="black">  45.             - partition: (string, required) Resolved partition name</font>
<font color="black">  46.             - endpointName: (string, required) Resolved endpoint name</font>
<font color="black">  47.             - hostname: (string, required) Hostname to use for this endpoint</font>
<font color="black">  48.             - sslCommonName: (string) sslCommonName to use for this endpoint.</font>
<font color="black">  49.             - credentialScope: (dict) Signature version 4 credential scope</font>
<font color="black">  50.               - region: (string) region name override when signing.</font>
<font color="black">  51.               - service: (string) service name override when signing.</font>
<font color="black">  52.             - signatureVersions: (list&lt;string&gt;) A list of possible signature</font>
<font color="black">  53.               versions, including s3, v4, v2, and s3v4</font>
<font color="black">  54.             - protocols: (list&lt;string&gt;) A list of supported protocols</font>
<font color="black">  55.               (e.g., http, https)</font>
<font color="black">  56.             - ...: Other keys may be included as well based on the metadata</font>
<font color="black">  57.         &quot;&quot;&quot;</font>
<font color="red">  58.         raise NotImplementedError</font>
<font color="black">  59. </font>
<font color="green">  60.     def get_available_partitions(self):</font>
<font color="black">  61.         &quot;&quot;&quot;Lists the partitions available to the endpoint resolver.</font>
<font color="black">  62. </font>
<font color="black">  63.         :return: Returns a list of partition names (e.g., [&quot;aws&quot;, &quot;aws-cn&quot;]).</font>
<font color="black">  64.         &quot;&quot;&quot;</font>
<font color="red">  65.         raise NotImplementedError</font>
<font color="black">  66. </font>
<font color="green">  67.     def get_available_endpoints(self, service_name, partition_name='aws',</font>
<font color="green">  68.                                 allow_non_regional=False):</font>
<font color="black">  69.         &quot;&quot;&quot;Lists the endpoint names of a particular partition.</font>
<font color="black">  70. </font>
<font color="black">  71.         :type service_name: string</font>
<font color="black">  72.         :param service_name: Name of a service to list endpoint for (e.g., s3)</font>
<font color="black">  73. </font>
<font color="black">  74.         :type partition_name: string</font>
<font color="black">  75.         :param partition_name: Name of the partition to limit endpoints to.</font>
<font color="black">  76.             (e.g., aws for the public AWS endpoints, aws-cn for AWS China</font>
<font color="black">  77.             endpoints, aws-us-gov for AWS GovCloud (US) Endpoints, etc.</font>
<font color="black">  78. </font>
<font color="black">  79.         :type allow_non_regional: bool</font>
<font color="black">  80.         :param allow_non_regional: Set to True to include endpoints that are</font>
<font color="black">  81.              not regional endpoints (e.g., s3-external-1,</font>
<font color="black">  82.              fips-us-gov-west-1, etc).</font>
<font color="black">  83.         :return: Returns a list of endpoint names (e.g., [&quot;us-east-1&quot;]).</font>
<font color="black">  84.         &quot;&quot;&quot;</font>
<font color="red">  85.         raise NotImplementedError</font>
<font color="black">  86. </font>
<font color="black">  87. </font>
<font color="green">  88. class EndpointResolver(BaseEndpointResolver):</font>
<font color="green">  89.     &quot;&quot;&quot;Resolves endpoints based on partition endpoint metadata&quot;&quot;&quot;</font>
<font color="green">  90.     def __init__(self, endpoint_data):</font>
<font color="black">  91.         &quot;&quot;&quot;</font>
<font color="black">  92.         :param endpoint_data: A dict of partition data.</font>
<font color="black">  93.         &quot;&quot;&quot;</font>
<font color="green">  94.         if 'partitions' not in endpoint_data:</font>
<font color="red">  95.             raise ValueError('Missing &quot;partitions&quot; in endpoint data')</font>
<font color="green">  96.         self._endpoint_data = endpoint_data</font>
<font color="black">  97. </font>
<font color="green">  98.     def get_available_partitions(self):</font>
<font color="red">  99.         result = []</font>
<font color="red"> 100.         for partition in self._endpoint_data['partitions']:</font>
<font color="red"> 101.             result.append(partition['partition'])</font>
<font color="red"> 102.         return result</font>
<font color="black"> 103. </font>
<font color="green"> 104.     def get_available_endpoints(self, service_name, partition_name='aws',</font>
<font color="green"> 105.                                 allow_non_regional=False):</font>
<font color="green"> 106.         result = []</font>
<font color="green"> 107.         for partition in self._endpoint_data['partitions']:</font>
<font color="green"> 108.             if partition['partition'] != partition_name:</font>
<font color="green"> 109.                 continue</font>
<font color="green"> 110.             services = partition['services']</font>
<font color="green"> 111.             if service_name not in services:</font>
<font color="red"> 112.                 continue</font>
<font color="green"> 113.             for endpoint_name in services[service_name]['endpoints']:</font>
<font color="green"> 114.                 if allow_non_regional or endpoint_name in partition['regions']:</font>
<font color="green"> 115.                     result.append(endpoint_name)</font>
<font color="green"> 116.         return result</font>
<font color="black"> 117. </font>
<font color="green"> 118.     def construct_endpoint(self, service_name, region_name=None):</font>
<font color="black"> 119.         # Iterate over each partition until a match is found.</font>
<font color="green"> 120.         for partition in self._endpoint_data['partitions']:</font>
<font color="green"> 121.             result = self._endpoint_for_partition(</font>
<font color="green"> 122.                 partition, service_name, region_name)</font>
<font color="green"> 123.             if result:</font>
<font color="green"> 124.                 return result</font>
<font color="black"> 125. </font>
<font color="green"> 126.     def _endpoint_for_partition(self, partition, service_name, region_name):</font>
<font color="black"> 127.         # Get the service from the partition, or an empty template.</font>
<font color="green"> 128.         service_data = partition['services'].get(</font>
<font color="green"> 129.             service_name, DEFAULT_SERVICE_DATA)</font>
<font color="black"> 130.         # Use the partition endpoint if no region is supplied.</font>
<font color="green"> 131.         if region_name is None:</font>
<font color="red"> 132.             if 'partitionEndpoint' in service_data:</font>
<font color="red"> 133.                 region_name = service_data['partitionEndpoint']</font>
<font color="black"> 134.             else:</font>
<font color="red"> 135.                 raise NoRegionError()</font>
<font color="black"> 136.         # Attempt to resolve the exact region for this partition.</font>
<font color="green"> 137.         if region_name in service_data['endpoints']:</font>
<font color="green"> 138.             return self._resolve(</font>
<font color="green"> 139.                 partition, service_name, service_data, region_name)</font>
<font color="black"> 140.         # Check to see if the endpoint provided is valid for the partition.</font>
<font color="red"> 141.         if self._region_match(partition, region_name):</font>
<font color="black"> 142.             # Use the partition endpoint if set and not regionalized.</font>
<font color="red"> 143.             partition_endpoint = service_data.get('partitionEndpoint')</font>
<font color="red"> 144.             is_regionalized = service_data.get('isRegionalized', True)</font>
<font color="red"> 145.             if partition_endpoint and not is_regionalized:</font>
<font color="red"> 146.                 LOG.debug('Using partition endpoint for %s, %s: %s',</font>
<font color="red"> 147.                           service_name, region_name, partition_endpoint)</font>
<font color="red"> 148.                 return self._resolve(</font>
<font color="red"> 149.                     partition, service_name, service_data, partition_endpoint)</font>
<font color="red"> 150.             LOG.debug('Creating a regex based endpoint for %s, %s',</font>
<font color="red"> 151.                       service_name, region_name)</font>
<font color="red"> 152.             return self._resolve(</font>
<font color="red"> 153.                 partition, service_name, service_data, region_name)</font>
<font color="black"> 154. </font>
<font color="green"> 155.     def _region_match(self, partition, region_name):</font>
<font color="red"> 156.         if region_name in partition['regions']:</font>
<font color="red"> 157.             return True</font>
<font color="red"> 158.         if 'regionRegex' in partition:</font>
<font color="red"> 159.             return re.compile(partition['regionRegex']).match(region_name)</font>
<font color="red"> 160.         return False</font>
<font color="black"> 161. </font>
<font color="green"> 162.     def _resolve(self, partition, service_name, service_data, endpoint_name):</font>
<font color="green"> 163.         result = service_data['endpoints'].get(endpoint_name, {})</font>
<font color="green"> 164.         result['partition'] = partition['partition']</font>
<font color="green"> 165.         result['endpointName'] = endpoint_name</font>
<font color="black"> 166.         # Merge in the service defaults then the partition defaults.</font>
<font color="green"> 167.         self._merge_keys(service_data.get('defaults', {}), result)</font>
<font color="green"> 168.         self._merge_keys(partition.get('defaults', {}), result)</font>
<font color="green"> 169.         hostname = result.get('hostname', DEFAULT_URI_TEMPLATE)</font>
<font color="green"> 170.         result['hostname'] = self._expand_template(</font>
<font color="green"> 171.             partition, result['hostname'], service_name, endpoint_name)</font>
<font color="green"> 172.         if 'sslCommonName' in result:</font>
<font color="red"> 173.             result['sslCommonName'] = self._expand_template(</font>
<font color="red"> 174.                 partition, result['sslCommonName'], service_name,</font>
<font color="red"> 175.                 endpoint_name)</font>
<font color="green"> 176.         result['dnsSuffix'] = partition['dnsSuffix']</font>
<font color="green"> 177.         return result</font>
<font color="black"> 178. </font>
<font color="green"> 179.     def _merge_keys(self, from_data, result):</font>
<font color="green"> 180.         for key in from_data:</font>
<font color="green"> 181.             if key not in result:</font>
<font color="green"> 182.                 result[key] = from_data[key]</font>
<font color="black"> 183. </font>
<font color="green"> 184.     def _expand_template(self, partition, template, service_name,</font>
<font color="black"> 185.                          endpoint_name):</font>
<font color="green"> 186.         return template.format(</font>
<font color="green"> 187.             service=service_name, region=endpoint_name,</font>
<font color="green"> 188.             dnsSuffix=partition['dnsSuffix'])</font>
</pre>

