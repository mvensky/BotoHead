source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/s3transfer/tasks.py</b><br>


file stats: <b>138 lines, 31 executed: 22.5% covered</b>
<pre>
<font color="black">   1. # Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="green">  13. import copy</font>
<font color="green">  14. import logging</font>
<font color="black">  15. </font>
<font color="green">  16. from s3transfer.utils import get_callbacks</font>
<font color="black">  17. </font>
<font color="black">  18. </font>
<font color="green">  19. logger = logging.getLogger(__name__)</font>
<font color="black">  20. </font>
<font color="black">  21. </font>
<font color="green">  22. class Task(object):</font>
<font color="black">  23.     &quot;&quot;&quot;A task associated to a TransferFuture request</font>
<font color="black">  24. </font>
<font color="black">  25.     This is a base class for other classes to subclass from. All subclassed</font>
<font color="black">  26.     classes must implement the main() method.</font>
<font color="green">  27.     &quot;&quot;&quot;</font>
<font color="green">  28.     def __init__(self, transfer_coordinator, main_kwargs=None,</font>
<font color="green">  29.                  pending_main_kwargs=None, done_callbacks=None,</font>
<font color="green">  30.                  is_final=False):</font>
<font color="black">  31.         &quot;&quot;&quot;</font>
<font color="black">  32.         :type transfer_coordinator: s3transfer.futures.TransferCoordinator</font>
<font color="black">  33.         :param transfer_coordinator: The context associated to the</font>
<font color="black">  34.             TransferFuture for which this Task is associated with.</font>
<font color="black">  35. </font>
<font color="black">  36.         :type main_kwargs: dict</font>
<font color="black">  37.         :param main_kwargs: The keyword args that can be immediately supplied</font>
<font color="black">  38.             to the _main() method of the task</font>
<font color="black">  39. </font>
<font color="black">  40.         :type pending_main_kwargs: dict</font>
<font color="black">  41.         :param pending_main_kwargs: The keyword args that are depended upon</font>
<font color="black">  42.             by the result from a dependent future(s). The result returned by</font>
<font color="black">  43.             the future(s) will be used as the value for the keyword argument</font>
<font color="black">  44.             when _main() is called. The values for each key can be:</font>
<font color="black">  45.                 * a single future - Once completed, its value will be the</font>
<font color="black">  46.                   result of that single future</font>
<font color="black">  47.                 * a list of futures - Once all of the futures complete, the</font>
<font color="black">  48.                   value used will be a list of each completed future result</font>
<font color="black">  49.                   value in order of when they were originally supplied.</font>
<font color="black">  50. </font>
<font color="black">  51.         :type done_callbacks: list of callbacks</font>
<font color="black">  52.         :param done_callbacks: A list of callbacks to call once the task is</font>
<font color="black">  53.             done completing. Each callback will be called with no arguments</font>
<font color="black">  54.             and will be called no matter if the task succeeds or an exception</font>
<font color="black">  55.             is raised.</font>
<font color="black">  56. </font>
<font color="black">  57.         :type is_final: boolean</font>
<font color="black">  58.         :param is_final: True, to indicate that this task is the final task</font>
<font color="black">  59.             for the TransferFuture request. By setting this value to True, it</font>
<font color="black">  60.             will set the result of the entire TransferFuture to the result</font>
<font color="black">  61.             returned by this task's main() method.</font>
<font color="black">  62.         &quot;&quot;&quot;</font>
<font color="red">  63.         self._transfer_coordinator = transfer_coordinator</font>
<font color="black">  64. </font>
<font color="red">  65.         self._main_kwargs = main_kwargs</font>
<font color="red">  66.         if self._main_kwargs is None:</font>
<font color="red">  67.             self._main_kwargs = {}</font>
<font color="black">  68. </font>
<font color="red">  69.         self._pending_main_kwargs = pending_main_kwargs</font>
<font color="red">  70.         if pending_main_kwargs is None:</font>
<font color="red">  71.             self._pending_main_kwargs = {}</font>
<font color="black">  72. </font>
<font color="red">  73.         self._done_callbacks = done_callbacks</font>
<font color="red">  74.         if self._done_callbacks is None:</font>
<font color="red">  75.             self._done_callbacks = []</font>
<font color="black">  76. </font>
<font color="red">  77.         self._is_final = is_final</font>
<font color="black">  78. </font>
<font color="green">  79.     def __repr__(self):</font>
<font color="black">  80.         # These are the general main_kwarg parameters that we want to</font>
<font color="black">  81.         # display in the repr.</font>
<font color="black">  82.         params_to_display = [</font>
<font color="red">  83.             'bucket', 'key', 'part_number', 'final_filename',</font>
<font color="red">  84.             'transfer_future', 'offset', 'extra_args'</font>
<font color="black">  85.         ]</font>
<font color="red">  86.         main_kwargs_to_display = self._get_kwargs_with_params_to_include(</font>
<font color="red">  87.             self._main_kwargs, params_to_display)</font>
<font color="red">  88.         return '%s(transfer_id=%s, %s)' % (</font>
<font color="red">  89.             self.__class__.__name__, self._transfer_coordinator.transfer_id,</font>
<font color="red">  90.             main_kwargs_to_display)</font>
<font color="black">  91. </font>
<font color="green">  92.     @property</font>
<font color="black">  93.     def transfer_id(self):</font>
<font color="black">  94.         &quot;&quot;&quot;The id for the transfer request that the task belongs to&quot;&quot;&quot;</font>
<font color="red">  95.         return self._transfer_coordinator.transfer_id</font>
<font color="black">  96. </font>
<font color="green">  97.     def _get_kwargs_with_params_to_include(self, kwargs, include):</font>
<font color="red">  98.         filtered_kwargs = {}</font>
<font color="red">  99.         for param in include:</font>
<font color="red"> 100.             if param in kwargs:</font>
<font color="red"> 101.                 filtered_kwargs[param] = kwargs[param]</font>
<font color="red"> 102.         return filtered_kwargs</font>
<font color="black"> 103. </font>
<font color="green"> 104.     def _get_kwargs_with_params_to_exclude(self, kwargs, exclude):</font>
<font color="red"> 105.         filtered_kwargs = {}</font>
<font color="red"> 106.         for param, value in kwargs.items():</font>
<font color="red"> 107.             if param in exclude:</font>
<font color="red"> 108.                 continue</font>
<font color="red"> 109.             filtered_kwargs[param] = value</font>
<font color="red"> 110.         return filtered_kwargs</font>
<font color="black"> 111. </font>
<font color="green"> 112.     def __call__(self):</font>
<font color="black"> 113.         &quot;&quot;&quot;The callable to use when submitting a Task to an executor&quot;&quot;&quot;</font>
<font color="red"> 114.         try:</font>
<font color="black"> 115.             # Wait for all of futures this task depends on.</font>
<font color="red"> 116.             self._wait_on_dependent_futures()</font>
<font color="black"> 117.             # Gather up all of the main keyword arguments for main().</font>
<font color="black"> 118.             # This includes the immediately provided main_kwargs and</font>
<font color="black"> 119.             # the values for pending_main_kwargs that source from the return</font>
<font color="black"> 120.             # values from the task's depenent futures.</font>
<font color="red"> 121.             kwargs = self._get_all_main_kwargs()</font>
<font color="black"> 122.             # If the task is not done (really only if some other related</font>
<font color="black"> 123.             # task to the TransferFuture had failed) then execute the task's</font>
<font color="black"> 124.             # main() method.</font>
<font color="red"> 125.             if not self._transfer_coordinator.done():</font>
<font color="red"> 126.                 return self._execute_main(kwargs)</font>
<font color="red"> 127.         except Exception as e:</font>
<font color="red"> 128.             self._log_and_set_exception(e)</font>
<font color="black"> 129.         finally:</font>
<font color="black"> 130.             # Run any done callbacks associated to the task no matter what.</font>
<font color="red"> 131.             for done_callback in self._done_callbacks:</font>
<font color="red"> 132.                 done_callback()</font>
<font color="black"> 133. </font>
<font color="red"> 134.             if self._is_final:</font>
<font color="black"> 135.                 # If this is the final task announce that it is done if results</font>
<font color="black"> 136.                 # are waiting on its completion.</font>
<font color="red"> 137.                 self._transfer_coordinator.announce_done()</font>
<font color="black"> 138. </font>
<font color="green"> 139.     def _execute_main(self, kwargs):</font>
<font color="black"> 140.         # Do not display keyword args that should not be printed, especially</font>
<font color="black"> 141.         # if they are going to make the logs hard to follow.</font>
<font color="red"> 142.         params_to_exclude = ['data']</font>
<font color="red"> 143.         kwargs_to_display = self._get_kwargs_with_params_to_exclude(</font>
<font color="red"> 144.             kwargs, params_to_exclude)</font>
<font color="black"> 145.         # Log what is about to be executed.</font>
<font color="red"> 146.         logger.debug(</font>
<font color="red"> 147.             &quot;Executing task %s with kwargs %s&quot; % (self, kwargs_to_display)</font>
<font color="black"> 148.         )</font>
<font color="black"> 149. </font>
<font color="red"> 150.         return_value = self._main(**kwargs)</font>
<font color="black"> 151.         # If the task is the final task, then set the TransferFuture's</font>
<font color="black"> 152.         # value to the return value from main().</font>
<font color="red"> 153.         if self._is_final:</font>
<font color="red"> 154.             self._transfer_coordinator.set_result(return_value)</font>
<font color="red"> 155.         return return_value</font>
<font color="black"> 156. </font>
<font color="green"> 157.     def _log_and_set_exception(self, exception):</font>
<font color="black"> 158.         # If an exception is ever thrown than set the exception for the</font>
<font color="black"> 159.         # entire TransferFuture.</font>
<font color="red"> 160.         logger.debug(&quot;Exception raised.&quot;, exc_info=True)</font>
<font color="red"> 161.         self._transfer_coordinator.set_exception(exception)</font>
<font color="black"> 162. </font>
<font color="green"> 163.     def _main(self, **kwargs):</font>
<font color="black"> 164.         &quot;&quot;&quot;The method that will be ran in the executor</font>
<font color="black"> 165. </font>
<font color="black"> 166.         This method must be implemented by subclasses from Task. main() can</font>
<font color="black"> 167.         be implemented with any arguments decided upon by the subclass.</font>
<font color="black"> 168.         &quot;&quot;&quot;</font>
<font color="red"> 169.         raise NotImplementedError('_main() must be implemented')</font>
<font color="black"> 170. </font>
<font color="green"> 171.     def _wait_on_dependent_futures(self):</font>
<font color="black"> 172.         # Gather all of the futures into that main() depends on.</font>
<font color="red"> 173.         futures_to_wait_on = []</font>
<font color="red"> 174.         for _, future in self._pending_main_kwargs.items():</font>
<font color="black"> 175.             # If the pending main keyword arg is a list then extend the list.</font>
<font color="red"> 176.             if isinstance(future, list):</font>
<font color="red"> 177.                 futures_to_wait_on.extend(future)</font>
<font color="black"> 178.             # If the pending main keword arg is a future append it to the list.</font>
<font color="black"> 179.             else:</font>
<font color="red"> 180.                 futures_to_wait_on.append(future)</font>
<font color="black"> 181.         # Now wait for all of the futures to complete.</font>
<font color="red"> 182.         self._wait_until_all_complete(futures_to_wait_on)</font>
<font color="black"> 183. </font>
<font color="green"> 184.     def _wait_until_all_complete(self, futures):</font>
<font color="black"> 185.         # This is a basic implementation of the concurrent.futures.wait()</font>
<font color="black"> 186.         #</font>
<font color="black"> 187.         # concurrent.futures.wait() is not used instead because of this</font>
<font color="black"> 188.         # reported issue: https://bugs.python.org/issue20319.</font>
<font color="black"> 189.         # The issue would occassionally cause multipart uploads to hang</font>
<font color="black"> 190.         # when wait() was called. With this approach, it avoids the</font>
<font color="black"> 191.         # concurrency bug by removing any association with concurrent.futures</font>
<font color="black"> 192.         # implementation of waiters.</font>
<font color="red"> 193.         logger.debug(</font>
<font color="red"> 194.             '%s about to wait for the following futures %s', self, futures)</font>
<font color="red"> 195.         for future in futures:</font>
<font color="red"> 196.             try:</font>
<font color="red"> 197.                 logger.debug('%s about to wait for %s', self, future)</font>
<font color="red"> 198.                 future.result()</font>
<font color="red"> 199.             except Exception:</font>
<font color="black"> 200.                 # result() can also produce exceptions. We want to ignore</font>
<font color="black"> 201.                 # these to be deffered to error handling down the road.</font>
<font color="red"> 202.                 pass</font>
<font color="red"> 203.         logger.debug('%s done waiting for dependent futures', self)</font>
<font color="black"> 204. </font>
<font color="green"> 205.     def _get_all_main_kwargs(self):</font>
<font color="black"> 206.         # Copy over all of the kwargs that we know is available.</font>
<font color="red"> 207.         kwargs = copy.copy(self._main_kwargs)</font>
<font color="black"> 208. </font>
<font color="black"> 209.         # Iterate through the kwargs whose values are pending on the result</font>
<font color="black"> 210.         # of a future.</font>
<font color="red"> 211.         for key, pending_value in self._pending_main_kwargs.items():</font>
<font color="black"> 212.             # If the value is a list of futures, iterate though the list</font>
<font color="black"> 213.             # appending on the result from each future.</font>
<font color="red"> 214.             if isinstance(pending_value, list):</font>
<font color="red"> 215.                 result = []</font>
<font color="red"> 216.                 for future in pending_value:</font>
<font color="red"> 217.                     result.append(future.result())</font>
<font color="black"> 218.             # Otherwise if the pending_value is a future, just wait for it.</font>
<font color="black"> 219.             else:</font>
<font color="red"> 220.                 result = pending_value.result()</font>
<font color="black"> 221.             # Add the retrieved value to the kwargs to be sent to the</font>
<font color="black"> 222.             # main() call.</font>
<font color="red"> 223.             kwargs[key] = result</font>
<font color="red"> 224.         return kwargs</font>
<font color="black"> 225. </font>
<font color="black"> 226. </font>
<font color="green"> 227. class SubmissionTask(Task):</font>
<font color="black"> 228.     &quot;&quot;&quot;A base class for any submission task</font>
<font color="black"> 229. </font>
<font color="black"> 230.     Submission tasks are the top-level task used to submit a series of tasks</font>
<font color="black"> 231.     to execute a particular transfer.</font>
<font color="green"> 232.     &quot;&quot;&quot;</font>
<font color="green"> 233.     def _main(self, transfer_future, **kwargs):</font>
<font color="black"> 234.         &quot;&quot;&quot;</font>
<font color="black"> 235.         :type transfer_future: s3transfer.futures.TransferFuture</font>
<font color="black"> 236.         :param transfer_future: The transfer future associated with the</font>
<font color="black"> 237.             transfer request that tasks are being submitted for</font>
<font color="black"> 238. </font>
<font color="black"> 239.         :param kwargs: Any additional kwargs that you may want to pass</font>
<font color="black"> 240.             to the _submit() method</font>
<font color="black"> 241.         &quot;&quot;&quot;</font>
<font color="red"> 242.         try:</font>
<font color="red"> 243.             self._transfer_coordinator.set_status_to_queued()</font>
<font color="black"> 244. </font>
<font color="black"> 245.             # Before submitting any tasks, run all of the on_queued callbacks</font>
<font color="red"> 246.             on_queued_callbacks = get_callbacks(transfer_future, 'queued')</font>
<font color="red"> 247.             for on_queued_callback in on_queued_callbacks:</font>
<font color="red"> 248.                 on_queued_callback()</font>
<font color="black"> 249. </font>
<font color="black"> 250.             # Once callbacks have been ran set the status to running.</font>
<font color="red"> 251.             self._transfer_coordinator.set_status_to_running()</font>
<font color="black"> 252. </font>
<font color="black"> 253.             # Call the submit method to start submitting tasks to execute the</font>
<font color="black"> 254.             # transfer.</font>
<font color="red"> 255.             self._submit(transfer_future=transfer_future, **kwargs)</font>
<font color="red"> 256.         except BaseException as e:</font>
<font color="black"> 257.             # If there was an exception raised during the submission of task</font>
<font color="black"> 258.             # there is a chance that the final task that signals if a transfer</font>
<font color="black"> 259.             # is done and too run the cleanup may never have been submitted in</font>
<font color="black"> 260.             # the first place so we need to account accordingly.</font>
<font color="black"> 261.             #</font>
<font color="black"> 262.             # Note that BaseException is caught, instead of Exception, because</font>
<font color="black"> 263.             # for some implmentations of executors, specifically the serial</font>
<font color="black"> 264.             # implementation, the SubmissionTask is directly exposed to</font>
<font color="black"> 265.             # KeyboardInterupts and so needs to cleanup and signal done</font>
<font color="black"> 266.             # for those as well.</font>
<font color="black"> 267. </font>
<font color="black"> 268.             # Set the exception, that caused the process to fail.</font>
<font color="red"> 269.             self._log_and_set_exception(e)</font>
<font color="black"> 270. </font>
<font color="black"> 271.             # Wait for all possibly associated futures that may have spawned</font>
<font color="black"> 272.             # from this submission task have finished before we anounce the</font>
<font color="black"> 273.             # transfer done.</font>
<font color="red"> 274.             self._wait_for_all_submitted_futures_to_complete()</font>
<font color="black"> 275. </font>
<font color="black"> 276.             # Announce the transfer as done, which will run any cleanups</font>
<font color="black"> 277.             # and done callbacks as well.</font>
<font color="red"> 278.             self._transfer_coordinator.announce_done()</font>
<font color="black"> 279. </font>
<font color="green"> 280.     def _submit(self, transfer_future, **kwargs):</font>
<font color="black"> 281.         &quot;&quot;&quot;The submition method to be implemented</font>
<font color="black"> 282. </font>
<font color="black"> 283.         :type transfer_future: s3transfer.futures.TransferFuture</font>
<font color="black"> 284.         :param transfer_future: The transfer future associated with the</font>
<font color="black"> 285.             transfer request that tasks are being submitted for</font>
<font color="black"> 286. </font>
<font color="black"> 287.         :param kwargs: Any additional keyword arguments you want to be passed</font>
<font color="black"> 288.             in</font>
<font color="black"> 289.         &quot;&quot;&quot;</font>
<font color="red"> 290.         raise NotImplementedError('_submit() must be implemented')</font>
<font color="black"> 291. </font>
<font color="green"> 292.     def _wait_for_all_submitted_futures_to_complete(self):</font>
<font color="black"> 293.         # We want to wait for all futures that were submitted to</font>
<font color="black"> 294.         # complete as we do not want the cleanup callbacks or done callbacks</font>
<font color="black"> 295.         # to be called to early. The main problem is any task that was</font>
<font color="black"> 296.         # submitted may have submitted even more during its process and so</font>
<font color="black"> 297.         # we need to account accordingly.</font>
<font color="black"> 298. </font>
<font color="black"> 299.         # First get all of the futures that were submitted up to this point.</font>
<font color="red"> 300.         submitted_futures = self._transfer_coordinator.associated_futures</font>
<font color="red"> 301.         while submitted_futures:</font>
<font color="black"> 302.             # Wait for those futures to complete.</font>
<font color="red"> 303.             self._wait_until_all_complete(submitted_futures)</font>
<font color="black"> 304.             # However, more futures may have been submitted as we waited so</font>
<font color="black"> 305.             # we need to check again for any more associated futures.</font>
<font color="black"> 306.             possibly_more_submitted_futures = \</font>
<font color="red"> 307.                 self._transfer_coordinator.associated_futures</font>
<font color="black"> 308.             # If the current list of submitted futures is equal to the</font>
<font color="black"> 309.             # the list of associated futures for when after the wait completes,</font>
<font color="black"> 310.             # we can ensure no more futures were submitted in waiting on</font>
<font color="black"> 311.             # the current list of futures to complete ultimately meaning all</font>
<font color="black"> 312.             # futures that may have spawned from the original submission task</font>
<font color="black"> 313.             # have completed.</font>
<font color="red"> 314.             if submitted_futures == possibly_more_submitted_futures:</font>
<font color="red"> 315.                 break</font>
<font color="red"> 316.             submitted_futures = possibly_more_submitted_futures</font>
<font color="black"> 317. </font>
<font color="black"> 318. </font>
<font color="green"> 319. class CreateMultipartUploadTask(Task):</font>
<font color="green"> 320.     &quot;&quot;&quot;Task to initiate a multipart upload&quot;&quot;&quot;</font>
<font color="green"> 321.     def _main(self, client, bucket, key, extra_args):</font>
<font color="black"> 322.         &quot;&quot;&quot;</font>
<font color="black"> 323.         :param client: The client to use when calling CreateMultipartUpload</font>
<font color="black"> 324.         :param bucket: The name of the bucket to upload to</font>
<font color="black"> 325.         :param key: The name of the key to upload to</font>
<font color="black"> 326.         :param extra_args: A dictionary of any extra arguments that may be</font>
<font color="black"> 327.             used in the intialization.</font>
<font color="black"> 328. </font>
<font color="black"> 329.         :returns: The upload id of the multipart upload</font>
<font color="black"> 330.         &quot;&quot;&quot;</font>
<font color="black"> 331.         # Create the multipart upload.</font>
<font color="red"> 332.         response = client.create_multipart_upload(</font>
<font color="red"> 333.             Bucket=bucket, Key=key, **extra_args)</font>
<font color="red"> 334.         upload_id = response['UploadId']</font>
<font color="black"> 335. </font>
<font color="black"> 336.         # Add a cleanup if the multipart upload fails at any point.</font>
<font color="red"> 337.         self._transfer_coordinator.add_failure_cleanup(</font>
<font color="red"> 338.             client.abort_multipart_upload, Bucket=bucket, Key=key,</font>
<font color="red"> 339.             UploadId=upload_id</font>
<font color="black"> 340.         )</font>
<font color="red"> 341.         return upload_id</font>
<font color="black"> 342. </font>
<font color="black"> 343. </font>
<font color="green"> 344. class CompleteMultipartUploadTask(Task):</font>
<font color="green"> 345.     &quot;&quot;&quot;Task to complete a multipart upload&quot;&quot;&quot;</font>
<font color="green"> 346.     def _main(self, client, bucket, key, upload_id, parts, extra_args):</font>
<font color="black"> 347.         &quot;&quot;&quot;</font>
<font color="black"> 348.         :param client: The client to use when calling CompleteMultipartUpload</font>
<font color="black"> 349.         :param bucket: The name of the bucket to upload to</font>
<font color="black"> 350.         :param key: The name of the key to upload to</font>
<font color="black"> 351.         :param upload_id: The id of the upload</font>
<font color="black"> 352.         :param parts: A list of parts to use to complete the multipart upload::</font>
<font color="black"> 353. </font>
<font color="black"> 354.             [{'Etag': etag_value, 'PartNumber': part_number}, ...]</font>
<font color="black"> 355. </font>
<font color="black"> 356.             Each element in the list consists of a return value from</font>
<font color="black"> 357.             ``UploadPartTask.main()``.</font>
<font color="black"> 358.         :param extra_args:  A dictionary of any extra arguments that may be</font>
<font color="black"> 359.             used in completing the multipart transfer.</font>
<font color="black"> 360.         &quot;&quot;&quot;</font>
<font color="red"> 361.         client.complete_multipart_upload(</font>
<font color="red"> 362.             Bucket=bucket, Key=key, UploadId=upload_id,</font>
<font color="red"> 363.             MultipartUpload={'Parts': parts},</font>
<font color="red"> 364.             **extra_args)</font>
</pre>

