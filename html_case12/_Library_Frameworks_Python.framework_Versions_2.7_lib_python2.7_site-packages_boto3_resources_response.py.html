source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/boto3/resources/response.py</b><br>


file stats: <b>109 lines, 15 executed: 13.8% covered</b>
<pre>
<font color="black">   1. # Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="black">  13. </font>
<font color="green">  14. import jmespath</font>
<font color="green">  15. from botocore import xform_name</font>
<font color="black">  16. </font>
<font color="green">  17. from .params import get_data_member</font>
<font color="black">  18. </font>
<font color="black">  19. </font>
<font color="green">  20. def all_not_none(iterable):</font>
<font color="black">  21.     &quot;&quot;&quot;</font>
<font color="black">  22.     Return True if all elements of the iterable are not None (or if the</font>
<font color="black">  23.     iterable is empty). This is like the built-in ``all``, except checks</font>
<font color="black">  24.     against None, so 0 and False are allowable values.</font>
<font color="black">  25.     &quot;&quot;&quot;</font>
<font color="red">  26.     for element in iterable:</font>
<font color="red">  27.         if element is None:</font>
<font color="red">  28.             return False</font>
<font color="red">  29.     return True</font>
<font color="black">  30. </font>
<font color="black">  31. </font>
<font color="green">  32. def build_identifiers(identifiers, parent, params=None, raw_response=None):</font>
<font color="black">  33.     &quot;&quot;&quot;</font>
<font color="black">  34.     Builds a mapping of identifier names to values based on the</font>
<font color="black">  35.     identifier source location, type, and target. Identifier</font>
<font color="black">  36.     values may be scalars or lists depending on the source type</font>
<font color="black">  37.     and location.</font>
<font color="black">  38. </font>
<font color="black">  39.     :type identifiers: list</font>
<font color="black">  40.     :param identifiers: List of :py:class:`~boto3.resources.model.Parameter`</font>
<font color="black">  41.                         definitions</font>
<font color="black">  42.     :type parent: ServiceResource</font>
<font color="black">  43.     :param parent: The resource instance to which this action is attached.</font>
<font color="black">  44.     :type params: dict</font>
<font color="black">  45.     :param params: Request parameters sent to the service.</font>
<font color="black">  46.     :type raw_response: dict</font>
<font color="black">  47.     :param raw_response: Low-level operation response.</font>
<font color="black">  48.     :rtype: list</font>
<font color="black">  49.     :return: An ordered list of ``(name, value)`` identifier tuples.</font>
<font color="black">  50.     &quot;&quot;&quot;</font>
<font color="red">  51.     results = []</font>
<font color="black">  52. </font>
<font color="red">  53.     for identifier in identifiers:</font>
<font color="red">  54.         source = identifier.source</font>
<font color="red">  55.         target = identifier.target</font>
<font color="black">  56. </font>
<font color="red">  57.         if source == 'response':</font>
<font color="red">  58.             value = jmespath.search(identifier.path, raw_response)</font>
<font color="red">  59.         elif source == 'requestParameter':</font>
<font color="red">  60.             value = jmespath.search(identifier.path, params)</font>
<font color="red">  61.         elif source == 'identifier':</font>
<font color="red">  62.             value = getattr(parent, xform_name(identifier.name))</font>
<font color="red">  63.         elif source == 'data':</font>
<font color="black">  64.             # If this is a data member then it may incur a load</font>
<font color="black">  65.             # action before returning the value.</font>
<font color="red">  66.             value = get_data_member(parent, identifier.path)</font>
<font color="red">  67.         elif source == 'input':</font>
<font color="black">  68.             # This value is set by the user, so ignore it here</font>
<font color="red">  69.             continue</font>
<font color="black">  70.         else:</font>
<font color="red">  71.             raise NotImplementedError(</font>
<font color="red">  72.                 'Unsupported source type: {0}'.format(source))</font>
<font color="black">  73. </font>
<font color="red">  74.         results.append((xform_name(target), value))</font>
<font color="black">  75. </font>
<font color="red">  76.     return results</font>
<font color="black">  77. </font>
<font color="black">  78. </font>
<font color="green">  79. def build_empty_response(search_path, operation_name, service_model):</font>
<font color="black">  80.     &quot;&quot;&quot;</font>
<font color="black">  81.     Creates an appropriate empty response for the type that is expected,</font>
<font color="black">  82.     based on the service model's shape type. For example, a value that</font>
<font color="black">  83.     is normally a list would then return an empty list. A structure would</font>
<font color="black">  84.     return an empty dict, and a number would return None.</font>
<font color="black">  85. </font>
<font color="black">  86.     :type search_path: string</font>
<font color="black">  87.     :param search_path: JMESPath expression to search in the response</font>
<font color="black">  88.     :type operation_name: string</font>
<font color="black">  89.     :param operation_name: Name of the underlying service operation.</font>
<font color="black">  90.     :type service_model: :ref:`botocore.model.ServiceModel`</font>
<font color="black">  91.     :param service_model: The Botocore service model</font>
<font color="black">  92.     :rtype: dict, list, or None</font>
<font color="black">  93.     :return: An appropriate empty value</font>
<font color="black">  94.     &quot;&quot;&quot;</font>
<font color="red">  95.     response = None</font>
<font color="black">  96. </font>
<font color="red">  97.     operation_model = service_model.operation_model(operation_name)</font>
<font color="red">  98.     shape = operation_model.output_shape</font>
<font color="black">  99. </font>
<font color="red"> 100.     if search_path:</font>
<font color="black"> 101.         # Walk the search path and find the final shape. For example, given</font>
<font color="black"> 102.         # a path of ``foo.bar[0].baz``, we first find the shape for ``foo``,</font>
<font color="black"> 103.         # then the shape for ``bar`` (ignoring the indexing), and finally</font>
<font color="black"> 104.         # the shape for ``baz``.</font>
<font color="red"> 105.         for item in search_path.split('.'):</font>
<font color="red"> 106.             item = item.strip('[0123456789]$')</font>
<font color="black"> 107. </font>
<font color="red"> 108.             if shape.type_name == 'structure':</font>
<font color="red"> 109.                 shape = shape.members[item]</font>
<font color="red"> 110.             elif shape.type_name == 'list':</font>
<font color="red"> 111.                 shape = shape.member</font>
<font color="black"> 112.             else:</font>
<font color="red"> 113.                 raise NotImplementedError(</font>
<font color="red"> 114.                     'Search path hits shape type {0} from {1}'.format(</font>
<font color="red"> 115.                         shape.type_name, item))</font>
<font color="black"> 116. </font>
<font color="black"> 117.     # Anything not handled here is set to None</font>
<font color="red"> 118.     if shape.type_name == 'structure':</font>
<font color="red"> 119.         response = {}</font>
<font color="red"> 120.     elif shape.type_name == 'list':</font>
<font color="red"> 121.         response = []</font>
<font color="red"> 122.     elif shape.type_name == 'map':</font>
<font color="red"> 123.         response = {}</font>
<font color="black"> 124. </font>
<font color="red"> 125.     return response</font>
<font color="black"> 126. </font>
<font color="black"> 127. </font>
<font color="green"> 128. class RawHandler(object):</font>
<font color="black"> 129.     &quot;&quot;&quot;</font>
<font color="black"> 130.     A raw action response handler. This passed through the response</font>
<font color="black"> 131.     dictionary, optionally after performing a JMESPath search if one</font>
<font color="black"> 132.     has been defined for the action.</font>
<font color="black"> 133. </font>
<font color="black"> 134.     :type search_path: string</font>
<font color="black"> 135.     :param search_path: JMESPath expression to search in the response</font>
<font color="black"> 136.     :rtype: dict</font>
<font color="black"> 137.     :return: Service response</font>
<font color="green"> 138.     &quot;&quot;&quot;</font>
<font color="green"> 139.     def __init__(self, search_path):</font>
<font color="red"> 140.         self.search_path = search_path</font>
<font color="black"> 141. </font>
<font color="green"> 142.     def __call__(self, parent, params, response):</font>
<font color="black"> 143.         &quot;&quot;&quot;</font>
<font color="black"> 144.         :type parent: ServiceResource</font>
<font color="black"> 145.         :param parent: The resource instance to which this action is attached.</font>
<font color="black"> 146.         :type params: dict</font>
<font color="black"> 147.         :param params: Request parameters sent to the service.</font>
<font color="black"> 148.         :type response: dict</font>
<font color="black"> 149.         :param response: Low-level operation response.</font>
<font color="black"> 150.         &quot;&quot;&quot;</font>
<font color="black"> 151.         # TODO: Remove the '$' check after JMESPath supports it</font>
<font color="red"> 152.         if self.search_path and self.search_path != '$':</font>
<font color="red"> 153.             response = jmespath.search(self.search_path, response)</font>
<font color="black"> 154. </font>
<font color="red"> 155.         return response</font>
<font color="black"> 156. </font>
<font color="black"> 157. </font>
<font color="green"> 158. class ResourceHandler(object):</font>
<font color="black"> 159.     &quot;&quot;&quot;</font>
<font color="black"> 160.     Creates a new resource or list of new resources from the low-level</font>
<font color="black"> 161.     response based on the given response resource definition.</font>
<font color="black"> 162. </font>
<font color="black"> 163.     :type search_path: string</font>
<font color="black"> 164.     :param search_path: JMESPath expression to search in the response</font>
<font color="black"> 165. </font>
<font color="black"> 166.     :type factory: ResourceFactory</font>
<font color="black"> 167.     :param factory: The factory that created the resource class to which</font>
<font color="black"> 168.                     this action is attached.</font>
<font color="black"> 169. </font>
<font color="black"> 170.     :type resource_model: :py:class:`~boto3.resources.model.ResponseResource`</font>
<font color="black"> 171.     :param resource_model: Response resource model.</font>
<font color="black"> 172. </font>
<font color="black"> 173.     :type service_context: :py:class:`~boto3.utils.ServiceContext`</font>
<font color="black"> 174.     :param service_context: Context about the AWS service</font>
<font color="black"> 175. </font>
<font color="black"> 176.     :type operation_name: string</font>
<font color="black"> 177.     :param operation_name: Name of the underlying service operation, if it</font>
<font color="black"> 178.                            exists.</font>
<font color="black"> 179. </font>
<font color="black"> 180.     :rtype: ServiceResource or list</font>
<font color="black"> 181.     :return: New resource instance(s).</font>
<font color="green"> 182.     &quot;&quot;&quot;</font>
<font color="black"> 183.     def __init__(self, search_path, factory, resource_model,</font>
<font color="green"> 184.                  service_context, operation_name=None):</font>
<font color="red"> 185.         self.search_path = search_path</font>
<font color="red"> 186.         self.factory = factory</font>
<font color="red"> 187.         self.resource_model = resource_model</font>
<font color="red"> 188.         self.operation_name = operation_name</font>
<font color="red"> 189.         self.service_context = service_context</font>
<font color="black"> 190. </font>
<font color="green"> 191.     def __call__(self, parent, params, response):</font>
<font color="black"> 192.         &quot;&quot;&quot;</font>
<font color="black"> 193.         :type parent: ServiceResource</font>
<font color="black"> 194.         :param parent: The resource instance to which this action is attached.</font>
<font color="black"> 195.         :type params: dict</font>
<font color="black"> 196.         :param params: Request parameters sent to the service.</font>
<font color="black"> 197.         :type response: dict</font>
<font color="black"> 198.         :param response: Low-level operation response.</font>
<font color="black"> 199.         &quot;&quot;&quot;</font>
<font color="red"> 200.         resource_name = self.resource_model.type</font>
<font color="red"> 201.         json_definition = self.service_context.resource_json_definitions.get(</font>
<font color="red"> 202.             resource_name)</font>
<font color="black"> 203. </font>
<font color="black"> 204.         # Load the new resource class that will result from this action.</font>
<font color="red"> 205.         resource_cls = self.factory.load_from_definition(</font>
<font color="red"> 206.             resource_name=resource_name,</font>
<font color="red"> 207.             single_resource_json_definition=json_definition,</font>
<font color="red"> 208.             service_context=self.service_context</font>
<font color="black"> 209.         )</font>
<font color="red"> 210.         raw_response = response</font>
<font color="red"> 211.         search_response = None</font>
<font color="black"> 212. </font>
<font color="black"> 213.         # Anytime a path is defined, it means the response contains the</font>
<font color="black"> 214.         # resource's attributes, so resource_data gets set here. It</font>
<font color="black"> 215.         # eventually ends up in resource.meta.data, which is where</font>
<font color="black"> 216.         # the attribute properties look for data.</font>
<font color="red"> 217.         if self.search_path:</font>
<font color="red"> 218.             search_response = jmespath.search(self.search_path, raw_response)</font>
<font color="black"> 219. </font>
<font color="black"> 220.         # First, we parse all the identifiers, then create the individual</font>
<font color="black"> 221.         # response resources using them. Any identifiers that are lists</font>
<font color="black"> 222.         # will have one item consumed from the front of the list for each</font>
<font color="black"> 223.         # resource that is instantiated. Items which are not a list will</font>
<font color="black"> 224.         # be set as the same value on each new resource instance.</font>
<font color="red"> 225.         identifiers = dict(build_identifiers(</font>
<font color="red"> 226.             self.resource_model.identifiers, parent, params,</font>
<font color="red"> 227.             raw_response))</font>
<font color="black"> 228. </font>
<font color="black"> 229.         # If any of the identifiers is a list, then the response is plural</font>
<font color="red"> 230.         plural = [v for v in identifiers.values() if isinstance(v, list)]</font>
<font color="black"> 231. </font>
<font color="red"> 232.         if plural:</font>
<font color="red"> 233.             response = []</font>
<font color="black"> 234. </font>
<font color="black"> 235.             # The number of items in an identifier that is a list will</font>
<font color="black"> 236.             # determine how many resource instances to create.</font>
<font color="red"> 237.             for i in range(len(plural[0])):</font>
<font color="black"> 238.                 # Response item data is *only* available if a search path</font>
<font color="black"> 239.                 # was given. This prevents accidentally loading unrelated</font>
<font color="black"> 240.                 # data that may be in the response.</font>
<font color="red"> 241.                 response_item = None</font>
<font color="red"> 242.                 if search_response:</font>
<font color="red"> 243.                     response_item = search_response[i]</font>
<font color="red"> 244.                 response.append(</font>
<font color="red"> 245.                     self.handle_response_item(resource_cls, parent,</font>
<font color="red"> 246.                                               identifiers, response_item))</font>
<font color="red"> 247.         elif all_not_none(identifiers.values()):</font>
<font color="black"> 248.             # All identifiers must always exist, otherwise the resource</font>
<font color="black"> 249.             # cannot be instantiated.</font>
<font color="red"> 250.             response = self.handle_response_item(</font>
<font color="red"> 251.                 resource_cls, parent, identifiers, search_response)</font>
<font color="black"> 252.         else:</font>
<font color="black"> 253.             # The response should be empty, but that may mean an</font>
<font color="black"> 254.             # empty dict, list, or None based on whether we make</font>
<font color="black"> 255.             # a remote service call and what shape it is expected</font>
<font color="black"> 256.             # to return.</font>
<font color="red"> 257.             response = None</font>
<font color="red"> 258.             if self.operation_name is not None:</font>
<font color="black"> 259.                 # A remote service call was made, so try and determine</font>
<font color="black"> 260.                 # its shape.</font>
<font color="red"> 261.                 response = build_empty_response(</font>
<font color="red"> 262.                     self.search_path, self.operation_name,</font>
<font color="red"> 263.                     self.service_context.service_model)</font>
<font color="black"> 264. </font>
<font color="red"> 265.         return response</font>
<font color="black"> 266. </font>
<font color="green"> 267.     def handle_response_item(self, resource_cls, parent, identifiers,</font>
<font color="black"> 268.                              resource_data):</font>
<font color="black"> 269.         &quot;&quot;&quot;</font>
<font color="black"> 270.         Handles the creation of a single response item by setting</font>
<font color="black"> 271.         parameters and creating the appropriate resource instance.</font>
<font color="black"> 272. </font>
<font color="black"> 273.         :type resource_cls: ServiceResource subclass</font>
<font color="black"> 274.         :param resource_cls: The resource class to instantiate.</font>
<font color="black"> 275.         :type parent: ServiceResource</font>
<font color="black"> 276.         :param parent: The resource instance to which this action is attached.</font>
<font color="black"> 277.         :type identifiers: dict</font>
<font color="black"> 278.         :param identifiers: Map of identifier names to value or values.</font>
<font color="black"> 279.         :type resource_data: dict or None</font>
<font color="black"> 280.         :param resource_data: Data for resource attributes.</font>
<font color="black"> 281.         :rtype: ServiceResource</font>
<font color="black"> 282.         :return: New resource instance.</font>
<font color="black"> 283.         &quot;&quot;&quot;</font>
<font color="red"> 284.         kwargs = {</font>
<font color="red"> 285.             'client': parent.meta.client,</font>
<font color="black"> 286.         }</font>
<font color="black"> 287. </font>
<font color="red"> 288.         for name, value in identifiers.items():</font>
<font color="black"> 289.             # If value is a list, then consume the next item</font>
<font color="red"> 290.             if isinstance(value, list):</font>
<font color="red"> 291.                 value = value.pop(0)</font>
<font color="black"> 292. </font>
<font color="red"> 293.             kwargs[name] = value</font>
<font color="black"> 294. </font>
<font color="red"> 295.         resource = resource_cls(**kwargs)</font>
<font color="black"> 296. </font>
<font color="red"> 297.         if resource_data is not None:</font>
<font color="red"> 298.             resource.meta.data = resource_data</font>
<font color="black"> 299. </font>
<font color="red"> 300.         return resource</font>
</pre>

