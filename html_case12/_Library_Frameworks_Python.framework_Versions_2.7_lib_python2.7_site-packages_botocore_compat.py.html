source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/compat.py</b><br>


file stats: <b>189 lines, 73 executed: 38.6% covered</b>
<pre>
<font color="black">   1. # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="black">  13. </font>
<font color="green">  14. import copy</font>
<font color="green">  15. import datetime</font>
<font color="green">  16. import sys</font>
<font color="green">  17. import inspect</font>
<font color="green">  18. import warnings</font>
<font color="green">  19. import hashlib</font>
<font color="green">  20. import logging</font>
<font color="green">  21. import shlex</font>
<font color="green">  22. from math import floor</font>
<font color="black">  23. </font>
<font color="green">  24. from botocore.vendored import six</font>
<font color="green">  25. from botocore.exceptions import MD5UnavailableError</font>
<font color="green">  26. from botocore.vendored.requests.packages.urllib3 import exceptions</font>
<font color="black">  27. </font>
<font color="green">  28. logger = logging.getLogger(__name__)</font>
<font color="black">  29. </font>
<font color="black">  30. </font>
<font color="green">  31. if six.PY3:</font>
<font color="red">  32.     from botocore.vendored.six.moves import http_client</font>
<font color="black">  33. </font>
<font color="red">  34.     class HTTPHeaders(http_client.HTTPMessage):</font>
<font color="red">  35.         pass</font>
<font color="black">  36. </font>
<font color="red">  37.     from urllib.parse import quote</font>
<font color="red">  38.     from urllib.parse import urlencode</font>
<font color="red">  39.     from urllib.parse import unquote</font>
<font color="red">  40.     from urllib.parse import unquote_plus</font>
<font color="red">  41.     from urllib.parse import urlparse</font>
<font color="red">  42.     from urllib.parse import urlsplit</font>
<font color="red">  43.     from urllib.parse import urlunsplit</font>
<font color="red">  44.     from urllib.parse import urljoin</font>
<font color="red">  45.     from urllib.parse import parse_qsl</font>
<font color="red">  46.     from urllib.parse import parse_qs</font>
<font color="red">  47.     from http.client import HTTPResponse</font>
<font color="red">  48.     from io import IOBase as _IOBase</font>
<font color="red">  49.     from base64 import encodebytes</font>
<font color="red">  50.     from email.utils import formatdate</font>
<font color="red">  51.     from itertools import zip_longest</font>
<font color="red">  52.     file_type = _IOBase</font>
<font color="red">  53.     zip = zip</font>
<font color="black">  54. </font>
<font color="black">  55.     # In python3, unquote takes a str() object, url decodes it,</font>
<font color="black">  56.     # then takes the bytestring and decodes it to utf-8.</font>
<font color="black">  57.     # Python2 we'll have to do this ourself (see below).</font>
<font color="red">  58.     unquote_str = unquote_plus</font>
<font color="black">  59. </font>
<font color="red">  60.     def set_socket_timeout(http_response, timeout):</font>
<font color="black">  61.         &quot;&quot;&quot;Set the timeout of the socket from an HTTPResponse.</font>
<font color="black">  62. </font>
<font color="black">  63.         :param http_response: An instance of ``httplib.HTTPResponse``</font>
<font color="black">  64. </font>
<font color="black">  65.         &quot;&quot;&quot;</font>
<font color="red">  66.         http_response._fp.fp.raw._sock.settimeout(timeout)</font>
<font color="black">  67. </font>
<font color="red">  68.     def accepts_kwargs(func):</font>
<font color="black">  69.         # In python3.4.1, there's backwards incompatible</font>
<font color="black">  70.         # changes when using getargspec with functools.partials.</font>
<font color="red">  71.         return inspect.getfullargspec(func)[2]</font>
<font color="black">  72. </font>
<font color="red">  73.     def ensure_unicode(s, encoding=None, errors=None):</font>
<font color="black">  74.         # NOOP in Python 3, because every string is already unicode</font>
<font color="red">  75.         return s</font>
<font color="black">  76. </font>
<font color="red">  77.     def ensure_bytes(s, encoding='utf-8', errors='strict'):</font>
<font color="red">  78.         if isinstance(s, str):</font>
<font color="red">  79.             return s.encode(encoding, errors)</font>
<font color="red">  80.         if isinstance(s, bytes):</font>
<font color="red">  81.             return s</font>
<font color="red">  82.         raise ValueError(&quot;Expected str or bytes, received %s.&quot; % type(s))</font>
<font color="black">  83. </font>
<font color="black">  84. else:</font>
<font color="green">  85.     from urllib import quote</font>
<font color="green">  86.     from urllib import urlencode</font>
<font color="green">  87.     from urllib import unquote</font>
<font color="green">  88.     from urllib import unquote_plus</font>
<font color="green">  89.     from urlparse import urlparse</font>
<font color="green">  90.     from urlparse import urlsplit</font>
<font color="green">  91.     from urlparse import urlunsplit</font>
<font color="green">  92.     from urlparse import urljoin</font>
<font color="green">  93.     from urlparse import parse_qsl</font>
<font color="green">  94.     from urlparse import parse_qs</font>
<font color="green">  95.     from email.message import Message</font>
<font color="green">  96.     from email.Utils import formatdate</font>
<font color="green">  97.     file_type = file</font>
<font color="green">  98.     from itertools import izip as zip</font>
<font color="green">  99.     from itertools import izip_longest as zip_longest</font>
<font color="green"> 100.     from httplib import HTTPResponse</font>
<font color="green"> 101.     from base64 import encodestring as encodebytes</font>
<font color="black"> 102. </font>
<font color="green"> 103.     class HTTPHeaders(Message):</font>
<font color="black"> 104. </font>
<font color="black"> 105.         # The __iter__ method is not available in python2.x, so we have</font>
<font color="black"> 106.         # to port the py3 version.</font>
<font color="green"> 107.         def __iter__(self):</font>
<font color="green"> 108.             for field, value in self._headers:</font>
<font color="green"> 109.                 yield field</font>
<font color="black"> 110. </font>
<font color="green"> 111.     def unquote_str(value, encoding='utf-8'):</font>
<font color="black"> 112.         # In python2, unquote() gives us a string back that has the urldecoded</font>
<font color="black"> 113.         # bits, but not the unicode parts.  We need to decode this manually.</font>
<font color="black"> 114.         # unquote has special logic in which if it receives a unicode object it</font>
<font color="black"> 115.         # will decode it to latin1.  This is hard coded.  To avoid this, we'll</font>
<font color="black"> 116.         # encode the string with the passed in encoding before trying to</font>
<font color="black"> 117.         # unquote it.</font>
<font color="red"> 118.         byte_string = value.encode(encoding)</font>
<font color="red"> 119.         return unquote_plus(byte_string).decode(encoding)</font>
<font color="black"> 120. </font>
<font color="green"> 121.     def set_socket_timeout(http_response, timeout):</font>
<font color="black"> 122.         &quot;&quot;&quot;Set the timeout of the socket from an HTTPResponse.</font>
<font color="black"> 123. </font>
<font color="black"> 124.         :param http_response: An instance of ``httplib.HTTPResponse``</font>
<font color="black"> 125. </font>
<font color="black"> 126.         &quot;&quot;&quot;</font>
<font color="red"> 127.         http_response._fp.fp._sock.settimeout(timeout)</font>
<font color="black"> 128. </font>
<font color="green"> 129.     def accepts_kwargs(func):</font>
<font color="green"> 130.         return inspect.getargspec(func)[2]</font>
<font color="black"> 131. </font>
<font color="green"> 132.     def ensure_unicode(s, encoding='utf-8', errors='strict'):</font>
<font color="green"> 133.         if isinstance(s, six.text_type):</font>
<font color="green"> 134.             return s</font>
<font color="green"> 135.         return unicode(s, encoding, errors)</font>
<font color="black"> 136. </font>
<font color="green"> 137.     def ensure_bytes(s, encoding='utf-8', errors='strict'):</font>
<font color="red"> 138.         if isinstance(s, unicode):</font>
<font color="red"> 139.             return s.encode(encoding, errors)</font>
<font color="red"> 140.         if isinstance(s, str):</font>
<font color="red"> 141.             return s</font>
<font color="red"> 142.         raise ValueError(&quot;Expected str or unicode, received %s.&quot; % type(s))</font>
<font color="black"> 143. </font>
<font color="green"> 144. try:</font>
<font color="green"> 145.     from collections import OrderedDict</font>
<font color="red"> 146. except ImportError:</font>
<font color="black"> 147.     # Python2.6 we use the 3rd party back port.</font>
<font color="red"> 148.     from ordereddict import OrderedDict</font>
<font color="black"> 149. </font>
<font color="black"> 150. </font>
<font color="green"> 151. if sys.version_info[:2] == (2, 6):</font>
<font color="red"> 152.     import simplejson as json</font>
<font color="black"> 153.     # In py26, invalid xml parsed by element tree</font>
<font color="black"> 154.     # will raise a plain old SyntaxError instead of</font>
<font color="black"> 155.     # a real exception, so we need to abstract this change.</font>
<font color="red"> 156.     XMLParseError = SyntaxError</font>
<font color="black"> 157. </font>
<font color="black"> 158.     # Handle https://github.com/shazow/urllib3/issues/497 for py2.6.  In</font>
<font color="black"> 159.     # python2.6, there is a known issue where sometimes we cannot read the SAN</font>
<font color="black"> 160.     # from an SSL cert (http://bugs.python.org/issue13034).  However, newer</font>
<font color="black"> 161.     # versions of urllib3 will warn you when there is no SAN.  While we could</font>
<font color="black"> 162.     # just turn off this warning in urllib3 altogether, we _do_ want warnings</font>
<font color="black"> 163.     # when they're legitimate warnings.  This method tries to scope the warning</font>
<font color="black"> 164.     # filter to be as specific as possible.</font>
<font color="red"> 165.     def filter_ssl_san_warnings():</font>
<font color="red"> 166.         warnings.filterwarnings(</font>
<font color="red"> 167.             'ignore',</font>
<font color="red"> 168.             message=&quot;Certificate has no.*subjectAltName.*&quot;,</font>
<font color="red"> 169.             category=exceptions.SecurityWarning,</font>
<font color="red"> 170.             module=r&quot;.*urllib3\.connection&quot;)</font>
<font color="black"> 171. else:</font>
<font color="green"> 172.     import xml.etree.cElementTree</font>
<font color="green"> 173.     XMLParseError = xml.etree.cElementTree.ParseError</font>
<font color="green"> 174.     import json</font>
<font color="black"> 175. </font>
<font color="green"> 176.     def filter_ssl_san_warnings():</font>
<font color="black"> 177.         # Noop for non-py26 versions.  We will parse the SAN</font>
<font color="black"> 178.         # appropriately.</font>
<font color="green"> 179.         pass</font>
<font color="black"> 180. </font>
<font color="black"> 181. </font>
<font color="green"> 182. def filter_ssl_warnings():</font>
<font color="black"> 183.     # Ignore warnings related to SNI as it is not being used in validations.</font>
<font color="green"> 184.     warnings.filterwarnings(</font>
<font color="green"> 185.         'ignore',</font>
<font color="green"> 186.         message=&quot;A true SSLContext object is not available.*&quot;,</font>
<font color="green"> 187.         category=exceptions.InsecurePlatformWarning,</font>
<font color="green"> 188.         module=r&quot;.*urllib3\.util\.ssl_&quot;)</font>
<font color="green"> 189.     filter_ssl_san_warnings()</font>
<font color="black"> 190. </font>
<font color="black"> 191. </font>
<font color="green"> 192. @classmethod</font>
<font color="black"> 193. def from_dict(cls, d):</font>
<font color="red"> 194.     new_instance = cls()</font>
<font color="red"> 195.     for key, value in d.items():</font>
<font color="red"> 196.         new_instance[key] = value</font>
<font color="red"> 197.     return new_instance</font>
<font color="black"> 198. </font>
<font color="black"> 199. </font>
<font color="green"> 200. @classmethod</font>
<font color="black"> 201. def from_pairs(cls, pairs):</font>
<font color="red"> 202.     new_instance = cls()</font>
<font color="red"> 203.     for key, value in pairs:</font>
<font color="red"> 204.         new_instance[key] = value</font>
<font color="red"> 205.     return new_instance</font>
<font color="black"> 206. </font>
<font color="green"> 207. HTTPHeaders.from_dict = from_dict</font>
<font color="green"> 208. HTTPHeaders.from_pairs = from_pairs</font>
<font color="black"> 209. </font>
<font color="black"> 210. </font>
<font color="green"> 211. def copy_kwargs(kwargs):</font>
<font color="black"> 212.     &quot;&quot;&quot;</font>
<font color="black"> 213.     There is a bug in Python versions &lt; 2.6.5 that prevents you</font>
<font color="black"> 214.     from passing unicode keyword args (#4978).  This function</font>
<font color="black"> 215.     takes a dictionary of kwargs and returns a copy.  If you are</font>
<font color="black"> 216.     using Python &lt; 2.6.5, it also encodes the keys to avoid this bug.</font>
<font color="black"> 217.     Oh, and version_info wasn't a namedtuple back then, either!</font>
<font color="black"> 218.     &quot;&quot;&quot;</font>
<font color="red"> 219.     vi = sys.version_info</font>
<font color="red"> 220.     if vi[0] == 2 and vi[1] &lt;= 6 and vi[3] &lt; 5:</font>
<font color="red"> 221.         copy_kwargs = {}</font>
<font color="red"> 222.         for key in kwargs:</font>
<font color="red"> 223.             copy_kwargs[key.encode('utf-8')] = kwargs[key]</font>
<font color="black"> 224.     else:</font>
<font color="red"> 225.         copy_kwargs = copy.copy(kwargs)</font>
<font color="red"> 226.     return copy_kwargs</font>
<font color="black"> 227. </font>
<font color="black"> 228. </font>
<font color="green"> 229. def total_seconds(delta):</font>
<font color="black"> 230.     &quot;&quot;&quot;</font>
<font color="black"> 231.     Returns the total seconds in a ``datetime.timedelta``.</font>
<font color="black"> 232. </font>
<font color="black"> 233.     Python 2.6 does not have ``timedelta.total_seconds()``, so we have</font>
<font color="black"> 234.     to calculate this ourselves. On 2.7 or better, we'll take advantage of the</font>
<font color="black"> 235.     built-in method.</font>
<font color="black"> 236. </font>
<font color="black"> 237.     The math was pulled from the ``datetime`` docs</font>
<font color="black"> 238.     (http://docs.python.org/2.7/library/datetime.html#datetime.timedelta.total_seconds).</font>
<font color="black"> 239. </font>
<font color="black"> 240.     :param delta: The timedelta object</font>
<font color="black"> 241.     :type delta: ``datetime.timedelta``</font>
<font color="black"> 242.     &quot;&quot;&quot;</font>
<font color="red"> 243.     if sys.version_info[:2] != (2, 6):</font>
<font color="red"> 244.         return delta.total_seconds()</font>
<font color="black"> 245. </font>
<font color="red"> 246.     day_in_seconds = delta.days * 24 * 3600.0</font>
<font color="red"> 247.     micro_in_seconds = delta.microseconds / 10.0**6</font>
<font color="red"> 248.     return day_in_seconds + delta.seconds + micro_in_seconds</font>
<font color="black"> 249. </font>
<font color="black"> 250. </font>
<font color="black"> 251. # Checks to see if md5 is available on this system. A given system might not</font>
<font color="black"> 252. # have access to it for various reasons, such as FIPS mode being enabled.</font>
<font color="green"> 253. try:</font>
<font color="green"> 254.     hashlib.md5()</font>
<font color="green"> 255.     MD5_AVAILABLE = True</font>
<font color="red"> 256. except ValueError:</font>
<font color="red"> 257.     MD5_AVAILABLE = False</font>
<font color="black"> 258. </font>
<font color="black"> 259. </font>
<font color="green"> 260. def get_md5(*args, **kwargs):</font>
<font color="black"> 261.     &quot;&quot;&quot;</font>
<font color="black"> 262.     Attempts to get an md5 hashing object.</font>
<font color="black"> 263. </font>
<font color="black"> 264.     :param raise_error_if_unavailable: raise an error if md5 is unavailable on</font>
<font color="black"> 265.         this system. If False, None will be returned if it is unavailable.</font>
<font color="black"> 266.     :type raise_error_if_unavailable: bool</font>
<font color="black"> 267.     :param args: Args to pass to the MD5 constructor</font>
<font color="black"> 268.     :param kwargs: Key word arguments to pass to the MD5 constructor</font>
<font color="black"> 269.     :return: An MD5 hashing object if available. If it is unavailable, None</font>
<font color="black"> 270.         is returned if raise_error_if_unavailable is set to False.</font>
<font color="black"> 271.     &quot;&quot;&quot;</font>
<font color="green"> 272.     if MD5_AVAILABLE:</font>
<font color="green"> 273.         return hashlib.md5(*args, **kwargs)</font>
<font color="black"> 274.     else:</font>
<font color="red"> 275.         raise MD5UnavailableError()</font>
<font color="black"> 276. </font>
<font color="black"> 277. </font>
<font color="green"> 278. def compat_shell_split(s, platform=None):</font>
<font color="red"> 279.     if platform is None:</font>
<font color="red"> 280.         platform = sys.platform</font>
<font color="black"> 281. </font>
<font color="red"> 282.     if platform == &quot;win32&quot;:</font>
<font color="red"> 283.         return _windows_shell_split(s)</font>
<font color="black"> 284.     else:</font>
<font color="red"> 285.         return shlex.split(s)</font>
<font color="black"> 286. </font>
<font color="black"> 287. </font>
<font color="green"> 288. def _windows_shell_split(s):</font>
<font color="black"> 289.     &quot;&quot;&quot;Splits up a windows command as the built-in command parser would.</font>
<font color="black"> 290. </font>
<font color="black"> 291.     Windows has potentially bizarre rules depending on where you look. When</font>
<font color="black"> 292.     spawning a process via the Windows C runtime (which is what python does</font>
<font color="black"> 293.     when you call popen) the rules are as follows:</font>
<font color="black"> 294. </font>
<font color="black"> 295.     https://docs.microsoft.com/en-us/cpp/cpp/parsing-cpp-command-line-arguments</font>
<font color="black"> 296. </font>
<font color="black"> 297.     To summarize:</font>
<font color="black"> 298. </font>
<font color="black"> 299.     * Only space and tab are valid delimiters</font>
<font color="black"> 300.     * Double quotes are the only valid quotes</font>
<font color="black"> 301.     * Backslash is interpreted literally unless it is part of a chain that</font>
<font color="black"> 302.       leads up to a double quote. Then the backslashes escape the backslashes,</font>
<font color="black"> 303.       and if there is an odd number the final backslash escapes the quote.</font>
<font color="black"> 304. </font>
<font color="black"> 305.     :param s: The command string to split up into parts.</font>
<font color="black"> 306.     :return: A list of command components.</font>
<font color="black"> 307.     &quot;&quot;&quot;</font>
<font color="red"> 308.     if not s:</font>
<font color="red"> 309.         return []</font>
<font color="black"> 310. </font>
<font color="red"> 311.     components = []</font>
<font color="red"> 312.     buff = []</font>
<font color="red"> 313.     is_quoted = False</font>
<font color="red"> 314.     num_backslashes = 0</font>
<font color="red"> 315.     for character in s:</font>
<font color="red"> 316.         if character == '\\':</font>
<font color="black"> 317.             # We can't simply append backslashes because we don't know if</font>
<font color="black"> 318.             # they are being used as escape characters or not. Instead we</font>
<font color="black"> 319.             # keep track of how many we've encountered and handle them when</font>
<font color="black"> 320.             # we encounter a different character.</font>
<font color="red"> 321.             num_backslashes += 1</font>
<font color="red"> 322.         elif character == '&quot;':</font>
<font color="red"> 323.             if num_backslashes &gt; 0:</font>
<font color="black"> 324.                 # The backslashes are in a chain leading up to a double</font>
<font color="black"> 325.                 # quote, so they are escaping each other.</font>
<font color="red"> 326.                 buff.append('\\' * int(floor(num_backslashes / 2)))</font>
<font color="red"> 327.                 remainder = num_backslashes % 2</font>
<font color="red"> 328.                 num_backslashes = 0</font>
<font color="red"> 329.                 if remainder == 1:</font>
<font color="black"> 330.                     # The number of backslashes is uneven, so they are also</font>
<font color="black"> 331.                     # escaping the double quote, so it needs to be added to</font>
<font color="black"> 332.                     # the current component buffer.</font>
<font color="red"> 333.                     buff.append('&quot;')</font>
<font color="red"> 334.                     continue</font>
<font color="black"> 335. </font>
<font color="black"> 336.             # We've encountered a double quote that is not escaped,</font>
<font color="black"> 337.             # so we toggle is_quoted.</font>
<font color="red"> 338.             is_quoted = not is_quoted</font>
<font color="black"> 339. </font>
<font color="black"> 340.             # If there are quotes, then we may want an empty string. To be</font>
<font color="black"> 341.             # safe, we add an empty string to the buffer so that we make</font>
<font color="black"> 342.             # sure it sticks around if there's nothing else between quotes.</font>
<font color="black"> 343.             # If there is other stuff between quotes, the empty string will</font>
<font color="black"> 344.             # disappear during the joining process.</font>
<font color="red"> 345.             buff.append('')</font>
<font color="red"> 346.         elif character in [' ', '\t'] and not is_quoted:</font>
<font color="black"> 347.             # Since the backslashes aren't leading up to a quote, we put in</font>
<font color="black"> 348.             # the exact number of backslashes.</font>
<font color="red"> 349.             if num_backslashes &gt; 0:</font>
<font color="red"> 350.                 buff.append('\\' * num_backslashes)</font>
<font color="red"> 351.                 num_backslashes = 0</font>
<font color="black"> 352. </font>
<font color="black"> 353.             # Excess whitespace is ignored, so only add the components list</font>
<font color="black"> 354.             # if there is anything in the buffer.</font>
<font color="red"> 355.             if buff:</font>
<font color="red"> 356.                 components.append(''.join(buff))</font>
<font color="red"> 357.                 buff = []</font>
<font color="black"> 358.         else:</font>
<font color="black"> 359.             # Since the backslashes aren't leading up to a quote, we put in</font>
<font color="black"> 360.             # the exact number of backslashes.</font>
<font color="red"> 361.             if num_backslashes &gt; 0:</font>
<font color="red"> 362.                 buff.append('\\' * num_backslashes)</font>
<font color="red"> 363.                 num_backslashes = 0</font>
<font color="red"> 364.             buff.append(character)</font>
<font color="black"> 365. </font>
<font color="black"> 366.     # Quotes must be terminated.</font>
<font color="red"> 367.     if is_quoted:</font>
<font color="red"> 368.         raise ValueError('No closing quotation in string: %s' % s)</font>
<font color="black"> 369. </font>
<font color="black"> 370.     # There may be some leftover backslashes, so we need to add them in.</font>
<font color="black"> 371.     # There's no quote so we add the exact number.</font>
<font color="red"> 372.     if num_backslashes &gt; 0:</font>
<font color="red"> 373.         buff.append('\\' * num_backslashes)</font>
<font color="black"> 374. </font>
<font color="black"> 375.     # Add the final component in if there is anything in the buffer.</font>
<font color="red"> 376.     if buff:</font>
<font color="red"> 377.         components.append(''.join(buff))</font>
<font color="black"> 378. </font>
<font color="red"> 379.     return components</font>
</pre>

