source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/packages/urllib3/request.py</b><br>


file stats: <b>43 lines, 17 executed: 39.5% covered</b>
<pre>
<font color="green">   1. try:</font>
<font color="green">   2.     from urllib.parse import urlencode</font>
<font color="green">   3. except ImportError:</font>
<font color="green">   4.     from urllib import urlencode</font>
<font color="black">   5. </font>
<font color="green">   6. from .filepost import encode_multipart_formdata</font>
<font color="black">   7. </font>
<font color="black">   8. </font>
<font color="green">   9. __all__ = ['RequestMethods']</font>
<font color="black">  10. </font>
<font color="black">  11. </font>
<font color="green">  12. class RequestMethods(object):</font>
<font color="black">  13.     &quot;&quot;&quot;</font>
<font color="black">  14.     Convenience mixin for classes who implement a :meth:`urlopen` method, such</font>
<font color="black">  15.     as :class:`~urllib3.connectionpool.HTTPConnectionPool` and</font>
<font color="black">  16.     :class:`~urllib3.poolmanager.PoolManager`.</font>
<font color="black">  17. </font>
<font color="black">  18.     Provides behavior for making common types of HTTP request methods and</font>
<font color="black">  19.     decides which type of request field encoding to use.</font>
<font color="black">  20. </font>
<font color="black">  21.     Specifically,</font>
<font color="black">  22. </font>
<font color="black">  23.     :meth:`.request_encode_url` is for sending requests whose fields are</font>
<font color="black">  24.     encoded in the URL (such as GET, HEAD, DELETE).</font>
<font color="black">  25. </font>
<font color="black">  26.     :meth:`.request_encode_body` is for sending requests whose fields are</font>
<font color="black">  27.     encoded in the *body* of the request using multipart or www-form-urlencoded</font>
<font color="black">  28.     (such as for POST, PUT, PATCH).</font>
<font color="black">  29. </font>
<font color="black">  30.     :meth:`.request` is for making any kind of request, it will look up the</font>
<font color="black">  31.     appropriate encoding format and use one of the above two methods to make</font>
<font color="black">  32.     the request.</font>
<font color="black">  33. </font>
<font color="black">  34.     Initializer parameters:</font>
<font color="black">  35. </font>
<font color="black">  36.     :param headers:</font>
<font color="black">  37.         Headers to include with all requests, unless other headers are given</font>
<font color="black">  38.         explicitly.</font>
<font color="green">  39.     &quot;&quot;&quot;</font>
<font color="black">  40. </font>
<font color="green">  41.     _encode_url_methods = set(['DELETE', 'GET', 'HEAD', 'OPTIONS'])</font>
<font color="black">  42. </font>
<font color="green">  43.     def __init__(self, headers=None):</font>
<font color="green">  44.         self.headers = headers or {}</font>
<font color="black">  45. </font>
<font color="green">  46.     def urlopen(self, method, url, body=None, headers=None,</font>
<font color="green">  47.                 encode_multipart=True, multipart_boundary=None,</font>
<font color="black">  48.                 **kw):  # Abstract</font>
<font color="red">  49.         raise NotImplemented(&quot;Classes extending RequestMethods must implement &quot;</font>
<font color="black">  50.                              &quot;their own ``urlopen`` method.&quot;)</font>
<font color="black">  51. </font>
<font color="green">  52.     def request(self, method, url, fields=None, headers=None, **urlopen_kw):</font>
<font color="black">  53.         &quot;&quot;&quot;</font>
<font color="black">  54.         Make a request using :meth:`urlopen` with the appropriate encoding of</font>
<font color="black">  55.         ``fields`` based on the ``method`` used.</font>
<font color="black">  56. </font>
<font color="black">  57.         This is a convenience method that requires the least amount of manual</font>
<font color="black">  58.         effort. It can be used in most situations, while still having the</font>
<font color="black">  59.         option to drop down to more specific methods when necessary, such as</font>
<font color="black">  60.         :meth:`request_encode_url`, :meth:`request_encode_body`,</font>
<font color="black">  61.         or even the lowest level :meth:`urlopen`.</font>
<font color="black">  62.         &quot;&quot;&quot;</font>
<font color="red">  63.         method = method.upper()</font>
<font color="black">  64. </font>
<font color="red">  65.         if method in self._encode_url_methods:</font>
<font color="red">  66.             return self.request_encode_url(method, url, fields=fields,</font>
<font color="red">  67.                                            headers=headers,</font>
<font color="red">  68.                                            **urlopen_kw)</font>
<font color="black">  69.         else:</font>
<font color="red">  70.             return self.request_encode_body(method, url, fields=fields,</font>
<font color="red">  71.                                             headers=headers,</font>
<font color="red">  72.                                             **urlopen_kw)</font>
<font color="black">  73. </font>
<font color="green">  74.     def request_encode_url(self, method, url, fields=None, **urlopen_kw):</font>
<font color="black">  75.         &quot;&quot;&quot;</font>
<font color="black">  76.         Make a request using :meth:`urlopen` with the ``fields`` encoded in</font>
<font color="black">  77.         the url. This is useful for request methods like GET, HEAD, DELETE, etc.</font>
<font color="black">  78.         &quot;&quot;&quot;</font>
<font color="red">  79.         if fields:</font>
<font color="red">  80.             url += '?' + urlencode(fields)</font>
<font color="red">  81.         return self.urlopen(method, url, **urlopen_kw)</font>
<font color="black">  82. </font>
<font color="green">  83.     def request_encode_body(self, method, url, fields=None, headers=None,</font>
<font color="green">  84.                             encode_multipart=True, multipart_boundary=None,</font>
<font color="black">  85.                             **urlopen_kw):</font>
<font color="black">  86.         &quot;&quot;&quot;</font>
<font color="black">  87.         Make a request using :meth:`urlopen` with the ``fields`` encoded in</font>
<font color="black">  88.         the body. This is useful for request methods like POST, PUT, PATCH, etc.</font>
<font color="black">  89. </font>
<font color="black">  90.         When ``encode_multipart=True`` (default), then</font>
<font color="black">  91.         :meth:`urllib3.filepost.encode_multipart_formdata` is used to encode</font>
<font color="black">  92.         the payload with the appropriate content type. Otherwise</font>
<font color="black">  93.         :meth:`urllib.urlencode` is used with the</font>
<font color="black">  94.         'application/x-www-form-urlencoded' content type.</font>
<font color="black">  95. </font>
<font color="black">  96.         Multipart encoding must be used when posting files, and it's reasonably</font>
<font color="black">  97.         safe to use it in other times too. However, it may break request</font>
<font color="black">  98.         signing, such as with OAuth.</font>
<font color="black">  99. </font>
<font color="black"> 100.         Supports an optional ``fields`` parameter of key/value strings AND</font>
<font color="black"> 101.         key/filetuple. A filetuple is a (filename, data, MIME type) tuple where</font>
<font color="black"> 102.         the MIME type is optional. For example::</font>
<font color="black"> 103. </font>
<font color="black"> 104.             fields = {</font>
<font color="black"> 105.                 'foo': 'bar',</font>
<font color="black"> 106.                 'fakefile': ('foofile.txt', 'contents of foofile'),</font>
<font color="black"> 107.                 'realfile': ('barfile.txt', open('realfile').read()),</font>
<font color="black"> 108.                 'typedfile': ('bazfile.bin', open('bazfile').read(),</font>
<font color="black"> 109.                               'image/jpeg'),</font>
<font color="black"> 110.                 'nonamefile': 'contents of nonamefile field',</font>
<font color="black"> 111.             }</font>
<font color="black"> 112. </font>
<font color="black"> 113.         When uploading a file, providing a filename (the first parameter of the</font>
<font color="black"> 114.         tuple) is optional but recommended to best mimick behavior of browsers.</font>
<font color="black"> 115. </font>
<font color="black"> 116.         Note that if ``headers`` are supplied, the 'Content-Type' header will</font>
<font color="black"> 117.         be overwritten because it depends on the dynamic random boundary string</font>
<font color="black"> 118.         which is used to compose the body of the request. The random boundary</font>
<font color="black"> 119.         string can be explicitly set with the ``multipart_boundary`` parameter.</font>
<font color="black"> 120.         &quot;&quot;&quot;</font>
<font color="red"> 121.         if headers is None:</font>
<font color="red"> 122.             headers = self.headers</font>
<font color="black"> 123. </font>
<font color="red"> 124.         extra_kw = {'headers': {}}</font>
<font color="black"> 125. </font>
<font color="red"> 126.         if fields:</font>
<font color="red"> 127.             if 'body' in urlopen_kw:</font>
<font color="red"> 128.                 raise TypeError('request got values for both \'fields\' and \'body\', can only specify one.')</font>
<font color="black"> 129. </font>
<font color="red"> 130.             if encode_multipart:</font>
<font color="red"> 131.                 body, content_type = encode_multipart_formdata(fields, boundary=multipart_boundary)</font>
<font color="black"> 132.             else:</font>
<font color="red"> 133.                 body, content_type = urlencode(fields), 'application/x-www-form-urlencoded'</font>
<font color="black"> 134. </font>
<font color="red"> 135.             extra_kw['body'] = body</font>
<font color="red"> 136.             extra_kw['headers'] = {'Content-Type': content_type}</font>
<font color="black"> 137. </font>
<font color="red"> 138.         extra_kw['headers'].update(headers)</font>
<font color="red"> 139.         extra_kw.update(urlopen_kw)</font>
<font color="black"> 140. </font>
<font color="red"> 141.         return self.urlopen(method, url, **extra_kw)</font>
</pre>

