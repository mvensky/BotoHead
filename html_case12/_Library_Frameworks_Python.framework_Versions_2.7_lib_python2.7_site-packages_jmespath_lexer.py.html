source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/jmespath/lexer.py</b><br>


file stats: <b>156 lines, 29 executed: 18.6% covered</b>
<pre>
<font color="green">   1. import string</font>
<font color="green">   2. import warnings</font>
<font color="green">   3. from json import loads</font>
<font color="black">   4. </font>
<font color="green">   5. from jmespath.exceptions import LexerError, EmptyExpressionError</font>
<font color="black">   6. </font>
<font color="black">   7. </font>
<font color="green">   8. class Lexer(object):</font>
<font color="green">   9.     START_IDENTIFIER = set(string.ascii_letters + '_')</font>
<font color="green">  10.     VALID_IDENTIFIER = set(string.ascii_letters + string.digits + '_')</font>
<font color="green">  11.     START_NUMBER = set(string.digits + '-')</font>
<font color="green">  12.     VALID_NUMBER = set(string.digits)</font>
<font color="green">  13.     WHITESPACE = set(&quot; \t\n\r&quot;)</font>
<font color="green">  14.     SIMPLE_TOKENS = {</font>
<font color="green">  15.         '.': 'dot',</font>
<font color="green">  16.         '*': 'star',</font>
<font color="green">  17.         ']': 'rbracket',</font>
<font color="green">  18.         ',': 'comma',</font>
<font color="green">  19.         ':': 'colon',</font>
<font color="green">  20.         '@': 'current',</font>
<font color="green">  21.         '(': 'lparen',</font>
<font color="green">  22.         ')': 'rparen',</font>
<font color="green">  23.         '{': 'lbrace',</font>
<font color="green">  24.         '}': 'rbrace',</font>
<font color="black">  25.     }</font>
<font color="black">  26. </font>
<font color="green">  27.     def tokenize(self, expression):</font>
<font color="red">  28.         self._initialize_for_expression(expression)</font>
<font color="red">  29.         while self._current is not None:</font>
<font color="red">  30.             if self._current in self.SIMPLE_TOKENS:</font>
<font color="red">  31.                 yield {'type': self.SIMPLE_TOKENS[self._current],</font>
<font color="red">  32.                        'value': self._current,</font>
<font color="red">  33.                        'start': self._position, 'end': self._position + 1}</font>
<font color="red">  34.                 self._next()</font>
<font color="red">  35.             elif self._current in self.START_IDENTIFIER:</font>
<font color="red">  36.                 start = self._position</font>
<font color="red">  37.                 buff = self._current</font>
<font color="red">  38.                 while self._next() in self.VALID_IDENTIFIER:</font>
<font color="red">  39.                     buff += self._current</font>
<font color="red">  40.                 yield {'type': 'unquoted_identifier', 'value': buff,</font>
<font color="red">  41.                        'start': start, 'end': start + len(buff)}</font>
<font color="red">  42.             elif self._current in self.WHITESPACE:</font>
<font color="red">  43.                 self._next()</font>
<font color="red">  44.             elif self._current == '[':</font>
<font color="red">  45.                 start = self._position</font>
<font color="red">  46.                 next_char = self._next()</font>
<font color="red">  47.                 if next_char == ']':</font>
<font color="red">  48.                     self._next()</font>
<font color="red">  49.                     yield {'type': 'flatten', 'value': '[]',</font>
<font color="red">  50.                            'start': start, 'end': start + 2}</font>
<font color="red">  51.                 elif next_char == '?':</font>
<font color="red">  52.                     self._next()</font>
<font color="red">  53.                     yield {'type': 'filter', 'value': '[?',</font>
<font color="red">  54.                            'start': start, 'end': start + 2}</font>
<font color="black">  55.                 else:</font>
<font color="red">  56.                     yield {'type': 'lbracket', 'value': '[',</font>
<font color="red">  57.                            'start': start, 'end': start + 1}</font>
<font color="red">  58.             elif self._current == &quot;'&quot;:</font>
<font color="red">  59.                 yield self._consume_raw_string_literal()</font>
<font color="red">  60.             elif self._current == '|':</font>
<font color="red">  61.                 yield self._match_or_else('|', 'or', 'pipe')</font>
<font color="red">  62.             elif self._current == '&amp;':</font>
<font color="red">  63.                 yield self._match_or_else('&amp;', 'and', 'expref')</font>
<font color="red">  64.             elif self._current == '`':</font>
<font color="red">  65.                 yield self._consume_literal()</font>
<font color="red">  66.             elif self._current in self.START_NUMBER:</font>
<font color="red">  67.                 start = self._position</font>
<font color="red">  68.                 buff = self._current</font>
<font color="red">  69.                 while self._next() in self.VALID_NUMBER:</font>
<font color="red">  70.                     buff += self._current</font>
<font color="red">  71.                 yield {'type': 'number', 'value': int(buff),</font>
<font color="red">  72.                        'start': start, 'end': start + len(buff)}</font>
<font color="red">  73.             elif self._current == '&quot;':</font>
<font color="red">  74.                 yield self._consume_quoted_identifier()</font>
<font color="red">  75.             elif self._current == '&lt;':</font>
<font color="red">  76.                 yield self._match_or_else('=', 'lte', 'lt')</font>
<font color="red">  77.             elif self._current == '&gt;':</font>
<font color="red">  78.                 yield self._match_or_else('=', 'gte', 'gt')</font>
<font color="red">  79.             elif self._current == '!':</font>
<font color="red">  80.                 yield self._match_or_else('=', 'ne', 'not')</font>
<font color="red">  81.             elif self._current == '=':</font>
<font color="red">  82.                 yield self._match_or_else('=', 'eq', 'unknown')</font>
<font color="black">  83.             else:</font>
<font color="red">  84.                 raise LexerError(lexer_position=self._position,</font>
<font color="red">  85.                                  lexer_value=self._current,</font>
<font color="red">  86.                                  message=&quot;Unknown token %s&quot; % self._current)</font>
<font color="red">  87.         yield {'type': 'eof', 'value': '',</font>
<font color="red">  88.                'start': self._length, 'end': self._length}</font>
<font color="black">  89. </font>
<font color="green">  90.     def _initialize_for_expression(self, expression):</font>
<font color="red">  91.         if not expression:</font>
<font color="red">  92.             raise EmptyExpressionError()</font>
<font color="red">  93.         self._position = 0</font>
<font color="red">  94.         self._expression = expression</font>
<font color="red">  95.         self._chars = list(self._expression)</font>
<font color="red">  96.         self._current = self._chars[self._position]</font>
<font color="red">  97.         self._length = len(self._expression)</font>
<font color="black">  98. </font>
<font color="green">  99.     def _next(self):</font>
<font color="red"> 100.         if self._position == self._length - 1:</font>
<font color="red"> 101.             self._current = None</font>
<font color="black"> 102.         else:</font>
<font color="red"> 103.             self._position += 1</font>
<font color="red"> 104.             self._current = self._chars[self._position]</font>
<font color="red"> 105.         return self._current</font>
<font color="black"> 106. </font>
<font color="green"> 107.     def _consume_until(self, delimiter):</font>
<font color="black"> 108.         # Consume until the delimiter is reached,</font>
<font color="black"> 109.         # allowing for the delimiter to be escaped with &quot;\&quot;.</font>
<font color="red"> 110.         start = self._position</font>
<font color="red"> 111.         buff = ''</font>
<font color="red"> 112.         self._next()</font>
<font color="red"> 113.         while self._current != delimiter:</font>
<font color="red"> 114.             if self._current == '\\':</font>
<font color="red"> 115.                 buff += '\\'</font>
<font color="red"> 116.                 self._next()</font>
<font color="red"> 117.             if self._current is None:</font>
<font color="red"> 118.                 raise LexerError(lexer_position=start,</font>
<font color="red"> 119.                                  lexer_value=self._expression,</font>
<font color="red"> 120.                                  message=&quot;Unclosed %s delimiter&quot; % delimiter)</font>
<font color="red"> 121.             buff += self._current</font>
<font color="red"> 122.             self._next()</font>
<font color="black"> 123.         # Skip the closing delimiter.</font>
<font color="red"> 124.         self._next()</font>
<font color="red"> 125.         return buff</font>
<font color="black"> 126. </font>
<font color="green"> 127.     def _consume_literal(self):</font>
<font color="red"> 128.         start = self._position</font>
<font color="red"> 129.         lexeme = self._consume_until('`').replace('\\`', '`')</font>
<font color="red"> 130.         try:</font>
<font color="black"> 131.             # Assume it is valid JSON and attempt to parse.</font>
<font color="red"> 132.             parsed_json = loads(lexeme)</font>
<font color="red"> 133.         except ValueError:</font>
<font color="red"> 134.             try:</font>
<font color="black"> 135.                 # Invalid JSON values should be converted to quoted</font>
<font color="black"> 136.                 # JSON strings during the JEP-12 deprecation period.</font>
<font color="red"> 137.                 parsed_json = loads('&quot;%s&quot;' % lexeme.lstrip())</font>
<font color="red"> 138.                 warnings.warn(&quot;deprecated string literal syntax&quot;,</font>
<font color="red"> 139.                               PendingDeprecationWarning)</font>
<font color="red"> 140.             except ValueError:</font>
<font color="red"> 141.                 raise LexerError(lexer_position=start,</font>
<font color="red"> 142.                                  lexer_value=self._expression,</font>
<font color="red"> 143.                                  message=&quot;Bad token %s&quot; % lexeme)</font>
<font color="red"> 144.         token_len = self._position - start</font>
<font color="red"> 145.         return {'type': 'literal', 'value': parsed_json,</font>
<font color="red"> 146.                 'start': start, 'end': token_len}</font>
<font color="black"> 147. </font>
<font color="green"> 148.     def _consume_quoted_identifier(self):</font>
<font color="red"> 149.         start = self._position</font>
<font color="red"> 150.         lexeme = '&quot;' + self._consume_until('&quot;') + '&quot;'</font>
<font color="red"> 151.         try:</font>
<font color="red"> 152.             token_len = self._position - start</font>
<font color="red"> 153.             return {'type': 'quoted_identifier', 'value': loads(lexeme),</font>
<font color="red"> 154.                     'start': start, 'end': token_len}</font>
<font color="red"> 155.         except ValueError as e:</font>
<font color="red"> 156.             error_message = str(e).split(':')[0]</font>
<font color="red"> 157.             raise LexerError(lexer_position=start,</font>
<font color="red"> 158.                              lexer_value=lexeme,</font>
<font color="red"> 159.                              message=error_message)</font>
<font color="black"> 160. </font>
<font color="green"> 161.     def _consume_raw_string_literal(self):</font>
<font color="red"> 162.         start = self._position</font>
<font color="red"> 163.         lexeme = self._consume_until(&quot;'&quot;).replace(&quot;\\'&quot;, &quot;'&quot;)</font>
<font color="red"> 164.         token_len = self._position - start</font>
<font color="red"> 165.         return {'type': 'literal', 'value': lexeme,</font>
<font color="red"> 166.                 'start': start, 'end': token_len}</font>
<font color="black"> 167. </font>
<font color="green"> 168.     def _match_or_else(self, expected, match_type, else_type):</font>
<font color="red"> 169.         start = self._position</font>
<font color="red"> 170.         current = self._current</font>
<font color="red"> 171.         next_char = self._next()</font>
<font color="red"> 172.         if next_char == expected:</font>
<font color="red"> 173.             self._next()</font>
<font color="red"> 174.             return {'type': match_type, 'value': current + next_char,</font>
<font color="red"> 175.                     'start': start, 'end': start + 1}</font>
<font color="red"> 176.         return {'type': else_type, 'value': current,</font>
<font color="red"> 177.                 'start': start, 'end': start}</font>
</pre>

