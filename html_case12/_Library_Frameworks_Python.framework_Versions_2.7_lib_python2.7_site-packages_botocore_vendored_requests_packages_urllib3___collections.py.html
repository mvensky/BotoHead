source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/packages/urllib3/_collections.py</b><br>


file stats: <b>181 lines, 94 executed: 51.9% covered</b>
<pre>
<font color="green">   1. from collections import Mapping, MutableMapping</font>
<font color="green">   2. try:</font>
<font color="green">   3.     from threading import RLock</font>
<font color="red">   4. except ImportError:  # Platform-specific: No threads available</font>
<font color="red">   5.     class RLock:</font>
<font color="red">   6.         def __enter__(self):</font>
<font color="red">   7.             pass</font>
<font color="black">   8. </font>
<font color="red">   9.         def __exit__(self, exc_type, exc_value, traceback):</font>
<font color="red">  10.             pass</font>
<font color="black">  11. </font>
<font color="black">  12. </font>
<font color="green">  13. try:  # Python 2.7+</font>
<font color="green">  14.     from collections import OrderedDict</font>
<font color="red">  15. except ImportError:</font>
<font color="red">  16.     from .packages.ordered_dict import OrderedDict</font>
<font color="green">  17. from .packages.six import iterkeys, itervalues, PY3</font>
<font color="black">  18. </font>
<font color="black">  19. </font>
<font color="green">  20. __all__ = ['RecentlyUsedContainer', 'HTTPHeaderDict']</font>
<font color="black">  21. </font>
<font color="black">  22. </font>
<font color="green">  23. _Null = object()</font>
<font color="black">  24. </font>
<font color="black">  25. </font>
<font color="green">  26. class RecentlyUsedContainer(MutableMapping):</font>
<font color="black">  27.     &quot;&quot;&quot;</font>
<font color="black">  28.     Provides a thread-safe dict-like container which maintains up to</font>
<font color="black">  29.     ``maxsize`` keys while throwing away the least-recently-used keys beyond</font>
<font color="black">  30.     ``maxsize``.</font>
<font color="black">  31. </font>
<font color="black">  32.     :param maxsize:</font>
<font color="black">  33.         Maximum number of recent elements to retain.</font>
<font color="black">  34. </font>
<font color="black">  35.     :param dispose_func:</font>
<font color="black">  36.         Every time an item is evicted from the container,</font>
<font color="black">  37.         ``dispose_func(value)`` is called.  Callback which will get called</font>
<font color="green">  38.     &quot;&quot;&quot;</font>
<font color="black">  39. </font>
<font color="green">  40.     ContainerCls = OrderedDict</font>
<font color="black">  41. </font>
<font color="green">  42.     def __init__(self, maxsize=10, dispose_func=None):</font>
<font color="green">  43.         self._maxsize = maxsize</font>
<font color="green">  44.         self.dispose_func = dispose_func</font>
<font color="black">  45. </font>
<font color="green">  46.         self._container = self.ContainerCls()</font>
<font color="green">  47.         self.lock = RLock()</font>
<font color="black">  48. </font>
<font color="green">  49.     def __getitem__(self, key):</font>
<font color="black">  50.         # Re-insert the item, moving it to the end of the eviction line.</font>
<font color="green">  51.         with self.lock:</font>
<font color="green">  52.             item = self._container.pop(key)</font>
<font color="green">  53.             self._container[key] = item</font>
<font color="green">  54.             return item</font>
<font color="black">  55. </font>
<font color="green">  56.     def __setitem__(self, key, value):</font>
<font color="green">  57.         evicted_value = _Null</font>
<font color="green">  58.         with self.lock:</font>
<font color="black">  59.             # Possibly evict the existing value of 'key'</font>
<font color="green">  60.             evicted_value = self._container.get(key, _Null)</font>
<font color="green">  61.             self._container[key] = value</font>
<font color="black">  62. </font>
<font color="black">  63.             # If we didn't evict an existing value, we might have to evict the</font>
<font color="black">  64.             # least recently used item from the beginning of the container.</font>
<font color="green">  65.             if len(self._container) &gt; self._maxsize:</font>
<font color="red">  66.                 _key, evicted_value = self._container.popitem(last=False)</font>
<font color="black">  67. </font>
<font color="green">  68.         if self.dispose_func and evicted_value is not _Null:</font>
<font color="red">  69.             self.dispose_func(evicted_value)</font>
<font color="black">  70. </font>
<font color="green">  71.     def __delitem__(self, key):</font>
<font color="red">  72.         with self.lock:</font>
<font color="red">  73.             value = self._container.pop(key)</font>
<font color="black">  74. </font>
<font color="red">  75.         if self.dispose_func:</font>
<font color="red">  76.             self.dispose_func(value)</font>
<font color="black">  77. </font>
<font color="green">  78.     def __len__(self):</font>
<font color="red">  79.         with self.lock:</font>
<font color="red">  80.             return len(self._container)</font>
<font color="black">  81. </font>
<font color="green">  82.     def __iter__(self):</font>
<font color="red">  83.         raise NotImplementedError('Iteration over this class is unlikely to be threadsafe.')</font>
<font color="black">  84. </font>
<font color="green">  85.     def clear(self):</font>
<font color="red">  86.         with self.lock:</font>
<font color="black">  87.             # Copy pointers to all values, then wipe the mapping</font>
<font color="red">  88.             values = list(itervalues(self._container))</font>
<font color="red">  89.             self._container.clear()</font>
<font color="black">  90. </font>
<font color="red">  91.         if self.dispose_func:</font>
<font color="red">  92.             for value in values:</font>
<font color="red">  93.                 self.dispose_func(value)</font>
<font color="black">  94. </font>
<font color="green">  95.     def keys(self):</font>
<font color="red">  96.         with self.lock:</font>
<font color="red">  97.             return list(iterkeys(self._container))</font>
<font color="black">  98. </font>
<font color="black">  99. </font>
<font color="green"> 100. _dict_setitem = dict.__setitem__</font>
<font color="green"> 101. _dict_getitem = dict.__getitem__</font>
<font color="green"> 102. _dict_delitem = dict.__delitem__</font>
<font color="green"> 103. _dict_contains = dict.__contains__</font>
<font color="green"> 104. _dict_setdefault = dict.setdefault</font>
<font color="black"> 105. </font>
<font color="black"> 106. </font>
<font color="green"> 107. class HTTPHeaderDict(dict):</font>
<font color="black"> 108.     &quot;&quot;&quot;</font>
<font color="black"> 109.     :param headers:</font>
<font color="black"> 110.         An iterable of field-value pairs. Must not contain multiple field names</font>
<font color="black"> 111.         when compared case-insensitively.</font>
<font color="black"> 112. </font>
<font color="black"> 113.     :param kwargs:</font>
<font color="black"> 114.         Additional field-value pairs to pass in to ``dict.update``.</font>
<font color="black"> 115. </font>
<font color="black"> 116.     A ``dict`` like container for storing HTTP Headers.</font>
<font color="black"> 117. </font>
<font color="black"> 118.     Field names are stored and compared case-insensitively in compliance with</font>
<font color="black"> 119.     RFC 7230. Iteration provides the first case-sensitive key seen for each</font>
<font color="black"> 120.     case-insensitive pair.</font>
<font color="black"> 121. </font>
<font color="black"> 122.     Using ``__setitem__`` syntax overwrites fields that compare equal</font>
<font color="black"> 123.     case-insensitively in order to maintain ``dict``'s api. For fields that</font>
<font color="black"> 124.     compare equal, instead create a new ``HTTPHeaderDict`` and use ``.add``</font>
<font color="black"> 125.     in a loop.</font>
<font color="black"> 126. </font>
<font color="black"> 127.     If multiple fields that are equal case-insensitively are passed to the</font>
<font color="black"> 128.     constructor or ``.update``, the behavior is undefined and some will be</font>
<font color="black"> 129.     lost.</font>
<font color="black"> 130. </font>
<font color="black"> 131.     &gt;&gt;&gt; headers = HTTPHeaderDict()</font>
<font color="black"> 132.     &gt;&gt;&gt; headers.add('Set-Cookie', 'foo=bar')</font>
<font color="black"> 133.     &gt;&gt;&gt; headers.add('set-cookie', 'baz=quxx')</font>
<font color="black"> 134.     &gt;&gt;&gt; headers['content-length'] = '7'</font>
<font color="black"> 135.     &gt;&gt;&gt; headers['SET-cookie']</font>
<font color="black"> 136.     'foo=bar, baz=quxx'</font>
<font color="black"> 137.     &gt;&gt;&gt; headers['Content-Length']</font>
<font color="black"> 138.     '7'</font>
<font color="green"> 139.     &quot;&quot;&quot;</font>
<font color="black"> 140. </font>
<font color="green"> 141.     def __init__(self, headers=None, **kwargs):</font>
<font color="green"> 142.         dict.__init__(self)</font>
<font color="green"> 143.         if headers is not None:</font>
<font color="green"> 144.             if isinstance(headers, HTTPHeaderDict):</font>
<font color="red"> 145.                 self._copy_from(headers)</font>
<font color="black"> 146.             else:</font>
<font color="green"> 147.                 self.extend(headers)</font>
<font color="green"> 148.         if kwargs:</font>
<font color="red"> 149.             self.extend(kwargs)</font>
<font color="black"> 150. </font>
<font color="green"> 151.     def __setitem__(self, key, val):</font>
<font color="red"> 152.         return _dict_setitem(self, key.lower(), (key, val))</font>
<font color="black"> 153. </font>
<font color="green"> 154.     def __getitem__(self, key):</font>
<font color="green"> 155.         val = _dict_getitem(self, key.lower())</font>
<font color="green"> 156.         return ', '.join(val[1:])</font>
<font color="black"> 157. </font>
<font color="green"> 158.     def __delitem__(self, key):</font>
<font color="red"> 159.         return _dict_delitem(self, key.lower())</font>
<font color="black"> 160. </font>
<font color="green"> 161.     def __contains__(self, key):</font>
<font color="red"> 162.         return _dict_contains(self, key.lower())</font>
<font color="black"> 163. </font>
<font color="green"> 164.     def __eq__(self, other):</font>
<font color="red"> 165.         if not isinstance(other, Mapping) and not hasattr(other, 'keys'):</font>
<font color="red"> 166.             return False</font>
<font color="red"> 167.         if not isinstance(other, type(self)):</font>
<font color="red"> 168.             other = type(self)(other)</font>
<font color="red"> 169.         return dict((k1, self[k1]) for k1 in self) == dict((k2, other[k2]) for k2 in other)</font>
<font color="black"> 170. </font>
<font color="green"> 171.     def __ne__(self, other):</font>
<font color="red"> 172.         return not self.__eq__(other)</font>
<font color="black"> 173. </font>
<font color="green"> 174.     values = MutableMapping.values</font>
<font color="green"> 175.     get = MutableMapping.get</font>
<font color="green"> 176.     update = MutableMapping.update</font>
<font color="black"> 177. </font>
<font color="green"> 178.     if not PY3: # Python 2</font>
<font color="green"> 179.         iterkeys = MutableMapping.iterkeys</font>
<font color="green"> 180.         itervalues = MutableMapping.itervalues</font>
<font color="black"> 181. </font>
<font color="green"> 182.     __marker = object()</font>
<font color="black"> 183. </font>
<font color="green"> 184.     def pop(self, key, default=__marker):</font>
<font color="black"> 185.         '''D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.</font>
<font color="black"> 186.           If key is not found, d is returned if given, otherwise KeyError is raised.</font>
<font color="black"> 187.         '''</font>
<font color="black"> 188.         # Using the MutableMapping function directly fails due to the private marker.</font>
<font color="black"> 189.         # Using ordinary dict.pop would expose the internal structures.</font>
<font color="black"> 190.         # So let's reinvent the wheel.</font>
<font color="red"> 191.         try:</font>
<font color="red"> 192.             value = self[key]</font>
<font color="red"> 193.         except KeyError:</font>
<font color="red"> 194.             if default is self.__marker:</font>
<font color="red"> 195.                 raise</font>
<font color="red"> 196.             return default</font>
<font color="black"> 197.         else:</font>
<font color="red"> 198.             del self[key]</font>
<font color="red"> 199.             return value</font>
<font color="black"> 200. </font>
<font color="green"> 201.     def discard(self, key):</font>
<font color="red"> 202.         try:</font>
<font color="red"> 203.             del self[key]</font>
<font color="red"> 204.         except KeyError:</font>
<font color="red"> 205.             pass</font>
<font color="black"> 206. </font>
<font color="green"> 207.     def add(self, key, val):</font>
<font color="black"> 208.         &quot;&quot;&quot;Adds a (name, value) pair, doesn't overwrite the value if it already</font>
<font color="black"> 209.         exists.</font>
<font color="black"> 210. </font>
<font color="black"> 211.         &gt;&gt;&gt; headers = HTTPHeaderDict(foo='bar')</font>
<font color="black"> 212.         &gt;&gt;&gt; headers.add('Foo', 'baz')</font>
<font color="black"> 213.         &gt;&gt;&gt; headers['foo']</font>
<font color="black"> 214.         'bar, baz'</font>
<font color="black"> 215.         &quot;&quot;&quot;</font>
<font color="green"> 216.         key_lower = key.lower()</font>
<font color="green"> 217.         new_vals = key, val</font>
<font color="black"> 218.         # Keep the common case aka no item present as fast as possible</font>
<font color="green"> 219.         vals = _dict_setdefault(self, key_lower, new_vals)</font>
<font color="green"> 220.         if new_vals is not vals:</font>
<font color="black"> 221.             # new_vals was not inserted, as there was a previous one</font>
<font color="red"> 222.             if isinstance(vals, list):</font>
<font color="black"> 223.                 # If already several items got inserted, we have a list</font>
<font color="red"> 224.                 vals.append(val)</font>
<font color="black"> 225.             else:</font>
<font color="black"> 226.                 # vals should be a tuple then, i.e. only one item so far</font>
<font color="black"> 227.                 # Need to convert the tuple to list for further extension</font>
<font color="red"> 228.                 _dict_setitem(self, key_lower, [vals[0], vals[1], val])</font>
<font color="black"> 229. </font>
<font color="green"> 230.     def extend(self, *args, **kwargs):</font>
<font color="black"> 231.         &quot;&quot;&quot;Generic import function for any type of header-like object.</font>
<font color="black"> 232.         Adapted version of MutableMapping.update in order to insert items</font>
<font color="black"> 233.         with self.add instead of self.__setitem__</font>
<font color="black"> 234.         &quot;&quot;&quot;</font>
<font color="green"> 235.         if len(args) &gt; 1:</font>
<font color="red"> 236.             raise TypeError(&quot;extend() takes at most 1 positional &quot;</font>
<font color="red"> 237.                             &quot;arguments ({} given)&quot;.format(len(args)))</font>
<font color="green"> 238.         other = args[0] if len(args) &gt;= 1 else ()</font>
<font color="black"> 239. </font>
<font color="green"> 240.         if isinstance(other, HTTPHeaderDict):</font>
<font color="red"> 241.             for key, val in other.iteritems():</font>
<font color="red"> 242.                 self.add(key, val)</font>
<font color="green"> 243.         elif isinstance(other, Mapping):</font>
<font color="red"> 244.             for key in other:</font>
<font color="red"> 245.                 self.add(key, other[key])</font>
<font color="green"> 246.         elif hasattr(other, &quot;keys&quot;):</font>
<font color="red"> 247.             for key in other.keys():</font>
<font color="red"> 248.                 self.add(key, other[key])</font>
<font color="black"> 249.         else:</font>
<font color="green"> 250.             for key, value in other:</font>
<font color="green"> 251.                 self.add(key, value)</font>
<font color="black"> 252. </font>
<font color="green"> 253.         for key, value in kwargs.items():</font>
<font color="red"> 254.             self.add(key, value)</font>
<font color="black"> 255. </font>
<font color="green"> 256.     def getlist(self, key):</font>
<font color="black"> 257.         &quot;&quot;&quot;Returns a list of all the values for the named field. Returns an</font>
<font color="black"> 258.         empty list if the key doesn't exist.&quot;&quot;&quot;</font>
<font color="red"> 259.         try:</font>
<font color="red"> 260.             vals = _dict_getitem(self, key.lower())</font>
<font color="red"> 261.         except KeyError:</font>
<font color="red"> 262.             return []</font>
<font color="black"> 263.         else:</font>
<font color="red"> 264.             if isinstance(vals, tuple):</font>
<font color="red"> 265.                 return [vals[1]]</font>
<font color="black"> 266.             else:</font>
<font color="red"> 267.                 return vals[1:]</font>
<font color="black"> 268. </font>
<font color="black"> 269.     # Backwards compatibility for httplib</font>
<font color="green"> 270.     getheaders = getlist</font>
<font color="green"> 271.     getallmatchingheaders = getlist</font>
<font color="green"> 272.     iget = getlist</font>
<font color="black"> 273. </font>
<font color="green"> 274.     def __repr__(self):</font>
<font color="red"> 275.         return &quot;%s(%s)&quot; % (type(self).__name__, dict(self.itermerged()))</font>
<font color="black"> 276. </font>
<font color="green"> 277.     def _copy_from(self, other):</font>
<font color="red"> 278.         for key in other:</font>
<font color="red"> 279.             val = _dict_getitem(other, key)</font>
<font color="red"> 280.             if isinstance(val, list):</font>
<font color="black"> 281.                 # Don't need to convert tuples</font>
<font color="red"> 282.                 val = list(val)</font>
<font color="red"> 283.             _dict_setitem(self, key, val)</font>
<font color="black"> 284. </font>
<font color="green"> 285.     def copy(self):</font>
<font color="red"> 286.         clone = type(self)()</font>
<font color="red"> 287.         clone._copy_from(self)</font>
<font color="red"> 288.         return clone</font>
<font color="black"> 289. </font>
<font color="green"> 290.     def iteritems(self):</font>
<font color="black"> 291.         &quot;&quot;&quot;Iterate over all header lines, including duplicate ones.&quot;&quot;&quot;</font>
<font color="red"> 292.         for key in self:</font>
<font color="red"> 293.             vals = _dict_getitem(self, key)</font>
<font color="red"> 294.             for val in vals[1:]:</font>
<font color="red"> 295.                 yield vals[0], val</font>
<font color="black"> 296. </font>
<font color="green"> 297.     def itermerged(self):</font>
<font color="black"> 298.         &quot;&quot;&quot;Iterate over all headers, merging duplicate ones together.&quot;&quot;&quot;</font>
<font color="red"> 299.         for key in self:</font>
<font color="red"> 300.             val = _dict_getitem(self, key)</font>
<font color="red"> 301.             yield val[0], ', '.join(val[1:])</font>
<font color="black"> 302. </font>
<font color="green"> 303.     def items(self):</font>
<font color="red"> 304.         return list(self.iteritems())</font>
<font color="black"> 305. </font>
<font color="green"> 306.     @classmethod</font>
<font color="black"> 307.     def from_httplib(cls, message): # Python 2</font>
<font color="black"> 308.         &quot;&quot;&quot;Read headers from a Python 2 httplib message object.&quot;&quot;&quot;</font>
<font color="black"> 309.         # python2.7 does not expose a proper API for exporting multiheaders</font>
<font color="black"> 310.         # efficiently. This function re-reads raw lines from the message</font>
<font color="black"> 311.         # object and extracts the multiheaders properly.</font>
<font color="green"> 312.         headers = []</font>
<font color="black"> 313. </font>
<font color="green"> 314.         for line in message.headers:</font>
<font color="green"> 315.             if line.startswith((' ', '\t')):</font>
<font color="red"> 316.                 key, value = headers[-1]</font>
<font color="red"> 317.                 headers[-1] = (key, value + '\r\n' + line.rstrip())</font>
<font color="red"> 318.                 continue</font>
<font color="black"> 319. </font>
<font color="green"> 320.             key, value = line.split(':', 1)</font>
<font color="green"> 321.             headers.append((key, value.strip()))</font>
<font color="black"> 322. </font>
<font color="green"> 323.         return cls(headers)</font>
</pre>

