source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/eventstream.py</b><br>


file stats: <b>242 lines, 102 executed: 42.1% covered</b>
<pre>
<font color="black">   1. # Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="green">  13. &quot;&quot;&quot;Binary Event Stream Decoding &quot;&quot;&quot;</font>
<font color="black">  14. </font>
<font color="green">  15. from binascii import crc32</font>
<font color="green">  16. from struct import unpack</font>
<font color="green">  17. from botocore.exceptions import EventStreamError</font>
<font color="black">  18. </font>
<font color="black">  19. # byte length of the prelude (total_length + header_length + prelude_crc)</font>
<font color="green">  20. _PRELUDE_LENGTH = 12</font>
<font color="green">  21. _MAX_HEADERS_LENGTH = 128 * 1024  # 128 Kb</font>
<font color="green">  22. _MAX_PAYLOAD_LENGTH = 16 * 1024 ** 2  # 16 Mb</font>
<font color="black">  23. </font>
<font color="black">  24. </font>
<font color="green">  25. class ParserError(Exception):</font>
<font color="green">  26.     &quot;&quot;&quot;Base binary flow encoding parsing exception.  &quot;&quot;&quot;</font>
<font color="green">  27.     pass</font>
<font color="black">  28. </font>
<font color="black">  29. </font>
<font color="green">  30. class DuplicateHeader(ParserError):</font>
<font color="green">  31.     &quot;&quot;&quot;Duplicate header found in the event. &quot;&quot;&quot;</font>
<font color="green">  32.     def __init__(self, header):</font>
<font color="red">  33.         message = 'Duplicate header present: &quot;%s&quot;' % header</font>
<font color="red">  34.         super(DuplicateHeader, self).__init__(message)</font>
<font color="black">  35. </font>
<font color="black">  36. </font>
<font color="green">  37. class InvalidHeadersLength(ParserError):</font>
<font color="green">  38.     &quot;&quot;&quot;Headers length is longer than the maximum. &quot;&quot;&quot;</font>
<font color="green">  39.     def __init__(self, length):</font>
<font color="red">  40.         message = 'Header length of %s exceeded the maximum of %s' % (</font>
<font color="red">  41.             length, _MAX_HEADERS_LENGTH</font>
<font color="black">  42.         )</font>
<font color="red">  43.         super(InvalidHeadersLength, self).__init__(message)</font>
<font color="black">  44. </font>
<font color="black">  45. </font>
<font color="green">  46. class InvalidPayloadLength(ParserError):</font>
<font color="green">  47.     &quot;&quot;&quot;Payload length is longer than the maximum. &quot;&quot;&quot;</font>
<font color="green">  48.     def __init__(self, length):</font>
<font color="red">  49.         message = 'Payload length of %s exceeded the maximum of %s' % (</font>
<font color="red">  50.             length, _MAX_PAYLOAD_LENGTH</font>
<font color="black">  51.         )</font>
<font color="red">  52.         super(InvalidPayloadLength, self).__init__(message)</font>
<font color="black">  53. </font>
<font color="black">  54. </font>
<font color="green">  55. class ChecksumMismatch(ParserError):</font>
<font color="green">  56.     &quot;&quot;&quot;Calculated checksum did not match the expected checksum. &quot;&quot;&quot;</font>
<font color="green">  57.     def __init__(self, expected, calculated):</font>
<font color="red">  58.         message = 'Checksum mismatch: expected 0x%08x, calculated 0x%08x' % (</font>
<font color="red">  59.             expected, calculated</font>
<font color="black">  60.         )</font>
<font color="red">  61.         super(ChecksumMismatch, self).__init__(message)</font>
<font color="black">  62. </font>
<font color="black">  63. </font>
<font color="green">  64. class DecodeUtils(object):</font>
<font color="black">  65.     &quot;&quot;&quot;Unpacking utility functions used in the decoder.</font>
<font color="black">  66. </font>
<font color="black">  67.     All methods on this class take raw bytes and return  a tuple containing</font>
<font color="black">  68.     the value parsed from the bytes and the number of bytes consumed to parse</font>
<font color="black">  69.     that value.</font>
<font color="green">  70.     &quot;&quot;&quot;</font>
<font color="black">  71. </font>
<font color="green">  72.     UINT8_BYTE_FORMAT = '!B'</font>
<font color="green">  73.     UINT16_BYTE_FORMAT = '!H'</font>
<font color="green">  74.     UINT32_BYTE_FORMAT = '!I'</font>
<font color="green">  75.     INT16_BYTE_FORMAT = '!h'</font>
<font color="green">  76.     INT32_BYTE_FORMAT = '!i'</font>
<font color="green">  77.     INT64_BYTE_FORMAT = '!q'</font>
<font color="green">  78.     PRELUDE_BYTE_FORMAT = '!III'</font>
<font color="black">  79. </font>
<font color="black">  80.     # uint byte size to unpack format</font>
<font color="green">  81.     UINT_BYTE_FORMAT = {</font>
<font color="green">  82.         1: UINT8_BYTE_FORMAT,</font>
<font color="green">  83.         2: UINT16_BYTE_FORMAT,</font>
<font color="green">  84.         4: UINT32_BYTE_FORMAT,</font>
<font color="black">  85.     }</font>
<font color="black">  86. </font>
<font color="green">  87.     @staticmethod</font>
<font color="black">  88.     def unpack_true(data):</font>
<font color="black">  89.         &quot;&quot;&quot;This method consumes none of the provided bytes and returns True.</font>
<font color="black">  90. </font>
<font color="black">  91.         :type data: bytes</font>
<font color="black">  92.         :param data: The bytes to parse from. This is ignored in this method.</font>
<font color="black">  93. </font>
<font color="black">  94.         :rtype: tuple</font>
<font color="black">  95.         :rtype: (bool, int)</font>
<font color="black">  96.         :returns: The tuple (True, 0)</font>
<font color="black">  97.         &quot;&quot;&quot;</font>
<font color="red">  98.         return True, 0</font>
<font color="black">  99. </font>
<font color="green"> 100.     @staticmethod</font>
<font color="black"> 101.     def unpack_false(data):</font>
<font color="black"> 102.         &quot;&quot;&quot;This method consumes none of the provided bytes and returns False.</font>
<font color="black"> 103. </font>
<font color="black"> 104.         :type data: bytes</font>
<font color="black"> 105.         :param data: The bytes to parse from. This is ignored in this method.</font>
<font color="black"> 106. </font>
<font color="black"> 107.         :rtype: tuple</font>
<font color="black"> 108.         :rtype: (bool, int)</font>
<font color="black"> 109.         :returns: The tuple (False, 0)</font>
<font color="black"> 110.         &quot;&quot;&quot;</font>
<font color="red"> 111.         return False, 0</font>
<font color="black"> 112. </font>
<font color="green"> 113.     @staticmethod</font>
<font color="black"> 114.     def unpack_uint8(data):</font>
<font color="black"> 115.         &quot;&quot;&quot;Parse an unsigned 8-bit integer from the bytes.</font>
<font color="black"> 116. </font>
<font color="black"> 117.         :type data: bytes</font>
<font color="black"> 118.         :param data: The bytes to parse from.</font>
<font color="black"> 119. </font>
<font color="black"> 120.         :rtype: (int, int)</font>
<font color="black"> 121.         :returns: A tuple containing the (parsed integer value, bytes consumed)</font>
<font color="black"> 122.         &quot;&quot;&quot;</font>
<font color="red"> 123.         value = unpack(DecodeUtils.UINT8_BYTE_FORMAT, data[:1])[0]</font>
<font color="red"> 124.         return value, 1</font>
<font color="black"> 125. </font>
<font color="green"> 126.     @staticmethod</font>
<font color="black"> 127.     def unpack_uint32(data):</font>
<font color="black"> 128.         &quot;&quot;&quot;Parse an unsigned 32-bit integer from the bytes.</font>
<font color="black"> 129. </font>
<font color="black"> 130.         :type data: bytes</font>
<font color="black"> 131.         :param data: The bytes to parse from.</font>
<font color="black"> 132. </font>
<font color="black"> 133.         :rtype: (int, int)</font>
<font color="black"> 134.         :returns: A tuple containing the (parsed integer value, bytes consumed)</font>
<font color="black"> 135.         &quot;&quot;&quot;</font>
<font color="red"> 136.         value = unpack(DecodeUtils.UINT32_BYTE_FORMAT, data[:4])[0]</font>
<font color="red"> 137.         return value, 4</font>
<font color="black"> 138. </font>
<font color="green"> 139.     @staticmethod</font>
<font color="black"> 140.     def unpack_int16(data):</font>
<font color="black"> 141.         &quot;&quot;&quot;Parse a signed 16-bit integer from the bytes.</font>
<font color="black"> 142. </font>
<font color="black"> 143.         :type data: bytes</font>
<font color="black"> 144.         :param data: The bytes to parse from.</font>
<font color="black"> 145. </font>
<font color="black"> 146.         :rtype: tuple</font>
<font color="black"> 147.         :rtype: (int, int)</font>
<font color="black"> 148.         :returns: A tuple containing the (parsed integer value, bytes consumed)</font>
<font color="black"> 149.         &quot;&quot;&quot;</font>
<font color="red"> 150.         value = unpack(DecodeUtils.INT16_BYTE_FORMAT, data[:2])[0]</font>
<font color="red"> 151.         return value, 2</font>
<font color="black"> 152. </font>
<font color="green"> 153.     @staticmethod</font>
<font color="black"> 154.     def unpack_int32(data):</font>
<font color="black"> 155.         &quot;&quot;&quot;Parse a signed 32-bit integer from the bytes.</font>
<font color="black"> 156. </font>
<font color="black"> 157.         :type data: bytes</font>
<font color="black"> 158.         :param data: The bytes to parse from.</font>
<font color="black"> 159. </font>
<font color="black"> 160.         :rtype: tuple</font>
<font color="black"> 161.         :rtype: (int, int)</font>
<font color="black"> 162.         :returns: A tuple containing the (parsed integer value, bytes consumed)</font>
<font color="black"> 163.         &quot;&quot;&quot;</font>
<font color="red"> 164.         value = unpack(DecodeUtils.INT32_BYTE_FORMAT, data[:4])[0]</font>
<font color="red"> 165.         return value, 4</font>
<font color="black"> 166. </font>
<font color="green"> 167.     @staticmethod</font>
<font color="black"> 168.     def unpack_int64(data):</font>
<font color="black"> 169.         &quot;&quot;&quot;Parse a signed 64-bit integer from the bytes.</font>
<font color="black"> 170. </font>
<font color="black"> 171.         :type data: bytes</font>
<font color="black"> 172.         :param data: The bytes to parse from.</font>
<font color="black"> 173. </font>
<font color="black"> 174.         :rtype: tuple</font>
<font color="black"> 175.         :rtype: (int, int)</font>
<font color="black"> 176.         :returns: A tuple containing the (parsed integer value, bytes consumed)</font>
<font color="black"> 177.         &quot;&quot;&quot;</font>
<font color="red"> 178.         value = unpack(DecodeUtils.INT64_BYTE_FORMAT, data[:8])[0]</font>
<font color="red"> 179.         return value, 8</font>
<font color="black"> 180. </font>
<font color="green"> 181.     @staticmethod</font>
<font color="green"> 182.     def unpack_byte_array(data, length_byte_size=2):</font>
<font color="black"> 183.         &quot;&quot;&quot;Parse a variable length byte array from the bytes.</font>
<font color="black"> 184. </font>
<font color="black"> 185.         The bytes are expected to be in the following format:</font>
<font color="black"> 186.             [ length ][0 ... length bytes]</font>
<font color="black"> 187.         where length is an unsigned integer represented in the smallest number</font>
<font color="black"> 188.         of bytes to hold the maximum length of the array.</font>
<font color="black"> 189. </font>
<font color="black"> 190.         :type data: bytes</font>
<font color="black"> 191.         :param data: The bytes to parse from.</font>
<font color="black"> 192. </font>
<font color="black"> 193.         :type length_byte_size: int</font>
<font color="black"> 194.         :param length_byte_size: The byte size of the preceeding integer that</font>
<font color="black"> 195.         represents the length of the array. Supported values are 1, 2, and 4.</font>
<font color="black"> 196. </font>
<font color="black"> 197.         :rtype: (bytes, int)</font>
<font color="black"> 198.         :returns: A tuple containing the (parsed byte array, bytes consumed).</font>
<font color="black"> 199.         &quot;&quot;&quot;</font>
<font color="red"> 200.         uint_byte_format = DecodeUtils.UINT_BYTE_FORMAT[length_byte_size]</font>
<font color="red"> 201.         length = unpack(uint_byte_format, data[:length_byte_size])[0]</font>
<font color="red"> 202.         bytes_end = length + length_byte_size</font>
<font color="red"> 203.         array_bytes = data[length_byte_size:bytes_end]</font>
<font color="red"> 204.         return array_bytes, bytes_end</font>
<font color="black"> 205. </font>
<font color="green"> 206.     @staticmethod</font>
<font color="green"> 207.     def unpack_utf8_string(data, length_byte_size=2):</font>
<font color="black"> 208.         &quot;&quot;&quot;Parse a variable length utf-8 string from the bytes.</font>
<font color="black"> 209. </font>
<font color="black"> 210.         The bytes are expected to be in the following format:</font>
<font color="black"> 211.             [ length ][0 ... length bytes]</font>
<font color="black"> 212.         where length is an unsigned integer represented in the smallest number</font>
<font color="black"> 213.         of bytes to hold the maximum length of the array and the following</font>
<font color="black"> 214.         bytes are a valid utf-8 string.</font>
<font color="black"> 215. </font>
<font color="black"> 216.         :type data: bytes</font>
<font color="black"> 217.         :param bytes: The bytes to parse from.</font>
<font color="black"> 218. </font>
<font color="black"> 219.         :type length_byte_size: int</font>
<font color="black"> 220.         :param length_byte_size: The byte size of the preceeding integer that</font>
<font color="black"> 221.         represents the length of the array. Supported values are 1, 2, and 4.</font>
<font color="black"> 222. </font>
<font color="black"> 223.         :rtype: (str, int)</font>
<font color="black"> 224.         :returns: A tuple containing the (utf-8 string, bytes consumed).</font>
<font color="black"> 225.         &quot;&quot;&quot;</font>
<font color="red"> 226.         array_bytes, consumed = DecodeUtils.unpack_byte_array(</font>
<font color="red"> 227.             data, length_byte_size)</font>
<font color="red"> 228.         return array_bytes.decode('utf-8'), consumed</font>
<font color="black"> 229. </font>
<font color="green"> 230.     @staticmethod</font>
<font color="black"> 231.     def unpack_uuid(data):</font>
<font color="black"> 232.         &quot;&quot;&quot;Parse a 16-byte uuid from the bytes.</font>
<font color="black"> 233. </font>
<font color="black"> 234.         :type data: bytes</font>
<font color="black"> 235.         :param data: The bytes to parse from.</font>
<font color="black"> 236. </font>
<font color="black"> 237.         :rtype: (bytes, int)</font>
<font color="black"> 238.         :returns: A tuple containing the (uuid bytes, bytes consumed).</font>
<font color="black"> 239.         &quot;&quot;&quot;</font>
<font color="red"> 240.         return data[:16], 16</font>
<font color="black"> 241. </font>
<font color="green"> 242.     @staticmethod</font>
<font color="black"> 243.     def unpack_prelude(data):</font>
<font color="black"> 244.         &quot;&quot;&quot;Parse the prelude for an event stream message from the bytes.</font>
<font color="black"> 245. </font>
<font color="black"> 246.         The prelude for an event stream message has the following format:</font>
<font color="black"> 247.             [total_length][header_length][prelude_crc]</font>
<font color="black"> 248.         where each field is an unsigned 32-bit integer.</font>
<font color="black"> 249. </font>
<font color="black"> 250.         :rtype: ((int, int, int), int)</font>
<font color="black"> 251.         :returns: A tuple of ((total_length, headers_length, prelude_crc),</font>
<font color="black"> 252.         consumed)</font>
<font color="black"> 253.         &quot;&quot;&quot;</font>
<font color="red"> 254.         return (unpack(DecodeUtils.PRELUDE_BYTE_FORMAT, data), _PRELUDE_LENGTH)</font>
<font color="black"> 255. </font>
<font color="black"> 256. </font>
<font color="green"> 257. def _validate_checksum(data, checksum, crc=0):</font>
<font color="black"> 258.     # To generate the same numeric value across all Python versions and</font>
<font color="black"> 259.     # platforms use crc32(data) &amp; 0xffffffff.</font>
<font color="red"> 260.     computed_checksum = crc32(data, crc) &amp; 0xFFFFFFFF</font>
<font color="red"> 261.     if checksum != computed_checksum:</font>
<font color="red"> 262.         raise ChecksumMismatch(checksum, computed_checksum)</font>
<font color="black"> 263. </font>
<font color="black"> 264. </font>
<font color="green"> 265. class MessagePrelude(object):</font>
<font color="green"> 266.     &quot;&quot;&quot;Represents the prelude of an event stream message. &quot;&quot;&quot;</font>
<font color="green"> 267.     def __init__(self, total_length, headers_length, crc):</font>
<font color="red"> 268.         self.total_length = total_length</font>
<font color="red"> 269.         self.headers_length = headers_length</font>
<font color="red"> 270.         self.crc = crc</font>
<font color="black"> 271. </font>
<font color="green"> 272.     @property</font>
<font color="black"> 273.     def payload_length(self):</font>
<font color="black"> 274.         &quot;&quot;&quot;Calculates the total payload length.</font>
<font color="black"> 275. </font>
<font color="black"> 276.         The extra minus 4 bytes is for the message CRC.</font>
<font color="black"> 277. </font>
<font color="black"> 278.         :rtype: int</font>
<font color="black"> 279.         :returns: The total payload length.</font>
<font color="black"> 280.         &quot;&quot;&quot;</font>
<font color="red"> 281.         return self.total_length - self.headers_length - _PRELUDE_LENGTH - 4</font>
<font color="black"> 282. </font>
<font color="green"> 283.     @property</font>
<font color="black"> 284.     def payload_end(self):</font>
<font color="black"> 285.         &quot;&quot;&quot;Calculates the byte offset for the end of the message payload.</font>
<font color="black"> 286. </font>
<font color="black"> 287.         The extra minus 4 bytes is for the message CRC.</font>
<font color="black"> 288. </font>
<font color="black"> 289.         :rtype: int</font>
<font color="black"> 290.         :returns: The byte offset from the beginning of the event stream</font>
<font color="black"> 291.         message to the end of the payload.</font>
<font color="black"> 292.         &quot;&quot;&quot;</font>
<font color="red"> 293.         return self.total_length - 4</font>
<font color="black"> 294. </font>
<font color="green"> 295.     @property</font>
<font color="black"> 296.     def headers_end(self):</font>
<font color="black"> 297.         &quot;&quot;&quot;Calculates the byte offset for the end of the message headers.</font>
<font color="black"> 298. </font>
<font color="black"> 299.         :rtype: int</font>
<font color="black"> 300.         :returns: The byte offset from the beginning of the event stream</font>
<font color="black"> 301.         message to the end of the headers.</font>
<font color="black"> 302.         &quot;&quot;&quot;</font>
<font color="red"> 303.         return _PRELUDE_LENGTH + self.headers_length</font>
<font color="black"> 304. </font>
<font color="black"> 305. </font>
<font color="green"> 306. class EventStreamMessage(object):</font>
<font color="green"> 307.     &quot;&quot;&quot;Represents an event stream message. &quot;&quot;&quot;</font>
<font color="green"> 308.     def __init__(self, prelude, headers, payload, crc):</font>
<font color="red"> 309.         self.prelude = prelude</font>
<font color="red"> 310.         self.headers = headers</font>
<font color="red"> 311.         self.payload = payload</font>
<font color="red"> 312.         self.crc = crc</font>
<font color="black"> 313. </font>
<font color="green"> 314.     def to_response_dict(self, status_code=200):</font>
<font color="red"> 315.         if self.headers.get(':message-type') == 'error':</font>
<font color="red"> 316.             status_code = 400</font>
<font color="red"> 317.         return {</font>
<font color="red"> 318.             'status_code': status_code,</font>
<font color="red"> 319.             'headers': self.headers,</font>
<font color="red"> 320.             'body': self.payload</font>
<font color="black"> 321.         }</font>
<font color="black"> 322. </font>
<font color="black"> 323. </font>
<font color="green"> 324. class EventStreamHeaderParser(object):</font>
<font color="black"> 325.     &quot;&quot;&quot; Parses the event headers from an event stream message.</font>
<font color="black"> 326. </font>
<font color="black"> 327.     Expects all of the header data upfront and creates a dictionary of headers</font>
<font color="black"> 328.     to return. This object can be reused multiple times to parse the headers</font>
<font color="black"> 329.     from multiple event stream messages.</font>
<font color="green"> 330.     &quot;&quot;&quot;</font>
<font color="black"> 331. </font>
<font color="black"> 332.     # Maps header type to appropriate unpacking function</font>
<font color="black"> 333.     # These unpacking functions return the value and the amount unpacked</font>
<font color="green"> 334.     _HEADER_TYPE_MAP = {</font>
<font color="black"> 335.         # boolean_true</font>
<font color="green"> 336.         0: DecodeUtils.unpack_true,</font>
<font color="black"> 337.         # boolean_false</font>
<font color="green"> 338.         1: DecodeUtils.unpack_false,</font>
<font color="black"> 339.         # byte</font>
<font color="green"> 340.         2: DecodeUtils.unpack_uint8,</font>
<font color="black"> 341.         # short</font>
<font color="green"> 342.         3: DecodeUtils.unpack_int16,</font>
<font color="black"> 343.         # integer</font>
<font color="green"> 344.         4: DecodeUtils.unpack_int32,</font>
<font color="black"> 345.         # long</font>
<font color="green"> 346.         5: DecodeUtils.unpack_int64,</font>
<font color="black"> 347.         # byte_array</font>
<font color="green"> 348.         6: DecodeUtils.unpack_byte_array,</font>
<font color="black"> 349.         # string</font>
<font color="green"> 350.         7: DecodeUtils.unpack_utf8_string,</font>
<font color="black"> 351.         # timestamp</font>
<font color="green"> 352.         8: DecodeUtils.unpack_int64,</font>
<font color="black"> 353.         # uuid</font>
<font color="green"> 354.         9: DecodeUtils.unpack_uuid,</font>
<font color="black"> 355.     }</font>
<font color="black"> 356. </font>
<font color="green"> 357.     def __init__(self):</font>
<font color="red"> 358.         self._data = None</font>
<font color="black"> 359. </font>
<font color="green"> 360.     def parse(self, data):</font>
<font color="black"> 361.         &quot;&quot;&quot;Parses the event stream headers from an event stream message.</font>
<font color="black"> 362. </font>
<font color="black"> 363.         :type data: bytes</font>
<font color="black"> 364.         :param data: The bytes that correspond to the headers section of an</font>
<font color="black"> 365.         event stream message.</font>
<font color="black"> 366. </font>
<font color="black"> 367.         :rtype: dict</font>
<font color="black"> 368.         :returns: A dicionary of header key, value pairs.</font>
<font color="black"> 369.         &quot;&quot;&quot;</font>
<font color="red"> 370.         self._data = data</font>
<font color="red"> 371.         return self._parse_headers()</font>
<font color="black"> 372. </font>
<font color="green"> 373.     def _parse_headers(self):</font>
<font color="red"> 374.         headers = {}</font>
<font color="red"> 375.         while self._data:</font>
<font color="red"> 376.             name, value = self._parse_header()</font>
<font color="red"> 377.             if name in headers:</font>
<font color="red"> 378.                 raise DuplicateHeader(name)</font>
<font color="red"> 379.             headers[name] = value</font>
<font color="red"> 380.         return headers</font>
<font color="black"> 381. </font>
<font color="green"> 382.     def _parse_header(self):</font>
<font color="red"> 383.         name = self._parse_name()</font>
<font color="red"> 384.         value = self._parse_value()</font>
<font color="red"> 385.         return name, value</font>
<font color="black"> 386. </font>
<font color="green"> 387.     def _parse_name(self):</font>
<font color="red"> 388.         name, consumed = DecodeUtils.unpack_utf8_string(self._data, 1)</font>
<font color="red"> 389.         self._advance_data(consumed)</font>
<font color="red"> 390.         return name</font>
<font color="black"> 391. </font>
<font color="green"> 392.     def _parse_type(self):</font>
<font color="red"> 393.         type, consumed = DecodeUtils.unpack_uint8(self._data)</font>
<font color="red"> 394.         self._advance_data(consumed)</font>
<font color="red"> 395.         return type</font>
<font color="black"> 396. </font>
<font color="green"> 397.     def _parse_value(self):</font>
<font color="red"> 398.         header_type = self._parse_type()</font>
<font color="red"> 399.         value_unpacker = self._HEADER_TYPE_MAP[header_type]</font>
<font color="red"> 400.         value, consumed = value_unpacker(self._data)</font>
<font color="red"> 401.         self._advance_data(consumed)</font>
<font color="red"> 402.         return value</font>
<font color="black"> 403. </font>
<font color="green"> 404.     def _advance_data(self, consumed):</font>
<font color="red"> 405.         self._data = self._data[consumed:]</font>
<font color="black"> 406. </font>
<font color="black"> 407. </font>
<font color="green"> 408. class EventStreamBuffer(object):</font>
<font color="black"> 409.     &quot;&quot;&quot;Streaming based event stream buffer</font>
<font color="black"> 410. </font>
<font color="black"> 411.     A buffer class that wraps bytes from an event stream providing parsed</font>
<font color="black"> 412.     messages as they become available via an iterable interface.</font>
<font color="green"> 413.     &quot;&quot;&quot;</font>
<font color="black"> 414. </font>
<font color="green"> 415.     def __init__(self):</font>
<font color="red"> 416.         self._data = b''</font>
<font color="red"> 417.         self._prelude = None</font>
<font color="red"> 418.         self._header_parser = EventStreamHeaderParser()</font>
<font color="black"> 419. </font>
<font color="green"> 420.     def add_data(self, data):</font>
<font color="black"> 421.         &quot;&quot;&quot;Add data to the buffer.</font>
<font color="black"> 422. </font>
<font color="black"> 423.         :type data: bytes</font>
<font color="black"> 424.         :param data: The bytes to add to the buffer to be used when parsing</font>
<font color="black"> 425.         &quot;&quot;&quot;</font>
<font color="red"> 426.         self._data += data</font>
<font color="black"> 427. </font>
<font color="green"> 428.     def _validate_prelude(self, prelude):</font>
<font color="red"> 429.         if prelude.headers_length &gt; _MAX_HEADERS_LENGTH:</font>
<font color="red"> 430.             raise InvalidHeadersLength(prelude.headers_length)</font>
<font color="black"> 431. </font>
<font color="red"> 432.         if prelude.payload_length &gt; _MAX_PAYLOAD_LENGTH:</font>
<font color="red"> 433.             raise InvalidPayloadLength(prelude.payload_length)</font>
<font color="black"> 434. </font>
<font color="green"> 435.     def _parse_prelude(self):</font>
<font color="red"> 436.         prelude_bytes = self._data[:_PRELUDE_LENGTH]</font>
<font color="red"> 437.         raw_prelude, _ = DecodeUtils.unpack_prelude(prelude_bytes)</font>
<font color="red"> 438.         prelude = MessagePrelude(*raw_prelude)</font>
<font color="red"> 439.         self._validate_prelude(prelude)</font>
<font color="black"> 440.         # The minus 4 removes the prelude crc from the bytes to be checked</font>
<font color="red"> 441.         _validate_checksum(prelude_bytes[:_PRELUDE_LENGTH-4], prelude.crc)</font>
<font color="red"> 442.         return prelude</font>
<font color="black"> 443. </font>
<font color="green"> 444.     def _parse_headers(self):</font>
<font color="red"> 445.         header_bytes = self._data[_PRELUDE_LENGTH:self._prelude.headers_end]</font>
<font color="red"> 446.         return self._header_parser.parse(header_bytes)</font>
<font color="black"> 447. </font>
<font color="green"> 448.     def _parse_payload(self):</font>
<font color="red"> 449.         prelude = self._prelude</font>
<font color="red"> 450.         payload_bytes = self._data[prelude.headers_end:prelude.payload_end]</font>
<font color="red"> 451.         return payload_bytes</font>
<font color="black"> 452. </font>
<font color="green"> 453.     def _parse_message_crc(self):</font>
<font color="red"> 454.         prelude = self._prelude</font>
<font color="red"> 455.         crc_bytes = self._data[prelude.payload_end:prelude.total_length]</font>
<font color="red"> 456.         message_crc, _ = DecodeUtils.unpack_uint32(crc_bytes)</font>
<font color="red"> 457.         return message_crc</font>
<font color="black"> 458. </font>
<font color="green"> 459.     def _parse_message_bytes(self):</font>
<font color="black"> 460.         # The minus 4 includes the prelude crc to the bytes to be checked</font>
<font color="red"> 461.         message_bytes = self._data[_PRELUDE_LENGTH-4:self._prelude.payload_end]</font>
<font color="red"> 462.         return message_bytes</font>
<font color="black"> 463. </font>
<font color="green"> 464.     def _validate_message_crc(self):</font>
<font color="red"> 465.         message_crc = self._parse_message_crc()</font>
<font color="red"> 466.         message_bytes = self._parse_message_bytes()</font>
<font color="red"> 467.         _validate_checksum(message_bytes, message_crc, crc=self._prelude.crc)</font>
<font color="red"> 468.         return message_crc</font>
<font color="black"> 469. </font>
<font color="green"> 470.     def _parse_message(self):</font>
<font color="red"> 471.         crc = self._validate_message_crc()</font>
<font color="red"> 472.         headers = self._parse_headers()</font>
<font color="red"> 473.         payload = self._parse_payload()</font>
<font color="red"> 474.         message = EventStreamMessage(self._prelude, headers, payload, crc)</font>
<font color="red"> 475.         self._prepare_for_next_message()</font>
<font color="red"> 476.         return message</font>
<font color="black"> 477. </font>
<font color="green"> 478.     def _prepare_for_next_message(self):</font>
<font color="black"> 479.         # Advance the data and reset the current prelude</font>
<font color="red"> 480.         self._data = self._data[self._prelude.total_length:]</font>
<font color="red"> 481.         self._prelude = None</font>
<font color="black"> 482. </font>
<font color="green"> 483.     def next(self):</font>
<font color="black"> 484.         &quot;&quot;&quot;Provides the next available message parsed from the stream</font>
<font color="black"> 485. </font>
<font color="black"> 486.         :rtype: EventStreamMessage</font>
<font color="black"> 487.         :returns: The next event stream message</font>
<font color="black"> 488.         &quot;&quot;&quot;</font>
<font color="red"> 489.         if len(self._data) &lt; _PRELUDE_LENGTH:</font>
<font color="red"> 490.             raise StopIteration()</font>
<font color="black"> 491. </font>
<font color="red"> 492.         if self._prelude is None:</font>
<font color="red"> 493.             self._prelude = self._parse_prelude()</font>
<font color="black"> 494. </font>
<font color="red"> 495.         if len(self._data) &lt; self._prelude.total_length:</font>
<font color="red"> 496.             raise StopIteration()</font>
<font color="black"> 497. </font>
<font color="red"> 498.         return self._parse_message()</font>
<font color="black"> 499. </font>
<font color="green"> 500.     def __next__(self):</font>
<font color="red"> 501.         return self.next()</font>
<font color="black"> 502. </font>
<font color="green"> 503.     def __iter__(self):</font>
<font color="red"> 504.         return self</font>
<font color="black"> 505. </font>
<font color="black"> 506. </font>
<font color="green"> 507. class EventStream(object):</font>
<font color="black"> 508.     &quot;&quot;&quot;Wrapper class for an event stream body.</font>
<font color="black"> 509. </font>
<font color="black"> 510.     This wraps the underlying streaming body, parsing it for individual events</font>
<font color="black"> 511.     and yielding them as they come available through the iterator interface.</font>
<font color="black"> 512. </font>
<font color="black"> 513.     The following example uses the S3 select API to get structured data out of</font>
<font color="black"> 514.     an object stored in S3 using an event stream.</font>
<font color="black"> 515. </font>
<font color="black"> 516.     **Example:**</font>
<font color="black"> 517.     ::</font>
<font color="black"> 518.         from botocore.session import Session</font>
<font color="black"> 519. </font>
<font color="black"> 520.         s3 = Session().create_client('s3')</font>
<font color="black"> 521.         response = s3.select_object_content(</font>
<font color="black"> 522.             Bucket='bucketname',</font>
<font color="black"> 523.             Key='keyname',</font>
<font color="black"> 524.             ExpressionType='SQL',</font>
<font color="black"> 525.             RequestProgress={'Enabled': True},</font>
<font color="black"> 526.             Expression=&quot;SELECT * FROM S3Object s&quot;,</font>
<font color="black"> 527.             InputSerialization={'CSV': {}},</font>
<font color="black"> 528.             OutputSerialization={'CSV': {}},</font>
<font color="black"> 529.         )</font>
<font color="black"> 530.         # This is the event stream in the response</font>
<font color="black"> 531.         event_stream = response['Payload']</font>
<font color="black"> 532.         end_event_received = False</font>
<font color="black"> 533.         with open('output', 'wb') as f:</font>
<font color="black"> 534.             # Iterate over events in the event stream as they come</font>
<font color="black"> 535.             for event in event_stream:</font>
<font color="black"> 536.                 # If we received a records event, write the data to a file</font>
<font color="black"> 537.                 if 'Records' in event:</font>
<font color="black"> 538.                     data = event['Records']['Payload']</font>
<font color="black"> 539.                     f.write(data)</font>
<font color="black"> 540.                 # If we received a progress event, print the details</font>
<font color="black"> 541.                 elif 'Progress' in event:</font>
<font color="black"> 542.                     print(event['Progress']['Details'])</font>
<font color="black"> 543.                 # End event indicates that the request finished successfully</font>
<font color="black"> 544.                 elif 'End' in event:</font>
<font color="black"> 545.                     print('Result is complete')</font>
<font color="black"> 546.                     end_event_received = True</font>
<font color="black"> 547.         if not end_event_received:</font>
<font color="black"> 548.             raise Exception(&quot;End event not received, request incomplete.&quot;)</font>
<font color="green"> 549.     &quot;&quot;&quot;</font>
<font color="green"> 550.     def __init__(self, raw_stream, output_shape, parser, operation_name):</font>
<font color="red"> 551.         self._raw_stream = raw_stream</font>
<font color="red"> 552.         self._output_shape = output_shape</font>
<font color="red"> 553.         self._operation_name = operation_name</font>
<font color="red"> 554.         self._parser = parser</font>
<font color="red"> 555.         self._buffer = EventStreamBuffer()</font>
<font color="black"> 556. </font>
<font color="green"> 557.     def __iter__(self):</font>
<font color="red"> 558.         for data in self._raw_stream.stream():</font>
<font color="red"> 559.             self._buffer.add_data(data)</font>
<font color="red"> 560.             for event in self._buffer:</font>
<font color="red"> 561.                 parsed_event = self._parse_event(event)</font>
<font color="red"> 562.                 if parsed_event:</font>
<font color="red"> 563.                     yield parsed_event</font>
<font color="black"> 564. </font>
<font color="green"> 565.     def _parse_event(self, event):</font>
<font color="red"> 566.         response_dict = event.to_response_dict()</font>
<font color="red"> 567.         parsed_response = self._parser.parse(response_dict, self._output_shape)</font>
<font color="red"> 568.         if response_dict['status_code'] == 200:</font>
<font color="red"> 569.             return parsed_response</font>
<font color="black"> 570.         else:</font>
<font color="red"> 571.             raise EventStreamError(parsed_response, self._operation_name)</font>
<font color="black"> 572. </font>
<font color="green"> 573.     def close(self):</font>
<font color="black"> 574.         &quot;&quot;&quot;Closes the underlying streaming body. &quot;&quot;&quot;</font>
<font color="red"> 575.         self._raw_stream.close()</font>
</pre>

