source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/packages/urllib3/connection.py</b><br>


file stats: <b>135 lines, 95 executed: 70.4% covered</b>
<pre>
<font color="green">   1. import datetime</font>
<font color="green">   2. import sys</font>
<font color="green">   3. import socket</font>
<font color="green">   4. from socket import timeout as SocketTimeout</font>
<font color="green">   5. import warnings</font>
<font color="green">   6. from .packages import six</font>
<font color="black">   7. </font>
<font color="green">   8. try:  # Python 3</font>
<font color="green">   9.     from http.client import HTTPConnection as _HTTPConnection, HTTPException</font>
<font color="green">  10. except ImportError:</font>
<font color="green">  11.     from httplib import HTTPConnection as _HTTPConnection, HTTPException</font>
<font color="black">  12. </font>
<font color="black">  13. </font>
<font color="green">  14. class DummyConnection(object):</font>
<font color="green">  15.     &quot;Used to detect a failed ConnectionCls import.&quot;</font>
<font color="green">  16.     pass</font>
<font color="black">  17. </font>
<font color="black">  18. </font>
<font color="green">  19. try:  # Compiled with SSL?</font>
<font color="green">  20.     HTTPSConnection = DummyConnection</font>
<font color="green">  21.     import ssl</font>
<font color="green">  22.     BaseSSLError = ssl.SSLError</font>
<font color="red">  23. except (ImportError, AttributeError):  # Platform-specific: No SSL.</font>
<font color="red">  24.     ssl = None</font>
<font color="black">  25. </font>
<font color="red">  26.     class BaseSSLError(BaseException):</font>
<font color="red">  27.         pass</font>
<font color="black">  28. </font>
<font color="black">  29. </font>
<font color="green">  30. try:  # Python 3:</font>
<font color="black">  31.     # Not a no-op, we're adding this to the namespace so it can be imported.</font>
<font color="green">  32.     ConnectionError = ConnectionError</font>
<font color="green">  33. except NameError:  # Python 2:</font>
<font color="green">  34.     class ConnectionError(Exception):</font>
<font color="green">  35.         pass</font>
<font color="black">  36. </font>
<font color="black">  37. </font>
<font color="green">  38. from .exceptions import (</font>
<font color="black">  39.     ConnectTimeoutError,</font>
<font color="black">  40.     SystemTimeWarning,</font>
<font color="black">  41.     SecurityWarning,</font>
<font color="black">  42. )</font>
<font color="green">  43. from .packages.ssl_match_hostname import match_hostname</font>
<font color="black">  44. </font>
<font color="green">  45. from .util.ssl_ import (</font>
<font color="black">  46.     resolve_cert_reqs,</font>
<font color="black">  47.     resolve_ssl_version,</font>
<font color="black">  48.     ssl_wrap_socket,</font>
<font color="black">  49.     assert_fingerprint,</font>
<font color="black">  50. )</font>
<font color="black">  51. </font>
<font color="black">  52. </font>
<font color="green">  53. from .util import connection</font>
<font color="black">  54. </font>
<font color="green">  55. port_by_scheme = {</font>
<font color="green">  56.     'http': 80,</font>
<font color="green">  57.     'https': 443,</font>
<font color="black">  58. }</font>
<font color="black">  59. </font>
<font color="green">  60. RECENT_DATE = datetime.date(2014, 1, 1)</font>
<font color="black">  61. </font>
<font color="black">  62. </font>
<font color="green">  63. class HTTPConnection(_HTTPConnection, object):</font>
<font color="black">  64.     &quot;&quot;&quot;</font>
<font color="black">  65.     Based on httplib.HTTPConnection but provides an extra constructor</font>
<font color="black">  66.     backwards-compatibility layer between older and newer Pythons.</font>
<font color="black">  67. </font>
<font color="black">  68.     Additional keyword parameters are used to configure attributes of the connection.</font>
<font color="black">  69.     Accepted parameters include:</font>
<font color="black">  70. </font>
<font color="black">  71.       - ``strict``: See the documentation on :class:`urllib3.connectionpool.HTTPConnectionPool`</font>
<font color="black">  72.       - ``source_address``: Set the source address for the current connection.</font>
<font color="black">  73. </font>
<font color="black">  74.         .. note:: This is ignored for Python 2.6. It is only applied for 2.7 and 3.x</font>
<font color="black">  75. </font>
<font color="black">  76.       - ``socket_options``: Set specific options on the underlying socket. If not specified, then</font>
<font color="black">  77.         defaults are loaded from ``HTTPConnection.default_socket_options`` which includes disabling</font>
<font color="black">  78.         Nagle's algorithm (sets TCP_NODELAY to 1) unless the connection is behind a proxy.</font>
<font color="black">  79. </font>
<font color="black">  80.         For example, if you wish to enable TCP Keep Alive in addition to the defaults,</font>
<font color="black">  81.         you might pass::</font>
<font color="black">  82. </font>
<font color="black">  83.             HTTPConnection.default_socket_options + [</font>
<font color="black">  84.                 (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1),</font>
<font color="black">  85.             ]</font>
<font color="black">  86. </font>
<font color="black">  87.         Or you may want to disable the defaults by passing an empty list (e.g., ``[]``).</font>
<font color="green">  88.     &quot;&quot;&quot;</font>
<font color="black">  89. </font>
<font color="green">  90.     default_port = port_by_scheme['http']</font>
<font color="black">  91. </font>
<font color="black">  92.     #: Disable Nagle's algorithm by default.</font>
<font color="black">  93.     #: ``[(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]``</font>
<font color="green">  94.     default_socket_options = [(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]</font>
<font color="black">  95. </font>
<font color="black">  96.     #: Whether this connection verifies the host's certificate.</font>
<font color="green">  97.     is_verified = False</font>
<font color="black">  98. </font>
<font color="green">  99.     def __init__(self, *args, **kw):</font>
<font color="green"> 100.         if six.PY3:  # Python 3</font>
<font color="red"> 101.             kw.pop('strict', None)</font>
<font color="black"> 102. </font>
<font color="black"> 103.         # Pre-set source_address in case we have an older Python like 2.6.</font>
<font color="green"> 104.         self.source_address = kw.get('source_address')</font>
<font color="black"> 105. </font>
<font color="green"> 106.         if sys.version_info &lt; (2, 7):  # Python 2.6</font>
<font color="black"> 107.             # _HTTPConnection on Python 2.6 will balk at this keyword arg, but</font>
<font color="black"> 108.             # not newer versions. We can still use it when creating a</font>
<font color="black"> 109.             # connection though, so we pop it *after* we have saved it as</font>
<font color="black"> 110.             # self.source_address.</font>
<font color="red"> 111.             kw.pop('source_address', None)</font>
<font color="black"> 112. </font>
<font color="black"> 113.         #: The socket options provided by the user. If no options are</font>
<font color="black"> 114.         #: provided, we use the default options.</font>
<font color="green"> 115.         self.socket_options = kw.pop('socket_options', self.default_socket_options)</font>
<font color="black"> 116. </font>
<font color="black"> 117.         # Superclass also sets self.source_address in Python 2.7+.</font>
<font color="green"> 118.         _HTTPConnection.__init__(self, *args, **kw)</font>
<font color="black"> 119. </font>
<font color="green"> 120.     def _new_conn(self):</font>
<font color="black"> 121.         &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.</font>
<font color="black"> 122. </font>
<font color="black"> 123.         :return: New socket connection.</font>
<font color="black"> 124.         &quot;&quot;&quot;</font>
<font color="green"> 125.         extra_kw = {}</font>
<font color="green"> 126.         if self.source_address:</font>
<font color="red"> 127.             extra_kw['source_address'] = self.source_address</font>
<font color="black"> 128. </font>
<font color="green"> 129.         if self.socket_options:</font>
<font color="green"> 130.             extra_kw['socket_options'] = self.socket_options</font>
<font color="black"> 131. </font>
<font color="green"> 132.         try:</font>
<font color="green"> 133.             conn = connection.create_connection(</font>
<font color="green"> 134.                 (self.host, self.port), self.timeout, **extra_kw)</font>
<font color="black"> 135. </font>
<font color="red"> 136.         except SocketTimeout:</font>
<font color="red"> 137.             raise ConnectTimeoutError(</font>
<font color="red"> 138.                 self, &quot;Connection to %s timed out. (connect timeout=%s)&quot; %</font>
<font color="red"> 139.                 (self.host, self.timeout))</font>
<font color="black"> 140. </font>
<font color="green"> 141.         return conn</font>
<font color="black"> 142. </font>
<font color="green"> 143.     def _prepare_conn(self, conn):</font>
<font color="red"> 144.         self.sock = conn</font>
<font color="black"> 145.         # the _tunnel_host attribute was added in python 2.6.3 (via</font>
<font color="black"> 146.         # http://hg.python.org/cpython/rev/0f57b30a152f) so pythons 2.6(0-2) do</font>
<font color="black"> 147.         # not have them.</font>
<font color="red"> 148.         if getattr(self, '_tunnel_host', None):</font>
<font color="black"> 149.             # TODO: Fix tunnel so it doesn't depend on self.sock state.</font>
<font color="red"> 150.             self._tunnel()</font>
<font color="black"> 151.             # Mark this connection as not reusable</font>
<font color="red"> 152.             self.auto_open = 0</font>
<font color="black"> 153. </font>
<font color="green"> 154.     def connect(self):</font>
<font color="red"> 155.         conn = self._new_conn()</font>
<font color="red"> 156.         self._prepare_conn(conn)</font>
<font color="black"> 157. </font>
<font color="black"> 158. </font>
<font color="green"> 159. class HTTPSConnection(HTTPConnection):</font>
<font color="green"> 160.     default_port = port_by_scheme['https']</font>
<font color="black"> 161. </font>
<font color="green"> 162.     def __init__(self, host, port=None, key_file=None, cert_file=None,</font>
<font color="green"> 163.                  strict=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT, **kw):</font>
<font color="black"> 164. </font>
<font color="red"> 165.         HTTPConnection.__init__(self, host, port, strict=strict,</font>
<font color="red"> 166.                                 timeout=timeout, **kw)</font>
<font color="black"> 167. </font>
<font color="red"> 168.         self.key_file = key_file</font>
<font color="red"> 169.         self.cert_file = cert_file</font>
<font color="black"> 170. </font>
<font color="black"> 171.         # Required property for Google AppEngine 1.9.0 which otherwise causes</font>
<font color="black"> 172.         # HTTPS requests to go out as HTTP. (See Issue #356)</font>
<font color="red"> 173.         self._protocol = 'https'</font>
<font color="black"> 174. </font>
<font color="green"> 175.     def connect(self):</font>
<font color="red"> 176.         conn = self._new_conn()</font>
<font color="red"> 177.         self._prepare_conn(conn)</font>
<font color="red"> 178.         self.sock = ssl.wrap_socket(conn, self.key_file, self.cert_file)</font>
<font color="black"> 179. </font>
<font color="black"> 180. </font>
<font color="green"> 181. class VerifiedHTTPSConnection(HTTPSConnection):</font>
<font color="black"> 182.     &quot;&quot;&quot;</font>
<font color="black"> 183.     Based on httplib.HTTPSConnection but wraps the socket with</font>
<font color="black"> 184.     SSL certification.</font>
<font color="green"> 185.     &quot;&quot;&quot;</font>
<font color="green"> 186.     cert_reqs = None</font>
<font color="green"> 187.     ca_certs = None</font>
<font color="green"> 188.     ssl_version = None</font>
<font color="green"> 189.     assert_fingerprint = None</font>
<font color="black"> 190. </font>
<font color="green"> 191.     def set_cert(self, key_file=None, cert_file=None,</font>
<font color="green"> 192.                  cert_reqs=None, ca_certs=None,</font>
<font color="green"> 193.                  assert_hostname=None, assert_fingerprint=None):</font>
<font color="black"> 194. </font>
<font color="green"> 195.         self.key_file = key_file</font>
<font color="green"> 196.         self.cert_file = cert_file</font>
<font color="green"> 197.         self.cert_reqs = cert_reqs</font>
<font color="green"> 198.         self.ca_certs = ca_certs</font>
<font color="green"> 199.         self.assert_hostname = assert_hostname</font>
<font color="green"> 200.         self.assert_fingerprint = assert_fingerprint</font>
<font color="black"> 201. </font>
<font color="green"> 202.     def connect(self):</font>
<font color="black"> 203.         # Add certificate verification</font>
<font color="green"> 204.         conn = self._new_conn()</font>
<font color="black"> 205. </font>
<font color="green"> 206.         resolved_cert_reqs = resolve_cert_reqs(self.cert_reqs)</font>
<font color="green"> 207.         resolved_ssl_version = resolve_ssl_version(self.ssl_version)</font>
<font color="black"> 208. </font>
<font color="green"> 209.         hostname = self.host</font>
<font color="green"> 210.         if getattr(self, '_tunnel_host', None):</font>
<font color="black"> 211.             # _tunnel_host was added in Python 2.6.3</font>
<font color="black"> 212.             # (See: http://hg.python.org/cpython/rev/0f57b30a152f)</font>
<font color="black"> 213. </font>
<font color="red"> 214.             self.sock = conn</font>
<font color="black"> 215.             # Calls self._set_hostport(), so self.host is</font>
<font color="black"> 216.             # self._tunnel_host below.</font>
<font color="red"> 217.             self._tunnel()</font>
<font color="black"> 218.             # Mark this connection as not reusable</font>
<font color="red"> 219.             self.auto_open = 0</font>
<font color="black"> 220. </font>
<font color="black"> 221.             # Override the host with the one we're requesting data from.</font>
<font color="red"> 222.             hostname = self._tunnel_host</font>
<font color="black"> 223. </font>
<font color="green"> 224.         is_time_off = datetime.date.today() &lt; RECENT_DATE</font>
<font color="green"> 225.         if is_time_off:</font>
<font color="red"> 226.             warnings.warn((</font>
<font color="red"> 227.                 'System time is way off (before {0}). This will probably '</font>
<font color="red"> 228.                 'lead to SSL verification errors').format(RECENT_DATE),</font>
<font color="red"> 229.                 SystemTimeWarning</font>
<font color="black"> 230.             )</font>
<font color="black"> 231. </font>
<font color="black"> 232.         # Wrap socket using verification with the root certs in</font>
<font color="black"> 233.         # trusted_root_certs</font>
<font color="green"> 234.         self.sock = ssl_wrap_socket(conn, self.key_file, self.cert_file,</font>
<font color="green"> 235.                                     cert_reqs=resolved_cert_reqs,</font>
<font color="green"> 236.                                     ca_certs=self.ca_certs,</font>
<font color="green"> 237.                                     server_hostname=hostname,</font>
<font color="green"> 238.                                     ssl_version=resolved_ssl_version)</font>
<font color="black"> 239. </font>
<font color="green"> 240.         if self.assert_fingerprint:</font>
<font color="red"> 241.             assert_fingerprint(self.sock.getpeercert(binary_form=True),</font>
<font color="red"> 242.                                self.assert_fingerprint)</font>
<font color="green"> 243.         elif resolved_cert_reqs != ssl.CERT_NONE \</font>
<font color="green"> 244.                 and self.assert_hostname is not False:</font>
<font color="green"> 245.             cert = self.sock.getpeercert()</font>
<font color="green"> 246.             if not cert.get('subjectAltName', ()):</font>
<font color="red"> 247.                 warnings.warn((</font>
<font color="red"> 248.                     'Certificate has no `subjectAltName`, falling back to check for a `commonName` for now. '</font>
<font color="black"> 249.                     'This feature is being removed by major browsers and deprecated by RFC 2818. '</font>
<font color="black"> 250.                     '(See https://github.com/shazow/urllib3/issues/497 for details.)'),</font>
<font color="red"> 251.                     SecurityWarning</font>
<font color="black"> 252.                 )</font>
<font color="green"> 253.             match_hostname(cert, self.assert_hostname or hostname)</font>
<font color="black"> 254. </font>
<font color="green"> 255.         self.is_verified = (resolved_cert_reqs == ssl.CERT_REQUIRED</font>
<font color="red"> 256.                             or self.assert_fingerprint is not None)</font>
<font color="black"> 257. </font>
<font color="black"> 258. </font>
<font color="green"> 259. if ssl:</font>
<font color="black"> 260.     # Make a copy for testing.</font>
<font color="green"> 261.     UnverifiedHTTPSConnection = HTTPSConnection</font>
<font color="green"> 262.     HTTPSConnection = VerifiedHTTPSConnection</font>
<font color="black"> 263. else:</font>
<font color="red"> 264.     HTTPSConnection = DummyConnection</font>
</pre>

