source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/decimal.py</b><br>


file stats: <b>2620 lines, 413 executed: 15.8% covered</b>
<pre>
<font color="black">   1. # Copyright (c) 2004 Python Software Foundation.</font>
<font color="black">   2. # All rights reserved.</font>
<font color="black">   3. </font>
<font color="black">   4. # Written by Eric Price &lt;eprice at tjhsst.edu&gt;</font>
<font color="black">   5. #    and Facundo Batista &lt;facundo at taniquetil.com.ar&gt;</font>
<font color="black">   6. #    and Raymond Hettinger &lt;python at rcn.com&gt;</font>
<font color="black">   7. #    and Aahz &lt;aahz at pobox.com&gt;</font>
<font color="black">   8. #    and Tim Peters</font>
<font color="black">   9. </font>
<font color="black">  10. # This module is currently Py2.3 compatible and should be kept that way</font>
<font color="black">  11. # unless a major compelling advantage arises.  IOW, 2.3 compatibility is</font>
<font color="black">  12. # strongly preferred, but not guaranteed.</font>
<font color="black">  13. </font>
<font color="black">  14. # Also, this module should be kept in sync with the latest updates of</font>
<font color="black">  15. # the IBM specification as it evolves.  Those updates will be treated</font>
<font color="black">  16. # as bug fixes (deviation from the spec is a compatibility, usability</font>
<font color="black">  17. # bug) and will be backported.  At this point the spec is stabilizing</font>
<font color="black">  18. # and the updates are becoming fewer, smaller, and less significant.</font>
<font color="black">  19. </font>
<font color="black">  20. &quot;&quot;&quot;</font>
<font color="black">  21. This is a Py2.3 implementation of decimal floating point arithmetic based on</font>
<font color="black">  22. the General Decimal Arithmetic Specification:</font>
<font color="black">  23. </font>
<font color="black">  24.     http://speleotrove.com/decimal/decarith.html</font>
<font color="black">  25. </font>
<font color="black">  26. and IEEE standard 854-1987:</font>
<font color="black">  27. </font>
<font color="black">  28.     http://en.wikipedia.org/wiki/IEEE_854-1987</font>
<font color="black">  29. </font>
<font color="black">  30. Decimal floating point has finite precision with arbitrarily large bounds.</font>
<font color="black">  31. </font>
<font color="black">  32. The purpose of this module is to support arithmetic using familiar</font>
<font color="black">  33. &quot;schoolhouse&quot; rules and to avoid some of the tricky representation</font>
<font color="black">  34. issues associated with binary floating point.  The package is especially</font>
<font color="black">  35. useful for financial applications or for contexts where users have</font>
<font color="black">  36. expectations that are at odds with binary floating point (for instance,</font>
<font color="black">  37. in binary floating point, 1.00 % 0.1 gives 0.09999999999999995 instead</font>
<font color="black">  38. of the expected Decimal('0.00') returned by decimal floating point).</font>
<font color="black">  39. </font>
<font color="black">  40. Here are some examples of using the decimal module:</font>
<font color="black">  41. </font>
<font color="black">  42. &gt;&gt;&gt; from decimal import *</font>
<font color="black">  43. &gt;&gt;&gt; setcontext(ExtendedContext)</font>
<font color="black">  44. &gt;&gt;&gt; Decimal(0)</font>
<font color="black">  45. Decimal('0')</font>
<font color="black">  46. &gt;&gt;&gt; Decimal('1')</font>
<font color="black">  47. Decimal('1')</font>
<font color="black">  48. &gt;&gt;&gt; Decimal('-.0123')</font>
<font color="black">  49. Decimal('-0.0123')</font>
<font color="black">  50. &gt;&gt;&gt; Decimal(123456)</font>
<font color="black">  51. Decimal('123456')</font>
<font color="black">  52. &gt;&gt;&gt; Decimal('123.45e12345678901234567890')</font>
<font color="black">  53. Decimal('1.2345E+12345678901234567892')</font>
<font color="black">  54. &gt;&gt;&gt; Decimal('1.33') + Decimal('1.27')</font>
<font color="black">  55. Decimal('2.60')</font>
<font color="black">  56. &gt;&gt;&gt; Decimal('12.34') + Decimal('3.87') - Decimal('18.41')</font>
<font color="black">  57. Decimal('-2.20')</font>
<font color="black">  58. &gt;&gt;&gt; dig = Decimal(1)</font>
<font color="black">  59. &gt;&gt;&gt; print dig / Decimal(3)</font>
<font color="black">  60. 0.333333333</font>
<font color="black">  61. &gt;&gt;&gt; getcontext().prec = 18</font>
<font color="black">  62. &gt;&gt;&gt; print dig / Decimal(3)</font>
<font color="black">  63. 0.333333333333333333</font>
<font color="black">  64. &gt;&gt;&gt; print dig.sqrt()</font>
<font color="black">  65. 1</font>
<font color="black">  66. &gt;&gt;&gt; print Decimal(3).sqrt()</font>
<font color="black">  67. 1.73205080756887729</font>
<font color="black">  68. &gt;&gt;&gt; print Decimal(3) ** 123</font>
<font color="black">  69. 4.85192780976896427E+58</font>
<font color="black">  70. &gt;&gt;&gt; inf = Decimal(1) / Decimal(0)</font>
<font color="black">  71. &gt;&gt;&gt; print inf</font>
<font color="black">  72. Infinity</font>
<font color="black">  73. &gt;&gt;&gt; neginf = Decimal(-1) / Decimal(0)</font>
<font color="black">  74. &gt;&gt;&gt; print neginf</font>
<font color="black">  75. -Infinity</font>
<font color="black">  76. &gt;&gt;&gt; print neginf + inf</font>
<font color="black">  77. NaN</font>
<font color="black">  78. &gt;&gt;&gt; print neginf * inf</font>
<font color="black">  79. -Infinity</font>
<font color="black">  80. &gt;&gt;&gt; print dig / 0</font>
<font color="black">  81. Infinity</font>
<font color="black">  82. &gt;&gt;&gt; getcontext().traps[DivisionByZero] = 1</font>
<font color="black">  83. &gt;&gt;&gt; print dig / 0</font>
<font color="black">  84. Traceback (most recent call last):</font>
<font color="black">  85.   ...</font>
<font color="black">  86.   ...</font>
<font color="black">  87.   ...</font>
<font color="black">  88. DivisionByZero: x / 0</font>
<font color="black">  89. &gt;&gt;&gt; c = Context()</font>
<font color="black">  90. &gt;&gt;&gt; c.traps[InvalidOperation] = 0</font>
<font color="black">  91. &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black">  92. 0</font>
<font color="black">  93. &gt;&gt;&gt; c.divide(Decimal(0), Decimal(0))</font>
<font color="black">  94. Decimal('NaN')</font>
<font color="black">  95. &gt;&gt;&gt; c.traps[InvalidOperation] = 1</font>
<font color="black">  96. &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black">  97. 1</font>
<font color="black">  98. &gt;&gt;&gt; c.flags[InvalidOperation] = 0</font>
<font color="black">  99. &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black"> 100. 0</font>
<font color="black"> 101. &gt;&gt;&gt; print c.divide(Decimal(0), Decimal(0))</font>
<font color="black"> 102. Traceback (most recent call last):</font>
<font color="black"> 103.   ...</font>
<font color="black"> 104.   ...</font>
<font color="black"> 105.   ...</font>
<font color="black"> 106. InvalidOperation: 0 / 0</font>
<font color="black"> 107. &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black"> 108. 1</font>
<font color="black"> 109. &gt;&gt;&gt; c.flags[InvalidOperation] = 0</font>
<font color="black"> 110. &gt;&gt;&gt; c.traps[InvalidOperation] = 0</font>
<font color="black"> 111. &gt;&gt;&gt; print c.divide(Decimal(0), Decimal(0))</font>
<font color="black"> 112. NaN</font>
<font color="black"> 113. &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black"> 114. 1</font>
<font color="black"> 115. &gt;&gt;&gt;</font>
<font color="green"> 116. &quot;&quot;&quot;</font>
<font color="black"> 117. </font>
<font color="black"> 118. __all__ = [</font>
<font color="black"> 119.     # Two major classes</font>
<font color="green"> 120.     'Decimal', 'Context',</font>
<font color="black"> 121. </font>
<font color="black"> 122.     # Contexts</font>
<font color="green"> 123.     'DefaultContext', 'BasicContext', 'ExtendedContext',</font>
<font color="black"> 124. </font>
<font color="black"> 125.     # Exceptions</font>
<font color="green"> 126.     'DecimalException', 'Clamped', 'InvalidOperation', 'DivisionByZero',</font>
<font color="green"> 127.     'Inexact', 'Rounded', 'Subnormal', 'Overflow', 'Underflow',</font>
<font color="black"> 128. </font>
<font color="black"> 129.     # Constants for use in setting up contexts</font>
<font color="green"> 130.     'ROUND_DOWN', 'ROUND_HALF_UP', 'ROUND_HALF_EVEN', 'ROUND_CEILING',</font>
<font color="green"> 131.     'ROUND_FLOOR', 'ROUND_UP', 'ROUND_HALF_DOWN', 'ROUND_05UP',</font>
<font color="black"> 132. </font>
<font color="black"> 133.     # Functions for manipulating contexts</font>
<font color="green"> 134.     'setcontext', 'getcontext', 'localcontext'</font>
<font color="black"> 135. ]</font>
<font color="black"> 136. </font>
<font color="green"> 137. __version__ = '1.70'    # Highest version of the spec this complies with</font>
<font color="black"> 138. </font>
<font color="green"> 139. import math as _math</font>
<font color="green"> 140. import numbers as _numbers</font>
<font color="black"> 141. </font>
<font color="green"> 142. try:</font>
<font color="green"> 143.     from collections import namedtuple as _namedtuple</font>
<font color="green"> 144.     DecimalTuple = _namedtuple('DecimalTuple', 'sign digits exponent')</font>
<font color="red"> 145. except ImportError:</font>
<font color="red"> 146.     DecimalTuple = lambda *args: args</font>
<font color="black"> 147. </font>
<font color="black"> 148. # Rounding</font>
<font color="green"> 149. ROUND_DOWN = 'ROUND_DOWN'</font>
<font color="green"> 150. ROUND_HALF_UP = 'ROUND_HALF_UP'</font>
<font color="green"> 151. ROUND_HALF_EVEN = 'ROUND_HALF_EVEN'</font>
<font color="green"> 152. ROUND_CEILING = 'ROUND_CEILING'</font>
<font color="green"> 153. ROUND_FLOOR = 'ROUND_FLOOR'</font>
<font color="green"> 154. ROUND_UP = 'ROUND_UP'</font>
<font color="green"> 155. ROUND_HALF_DOWN = 'ROUND_HALF_DOWN'</font>
<font color="green"> 156. ROUND_05UP = 'ROUND_05UP'</font>
<font color="black"> 157. </font>
<font color="black"> 158. # Errors</font>
<font color="black"> 159. </font>
<font color="green"> 160. class DecimalException(ArithmeticError):</font>
<font color="black"> 161.     &quot;&quot;&quot;Base exception class.</font>
<font color="black"> 162. </font>
<font color="black"> 163.     Used exceptions derive from this.</font>
<font color="black"> 164.     If an exception derives from another exception besides this (such as</font>
<font color="black"> 165.     Underflow (Inexact, Rounded, Subnormal) that indicates that it is only</font>
<font color="black"> 166.     called if the others are present.  This isn't actually used for</font>
<font color="black"> 167.     anything, though.</font>
<font color="black"> 168. </font>
<font color="black"> 169.     handle  -- Called when context._raise_error is called and the</font>
<font color="black"> 170.                trap_enabler is not set.  First argument is self, second is the</font>
<font color="black"> 171.                context.  More arguments can be given, those being after</font>
<font color="black"> 172.                the explanation in _raise_error (For example,</font>
<font color="black"> 173.                context._raise_error(NewError, '(-x)!', self._sign) would</font>
<font color="black"> 174.                call NewError().handle(context, self._sign).)</font>
<font color="black"> 175. </font>
<font color="black"> 176.     To define a new exception, it should be sufficient to have it derive</font>
<font color="black"> 177.     from DecimalException.</font>
<font color="green"> 178.     &quot;&quot;&quot;</font>
<font color="green"> 179.     def handle(self, context, *args):</font>
<font color="red"> 180.         pass</font>
<font color="black"> 181. </font>
<font color="black"> 182. </font>
<font color="green"> 183. class Clamped(DecimalException):</font>
<font color="black"> 184.     &quot;&quot;&quot;Exponent of a 0 changed to fit bounds.</font>
<font color="black"> 185. </font>
<font color="black"> 186.     This occurs and signals clamped if the exponent of a result has been</font>
<font color="black"> 187.     altered in order to fit the constraints of a specific concrete</font>
<font color="black"> 188.     representation.  This may occur when the exponent of a zero result would</font>
<font color="black"> 189.     be outside the bounds of a representation, or when a large normal</font>
<font color="black"> 190.     number would have an encoded exponent that cannot be represented.  In</font>
<font color="black"> 191.     this latter case, the exponent is reduced to fit and the corresponding</font>
<font color="black"> 192.     number of zero digits are appended to the coefficient (&quot;fold-down&quot;).</font>
<font color="green"> 193.     &quot;&quot;&quot;</font>
<font color="black"> 194. </font>
<font color="green"> 195. class InvalidOperation(DecimalException):</font>
<font color="black"> 196.     &quot;&quot;&quot;An invalid operation was performed.</font>
<font color="black"> 197. </font>
<font color="black"> 198.     Various bad things cause this:</font>
<font color="black"> 199. </font>
<font color="black"> 200.     Something creates a signaling NaN</font>
<font color="black"> 201.     -INF + INF</font>
<font color="black"> 202.     0 * (+-)INF</font>
<font color="black"> 203.     (+-)INF / (+-)INF</font>
<font color="black"> 204.     x % 0</font>
<font color="black"> 205.     (+-)INF % x</font>
<font color="black"> 206.     x._rescale( non-integer )</font>
<font color="black"> 207.     sqrt(-x) , x &gt; 0</font>
<font color="black"> 208.     0 ** 0</font>
<font color="black"> 209.     x ** (non-integer)</font>
<font color="black"> 210.     x ** (+-)INF</font>
<font color="black"> 211.     An operand is invalid</font>
<font color="black"> 212. </font>
<font color="black"> 213.     The result of the operation after these is a quiet positive NaN,</font>
<font color="black"> 214.     except when the cause is a signaling NaN, in which case the result is</font>
<font color="black"> 215.     also a quiet NaN, but with the original sign, and an optional</font>
<font color="black"> 216.     diagnostic information.</font>
<font color="green"> 217.     &quot;&quot;&quot;</font>
<font color="green"> 218.     def handle(self, context, *args):</font>
<font color="red"> 219.         if args:</font>
<font color="red"> 220.             ans = _dec_from_triple(args[0]._sign, args[0]._int, 'n', True)</font>
<font color="red"> 221.             return ans._fix_nan(context)</font>
<font color="red"> 222.         return _NaN</font>
<font color="black"> 223. </font>
<font color="green"> 224. class ConversionSyntax(InvalidOperation):</font>
<font color="black"> 225.     &quot;&quot;&quot;Trying to convert badly formed string.</font>
<font color="black"> 226. </font>
<font color="black"> 227.     This occurs and signals invalid-operation if a string is being</font>
<font color="black"> 228.     converted to a number and it does not conform to the numeric string</font>
<font color="black"> 229.     syntax.  The result is [0,qNaN].</font>
<font color="green"> 230.     &quot;&quot;&quot;</font>
<font color="green"> 231.     def handle(self, context, *args):</font>
<font color="red"> 232.         return _NaN</font>
<font color="black"> 233. </font>
<font color="green"> 234. class DivisionByZero(DecimalException, ZeroDivisionError):</font>
<font color="black"> 235.     &quot;&quot;&quot;Division by 0.</font>
<font color="black"> 236. </font>
<font color="black"> 237.     This occurs and signals division-by-zero if division of a finite number</font>
<font color="black"> 238.     by zero was attempted (during a divide-integer or divide operation, or a</font>
<font color="black"> 239.     power operation with negative right-hand operand), and the dividend was</font>
<font color="black"> 240.     not zero.</font>
<font color="black"> 241. </font>
<font color="black"> 242.     The result of the operation is [sign,inf], where sign is the exclusive</font>
<font color="black"> 243.     or of the signs of the operands for divide, or is 1 for an odd power of</font>
<font color="black"> 244.     -0, for power.</font>
<font color="green"> 245.     &quot;&quot;&quot;</font>
<font color="black"> 246. </font>
<font color="green"> 247.     def handle(self, context, sign, *args):</font>
<font color="red"> 248.         return _SignedInfinity[sign]</font>
<font color="black"> 249. </font>
<font color="green"> 250. class DivisionImpossible(InvalidOperation):</font>
<font color="black"> 251.     &quot;&quot;&quot;Cannot perform the division adequately.</font>
<font color="black"> 252. </font>
<font color="black"> 253.     This occurs and signals invalid-operation if the integer result of a</font>
<font color="black"> 254.     divide-integer or remainder operation had too many digits (would be</font>
<font color="black"> 255.     longer than precision).  The result is [0,qNaN].</font>
<font color="green"> 256.     &quot;&quot;&quot;</font>
<font color="black"> 257. </font>
<font color="green"> 258.     def handle(self, context, *args):</font>
<font color="red"> 259.         return _NaN</font>
<font color="black"> 260. </font>
<font color="green"> 261. class DivisionUndefined(InvalidOperation, ZeroDivisionError):</font>
<font color="black"> 262.     &quot;&quot;&quot;Undefined result of division.</font>
<font color="black"> 263. </font>
<font color="black"> 264.     This occurs and signals invalid-operation if division by zero was</font>
<font color="black"> 265.     attempted (during a divide-integer, divide, or remainder operation), and</font>
<font color="black"> 266.     the dividend is also zero.  The result is [0,qNaN].</font>
<font color="green"> 267.     &quot;&quot;&quot;</font>
<font color="black"> 268. </font>
<font color="green"> 269.     def handle(self, context, *args):</font>
<font color="red"> 270.         return _NaN</font>
<font color="black"> 271. </font>
<font color="green"> 272. class Inexact(DecimalException):</font>
<font color="black"> 273.     &quot;&quot;&quot;Had to round, losing information.</font>
<font color="black"> 274. </font>
<font color="black"> 275.     This occurs and signals inexact whenever the result of an operation is</font>
<font color="black"> 276.     not exact (that is, it needed to be rounded and any discarded digits</font>
<font color="black"> 277.     were non-zero), or if an overflow or underflow condition occurs.  The</font>
<font color="black"> 278.     result in all cases is unchanged.</font>
<font color="black"> 279. </font>
<font color="black"> 280.     The inexact signal may be tested (or trapped) to determine if a given</font>
<font color="black"> 281.     operation (or sequence of operations) was inexact.</font>
<font color="green"> 282.     &quot;&quot;&quot;</font>
<font color="black"> 283. </font>
<font color="green"> 284. class InvalidContext(InvalidOperation):</font>
<font color="black"> 285.     &quot;&quot;&quot;Invalid context.  Unknown rounding, for example.</font>
<font color="black"> 286. </font>
<font color="black"> 287.     This occurs and signals invalid-operation if an invalid context was</font>
<font color="black"> 288.     detected during an operation.  This can occur if contexts are not checked</font>
<font color="black"> 289.     on creation and either the precision exceeds the capability of the</font>
<font color="black"> 290.     underlying concrete representation or an unknown or unsupported rounding</font>
<font color="black"> 291.     was specified.  These aspects of the context need only be checked when</font>
<font color="black"> 292.     the values are required to be used.  The result is [0,qNaN].</font>
<font color="green"> 293.     &quot;&quot;&quot;</font>
<font color="black"> 294. </font>
<font color="green"> 295.     def handle(self, context, *args):</font>
<font color="red"> 296.         return _NaN</font>
<font color="black"> 297. </font>
<font color="green"> 298. class Rounded(DecimalException):</font>
<font color="black"> 299.     &quot;&quot;&quot;Number got rounded (not  necessarily changed during rounding).</font>
<font color="black"> 300. </font>
<font color="black"> 301.     This occurs and signals rounded whenever the result of an operation is</font>
<font color="black"> 302.     rounded (that is, some zero or non-zero digits were discarded from the</font>
<font color="black"> 303.     coefficient), or if an overflow or underflow condition occurs.  The</font>
<font color="black"> 304.     result in all cases is unchanged.</font>
<font color="black"> 305. </font>
<font color="black"> 306.     The rounded signal may be tested (or trapped) to determine if a given</font>
<font color="black"> 307.     operation (or sequence of operations) caused a loss of precision.</font>
<font color="green"> 308.     &quot;&quot;&quot;</font>
<font color="black"> 309. </font>
<font color="green"> 310. class Subnormal(DecimalException):</font>
<font color="black"> 311.     &quot;&quot;&quot;Exponent &lt; Emin before rounding.</font>
<font color="black"> 312. </font>
<font color="black"> 313.     This occurs and signals subnormal whenever the result of a conversion or</font>
<font color="black"> 314.     operation is subnormal (that is, its adjusted exponent is less than</font>
<font color="black"> 315.     Emin, before any rounding).  The result in all cases is unchanged.</font>
<font color="black"> 316. </font>
<font color="black"> 317.     The subnormal signal may be tested (or trapped) to determine if a given</font>
<font color="black"> 318.     or operation (or sequence of operations) yielded a subnormal result.</font>
<font color="green"> 319.     &quot;&quot;&quot;</font>
<font color="black"> 320. </font>
<font color="green"> 321. class Overflow(Inexact, Rounded):</font>
<font color="black"> 322.     &quot;&quot;&quot;Numerical overflow.</font>
<font color="black"> 323. </font>
<font color="black"> 324.     This occurs and signals overflow if the adjusted exponent of a result</font>
<font color="black"> 325.     (from a conversion or from an operation that is not an attempt to divide</font>
<font color="black"> 326.     by zero), after rounding, would be greater than the largest value that</font>
<font color="black"> 327.     can be handled by the implementation (the value Emax).</font>
<font color="black"> 328. </font>
<font color="black"> 329.     The result depends on the rounding mode:</font>
<font color="black"> 330. </font>
<font color="black"> 331.     For round-half-up and round-half-even (and for round-half-down and</font>
<font color="black"> 332.     round-up, if implemented), the result of the operation is [sign,inf],</font>
<font color="black"> 333.     where sign is the sign of the intermediate result.  For round-down, the</font>
<font color="black"> 334.     result is the largest finite number that can be represented in the</font>
<font color="black"> 335.     current precision, with the sign of the intermediate result.  For</font>
<font color="black"> 336.     round-ceiling, the result is the same as for round-down if the sign of</font>
<font color="black"> 337.     the intermediate result is 1, or is [0,inf] otherwise.  For round-floor,</font>
<font color="black"> 338.     the result is the same as for round-down if the sign of the intermediate</font>
<font color="black"> 339.     result is 0, or is [1,inf] otherwise.  In all cases, Inexact and Rounded</font>
<font color="black"> 340.     will also be raised.</font>
<font color="green"> 341.     &quot;&quot;&quot;</font>
<font color="black"> 342. </font>
<font color="green"> 343.     def handle(self, context, sign, *args):</font>
<font color="red"> 344.         if context.rounding in (ROUND_HALF_UP, ROUND_HALF_EVEN,</font>
<font color="red"> 345.                                 ROUND_HALF_DOWN, ROUND_UP):</font>
<font color="red"> 346.             return _SignedInfinity[sign]</font>
<font color="red"> 347.         if sign == 0:</font>
<font color="red"> 348.             if context.rounding == ROUND_CEILING:</font>
<font color="red"> 349.                 return _SignedInfinity[sign]</font>
<font color="red"> 350.             return _dec_from_triple(sign, '9'*context.prec,</font>
<font color="red"> 351.                             context.Emax-context.prec+1)</font>
<font color="red"> 352.         if sign == 1:</font>
<font color="red"> 353.             if context.rounding == ROUND_FLOOR:</font>
<font color="red"> 354.                 return _SignedInfinity[sign]</font>
<font color="red"> 355.             return _dec_from_triple(sign, '9'*context.prec,</font>
<font color="red"> 356.                              context.Emax-context.prec+1)</font>
<font color="black"> 357. </font>
<font color="black"> 358. </font>
<font color="green"> 359. class Underflow(Inexact, Rounded, Subnormal):</font>
<font color="black"> 360.     &quot;&quot;&quot;Numerical underflow with result rounded to 0.</font>
<font color="black"> 361. </font>
<font color="black"> 362.     This occurs and signals underflow if a result is inexact and the</font>
<font color="black"> 363.     adjusted exponent of the result would be smaller (more negative) than</font>
<font color="black"> 364.     the smallest value that can be handled by the implementation (the value</font>
<font color="black"> 365.     Emin).  That is, the result is both inexact and subnormal.</font>
<font color="black"> 366. </font>
<font color="black"> 367.     The result after an underflow will be a subnormal number rounded, if</font>
<font color="black"> 368.     necessary, so that its exponent is not less than Etiny.  This may result</font>
<font color="black"> 369.     in 0 with the sign of the intermediate result and an exponent of Etiny.</font>
<font color="black"> 370. </font>
<font color="black"> 371.     In all cases, Inexact, Rounded, and Subnormal will also be raised.</font>
<font color="green"> 372.     &quot;&quot;&quot;</font>
<font color="black"> 373. </font>
<font color="black"> 374. # List of public traps and flags</font>
<font color="green"> 375. _signals = [Clamped, DivisionByZero, Inexact, Overflow, Rounded,</font>
<font color="green"> 376.            Underflow, InvalidOperation, Subnormal]</font>
<font color="black"> 377. </font>
<font color="black"> 378. # Map conditions (per the spec) to signals</font>
<font color="green"> 379. _condition_map = {ConversionSyntax:InvalidOperation,</font>
<font color="green"> 380.                   DivisionImpossible:InvalidOperation,</font>
<font color="green"> 381.                   DivisionUndefined:InvalidOperation,</font>
<font color="green"> 382.                   InvalidContext:InvalidOperation}</font>
<font color="black"> 383. </font>
<font color="black"> 384. ##### Context Functions ##################################################</font>
<font color="black"> 385. </font>
<font color="black"> 386. # The getcontext() and setcontext() function manage access to a thread-local</font>
<font color="black"> 387. # current context.  Py2.4 offers direct support for thread locals.  If that</font>
<font color="black"> 388. # is not available, use threading.currentThread() which is slower but will</font>
<font color="black"> 389. # work for older Pythons.  If threads are not part of the build, create a</font>
<font color="black"> 390. # mock threading object with threading.local() returning the module namespace.</font>
<font color="black"> 391. </font>
<font color="green"> 392. try:</font>
<font color="green"> 393.     import threading</font>
<font color="red"> 394. except ImportError:</font>
<font color="black"> 395.     # Python was compiled without threads; create a mock object instead</font>
<font color="red"> 396.     import sys</font>
<font color="red"> 397.     class MockThreading(object):</font>
<font color="red"> 398.         def local(self, sys=sys):</font>
<font color="red"> 399.             return sys.modules[__name__]</font>
<font color="red"> 400.     threading = MockThreading()</font>
<font color="red"> 401.     del sys, MockThreading</font>
<font color="black"> 402. </font>
<font color="green"> 403. try:</font>
<font color="green"> 404.     threading.local</font>
<font color="black"> 405. </font>
<font color="red"> 406. except AttributeError:</font>
<font color="black"> 407. </font>
<font color="black"> 408.     # To fix reloading, force it to create a new context</font>
<font color="black"> 409.     # Old contexts have different exceptions in their dicts, making problems.</font>
<font color="red"> 410.     if hasattr(threading.currentThread(), '__decimal_context__'):</font>
<font color="red"> 411.         del threading.currentThread().__decimal_context__</font>
<font color="black"> 412. </font>
<font color="red"> 413.     def setcontext(context):</font>
<font color="black"> 414.         &quot;&quot;&quot;Set this thread's context to context.&quot;&quot;&quot;</font>
<font color="red"> 415.         if context in (DefaultContext, BasicContext, ExtendedContext):</font>
<font color="red"> 416.             context = context.copy()</font>
<font color="red"> 417.             context.clear_flags()</font>
<font color="red"> 418.         threading.currentThread().__decimal_context__ = context</font>
<font color="black"> 419. </font>
<font color="red"> 420.     def getcontext():</font>
<font color="black"> 421.         &quot;&quot;&quot;Returns this thread's context.</font>
<font color="black"> 422. </font>
<font color="black"> 423.         If this thread does not yet have a context, returns</font>
<font color="black"> 424.         a new context and sets this thread's context.</font>
<font color="black"> 425.         New contexts are copies of DefaultContext.</font>
<font color="black"> 426.         &quot;&quot;&quot;</font>
<font color="red"> 427.         try:</font>
<font color="red"> 428.             return threading.currentThread().__decimal_context__</font>
<font color="red"> 429.         except AttributeError:</font>
<font color="red"> 430.             context = Context()</font>
<font color="red"> 431.             threading.currentThread().__decimal_context__ = context</font>
<font color="red"> 432.             return context</font>
<font color="black"> 433. </font>
<font color="black"> 434. else:</font>
<font color="black"> 435. </font>
<font color="green"> 436.     local = threading.local()</font>
<font color="green"> 437.     if hasattr(local, '__decimal_context__'):</font>
<font color="red"> 438.         del local.__decimal_context__</font>
<font color="black"> 439. </font>
<font color="green"> 440.     def getcontext(_local=local):</font>
<font color="black"> 441.         &quot;&quot;&quot;Returns this thread's context.</font>
<font color="black"> 442. </font>
<font color="black"> 443.         If this thread does not yet have a context, returns</font>
<font color="black"> 444.         a new context and sets this thread's context.</font>
<font color="black"> 445.         New contexts are copies of DefaultContext.</font>
<font color="black"> 446.         &quot;&quot;&quot;</font>
<font color="red"> 447.         try:</font>
<font color="red"> 448.             return _local.__decimal_context__</font>
<font color="red"> 449.         except AttributeError:</font>
<font color="red"> 450.             context = Context()</font>
<font color="red"> 451.             _local.__decimal_context__ = context</font>
<font color="red"> 452.             return context</font>
<font color="black"> 453. </font>
<font color="green"> 454.     def setcontext(context, _local=local):</font>
<font color="black"> 455.         &quot;&quot;&quot;Set this thread's context to context.&quot;&quot;&quot;</font>
<font color="red"> 456.         if context in (DefaultContext, BasicContext, ExtendedContext):</font>
<font color="red"> 457.             context = context.copy()</font>
<font color="red"> 458.             context.clear_flags()</font>
<font color="red"> 459.         _local.__decimal_context__ = context</font>
<font color="black"> 460. </font>
<font color="green"> 461.     del threading, local        # Don't contaminate the namespace</font>
<font color="black"> 462. </font>
<font color="green"> 463. def localcontext(ctx=None):</font>
<font color="black"> 464.     &quot;&quot;&quot;Return a context manager for a copy of the supplied context</font>
<font color="black"> 465. </font>
<font color="black"> 466.     Uses a copy of the current context if no context is specified</font>
<font color="black"> 467.     The returned context manager creates a local decimal context</font>
<font color="black"> 468.     in a with statement:</font>
<font color="black"> 469.         def sin(x):</font>
<font color="black"> 470.              with localcontext() as ctx:</font>
<font color="black"> 471.                  ctx.prec += 2</font>
<font color="black"> 472.                  # Rest of sin calculation algorithm</font>
<font color="black"> 473.                  # uses a precision 2 greater than normal</font>
<font color="black"> 474.              return +s  # Convert result to normal precision</font>
<font color="black"> 475. </font>
<font color="black"> 476.          def sin(x):</font>
<font color="black"> 477.              with localcontext(ExtendedContext):</font>
<font color="black"> 478.                  # Rest of sin calculation algorithm</font>
<font color="black"> 479.                  # uses the Extended Context from the</font>
<font color="black"> 480.                  # General Decimal Arithmetic Specification</font>
<font color="black"> 481.              return +s  # Convert result to normal context</font>
<font color="black"> 482. </font>
<font color="black"> 483.     &gt;&gt;&gt; setcontext(DefaultContext)</font>
<font color="black"> 484.     &gt;&gt;&gt; print getcontext().prec</font>
<font color="black"> 485.     28</font>
<font color="black"> 486.     &gt;&gt;&gt; with localcontext():</font>
<font color="black"> 487.     ...     ctx = getcontext()</font>
<font color="black"> 488.     ...     ctx.prec += 2</font>
<font color="black"> 489.     ...     print ctx.prec</font>
<font color="black"> 490.     ...</font>
<font color="black"> 491.     30</font>
<font color="black"> 492.     &gt;&gt;&gt; with localcontext(ExtendedContext):</font>
<font color="black"> 493.     ...     print getcontext().prec</font>
<font color="black"> 494.     ...</font>
<font color="black"> 495.     9</font>
<font color="black"> 496.     &gt;&gt;&gt; print getcontext().prec</font>
<font color="black"> 497.     28</font>
<font color="black"> 498.     &quot;&quot;&quot;</font>
<font color="red"> 499.     if ctx is None: ctx = getcontext()</font>
<font color="red"> 500.     return _ContextManager(ctx)</font>
<font color="black"> 501. </font>
<font color="black"> 502. </font>
<font color="black"> 503. ##### Decimal class #######################################################</font>
<font color="black"> 504. </font>
<font color="green"> 505. class Decimal(object):</font>
<font color="green"> 506.     &quot;&quot;&quot;Floating point class for decimal arithmetic.&quot;&quot;&quot;</font>
<font color="black"> 507. </font>
<font color="green"> 508.     __slots__ = ('_exp','_int','_sign', '_is_special')</font>
<font color="black"> 509.     # Generally, the value of the Decimal instance is given by</font>
<font color="black"> 510.     #  (-1)**_sign * _int * 10**_exp</font>
<font color="black"> 511.     # Special values are signified by _is_special == True</font>
<font color="black"> 512. </font>
<font color="black"> 513.     # We're immutable, so use __new__ not __init__</font>
<font color="green"> 514.     def __new__(cls, value=&quot;0&quot;, context=None):</font>
<font color="black"> 515.         &quot;&quot;&quot;Create a decimal point instance.</font>
<font color="black"> 516. </font>
<font color="black"> 517.         &gt;&gt;&gt; Decimal('3.14')              # string input</font>
<font color="black"> 518.         Decimal('3.14')</font>
<font color="black"> 519.         &gt;&gt;&gt; Decimal((0, (3, 1, 4), -2))  # tuple (sign, digit_tuple, exponent)</font>
<font color="black"> 520.         Decimal('3.14')</font>
<font color="black"> 521.         &gt;&gt;&gt; Decimal(314)                 # int or long</font>
<font color="black"> 522.         Decimal('314')</font>
<font color="black"> 523.         &gt;&gt;&gt; Decimal(Decimal(314))        # another decimal instance</font>
<font color="black"> 524.         Decimal('314')</font>
<font color="black"> 525.         &gt;&gt;&gt; Decimal('  3.14  \\n')        # leading and trailing whitespace okay</font>
<font color="black"> 526.         Decimal('3.14')</font>
<font color="black"> 527.         &quot;&quot;&quot;</font>
<font color="black"> 528. </font>
<font color="black"> 529.         # Note that the coefficient, self._int, is actually stored as</font>
<font color="black"> 530.         # a string rather than as a tuple of digits.  This speeds up</font>
<font color="black"> 531.         # the &quot;digits to integer&quot; and &quot;integer to digits&quot; conversions</font>
<font color="black"> 532.         # that are used in almost every arithmetic operation on</font>
<font color="black"> 533.         # Decimals.  This is an internal detail: the as_tuple function</font>
<font color="black"> 534.         # and the Decimal constructor still deal with tuples of</font>
<font color="black"> 535.         # digits.</font>
<font color="black"> 536. </font>
<font color="green"> 537.         self = object.__new__(cls)</font>
<font color="black"> 538. </font>
<font color="black"> 539.         # From a string</font>
<font color="black"> 540.         # REs insist on real strings, so we can too.</font>
<font color="green"> 541.         if isinstance(value, basestring):</font>
<font color="green"> 542.             m = _parser(value.strip())</font>
<font color="green"> 543.             if m is None:</font>
<font color="red"> 544.                 if context is None:</font>
<font color="red"> 545.                     context = getcontext()</font>
<font color="red"> 546.                 return context._raise_error(ConversionSyntax,</font>
<font color="red"> 547.                                 &quot;Invalid literal for Decimal: %r&quot; % value)</font>
<font color="black"> 548. </font>
<font color="green"> 549.             if m.group('sign') == &quot;-&quot;:</font>
<font color="green"> 550.                 self._sign = 1</font>
<font color="black"> 551.             else:</font>
<font color="green"> 552.                 self._sign = 0</font>
<font color="green"> 553.             intpart = m.group('int')</font>
<font color="green"> 554.             if intpart is not None:</font>
<font color="black"> 555.                 # finite number</font>
<font color="red"> 556.                 fracpart = m.group('frac') or ''</font>
<font color="red"> 557.                 exp = int(m.group('exp') or '0')</font>
<font color="red"> 558.                 self._int = str(int(intpart+fracpart))</font>
<font color="red"> 559.                 self._exp = exp - len(fracpart)</font>
<font color="red"> 560.                 self._is_special = False</font>
<font color="black"> 561.             else:</font>
<font color="green"> 562.                 diag = m.group('diag')</font>
<font color="green"> 563.                 if diag is not None:</font>
<font color="black"> 564.                     # NaN</font>
<font color="green"> 565.                     self._int = str(int(diag or '0')).lstrip('0')</font>
<font color="green"> 566.                     if m.group('signal'):</font>
<font color="red"> 567.                         self._exp = 'N'</font>
<font color="black"> 568.                     else:</font>
<font color="green"> 569.                         self._exp = 'n'</font>
<font color="black"> 570.                 else:</font>
<font color="black"> 571.                     # infinity</font>
<font color="green"> 572.                     self._int = '0'</font>
<font color="green"> 573.                     self._exp = 'F'</font>
<font color="green"> 574.                 self._is_special = True</font>
<font color="green"> 575.             return self</font>
<font color="black"> 576. </font>
<font color="black"> 577.         # From an integer</font>
<font color="green"> 578.         if isinstance(value, (int,long)):</font>
<font color="green"> 579.             if value &gt;= 0:</font>
<font color="green"> 580.                 self._sign = 0</font>
<font color="black"> 581.             else:</font>
<font color="green"> 582.                 self._sign = 1</font>
<font color="green"> 583.             self._exp = 0</font>
<font color="green"> 584.             self._int = str(abs(value))</font>
<font color="green"> 585.             self._is_special = False</font>
<font color="green"> 586.             return self</font>
<font color="black"> 587. </font>
<font color="black"> 588.         # From another decimal</font>
<font color="red"> 589.         if isinstance(value, Decimal):</font>
<font color="red"> 590.             self._exp  = value._exp</font>
<font color="red"> 591.             self._sign = value._sign</font>
<font color="red"> 592.             self._int  = value._int</font>
<font color="red"> 593.             self._is_special  = value._is_special</font>
<font color="red"> 594.             return self</font>
<font color="black"> 595. </font>
<font color="black"> 596.         # From an internal working value</font>
<font color="red"> 597.         if isinstance(value, _WorkRep):</font>
<font color="red"> 598.             self._sign = value.sign</font>
<font color="red"> 599.             self._int = str(value.int)</font>
<font color="red"> 600.             self._exp = int(value.exp)</font>
<font color="red"> 601.             self._is_special = False</font>
<font color="red"> 602.             return self</font>
<font color="black"> 603. </font>
<font color="black"> 604.         # tuple/list conversion (possibly from as_tuple())</font>
<font color="red"> 605.         if isinstance(value, (list,tuple)):</font>
<font color="red"> 606.             if len(value) != 3:</font>
<font color="red"> 607.                 raise ValueError('Invalid tuple size in creation of Decimal '</font>
<font color="black"> 608.                                  'from list or tuple.  The list or tuple '</font>
<font color="black"> 609.                                  'should have exactly three elements.')</font>
<font color="black"> 610.             # process sign.  The isinstance test rejects floats</font>
<font color="red"> 611.             if not (isinstance(value[0], (int, long)) and value[0] in (0,1)):</font>
<font color="red"> 612.                 raise ValueError(&quot;Invalid sign.  The first value in the tuple &quot;</font>
<font color="black"> 613.                                  &quot;should be an integer; either 0 for a &quot;</font>
<font color="black"> 614.                                  &quot;positive number or 1 for a negative number.&quot;)</font>
<font color="red"> 615.             self._sign = value[0]</font>
<font color="red"> 616.             if value[2] == 'F':</font>
<font color="black"> 617.                 # infinity: value[1] is ignored</font>
<font color="red"> 618.                 self._int = '0'</font>
<font color="red"> 619.                 self._exp = value[2]</font>
<font color="red"> 620.                 self._is_special = True</font>
<font color="black"> 621.             else:</font>
<font color="black"> 622.                 # process and validate the digits in value[1]</font>
<font color="red"> 623.                 digits = []</font>
<font color="red"> 624.                 for digit in value[1]:</font>
<font color="red"> 625.                     if isinstance(digit, (int, long)) and 0 &lt;= digit &lt;= 9:</font>
<font color="black"> 626.                         # skip leading zeros</font>
<font color="red"> 627.                         if digits or digit != 0:</font>
<font color="red"> 628.                             digits.append(digit)</font>
<font color="black"> 629.                     else:</font>
<font color="red"> 630.                         raise ValueError(&quot;The second value in the tuple must &quot;</font>
<font color="black"> 631.                                          &quot;be composed of integers in the range &quot;</font>
<font color="black"> 632.                                          &quot;0 through 9.&quot;)</font>
<font color="red"> 633.                 if value[2] in ('n', 'N'):</font>
<font color="black"> 634.                     # NaN: digits form the diagnostic</font>
<font color="red"> 635.                     self._int = ''.join(map(str, digits))</font>
<font color="red"> 636.                     self._exp = value[2]</font>
<font color="red"> 637.                     self._is_special = True</font>
<font color="red"> 638.                 elif isinstance(value[2], (int, long)):</font>
<font color="black"> 639.                     # finite number: digits give the coefficient</font>
<font color="red"> 640.                     self._int = ''.join(map(str, digits or [0]))</font>
<font color="red"> 641.                     self._exp = value[2]</font>
<font color="red"> 642.                     self._is_special = False</font>
<font color="black"> 643.                 else:</font>
<font color="red"> 644.                     raise ValueError(&quot;The third value in the tuple must &quot;</font>
<font color="black"> 645.                                      &quot;be an integer, or one of the &quot;</font>
<font color="black"> 646.                                      &quot;strings 'F', 'n', 'N'.&quot;)</font>
<font color="red"> 647.             return self</font>
<font color="black"> 648. </font>
<font color="red"> 649.         if isinstance(value, float):</font>
<font color="red"> 650.             value = Decimal.from_float(value)</font>
<font color="red"> 651.             self._exp  = value._exp</font>
<font color="red"> 652.             self._sign = value._sign</font>
<font color="red"> 653.             self._int  = value._int</font>
<font color="red"> 654.             self._is_special  = value._is_special</font>
<font color="red"> 655.             return self</font>
<font color="black"> 656. </font>
<font color="red"> 657.         raise TypeError(&quot;Cannot convert %r to Decimal&quot; % value)</font>
<font color="black"> 658. </font>
<font color="black"> 659.     # @classmethod, but @decorator is not valid Python 2.3 syntax, so</font>
<font color="black"> 660.     # don't use it (see notes on Py2.3 compatibility at top of file)</font>
<font color="green"> 661.     def from_float(cls, f):</font>
<font color="black"> 662.         &quot;&quot;&quot;Converts a float to a decimal number, exactly.</font>
<font color="black"> 663. </font>
<font color="black"> 664.         Note that Decimal.from_float(0.1) is not the same as Decimal('0.1').</font>
<font color="black"> 665.         Since 0.1 is not exactly representable in binary floating point, the</font>
<font color="black"> 666.         value is stored as the nearest representable value which is</font>
<font color="black"> 667.         0x1.999999999999ap-4.  The exact equivalent of the value in decimal</font>
<font color="black"> 668.         is 0.1000000000000000055511151231257827021181583404541015625.</font>
<font color="black"> 669. </font>
<font color="black"> 670.         &gt;&gt;&gt; Decimal.from_float(0.1)</font>
<font color="black"> 671.         Decimal('0.1000000000000000055511151231257827021181583404541015625')</font>
<font color="black"> 672.         &gt;&gt;&gt; Decimal.from_float(float('nan'))</font>
<font color="black"> 673.         Decimal('NaN')</font>
<font color="black"> 674.         &gt;&gt;&gt; Decimal.from_float(float('inf'))</font>
<font color="black"> 675.         Decimal('Infinity')</font>
<font color="black"> 676.         &gt;&gt;&gt; Decimal.from_float(-float('inf'))</font>
<font color="black"> 677.         Decimal('-Infinity')</font>
<font color="black"> 678.         &gt;&gt;&gt; Decimal.from_float(-0.0)</font>
<font color="black"> 679.         Decimal('-0')</font>
<font color="black"> 680. </font>
<font color="black"> 681.         &quot;&quot;&quot;</font>
<font color="red"> 682.         if isinstance(f, (int, long)):        # handle integer inputs</font>
<font color="red"> 683.             return cls(f)</font>
<font color="red"> 684.         if _math.isinf(f) or _math.isnan(f):  # raises TypeError if not a float</font>
<font color="red"> 685.             return cls(repr(f))</font>
<font color="red"> 686.         if _math.copysign(1.0, f) == 1.0:</font>
<font color="red"> 687.             sign = 0</font>
<font color="black"> 688.         else:</font>
<font color="red"> 689.             sign = 1</font>
<font color="red"> 690.         n, d = abs(f).as_integer_ratio()</font>
<font color="red"> 691.         k = d.bit_length() - 1</font>
<font color="red"> 692.         result = _dec_from_triple(sign, str(n*5**k), -k)</font>
<font color="red"> 693.         if cls is Decimal:</font>
<font color="red"> 694.             return result</font>
<font color="black"> 695.         else:</font>
<font color="red"> 696.             return cls(result)</font>
<font color="green"> 697.     from_float = classmethod(from_float)</font>
<font color="black"> 698. </font>
<font color="green"> 699.     def _isnan(self):</font>
<font color="black"> 700.         &quot;&quot;&quot;Returns whether the number is not actually one.</font>
<font color="black"> 701. </font>
<font color="black"> 702.         0 if a number</font>
<font color="black"> 703.         1 if NaN</font>
<font color="black"> 704.         2 if sNaN</font>
<font color="black"> 705.         &quot;&quot;&quot;</font>
<font color="red"> 706.         if self._is_special:</font>
<font color="red"> 707.             exp = self._exp</font>
<font color="red"> 708.             if exp == 'n':</font>
<font color="red"> 709.                 return 1</font>
<font color="red"> 710.             elif exp == 'N':</font>
<font color="red"> 711.                 return 2</font>
<font color="red"> 712.         return 0</font>
<font color="black"> 713. </font>
<font color="green"> 714.     def _isinfinity(self):</font>
<font color="black"> 715.         &quot;&quot;&quot;Returns whether the number is infinite</font>
<font color="black"> 716. </font>
<font color="black"> 717.         0 if finite or not a number</font>
<font color="black"> 718.         1 if +INF</font>
<font color="black"> 719.         -1 if -INF</font>
<font color="black"> 720.         &quot;&quot;&quot;</font>
<font color="red"> 721.         if self._exp == 'F':</font>
<font color="red"> 722.             if self._sign:</font>
<font color="red"> 723.                 return -1</font>
<font color="red"> 724.             return 1</font>
<font color="red"> 725.         return 0</font>
<font color="black"> 726. </font>
<font color="green"> 727.     def _check_nans(self, other=None, context=None):</font>
<font color="black"> 728.         &quot;&quot;&quot;Returns whether the number is not actually one.</font>
<font color="black"> 729. </font>
<font color="black"> 730.         if self, other are sNaN, signal</font>
<font color="black"> 731.         if self, other are NaN return nan</font>
<font color="black"> 732.         return 0</font>
<font color="black"> 733. </font>
<font color="black"> 734.         Done before operations.</font>
<font color="black"> 735.         &quot;&quot;&quot;</font>
<font color="black"> 736. </font>
<font color="red"> 737.         self_is_nan = self._isnan()</font>
<font color="red"> 738.         if other is None:</font>
<font color="red"> 739.             other_is_nan = False</font>
<font color="black"> 740.         else:</font>
<font color="red"> 741.             other_is_nan = other._isnan()</font>
<font color="black"> 742. </font>
<font color="red"> 743.         if self_is_nan or other_is_nan:</font>
<font color="red"> 744.             if context is None:</font>
<font color="red"> 745.                 context = getcontext()</font>
<font color="black"> 746. </font>
<font color="red"> 747.             if self_is_nan == 2:</font>
<font color="red"> 748.                 return context._raise_error(InvalidOperation, 'sNaN',</font>
<font color="red"> 749.                                         self)</font>
<font color="red"> 750.             if other_is_nan == 2:</font>
<font color="red"> 751.                 return context._raise_error(InvalidOperation, 'sNaN',</font>
<font color="red"> 752.                                         other)</font>
<font color="red"> 753.             if self_is_nan:</font>
<font color="red"> 754.                 return self._fix_nan(context)</font>
<font color="black"> 755. </font>
<font color="red"> 756.             return other._fix_nan(context)</font>
<font color="red"> 757.         return 0</font>
<font color="black"> 758. </font>
<font color="green"> 759.     def _compare_check_nans(self, other, context):</font>
<font color="black"> 760.         &quot;&quot;&quot;Version of _check_nans used for the signaling comparisons</font>
<font color="black"> 761.         compare_signal, __le__, __lt__, __ge__, __gt__.</font>
<font color="black"> 762. </font>
<font color="black"> 763.         Signal InvalidOperation if either self or other is a (quiet</font>
<font color="black"> 764.         or signaling) NaN.  Signaling NaNs take precedence over quiet</font>
<font color="black"> 765.         NaNs.</font>
<font color="black"> 766. </font>
<font color="black"> 767.         Return 0 if neither operand is a NaN.</font>
<font color="black"> 768. </font>
<font color="black"> 769.         &quot;&quot;&quot;</font>
<font color="red"> 770.         if context is None:</font>
<font color="red"> 771.             context = getcontext()</font>
<font color="black"> 772. </font>
<font color="red"> 773.         if self._is_special or other._is_special:</font>
<font color="red"> 774.             if self.is_snan():</font>
<font color="red"> 775.                 return context._raise_error(InvalidOperation,</font>
<font color="red"> 776.                                             'comparison involving sNaN',</font>
<font color="red"> 777.                                             self)</font>
<font color="red"> 778.             elif other.is_snan():</font>
<font color="red"> 779.                 return context._raise_error(InvalidOperation,</font>
<font color="red"> 780.                                             'comparison involving sNaN',</font>
<font color="red"> 781.                                             other)</font>
<font color="red"> 782.             elif self.is_qnan():</font>
<font color="red"> 783.                 return context._raise_error(InvalidOperation,</font>
<font color="red"> 784.                                             'comparison involving NaN',</font>
<font color="red"> 785.                                             self)</font>
<font color="red"> 786.             elif other.is_qnan():</font>
<font color="red"> 787.                 return context._raise_error(InvalidOperation,</font>
<font color="red"> 788.                                             'comparison involving NaN',</font>
<font color="red"> 789.                                             other)</font>
<font color="red"> 790.         return 0</font>
<font color="black"> 791. </font>
<font color="green"> 792.     def __nonzero__(self):</font>
<font color="black"> 793.         &quot;&quot;&quot;Return True if self is nonzero; otherwise return False.</font>
<font color="black"> 794. </font>
<font color="black"> 795.         NaNs and infinities are considered nonzero.</font>
<font color="black"> 796.         &quot;&quot;&quot;</font>
<font color="red"> 797.         return self._is_special or self._int != '0'</font>
<font color="black"> 798. </font>
<font color="green"> 799.     def _cmp(self, other):</font>
<font color="black"> 800.         &quot;&quot;&quot;Compare the two non-NaN decimal instances self and other.</font>
<font color="black"> 801. </font>
<font color="black"> 802.         Returns -1 if self &lt; other, 0 if self == other and 1</font>
<font color="black"> 803.         if self &gt; other.  This routine is for internal use only.&quot;&quot;&quot;</font>
<font color="black"> 804. </font>
<font color="red"> 805.         if self._is_special or other._is_special:</font>
<font color="red"> 806.             self_inf = self._isinfinity()</font>
<font color="red"> 807.             other_inf = other._isinfinity()</font>
<font color="red"> 808.             if self_inf == other_inf:</font>
<font color="red"> 809.                 return 0</font>
<font color="red"> 810.             elif self_inf &lt; other_inf:</font>
<font color="red"> 811.                 return -1</font>
<font color="black"> 812.             else:</font>
<font color="red"> 813.                 return 1</font>
<font color="black"> 814. </font>
<font color="black"> 815.         # check for zeros;  Decimal('0') == Decimal('-0')</font>
<font color="red"> 816.         if not self:</font>
<font color="red"> 817.             if not other:</font>
<font color="red"> 818.                 return 0</font>
<font color="black"> 819.             else:</font>
<font color="red"> 820.                 return -((-1)**other._sign)</font>
<font color="red"> 821.         if not other:</font>
<font color="red"> 822.             return (-1)**self._sign</font>
<font color="black"> 823. </font>
<font color="black"> 824.         # If different signs, neg one is less</font>
<font color="red"> 825.         if other._sign &lt; self._sign:</font>
<font color="red"> 826.             return -1</font>
<font color="red"> 827.         if self._sign &lt; other._sign:</font>
<font color="red"> 828.             return 1</font>
<font color="black"> 829. </font>
<font color="red"> 830.         self_adjusted = self.adjusted()</font>
<font color="red"> 831.         other_adjusted = other.adjusted()</font>
<font color="red"> 832.         if self_adjusted == other_adjusted:</font>
<font color="red"> 833.             self_padded = self._int + '0'*(self._exp - other._exp)</font>
<font color="red"> 834.             other_padded = other._int + '0'*(other._exp - self._exp)</font>
<font color="red"> 835.             if self_padded == other_padded:</font>
<font color="red"> 836.                 return 0</font>
<font color="red"> 837.             elif self_padded &lt; other_padded:</font>
<font color="red"> 838.                 return -(-1)**self._sign</font>
<font color="black"> 839.             else:</font>
<font color="red"> 840.                 return (-1)**self._sign</font>
<font color="red"> 841.         elif self_adjusted &gt; other_adjusted:</font>
<font color="red"> 842.             return (-1)**self._sign</font>
<font color="black"> 843.         else: # self_adjusted &lt; other_adjusted</font>
<font color="red"> 844.             return -((-1)**self._sign)</font>
<font color="black"> 845. </font>
<font color="black"> 846.     # Note: The Decimal standard doesn't cover rich comparisons for</font>
<font color="black"> 847.     # Decimals.  In particular, the specification is silent on the</font>
<font color="black"> 848.     # subject of what should happen for a comparison involving a NaN.</font>
<font color="black"> 849.     # We take the following approach:</font>
<font color="black"> 850.     #</font>
<font color="black"> 851.     #   == comparisons involving a quiet NaN always return False</font>
<font color="black"> 852.     #   != comparisons involving a quiet NaN always return True</font>
<font color="black"> 853.     #   == or != comparisons involving a signaling NaN signal</font>
<font color="black"> 854.     #      InvalidOperation, and return False or True as above if the</font>
<font color="black"> 855.     #      InvalidOperation is not trapped.</font>
<font color="black"> 856.     #   &lt;, &gt;, &lt;= and &gt;= comparisons involving a (quiet or signaling)</font>
<font color="black"> 857.     #      NaN signal InvalidOperation, and return False if the</font>
<font color="black"> 858.     #      InvalidOperation is not trapped.</font>
<font color="black"> 859.     #</font>
<font color="black"> 860.     # This behavior is designed to conform as closely as possible to</font>
<font color="black"> 861.     # that specified by IEEE 754.</font>
<font color="black"> 862. </font>
<font color="green"> 863.     def __eq__(self, other, context=None):</font>
<font color="red"> 864.         other = _convert_other(other, allow_float=True)</font>
<font color="red"> 865.         if other is NotImplemented:</font>
<font color="red"> 866.             return other</font>
<font color="red"> 867.         if self._check_nans(other, context):</font>
<font color="red"> 868.             return False</font>
<font color="red"> 869.         return self._cmp(other) == 0</font>
<font color="black"> 870. </font>
<font color="green"> 871.     def __ne__(self, other, context=None):</font>
<font color="red"> 872.         other = _convert_other(other, allow_float=True)</font>
<font color="red"> 873.         if other is NotImplemented:</font>
<font color="red"> 874.             return other</font>
<font color="red"> 875.         if self._check_nans(other, context):</font>
<font color="red"> 876.             return True</font>
<font color="red"> 877.         return self._cmp(other) != 0</font>
<font color="black"> 878. </font>
<font color="green"> 879.     def __lt__(self, other, context=None):</font>
<font color="red"> 880.         other = _convert_other(other, allow_float=True)</font>
<font color="red"> 881.         if other is NotImplemented:</font>
<font color="red"> 882.             return other</font>
<font color="red"> 883.         ans = self._compare_check_nans(other, context)</font>
<font color="red"> 884.         if ans:</font>
<font color="red"> 885.             return False</font>
<font color="red"> 886.         return self._cmp(other) &lt; 0</font>
<font color="black"> 887. </font>
<font color="green"> 888.     def __le__(self, other, context=None):</font>
<font color="red"> 889.         other = _convert_other(other, allow_float=True)</font>
<font color="red"> 890.         if other is NotImplemented:</font>
<font color="red"> 891.             return other</font>
<font color="red"> 892.         ans = self._compare_check_nans(other, context)</font>
<font color="red"> 893.         if ans:</font>
<font color="red"> 894.             return False</font>
<font color="red"> 895.         return self._cmp(other) &lt;= 0</font>
<font color="black"> 896. </font>
<font color="green"> 897.     def __gt__(self, other, context=None):</font>
<font color="red"> 898.         other = _convert_other(other, allow_float=True)</font>
<font color="red"> 899.         if other is NotImplemented:</font>
<font color="red"> 900.             return other</font>
<font color="red"> 901.         ans = self._compare_check_nans(other, context)</font>
<font color="red"> 902.         if ans:</font>
<font color="red"> 903.             return False</font>
<font color="red"> 904.         return self._cmp(other) &gt; 0</font>
<font color="black"> 905. </font>
<font color="green"> 906.     def __ge__(self, other, context=None):</font>
<font color="red"> 907.         other = _convert_other(other, allow_float=True)</font>
<font color="red"> 908.         if other is NotImplemented:</font>
<font color="red"> 909.             return other</font>
<font color="red"> 910.         ans = self._compare_check_nans(other, context)</font>
<font color="red"> 911.         if ans:</font>
<font color="red"> 912.             return False</font>
<font color="red"> 913.         return self._cmp(other) &gt;= 0</font>
<font color="black"> 914. </font>
<font color="green"> 915.     def compare(self, other, context=None):</font>
<font color="black"> 916.         &quot;&quot;&quot;Compares one to another.</font>
<font color="black"> 917. </font>
<font color="black"> 918.         -1 =&gt; a &lt; b</font>
<font color="black"> 919.         0  =&gt; a = b</font>
<font color="black"> 920.         1  =&gt; a &gt; b</font>
<font color="black"> 921.         NaN =&gt; one is NaN</font>
<font color="black"> 922.         Like __cmp__, but returns Decimal instances.</font>
<font color="black"> 923.         &quot;&quot;&quot;</font>
<font color="red"> 924.         other = _convert_other(other, raiseit=True)</font>
<font color="black"> 925. </font>
<font color="black"> 926.         # Compare(NaN, NaN) = NaN</font>
<font color="red"> 927.         if (self._is_special or other and other._is_special):</font>
<font color="red"> 928.             ans = self._check_nans(other, context)</font>
<font color="red"> 929.             if ans:</font>
<font color="red"> 930.                 return ans</font>
<font color="black"> 931. </font>
<font color="red"> 932.         return Decimal(self._cmp(other))</font>
<font color="black"> 933. </font>
<font color="green"> 934.     def __hash__(self):</font>
<font color="black"> 935.         &quot;&quot;&quot;x.__hash__() &lt;==&gt; hash(x)&quot;&quot;&quot;</font>
<font color="black"> 936.         # Decimal integers must hash the same as the ints</font>
<font color="black"> 937.         #</font>
<font color="black"> 938.         # The hash of a nonspecial noninteger Decimal must depend only</font>
<font color="black"> 939.         # on the value of that Decimal, and not on its representation.</font>
<font color="black"> 940.         # For example: hash(Decimal('100E-1')) == hash(Decimal('10')).</font>
<font color="black"> 941. </font>
<font color="black"> 942.         # Equality comparisons involving signaling nans can raise an</font>
<font color="black"> 943.         # exception; since equality checks are implicitly and</font>
<font color="black"> 944.         # unpredictably used when checking set and dict membership, we</font>
<font color="black"> 945.         # prevent signaling nans from being used as set elements or</font>
<font color="black"> 946.         # dict keys by making __hash__ raise an exception.</font>
<font color="red"> 947.         if self._is_special:</font>
<font color="red"> 948.             if self.is_snan():</font>
<font color="red"> 949.                 raise TypeError('Cannot hash a signaling NaN value.')</font>
<font color="red"> 950.             elif self.is_nan():</font>
<font color="black"> 951.                 # 0 to match hash(float('nan'))</font>
<font color="red"> 952.                 return 0</font>
<font color="black"> 953.             else:</font>
<font color="black"> 954.                 # values chosen to match hash(float('inf')) and</font>
<font color="black"> 955.                 # hash(float('-inf')).</font>
<font color="red"> 956.                 if self._sign:</font>
<font color="red"> 957.                     return -271828</font>
<font color="black"> 958.                 else:</font>
<font color="red"> 959.                     return 314159</font>
<font color="black"> 960. </font>
<font color="black"> 961.         # In Python 2.7, we're allowing comparisons (but not</font>
<font color="black"> 962.         # arithmetic operations) between floats and Decimals;  so if</font>
<font color="black"> 963.         # a Decimal instance is exactly representable as a float then</font>
<font color="black"> 964.         # its hash should match that of the float.</font>
<font color="red"> 965.         self_as_float = float(self)</font>
<font color="red"> 966.         if Decimal.from_float(self_as_float) == self:</font>
<font color="red"> 967.             return hash(self_as_float)</font>
<font color="black"> 968. </font>
<font color="red"> 969.         if self._isinteger():</font>
<font color="red"> 970.             op = _WorkRep(self.to_integral_value())</font>
<font color="black"> 971.             # to make computation feasible for Decimals with large</font>
<font color="black"> 972.             # exponent, we use the fact that hash(n) == hash(m) for</font>
<font color="black"> 973.             # any two nonzero integers n and m such that (i) n and m</font>
<font color="black"> 974.             # have the same sign, and (ii) n is congruent to m modulo</font>
<font color="black"> 975.             # 2**64-1.  So we can replace hash((-1)**s*c*10**e) with</font>
<font color="black"> 976.             # hash((-1)**s*c*pow(10, e, 2**64-1).</font>
<font color="red"> 977.             return hash((-1)**op.sign*op.int*pow(10, op.exp, 2**64-1))</font>
<font color="black"> 978.         # The value of a nonzero nonspecial Decimal instance is</font>
<font color="black"> 979.         # faithfully represented by the triple consisting of its sign,</font>
<font color="black"> 980.         # its adjusted exponent, and its coefficient with trailing</font>
<font color="black"> 981.         # zeros removed.</font>
<font color="red"> 982.         return hash((self._sign,</font>
<font color="red"> 983.                      self._exp+len(self._int),</font>
<font color="red"> 984.                      self._int.rstrip('0')))</font>
<font color="black"> 985. </font>
<font color="green"> 986.     def as_tuple(self):</font>
<font color="black"> 987.         &quot;&quot;&quot;Represents the number as a triple tuple.</font>
<font color="black"> 988. </font>
<font color="black"> 989.         To show the internals exactly as they are.</font>
<font color="black"> 990.         &quot;&quot;&quot;</font>
<font color="red"> 991.         return DecimalTuple(self._sign, tuple(map(int, self._int)), self._exp)</font>
<font color="black"> 992. </font>
<font color="green"> 993.     def __repr__(self):</font>
<font color="black"> 994.         &quot;&quot;&quot;Represents the number as an instance of Decimal.&quot;&quot;&quot;</font>
<font color="black"> 995.         # Invariant:  eval(repr(d)) == d</font>
<font color="red"> 996.         return &quot;Decimal('%s')&quot; % str(self)</font>
<font color="black"> 997. </font>
<font color="green"> 998.     def __str__(self, eng=False, context=None):</font>
<font color="black"> 999.         &quot;&quot;&quot;Return string representation of the number in scientific notation.</font>
<font color="black">1000. </font>
<font color="black">1001.         Captures all of the information in the underlying representation.</font>
<font color="black">1002.         &quot;&quot;&quot;</font>
<font color="black">1003. </font>
<font color="red">1004.         sign = ['', '-'][self._sign]</font>
<font color="red">1005.         if self._is_special:</font>
<font color="red">1006.             if self._exp == 'F':</font>
<font color="red">1007.                 return sign + 'Infinity'</font>
<font color="red">1008.             elif self._exp == 'n':</font>
<font color="red">1009.                 return sign + 'NaN' + self._int</font>
<font color="black">1010.             else: # self._exp == 'N'</font>
<font color="red">1011.                 return sign + 'sNaN' + self._int</font>
<font color="black">1012. </font>
<font color="black">1013.         # number of digits of self._int to left of decimal point</font>
<font color="red">1014.         leftdigits = self._exp + len(self._int)</font>
<font color="black">1015. </font>
<font color="black">1016.         # dotplace is number of digits of self._int to the left of the</font>
<font color="black">1017.         # decimal point in the mantissa of the output string (that is,</font>
<font color="black">1018.         # after adjusting the exponent)</font>
<font color="red">1019.         if self._exp &lt;= 0 and leftdigits &gt; -6:</font>
<font color="black">1020.             # no exponent required</font>
<font color="red">1021.             dotplace = leftdigits</font>
<font color="red">1022.         elif not eng:</font>
<font color="black">1023.             # usual scientific notation: 1 digit on left of the point</font>
<font color="red">1024.             dotplace = 1</font>
<font color="red">1025.         elif self._int == '0':</font>
<font color="black">1026.             # engineering notation, zero</font>
<font color="red">1027.             dotplace = (leftdigits + 1) % 3 - 1</font>
<font color="black">1028.         else:</font>
<font color="black">1029.             # engineering notation, nonzero</font>
<font color="red">1030.             dotplace = (leftdigits - 1) % 3 + 1</font>
<font color="black">1031. </font>
<font color="red">1032.         if dotplace &lt;= 0:</font>
<font color="red">1033.             intpart = '0'</font>
<font color="red">1034.             fracpart = '.' + '0'*(-dotplace) + self._int</font>
<font color="red">1035.         elif dotplace &gt;= len(self._int):</font>
<font color="red">1036.             intpart = self._int+'0'*(dotplace-len(self._int))</font>
<font color="red">1037.             fracpart = ''</font>
<font color="black">1038.         else:</font>
<font color="red">1039.             intpart = self._int[:dotplace]</font>
<font color="red">1040.             fracpart = '.' + self._int[dotplace:]</font>
<font color="red">1041.         if leftdigits == dotplace:</font>
<font color="red">1042.             exp = ''</font>
<font color="black">1043.         else:</font>
<font color="red">1044.             if context is None:</font>
<font color="red">1045.                 context = getcontext()</font>
<font color="red">1046.             exp = ['e', 'E'][context.capitals] + &quot;%+d&quot; % (leftdigits-dotplace)</font>
<font color="black">1047. </font>
<font color="red">1048.         return sign + intpart + fracpart + exp</font>
<font color="black">1049. </font>
<font color="green">1050.     def to_eng_string(self, context=None):</font>
<font color="black">1051.         &quot;&quot;&quot;Convert to a string, using engineering notation if an exponent is needed.</font>
<font color="black">1052. </font>
<font color="black">1053.         Engineering notation has an exponent which is a multiple of 3.  This</font>
<font color="black">1054.         can leave up to 3 digits to the left of the decimal place and may</font>
<font color="black">1055.         require the addition of either one or two trailing zeros.</font>
<font color="black">1056.         &quot;&quot;&quot;</font>
<font color="red">1057.         return self.__str__(eng=True, context=context)</font>
<font color="black">1058. </font>
<font color="green">1059.     def __neg__(self, context=None):</font>
<font color="black">1060.         &quot;&quot;&quot;Returns a copy with the sign switched.</font>
<font color="black">1061. </font>
<font color="black">1062.         Rounds, if it has reason.</font>
<font color="black">1063.         &quot;&quot;&quot;</font>
<font color="red">1064.         if self._is_special:</font>
<font color="red">1065.             ans = self._check_nans(context=context)</font>
<font color="red">1066.             if ans:</font>
<font color="red">1067.                 return ans</font>
<font color="black">1068. </font>
<font color="red">1069.         if context is None:</font>
<font color="red">1070.             context = getcontext()</font>
<font color="black">1071. </font>
<font color="red">1072.         if not self and context.rounding != ROUND_FLOOR:</font>
<font color="black">1073.             # -Decimal('0') is Decimal('0'), not Decimal('-0'), except</font>
<font color="black">1074.             # in ROUND_FLOOR rounding mode.</font>
<font color="red">1075.             ans = self.copy_abs()</font>
<font color="black">1076.         else:</font>
<font color="red">1077.             ans = self.copy_negate()</font>
<font color="black">1078. </font>
<font color="red">1079.         return ans._fix(context)</font>
<font color="black">1080. </font>
<font color="green">1081.     def __pos__(self, context=None):</font>
<font color="black">1082.         &quot;&quot;&quot;Returns a copy, unless it is a sNaN.</font>
<font color="black">1083. </font>
<font color="black">1084.         Rounds the number (if more than precision digits)</font>
<font color="black">1085.         &quot;&quot;&quot;</font>
<font color="red">1086.         if self._is_special:</font>
<font color="red">1087.             ans = self._check_nans(context=context)</font>
<font color="red">1088.             if ans:</font>
<font color="red">1089.                 return ans</font>
<font color="black">1090. </font>
<font color="red">1091.         if context is None:</font>
<font color="red">1092.             context = getcontext()</font>
<font color="black">1093. </font>
<font color="red">1094.         if not self and context.rounding != ROUND_FLOOR:</font>
<font color="black">1095.             # + (-0) = 0, except in ROUND_FLOOR rounding mode.</font>
<font color="red">1096.             ans = self.copy_abs()</font>
<font color="black">1097.         else:</font>
<font color="red">1098.             ans = Decimal(self)</font>
<font color="black">1099. </font>
<font color="red">1100.         return ans._fix(context)</font>
<font color="black">1101. </font>
<font color="green">1102.     def __abs__(self, round=True, context=None):</font>
<font color="black">1103.         &quot;&quot;&quot;Returns the absolute value of self.</font>
<font color="black">1104. </font>
<font color="black">1105.         If the keyword argument 'round' is false, do not round.  The</font>
<font color="black">1106.         expression self.__abs__(round=False) is equivalent to</font>
<font color="black">1107.         self.copy_abs().</font>
<font color="black">1108.         &quot;&quot;&quot;</font>
<font color="red">1109.         if not round:</font>
<font color="red">1110.             return self.copy_abs()</font>
<font color="black">1111. </font>
<font color="red">1112.         if self._is_special:</font>
<font color="red">1113.             ans = self._check_nans(context=context)</font>
<font color="red">1114.             if ans:</font>
<font color="red">1115.                 return ans</font>
<font color="black">1116. </font>
<font color="red">1117.         if self._sign:</font>
<font color="red">1118.             ans = self.__neg__(context=context)</font>
<font color="black">1119.         else:</font>
<font color="red">1120.             ans = self.__pos__(context=context)</font>
<font color="black">1121. </font>
<font color="red">1122.         return ans</font>
<font color="black">1123. </font>
<font color="green">1124.     def __add__(self, other, context=None):</font>
<font color="black">1125.         &quot;&quot;&quot;Returns self + other.</font>
<font color="black">1126. </font>
<font color="black">1127.         -INF + INF (or the reverse) cause InvalidOperation errors.</font>
<font color="black">1128.         &quot;&quot;&quot;</font>
<font color="red">1129.         other = _convert_other(other)</font>
<font color="red">1130.         if other is NotImplemented:</font>
<font color="red">1131.             return other</font>
<font color="black">1132. </font>
<font color="red">1133.         if context is None:</font>
<font color="red">1134.             context = getcontext()</font>
<font color="black">1135. </font>
<font color="red">1136.         if self._is_special or other._is_special:</font>
<font color="red">1137.             ans = self._check_nans(other, context)</font>
<font color="red">1138.             if ans:</font>
<font color="red">1139.                 return ans</font>
<font color="black">1140. </font>
<font color="red">1141.             if self._isinfinity():</font>
<font color="black">1142.                 # If both INF, same sign =&gt; same as both, opposite =&gt; error.</font>
<font color="red">1143.                 if self._sign != other._sign and other._isinfinity():</font>
<font color="red">1144.                     return context._raise_error(InvalidOperation, '-INF + INF')</font>
<font color="red">1145.                 return Decimal(self)</font>
<font color="red">1146.             if other._isinfinity():</font>
<font color="red">1147.                 return Decimal(other)  # Can't both be infinity here</font>
<font color="black">1148. </font>
<font color="red">1149.         exp = min(self._exp, other._exp)</font>
<font color="red">1150.         negativezero = 0</font>
<font color="red">1151.         if context.rounding == ROUND_FLOOR and self._sign != other._sign:</font>
<font color="black">1152.             # If the answer is 0, the sign should be negative, in this case.</font>
<font color="red">1153.             negativezero = 1</font>
<font color="black">1154. </font>
<font color="red">1155.         if not self and not other:</font>
<font color="red">1156.             sign = min(self._sign, other._sign)</font>
<font color="red">1157.             if negativezero:</font>
<font color="red">1158.                 sign = 1</font>
<font color="red">1159.             ans = _dec_from_triple(sign, '0', exp)</font>
<font color="red">1160.             ans = ans._fix(context)</font>
<font color="red">1161.             return ans</font>
<font color="red">1162.         if not self:</font>
<font color="red">1163.             exp = max(exp, other._exp - context.prec-1)</font>
<font color="red">1164.             ans = other._rescale(exp, context.rounding)</font>
<font color="red">1165.             ans = ans._fix(context)</font>
<font color="red">1166.             return ans</font>
<font color="red">1167.         if not other:</font>
<font color="red">1168.             exp = max(exp, self._exp - context.prec-1)</font>
<font color="red">1169.             ans = self._rescale(exp, context.rounding)</font>
<font color="red">1170.             ans = ans._fix(context)</font>
<font color="red">1171.             return ans</font>
<font color="black">1172. </font>
<font color="red">1173.         op1 = _WorkRep(self)</font>
<font color="red">1174.         op2 = _WorkRep(other)</font>
<font color="red">1175.         op1, op2 = _normalize(op1, op2, context.prec)</font>
<font color="black">1176. </font>
<font color="red">1177.         result = _WorkRep()</font>
<font color="red">1178.         if op1.sign != op2.sign:</font>
<font color="black">1179.             # Equal and opposite</font>
<font color="red">1180.             if op1.int == op2.int:</font>
<font color="red">1181.                 ans = _dec_from_triple(negativezero, '0', exp)</font>
<font color="red">1182.                 ans = ans._fix(context)</font>
<font color="red">1183.                 return ans</font>
<font color="red">1184.             if op1.int &lt; op2.int:</font>
<font color="red">1185.                 op1, op2 = op2, op1</font>
<font color="black">1186.                 # OK, now abs(op1) &gt; abs(op2)</font>
<font color="red">1187.             if op1.sign == 1:</font>
<font color="red">1188.                 result.sign = 1</font>
<font color="red">1189.                 op1.sign, op2.sign = op2.sign, op1.sign</font>
<font color="black">1190.             else:</font>
<font color="red">1191.                 result.sign = 0</font>
<font color="black">1192.                 # So we know the sign, and op1 &gt; 0.</font>
<font color="red">1193.         elif op1.sign == 1:</font>
<font color="red">1194.             result.sign = 1</font>
<font color="red">1195.             op1.sign, op2.sign = (0, 0)</font>
<font color="black">1196.         else:</font>
<font color="red">1197.             result.sign = 0</font>
<font color="black">1198.         # Now, op1 &gt; abs(op2) &gt; 0</font>
<font color="black">1199. </font>
<font color="red">1200.         if op2.sign == 0:</font>
<font color="red">1201.             result.int = op1.int + op2.int</font>
<font color="black">1202.         else:</font>
<font color="red">1203.             result.int = op1.int - op2.int</font>
<font color="black">1204. </font>
<font color="red">1205.         result.exp = op1.exp</font>
<font color="red">1206.         ans = Decimal(result)</font>
<font color="red">1207.         ans = ans._fix(context)</font>
<font color="red">1208.         return ans</font>
<font color="black">1209. </font>
<font color="green">1210.     __radd__ = __add__</font>
<font color="black">1211. </font>
<font color="green">1212.     def __sub__(self, other, context=None):</font>
<font color="black">1213.         &quot;&quot;&quot;Return self - other&quot;&quot;&quot;</font>
<font color="red">1214.         other = _convert_other(other)</font>
<font color="red">1215.         if other is NotImplemented:</font>
<font color="red">1216.             return other</font>
<font color="black">1217. </font>
<font color="red">1218.         if self._is_special or other._is_special:</font>
<font color="red">1219.             ans = self._check_nans(other, context=context)</font>
<font color="red">1220.             if ans:</font>
<font color="red">1221.                 return ans</font>
<font color="black">1222. </font>
<font color="black">1223.         # self - other is computed as self + other.copy_negate()</font>
<font color="red">1224.         return self.__add__(other.copy_negate(), context=context)</font>
<font color="black">1225. </font>
<font color="green">1226.     def __rsub__(self, other, context=None):</font>
<font color="black">1227.         &quot;&quot;&quot;Return other - self&quot;&quot;&quot;</font>
<font color="red">1228.         other = _convert_other(other)</font>
<font color="red">1229.         if other is NotImplemented:</font>
<font color="red">1230.             return other</font>
<font color="black">1231. </font>
<font color="red">1232.         return other.__sub__(self, context=context)</font>
<font color="black">1233. </font>
<font color="green">1234.     def __mul__(self, other, context=None):</font>
<font color="black">1235.         &quot;&quot;&quot;Return self * other.</font>
<font color="black">1236. </font>
<font color="black">1237.         (+-) INF * 0 (or its reverse) raise InvalidOperation.</font>
<font color="black">1238.         &quot;&quot;&quot;</font>
<font color="red">1239.         other = _convert_other(other)</font>
<font color="red">1240.         if other is NotImplemented:</font>
<font color="red">1241.             return other</font>
<font color="black">1242. </font>
<font color="red">1243.         if context is None:</font>
<font color="red">1244.             context = getcontext()</font>
<font color="black">1245. </font>
<font color="red">1246.         resultsign = self._sign ^ other._sign</font>
<font color="black">1247. </font>
<font color="red">1248.         if self._is_special or other._is_special:</font>
<font color="red">1249.             ans = self._check_nans(other, context)</font>
<font color="red">1250.             if ans:</font>
<font color="red">1251.                 return ans</font>
<font color="black">1252. </font>
<font color="red">1253.             if self._isinfinity():</font>
<font color="red">1254.                 if not other:</font>
<font color="red">1255.                     return context._raise_error(InvalidOperation, '(+-)INF * 0')</font>
<font color="red">1256.                 return _SignedInfinity[resultsign]</font>
<font color="black">1257. </font>
<font color="red">1258.             if other._isinfinity():</font>
<font color="red">1259.                 if not self:</font>
<font color="red">1260.                     return context._raise_error(InvalidOperation, '0 * (+-)INF')</font>
<font color="red">1261.                 return _SignedInfinity[resultsign]</font>
<font color="black">1262. </font>
<font color="red">1263.         resultexp = self._exp + other._exp</font>
<font color="black">1264. </font>
<font color="black">1265.         # Special case for multiplying by zero</font>
<font color="red">1266.         if not self or not other:</font>
<font color="red">1267.             ans = _dec_from_triple(resultsign, '0', resultexp)</font>
<font color="black">1268.             # Fixing in case the exponent is out of bounds</font>
<font color="red">1269.             ans = ans._fix(context)</font>
<font color="red">1270.             return ans</font>
<font color="black">1271. </font>
<font color="black">1272.         # Special case for multiplying by power of 10</font>
<font color="red">1273.         if self._int == '1':</font>
<font color="red">1274.             ans = _dec_from_triple(resultsign, other._int, resultexp)</font>
<font color="red">1275.             ans = ans._fix(context)</font>
<font color="red">1276.             return ans</font>
<font color="red">1277.         if other._int == '1':</font>
<font color="red">1278.             ans = _dec_from_triple(resultsign, self._int, resultexp)</font>
<font color="red">1279.             ans = ans._fix(context)</font>
<font color="red">1280.             return ans</font>
<font color="black">1281. </font>
<font color="red">1282.         op1 = _WorkRep(self)</font>
<font color="red">1283.         op2 = _WorkRep(other)</font>
<font color="black">1284. </font>
<font color="red">1285.         ans = _dec_from_triple(resultsign, str(op1.int * op2.int), resultexp)</font>
<font color="red">1286.         ans = ans._fix(context)</font>
<font color="black">1287. </font>
<font color="red">1288.         return ans</font>
<font color="green">1289.     __rmul__ = __mul__</font>
<font color="black">1290. </font>
<font color="green">1291.     def __truediv__(self, other, context=None):</font>
<font color="black">1292.         &quot;&quot;&quot;Return self / other.&quot;&quot;&quot;</font>
<font color="red">1293.         other = _convert_other(other)</font>
<font color="red">1294.         if other is NotImplemented:</font>
<font color="red">1295.             return NotImplemented</font>
<font color="black">1296. </font>
<font color="red">1297.         if context is None:</font>
<font color="red">1298.             context = getcontext()</font>
<font color="black">1299. </font>
<font color="red">1300.         sign = self._sign ^ other._sign</font>
<font color="black">1301. </font>
<font color="red">1302.         if self._is_special or other._is_special:</font>
<font color="red">1303.             ans = self._check_nans(other, context)</font>
<font color="red">1304.             if ans:</font>
<font color="red">1305.                 return ans</font>
<font color="black">1306. </font>
<font color="red">1307.             if self._isinfinity() and other._isinfinity():</font>
<font color="red">1308.                 return context._raise_error(InvalidOperation, '(+-)INF/(+-)INF')</font>
<font color="black">1309. </font>
<font color="red">1310.             if self._isinfinity():</font>
<font color="red">1311.                 return _SignedInfinity[sign]</font>
<font color="black">1312. </font>
<font color="red">1313.             if other._isinfinity():</font>
<font color="red">1314.                 context._raise_error(Clamped, 'Division by infinity')</font>
<font color="red">1315.                 return _dec_from_triple(sign, '0', context.Etiny())</font>
<font color="black">1316. </font>
<font color="black">1317.         # Special cases for zeroes</font>
<font color="red">1318.         if not other:</font>
<font color="red">1319.             if not self:</font>
<font color="red">1320.                 return context._raise_error(DivisionUndefined, '0 / 0')</font>
<font color="red">1321.             return context._raise_error(DivisionByZero, 'x / 0', sign)</font>
<font color="black">1322. </font>
<font color="red">1323.         if not self:</font>
<font color="red">1324.             exp = self._exp - other._exp</font>
<font color="red">1325.             coeff = 0</font>
<font color="black">1326.         else:</font>
<font color="black">1327.             # OK, so neither = 0, INF or NaN</font>
<font color="red">1328.             shift = len(other._int) - len(self._int) + context.prec + 1</font>
<font color="red">1329.             exp = self._exp - other._exp - shift</font>
<font color="red">1330.             op1 = _WorkRep(self)</font>
<font color="red">1331.             op2 = _WorkRep(other)</font>
<font color="red">1332.             if shift &gt;= 0:</font>
<font color="red">1333.                 coeff, remainder = divmod(op1.int * 10**shift, op2.int)</font>
<font color="black">1334.             else:</font>
<font color="red">1335.                 coeff, remainder = divmod(op1.int, op2.int * 10**-shift)</font>
<font color="red">1336.             if remainder:</font>
<font color="black">1337.                 # result is not exact; adjust to ensure correct rounding</font>
<font color="red">1338.                 if coeff % 5 == 0:</font>
<font color="red">1339.                     coeff += 1</font>
<font color="black">1340.             else:</font>
<font color="black">1341.                 # result is exact; get as close to ideal exponent as possible</font>
<font color="red">1342.                 ideal_exp = self._exp - other._exp</font>
<font color="red">1343.                 while exp &lt; ideal_exp and coeff % 10 == 0:</font>
<font color="red">1344.                     coeff //= 10</font>
<font color="red">1345.                     exp += 1</font>
<font color="black">1346. </font>
<font color="red">1347.         ans = _dec_from_triple(sign, str(coeff), exp)</font>
<font color="red">1348.         return ans._fix(context)</font>
<font color="black">1349. </font>
<font color="green">1350.     def _divide(self, other, context):</font>
<font color="black">1351.         &quot;&quot;&quot;Return (self // other, self % other), to context.prec precision.</font>
<font color="black">1352. </font>
<font color="black">1353.         Assumes that neither self nor other is a NaN, that self is not</font>
<font color="black">1354.         infinite and that other is nonzero.</font>
<font color="black">1355.         &quot;&quot;&quot;</font>
<font color="red">1356.         sign = self._sign ^ other._sign</font>
<font color="red">1357.         if other._isinfinity():</font>
<font color="red">1358.             ideal_exp = self._exp</font>
<font color="black">1359.         else:</font>
<font color="red">1360.             ideal_exp = min(self._exp, other._exp)</font>
<font color="black">1361. </font>
<font color="red">1362.         expdiff = self.adjusted() - other.adjusted()</font>
<font color="red">1363.         if not self or other._isinfinity() or expdiff &lt;= -2:</font>
<font color="red">1364.             return (_dec_from_triple(sign, '0', 0),</font>
<font color="red">1365.                     self._rescale(ideal_exp, context.rounding))</font>
<font color="red">1366.         if expdiff &lt;= context.prec:</font>
<font color="red">1367.             op1 = _WorkRep(self)</font>
<font color="red">1368.             op2 = _WorkRep(other)</font>
<font color="red">1369.             if op1.exp &gt;= op2.exp:</font>
<font color="red">1370.                 op1.int *= 10**(op1.exp - op2.exp)</font>
<font color="black">1371.             else:</font>
<font color="red">1372.                 op2.int *= 10**(op2.exp - op1.exp)</font>
<font color="red">1373.             q, r = divmod(op1.int, op2.int)</font>
<font color="red">1374.             if q &lt; 10**context.prec:</font>
<font color="red">1375.                 return (_dec_from_triple(sign, str(q), 0),</font>
<font color="red">1376.                         _dec_from_triple(self._sign, str(r), ideal_exp))</font>
<font color="black">1377. </font>
<font color="black">1378.         # Here the quotient is too large to be representable</font>
<font color="red">1379.         ans = context._raise_error(DivisionImpossible,</font>
<font color="red">1380.                                    'quotient too large in //, % or divmod')</font>
<font color="red">1381.         return ans, ans</font>
<font color="black">1382. </font>
<font color="green">1383.     def __rtruediv__(self, other, context=None):</font>
<font color="black">1384.         &quot;&quot;&quot;Swaps self/other and returns __truediv__.&quot;&quot;&quot;</font>
<font color="red">1385.         other = _convert_other(other)</font>
<font color="red">1386.         if other is NotImplemented:</font>
<font color="red">1387.             return other</font>
<font color="red">1388.         return other.__truediv__(self, context=context)</font>
<font color="black">1389. </font>
<font color="green">1390.     __div__ = __truediv__</font>
<font color="green">1391.     __rdiv__ = __rtruediv__</font>
<font color="black">1392. </font>
<font color="green">1393.     def __divmod__(self, other, context=None):</font>
<font color="black">1394.         &quot;&quot;&quot;</font>
<font color="black">1395.         Return (self // other, self % other)</font>
<font color="black">1396.         &quot;&quot;&quot;</font>
<font color="red">1397.         other = _convert_other(other)</font>
<font color="red">1398.         if other is NotImplemented:</font>
<font color="red">1399.             return other</font>
<font color="black">1400. </font>
<font color="red">1401.         if context is None:</font>
<font color="red">1402.             context = getcontext()</font>
<font color="black">1403. </font>
<font color="red">1404.         ans = self._check_nans(other, context)</font>
<font color="red">1405.         if ans:</font>
<font color="red">1406.             return (ans, ans)</font>
<font color="black">1407. </font>
<font color="red">1408.         sign = self._sign ^ other._sign</font>
<font color="red">1409.         if self._isinfinity():</font>
<font color="red">1410.             if other._isinfinity():</font>
<font color="red">1411.                 ans = context._raise_error(InvalidOperation, 'divmod(INF, INF)')</font>
<font color="red">1412.                 return ans, ans</font>
<font color="black">1413.             else:</font>
<font color="red">1414.                 return (_SignedInfinity[sign],</font>
<font color="red">1415.                         context._raise_error(InvalidOperation, 'INF % x'))</font>
<font color="black">1416. </font>
<font color="red">1417.         if not other:</font>
<font color="red">1418.             if not self:</font>
<font color="red">1419.                 ans = context._raise_error(DivisionUndefined, 'divmod(0, 0)')</font>
<font color="red">1420.                 return ans, ans</font>
<font color="black">1421.             else:</font>
<font color="red">1422.                 return (context._raise_error(DivisionByZero, 'x // 0', sign),</font>
<font color="red">1423.                         context._raise_error(InvalidOperation, 'x % 0'))</font>
<font color="black">1424. </font>
<font color="red">1425.         quotient, remainder = self._divide(other, context)</font>
<font color="red">1426.         remainder = remainder._fix(context)</font>
<font color="red">1427.         return quotient, remainder</font>
<font color="black">1428. </font>
<font color="green">1429.     def __rdivmod__(self, other, context=None):</font>
<font color="black">1430.         &quot;&quot;&quot;Swaps self/other and returns __divmod__.&quot;&quot;&quot;</font>
<font color="red">1431.         other = _convert_other(other)</font>
<font color="red">1432.         if other is NotImplemented:</font>
<font color="red">1433.             return other</font>
<font color="red">1434.         return other.__divmod__(self, context=context)</font>
<font color="black">1435. </font>
<font color="green">1436.     def __mod__(self, other, context=None):</font>
<font color="black">1437.         &quot;&quot;&quot;</font>
<font color="black">1438.         self % other</font>
<font color="black">1439.         &quot;&quot;&quot;</font>
<font color="red">1440.         other = _convert_other(other)</font>
<font color="red">1441.         if other is NotImplemented:</font>
<font color="red">1442.             return other</font>
<font color="black">1443. </font>
<font color="red">1444.         if context is None:</font>
<font color="red">1445.             context = getcontext()</font>
<font color="black">1446. </font>
<font color="red">1447.         ans = self._check_nans(other, context)</font>
<font color="red">1448.         if ans:</font>
<font color="red">1449.             return ans</font>
<font color="black">1450. </font>
<font color="red">1451.         if self._isinfinity():</font>
<font color="red">1452.             return context._raise_error(InvalidOperation, 'INF % x')</font>
<font color="red">1453.         elif not other:</font>
<font color="red">1454.             if self:</font>
<font color="red">1455.                 return context._raise_error(InvalidOperation, 'x % 0')</font>
<font color="black">1456.             else:</font>
<font color="red">1457.                 return context._raise_error(DivisionUndefined, '0 % 0')</font>
<font color="black">1458. </font>
<font color="red">1459.         remainder = self._divide(other, context)[1]</font>
<font color="red">1460.         remainder = remainder._fix(context)</font>
<font color="red">1461.         return remainder</font>
<font color="black">1462. </font>
<font color="green">1463.     def __rmod__(self, other, context=None):</font>
<font color="black">1464.         &quot;&quot;&quot;Swaps self/other and returns __mod__.&quot;&quot;&quot;</font>
<font color="red">1465.         other = _convert_other(other)</font>
<font color="red">1466.         if other is NotImplemented:</font>
<font color="red">1467.             return other</font>
<font color="red">1468.         return other.__mod__(self, context=context)</font>
<font color="black">1469. </font>
<font color="green">1470.     def remainder_near(self, other, context=None):</font>
<font color="black">1471.         &quot;&quot;&quot;</font>
<font color="black">1472.         Remainder nearest to 0-  abs(remainder-near) &lt;= other/2</font>
<font color="black">1473.         &quot;&quot;&quot;</font>
<font color="red">1474.         if context is None:</font>
<font color="red">1475.             context = getcontext()</font>
<font color="black">1476. </font>
<font color="red">1477.         other = _convert_other(other, raiseit=True)</font>
<font color="black">1478. </font>
<font color="red">1479.         ans = self._check_nans(other, context)</font>
<font color="red">1480.         if ans:</font>
<font color="red">1481.             return ans</font>
<font color="black">1482. </font>
<font color="black">1483.         # self == +/-infinity -&gt; InvalidOperation</font>
<font color="red">1484.         if self._isinfinity():</font>
<font color="red">1485.             return context._raise_error(InvalidOperation,</font>
<font color="red">1486.                                         'remainder_near(infinity, x)')</font>
<font color="black">1487. </font>
<font color="black">1488.         # other == 0 -&gt; either InvalidOperation or DivisionUndefined</font>
<font color="red">1489.         if not other:</font>
<font color="red">1490.             if self:</font>
<font color="red">1491.                 return context._raise_error(InvalidOperation,</font>
<font color="red">1492.                                             'remainder_near(x, 0)')</font>
<font color="black">1493.             else:</font>
<font color="red">1494.                 return context._raise_error(DivisionUndefined,</font>
<font color="red">1495.                                             'remainder_near(0, 0)')</font>
<font color="black">1496. </font>
<font color="black">1497.         # other = +/-infinity -&gt; remainder = self</font>
<font color="red">1498.         if other._isinfinity():</font>
<font color="red">1499.             ans = Decimal(self)</font>
<font color="red">1500.             return ans._fix(context)</font>
<font color="black">1501. </font>
<font color="black">1502.         # self = 0 -&gt; remainder = self, with ideal exponent</font>
<font color="red">1503.         ideal_exponent = min(self._exp, other._exp)</font>
<font color="red">1504.         if not self:</font>
<font color="red">1505.             ans = _dec_from_triple(self._sign, '0', ideal_exponent)</font>
<font color="red">1506.             return ans._fix(context)</font>
<font color="black">1507. </font>
<font color="black">1508.         # catch most cases of large or small quotient</font>
<font color="red">1509.         expdiff = self.adjusted() - other.adjusted()</font>
<font color="red">1510.         if expdiff &gt;= context.prec + 1:</font>
<font color="black">1511.             # expdiff &gt;= prec+1 =&gt; abs(self/other) &gt; 10**prec</font>
<font color="red">1512.             return context._raise_error(DivisionImpossible)</font>
<font color="red">1513.         if expdiff &lt;= -2:</font>
<font color="black">1514.             # expdiff &lt;= -2 =&gt; abs(self/other) &lt; 0.1</font>
<font color="red">1515.             ans = self._rescale(ideal_exponent, context.rounding)</font>
<font color="red">1516.             return ans._fix(context)</font>
<font color="black">1517. </font>
<font color="black">1518.         # adjust both arguments to have the same exponent, then divide</font>
<font color="red">1519.         op1 = _WorkRep(self)</font>
<font color="red">1520.         op2 = _WorkRep(other)</font>
<font color="red">1521.         if op1.exp &gt;= op2.exp:</font>
<font color="red">1522.             op1.int *= 10**(op1.exp - op2.exp)</font>
<font color="black">1523.         else:</font>
<font color="red">1524.             op2.int *= 10**(op2.exp - op1.exp)</font>
<font color="red">1525.         q, r = divmod(op1.int, op2.int)</font>
<font color="black">1526.         # remainder is r*10**ideal_exponent; other is +/-op2.int *</font>
<font color="black">1527.         # 10**ideal_exponent.   Apply correction to ensure that</font>
<font color="black">1528.         # abs(remainder) &lt;= abs(other)/2</font>
<font color="red">1529.         if 2*r + (q&amp;1) &gt; op2.int:</font>
<font color="red">1530.             r -= op2.int</font>
<font color="red">1531.             q += 1</font>
<font color="black">1532. </font>
<font color="red">1533.         if q &gt;= 10**context.prec:</font>
<font color="red">1534.             return context._raise_error(DivisionImpossible)</font>
<font color="black">1535. </font>
<font color="black">1536.         # result has same sign as self unless r is negative</font>
<font color="red">1537.         sign = self._sign</font>
<font color="red">1538.         if r &lt; 0:</font>
<font color="red">1539.             sign = 1-sign</font>
<font color="red">1540.             r = -r</font>
<font color="black">1541. </font>
<font color="red">1542.         ans = _dec_from_triple(sign, str(r), ideal_exponent)</font>
<font color="red">1543.         return ans._fix(context)</font>
<font color="black">1544. </font>
<font color="green">1545.     def __floordiv__(self, other, context=None):</font>
<font color="black">1546.         &quot;&quot;&quot;self // other&quot;&quot;&quot;</font>
<font color="red">1547.         other = _convert_other(other)</font>
<font color="red">1548.         if other is NotImplemented:</font>
<font color="red">1549.             return other</font>
<font color="black">1550. </font>
<font color="red">1551.         if context is None:</font>
<font color="red">1552.             context = getcontext()</font>
<font color="black">1553. </font>
<font color="red">1554.         ans = self._check_nans(other, context)</font>
<font color="red">1555.         if ans:</font>
<font color="red">1556.             return ans</font>
<font color="black">1557. </font>
<font color="red">1558.         if self._isinfinity():</font>
<font color="red">1559.             if other._isinfinity():</font>
<font color="red">1560.                 return context._raise_error(InvalidOperation, 'INF // INF')</font>
<font color="black">1561.             else:</font>
<font color="red">1562.                 return _SignedInfinity[self._sign ^ other._sign]</font>
<font color="black">1563. </font>
<font color="red">1564.         if not other:</font>
<font color="red">1565.             if self:</font>
<font color="red">1566.                 return context._raise_error(DivisionByZero, 'x // 0',</font>
<font color="red">1567.                                             self._sign ^ other._sign)</font>
<font color="black">1568.             else:</font>
<font color="red">1569.                 return context._raise_error(DivisionUndefined, '0 // 0')</font>
<font color="black">1570. </font>
<font color="red">1571.         return self._divide(other, context)[0]</font>
<font color="black">1572. </font>
<font color="green">1573.     def __rfloordiv__(self, other, context=None):</font>
<font color="black">1574.         &quot;&quot;&quot;Swaps self/other and returns __floordiv__.&quot;&quot;&quot;</font>
<font color="red">1575.         other = _convert_other(other)</font>
<font color="red">1576.         if other is NotImplemented:</font>
<font color="red">1577.             return other</font>
<font color="red">1578.         return other.__floordiv__(self, context=context)</font>
<font color="black">1579. </font>
<font color="green">1580.     def __float__(self):</font>
<font color="black">1581.         &quot;&quot;&quot;Float representation.&quot;&quot;&quot;</font>
<font color="red">1582.         if self._isnan():</font>
<font color="red">1583.             if self.is_snan():</font>
<font color="red">1584.                 raise ValueError(&quot;Cannot convert signaling NaN to float&quot;)</font>
<font color="red">1585.             s = &quot;-nan&quot; if self._sign else &quot;nan&quot;</font>
<font color="black">1586.         else:</font>
<font color="red">1587.             s = str(self)</font>
<font color="red">1588.         return float(s)</font>
<font color="black">1589. </font>
<font color="green">1590.     def __int__(self):</font>
<font color="black">1591.         &quot;&quot;&quot;Converts self to an int, truncating if necessary.&quot;&quot;&quot;</font>
<font color="red">1592.         if self._is_special:</font>
<font color="red">1593.             if self._isnan():</font>
<font color="red">1594.                 raise ValueError(&quot;Cannot convert NaN to integer&quot;)</font>
<font color="red">1595.             elif self._isinfinity():</font>
<font color="red">1596.                 raise OverflowError(&quot;Cannot convert infinity to integer&quot;)</font>
<font color="red">1597.         s = (-1)**self._sign</font>
<font color="red">1598.         if self._exp &gt;= 0:</font>
<font color="red">1599.             return s*int(self._int)*10**self._exp</font>
<font color="black">1600.         else:</font>
<font color="red">1601.             return s*int(self._int[:self._exp] or '0')</font>
<font color="black">1602. </font>
<font color="green">1603.     __trunc__ = __int__</font>
<font color="black">1604. </font>
<font color="green">1605.     def real(self):</font>
<font color="red">1606.         return self</font>
<font color="green">1607.     real = property(real)</font>
<font color="black">1608. </font>
<font color="green">1609.     def imag(self):</font>
<font color="red">1610.         return Decimal(0)</font>
<font color="green">1611.     imag = property(imag)</font>
<font color="black">1612. </font>
<font color="green">1613.     def conjugate(self):</font>
<font color="red">1614.         return self</font>
<font color="black">1615. </font>
<font color="green">1616.     def __complex__(self):</font>
<font color="red">1617.         return complex(float(self))</font>
<font color="black">1618. </font>
<font color="green">1619.     def __long__(self):</font>
<font color="black">1620.         &quot;&quot;&quot;Converts to a long.</font>
<font color="black">1621. </font>
<font color="black">1622.         Equivalent to long(int(self))</font>
<font color="black">1623.         &quot;&quot;&quot;</font>
<font color="red">1624.         return long(self.__int__())</font>
<font color="black">1625. </font>
<font color="green">1626.     def _fix_nan(self, context):</font>
<font color="black">1627.         &quot;&quot;&quot;Decapitate the payload of a NaN to fit the context&quot;&quot;&quot;</font>
<font color="red">1628.         payload = self._int</font>
<font color="black">1629. </font>
<font color="black">1630.         # maximum length of payload is precision if _clamp=0,</font>
<font color="black">1631.         # precision-1 if _clamp=1.</font>
<font color="red">1632.         max_payload_len = context.prec - context._clamp</font>
<font color="red">1633.         if len(payload) &gt; max_payload_len:</font>
<font color="red">1634.             payload = payload[len(payload)-max_payload_len:].lstrip('0')</font>
<font color="red">1635.             return _dec_from_triple(self._sign, payload, self._exp, True)</font>
<font color="red">1636.         return Decimal(self)</font>
<font color="black">1637. </font>
<font color="green">1638.     def _fix(self, context):</font>
<font color="black">1639.         &quot;&quot;&quot;Round if it is necessary to keep self within prec precision.</font>
<font color="black">1640. </font>
<font color="black">1641.         Rounds and fixes the exponent.  Does not raise on a sNaN.</font>
<font color="black">1642. </font>
<font color="black">1643.         Arguments:</font>
<font color="black">1644.         self - Decimal instance</font>
<font color="black">1645.         context - context used.</font>
<font color="black">1646.         &quot;&quot;&quot;</font>
<font color="black">1647. </font>
<font color="red">1648.         if self._is_special:</font>
<font color="red">1649.             if self._isnan():</font>
<font color="black">1650.                 # decapitate payload if necessary</font>
<font color="red">1651.                 return self._fix_nan(context)</font>
<font color="black">1652.             else:</font>
<font color="black">1653.                 # self is +/-Infinity; return unaltered</font>
<font color="red">1654.                 return Decimal(self)</font>
<font color="black">1655. </font>
<font color="black">1656.         # if self is zero then exponent should be between Etiny and</font>
<font color="black">1657.         # Emax if _clamp==0, and between Etiny and Etop if _clamp==1.</font>
<font color="red">1658.         Etiny = context.Etiny()</font>
<font color="red">1659.         Etop = context.Etop()</font>
<font color="red">1660.         if not self:</font>
<font color="red">1661.             exp_max = [context.Emax, Etop][context._clamp]</font>
<font color="red">1662.             new_exp = min(max(self._exp, Etiny), exp_max)</font>
<font color="red">1663.             if new_exp != self._exp:</font>
<font color="red">1664.                 context._raise_error(Clamped)</font>
<font color="red">1665.                 return _dec_from_triple(self._sign, '0', new_exp)</font>
<font color="black">1666.             else:</font>
<font color="red">1667.                 return Decimal(self)</font>
<font color="black">1668. </font>
<font color="black">1669.         # exp_min is the smallest allowable exponent of the result,</font>
<font color="black">1670.         # equal to max(self.adjusted()-context.prec+1, Etiny)</font>
<font color="red">1671.         exp_min = len(self._int) + self._exp - context.prec</font>
<font color="red">1672.         if exp_min &gt; Etop:</font>
<font color="black">1673.             # overflow: exp_min &gt; Etop iff self.adjusted() &gt; Emax</font>
<font color="red">1674.             ans = context._raise_error(Overflow, 'above Emax', self._sign)</font>
<font color="red">1675.             context._raise_error(Inexact)</font>
<font color="red">1676.             context._raise_error(Rounded)</font>
<font color="red">1677.             return ans</font>
<font color="black">1678. </font>
<font color="red">1679.         self_is_subnormal = exp_min &lt; Etiny</font>
<font color="red">1680.         if self_is_subnormal:</font>
<font color="red">1681.             exp_min = Etiny</font>
<font color="black">1682. </font>
<font color="black">1683.         # round if self has too many digits</font>
<font color="red">1684.         if self._exp &lt; exp_min:</font>
<font color="red">1685.             digits = len(self._int) + self._exp - exp_min</font>
<font color="red">1686.             if digits &lt; 0:</font>
<font color="red">1687.                 self = _dec_from_triple(self._sign, '1', exp_min-1)</font>
<font color="red">1688.                 digits = 0</font>
<font color="red">1689.             rounding_method = self._pick_rounding_function[context.rounding]</font>
<font color="red">1690.             changed = rounding_method(self, digits)</font>
<font color="red">1691.             coeff = self._int[:digits] or '0'</font>
<font color="red">1692.             if changed &gt; 0:</font>
<font color="red">1693.                 coeff = str(int(coeff)+1)</font>
<font color="red">1694.                 if len(coeff) &gt; context.prec:</font>
<font color="red">1695.                     coeff = coeff[:-1]</font>
<font color="red">1696.                     exp_min += 1</font>
<font color="black">1697. </font>
<font color="black">1698.             # check whether the rounding pushed the exponent out of range</font>
<font color="red">1699.             if exp_min &gt; Etop:</font>
<font color="red">1700.                 ans = context._raise_error(Overflow, 'above Emax', self._sign)</font>
<font color="black">1701.             else:</font>
<font color="red">1702.                 ans = _dec_from_triple(self._sign, coeff, exp_min)</font>
<font color="black">1703. </font>
<font color="black">1704.             # raise the appropriate signals, taking care to respect</font>
<font color="black">1705.             # the precedence described in the specification</font>
<font color="red">1706.             if changed and self_is_subnormal:</font>
<font color="red">1707.                 context._raise_error(Underflow)</font>
<font color="red">1708.             if self_is_subnormal:</font>
<font color="red">1709.                 context._raise_error(Subnormal)</font>
<font color="red">1710.             if changed:</font>
<font color="red">1711.                 context._raise_error(Inexact)</font>
<font color="red">1712.             context._raise_error(Rounded)</font>
<font color="red">1713.             if not ans:</font>
<font color="black">1714.                 # raise Clamped on underflow to 0</font>
<font color="red">1715.                 context._raise_error(Clamped)</font>
<font color="red">1716.             return ans</font>
<font color="black">1717. </font>
<font color="red">1718.         if self_is_subnormal:</font>
<font color="red">1719.             context._raise_error(Subnormal)</font>
<font color="black">1720. </font>
<font color="black">1721.         # fold down if _clamp == 1 and self has too few digits</font>
<font color="red">1722.         if context._clamp == 1 and self._exp &gt; Etop:</font>
<font color="red">1723.             context._raise_error(Clamped)</font>
<font color="red">1724.             self_padded = self._int + '0'*(self._exp - Etop)</font>
<font color="red">1725.             return _dec_from_triple(self._sign, self_padded, Etop)</font>
<font color="black">1726. </font>
<font color="black">1727.         # here self was representable to begin with; return unchanged</font>
<font color="red">1728.         return Decimal(self)</font>
<font color="black">1729. </font>
<font color="black">1730.     # for each of the rounding functions below:</font>
<font color="black">1731.     #   self is a finite, nonzero Decimal</font>
<font color="black">1732.     #   prec is an integer satisfying 0 &lt;= prec &lt; len(self._int)</font>
<font color="black">1733.     #</font>
<font color="black">1734.     # each function returns either -1, 0, or 1, as follows:</font>
<font color="black">1735.     #   1 indicates that self should be rounded up (away from zero)</font>
<font color="black">1736.     #   0 indicates that self should be truncated, and that all the</font>
<font color="black">1737.     #     digits to be truncated are zeros (so the value is unchanged)</font>
<font color="black">1738.     #  -1 indicates that there are nonzero digits to be truncated</font>
<font color="black">1739. </font>
<font color="green">1740.     def _round_down(self, prec):</font>
<font color="black">1741.         &quot;&quot;&quot;Also known as round-towards-0, truncate.&quot;&quot;&quot;</font>
<font color="red">1742.         if _all_zeros(self._int, prec):</font>
<font color="red">1743.             return 0</font>
<font color="black">1744.         else:</font>
<font color="red">1745.             return -1</font>
<font color="black">1746. </font>
<font color="green">1747.     def _round_up(self, prec):</font>
<font color="black">1748.         &quot;&quot;&quot;Rounds away from 0.&quot;&quot;&quot;</font>
<font color="red">1749.         return -self._round_down(prec)</font>
<font color="black">1750. </font>
<font color="green">1751.     def _round_half_up(self, prec):</font>
<font color="black">1752.         &quot;&quot;&quot;Rounds 5 up (away from 0)&quot;&quot;&quot;</font>
<font color="red">1753.         if self._int[prec] in '56789':</font>
<font color="red">1754.             return 1</font>
<font color="red">1755.         elif _all_zeros(self._int, prec):</font>
<font color="red">1756.             return 0</font>
<font color="black">1757.         else:</font>
<font color="red">1758.             return -1</font>
<font color="black">1759. </font>
<font color="green">1760.     def _round_half_down(self, prec):</font>
<font color="black">1761.         &quot;&quot;&quot;Round 5 down&quot;&quot;&quot;</font>
<font color="red">1762.         if _exact_half(self._int, prec):</font>
<font color="red">1763.             return -1</font>
<font color="black">1764.         else:</font>
<font color="red">1765.             return self._round_half_up(prec)</font>
<font color="black">1766. </font>
<font color="green">1767.     def _round_half_even(self, prec):</font>
<font color="black">1768.         &quot;&quot;&quot;Round 5 to even, rest to nearest.&quot;&quot;&quot;</font>
<font color="red">1769.         if _exact_half(self._int, prec) and \</font>
<font color="red">1770.                 (prec == 0 or self._int[prec-1] in '02468'):</font>
<font color="red">1771.             return -1</font>
<font color="black">1772.         else:</font>
<font color="red">1773.             return self._round_half_up(prec)</font>
<font color="black">1774. </font>
<font color="green">1775.     def _round_ceiling(self, prec):</font>
<font color="black">1776.         &quot;&quot;&quot;Rounds up (not away from 0 if negative.)&quot;&quot;&quot;</font>
<font color="red">1777.         if self._sign:</font>
<font color="red">1778.             return self._round_down(prec)</font>
<font color="black">1779.         else:</font>
<font color="red">1780.             return -self._round_down(prec)</font>
<font color="black">1781. </font>
<font color="green">1782.     def _round_floor(self, prec):</font>
<font color="black">1783.         &quot;&quot;&quot;Rounds down (not towards 0 if negative)&quot;&quot;&quot;</font>
<font color="red">1784.         if not self._sign:</font>
<font color="red">1785.             return self._round_down(prec)</font>
<font color="black">1786.         else:</font>
<font color="red">1787.             return -self._round_down(prec)</font>
<font color="black">1788. </font>
<font color="green">1789.     def _round_05up(self, prec):</font>
<font color="black">1790.         &quot;&quot;&quot;Round down unless digit prec-1 is 0 or 5.&quot;&quot;&quot;</font>
<font color="red">1791.         if prec and self._int[prec-1] not in '05':</font>
<font color="red">1792.             return self._round_down(prec)</font>
<font color="black">1793.         else:</font>
<font color="red">1794.             return -self._round_down(prec)</font>
<font color="black">1795. </font>
<font color="green">1796.     _pick_rounding_function = dict(</font>
<font color="green">1797.         ROUND_DOWN = _round_down,</font>
<font color="green">1798.         ROUND_UP = _round_up,</font>
<font color="green">1799.         ROUND_HALF_UP = _round_half_up,</font>
<font color="green">1800.         ROUND_HALF_DOWN = _round_half_down,</font>
<font color="green">1801.         ROUND_HALF_EVEN = _round_half_even,</font>
<font color="green">1802.         ROUND_CEILING = _round_ceiling,</font>
<font color="green">1803.         ROUND_FLOOR = _round_floor,</font>
<font color="green">1804.         ROUND_05UP = _round_05up,</font>
<font color="black">1805.     )</font>
<font color="black">1806. </font>
<font color="green">1807.     def fma(self, other, third, context=None):</font>
<font color="black">1808.         &quot;&quot;&quot;Fused multiply-add.</font>
<font color="black">1809. </font>
<font color="black">1810.         Returns self*other+third with no rounding of the intermediate</font>
<font color="black">1811.         product self*other.</font>
<font color="black">1812. </font>
<font color="black">1813.         self and other are multiplied together, with no rounding of</font>
<font color="black">1814.         the result.  The third operand is then added to the result,</font>
<font color="black">1815.         and a single final rounding is performed.</font>
<font color="black">1816.         &quot;&quot;&quot;</font>
<font color="black">1817. </font>
<font color="red">1818.         other = _convert_other(other, raiseit=True)</font>
<font color="black">1819. </font>
<font color="black">1820.         # compute product; raise InvalidOperation if either operand is</font>
<font color="black">1821.         # a signaling NaN or if the product is zero times infinity.</font>
<font color="red">1822.         if self._is_special or other._is_special:</font>
<font color="red">1823.             if context is None:</font>
<font color="red">1824.                 context = getcontext()</font>
<font color="red">1825.             if self._exp == 'N':</font>
<font color="red">1826.                 return context._raise_error(InvalidOperation, 'sNaN', self)</font>
<font color="red">1827.             if other._exp == 'N':</font>
<font color="red">1828.                 return context._raise_error(InvalidOperation, 'sNaN', other)</font>
<font color="red">1829.             if self._exp == 'n':</font>
<font color="red">1830.                 product = self</font>
<font color="red">1831.             elif other._exp == 'n':</font>
<font color="red">1832.                 product = other</font>
<font color="red">1833.             elif self._exp == 'F':</font>
<font color="red">1834.                 if not other:</font>
<font color="red">1835.                     return context._raise_error(InvalidOperation,</font>
<font color="red">1836.                                                 'INF * 0 in fma')</font>
<font color="red">1837.                 product = _SignedInfinity[self._sign ^ other._sign]</font>
<font color="red">1838.             elif other._exp == 'F':</font>
<font color="red">1839.                 if not self:</font>
<font color="red">1840.                     return context._raise_error(InvalidOperation,</font>
<font color="red">1841.                                                 '0 * INF in fma')</font>
<font color="red">1842.                 product = _SignedInfinity[self._sign ^ other._sign]</font>
<font color="black">1843.         else:</font>
<font color="red">1844.             product = _dec_from_triple(self._sign ^ other._sign,</font>
<font color="red">1845.                                        str(int(self._int) * int(other._int)),</font>
<font color="red">1846.                                        self._exp + other._exp)</font>
<font color="black">1847. </font>
<font color="red">1848.         third = _convert_other(third, raiseit=True)</font>
<font color="red">1849.         return product.__add__(third, context)</font>
<font color="black">1850. </font>
<font color="green">1851.     def _power_modulo(self, other, modulo, context=None):</font>
<font color="black">1852.         &quot;&quot;&quot;Three argument version of __pow__&quot;&quot;&quot;</font>
<font color="black">1853. </font>
<font color="black">1854.         # if can't convert other and modulo to Decimal, raise</font>
<font color="black">1855.         # TypeError; there's no point returning NotImplemented (no</font>
<font color="black">1856.         # equivalent of __rpow__ for three argument pow)</font>
<font color="red">1857.         other = _convert_other(other, raiseit=True)</font>
<font color="red">1858.         modulo = _convert_other(modulo, raiseit=True)</font>
<font color="black">1859. </font>
<font color="red">1860.         if context is None:</font>
<font color="red">1861.             context = getcontext()</font>
<font color="black">1862. </font>
<font color="black">1863.         # deal with NaNs: if there are any sNaNs then first one wins,</font>
<font color="black">1864.         # (i.e. behaviour for NaNs is identical to that of fma)</font>
<font color="red">1865.         self_is_nan = self._isnan()</font>
<font color="red">1866.         other_is_nan = other._isnan()</font>
<font color="red">1867.         modulo_is_nan = modulo._isnan()</font>
<font color="red">1868.         if self_is_nan or other_is_nan or modulo_is_nan:</font>
<font color="red">1869.             if self_is_nan == 2:</font>
<font color="red">1870.                 return context._raise_error(InvalidOperation, 'sNaN',</font>
<font color="red">1871.                                         self)</font>
<font color="red">1872.             if other_is_nan == 2:</font>
<font color="red">1873.                 return context._raise_error(InvalidOperation, 'sNaN',</font>
<font color="red">1874.                                         other)</font>
<font color="red">1875.             if modulo_is_nan == 2:</font>
<font color="red">1876.                 return context._raise_error(InvalidOperation, 'sNaN',</font>
<font color="red">1877.                                         modulo)</font>
<font color="red">1878.             if self_is_nan:</font>
<font color="red">1879.                 return self._fix_nan(context)</font>
<font color="red">1880.             if other_is_nan:</font>
<font color="red">1881.                 return other._fix_nan(context)</font>
<font color="red">1882.             return modulo._fix_nan(context)</font>
<font color="black">1883. </font>
<font color="black">1884.         # check inputs: we apply same restrictions as Python's pow()</font>
<font color="red">1885.         if not (self._isinteger() and</font>
<font color="red">1886.                 other._isinteger() and</font>
<font color="red">1887.                 modulo._isinteger()):</font>
<font color="red">1888.             return context._raise_error(InvalidOperation,</font>
<font color="red">1889.                                         'pow() 3rd argument not allowed '</font>
<font color="black">1890.                                         'unless all arguments are integers')</font>
<font color="red">1891.         if other &lt; 0:</font>
<font color="red">1892.             return context._raise_error(InvalidOperation,</font>
<font color="red">1893.                                         'pow() 2nd argument cannot be '</font>
<font color="black">1894.                                         'negative when 3rd argument specified')</font>
<font color="red">1895.         if not modulo:</font>
<font color="red">1896.             return context._raise_error(InvalidOperation,</font>
<font color="red">1897.                                         'pow() 3rd argument cannot be 0')</font>
<font color="black">1898. </font>
<font color="black">1899.         # additional restriction for decimal: the modulus must be less</font>
<font color="black">1900.         # than 10**prec in absolute value</font>
<font color="red">1901.         if modulo.adjusted() &gt;= context.prec:</font>
<font color="red">1902.             return context._raise_error(InvalidOperation,</font>
<font color="red">1903.                                         'insufficient precision: pow() 3rd '</font>
<font color="black">1904.                                         'argument must not have more than '</font>
<font color="black">1905.                                         'precision digits')</font>
<font color="black">1906. </font>
<font color="black">1907.         # define 0**0 == NaN, for consistency with two-argument pow</font>
<font color="black">1908.         # (even though it hurts!)</font>
<font color="red">1909.         if not other and not self:</font>
<font color="red">1910.             return context._raise_error(InvalidOperation,</font>
<font color="red">1911.                                         'at least one of pow() 1st argument '</font>
<font color="black">1912.                                         'and 2nd argument must be nonzero ;'</font>
<font color="black">1913.                                         '0**0 is not defined')</font>
<font color="black">1914. </font>
<font color="black">1915.         # compute sign of result</font>
<font color="red">1916.         if other._iseven():</font>
<font color="red">1917.             sign = 0</font>
<font color="black">1918.         else:</font>
<font color="red">1919.             sign = self._sign</font>
<font color="black">1920. </font>
<font color="black">1921.         # convert modulo to a Python integer, and self and other to</font>
<font color="black">1922.         # Decimal integers (i.e. force their exponents to be &gt;= 0)</font>
<font color="red">1923.         modulo = abs(int(modulo))</font>
<font color="red">1924.         base = _WorkRep(self.to_integral_value())</font>
<font color="red">1925.         exponent = _WorkRep(other.to_integral_value())</font>
<font color="black">1926. </font>
<font color="black">1927.         # compute result using integer pow()</font>
<font color="red">1928.         base = (base.int % modulo * pow(10, base.exp, modulo)) % modulo</font>
<font color="red">1929.         for i in xrange(exponent.exp):</font>
<font color="red">1930.             base = pow(base, 10, modulo)</font>
<font color="red">1931.         base = pow(base, exponent.int, modulo)</font>
<font color="black">1932. </font>
<font color="red">1933.         return _dec_from_triple(sign, str(base), 0)</font>
<font color="black">1934. </font>
<font color="green">1935.     def _power_exact(self, other, p):</font>
<font color="black">1936.         &quot;&quot;&quot;Attempt to compute self**other exactly.</font>
<font color="black">1937. </font>
<font color="black">1938.         Given Decimals self and other and an integer p, attempt to</font>
<font color="black">1939.         compute an exact result for the power self**other, with p</font>
<font color="black">1940.         digits of precision.  Return None if self**other is not</font>
<font color="black">1941.         exactly representable in p digits.</font>
<font color="black">1942. </font>
<font color="black">1943.         Assumes that elimination of special cases has already been</font>
<font color="black">1944.         performed: self and other must both be nonspecial; self must</font>
<font color="black">1945.         be positive and not numerically equal to 1; other must be</font>
<font color="black">1946.         nonzero.  For efficiency, other._exp should not be too large,</font>
<font color="black">1947.         so that 10**abs(other._exp) is a feasible calculation.&quot;&quot;&quot;</font>
<font color="black">1948. </font>
<font color="black">1949.         # In the comments below, we write x for the value of self and y for the</font>
<font color="black">1950.         # value of other.  Write x = xc*10**xe and abs(y) = yc*10**ye, with xc</font>
<font color="black">1951.         # and yc positive integers not divisible by 10.</font>
<font color="black">1952. </font>
<font color="black">1953.         # The main purpose of this method is to identify the *failure*</font>
<font color="black">1954.         # of x**y to be exactly representable with as little effort as</font>
<font color="black">1955.         # possible.  So we look for cheap and easy tests that</font>
<font color="black">1956.         # eliminate the possibility of x**y being exact.  Only if all</font>
<font color="black">1957.         # these tests are passed do we go on to actually compute x**y.</font>
<font color="black">1958. </font>
<font color="black">1959.         # Here's the main idea.  Express y as a rational number m/n, with m and</font>
<font color="black">1960.         # n relatively prime and n&gt;0.  Then for x**y to be exactly</font>
<font color="black">1961.         # representable (at *any* precision), xc must be the nth power of a</font>
<font color="black">1962.         # positive integer and xe must be divisible by n.  If y is negative</font>
<font color="black">1963.         # then additionally xc must be a power of either 2 or 5, hence a power</font>
<font color="black">1964.         # of 2**n or 5**n.</font>
<font color="black">1965.         #</font>
<font color="black">1966.         # There's a limit to how small |y| can be: if y=m/n as above</font>
<font color="black">1967.         # then:</font>
<font color="black">1968.         #</font>
<font color="black">1969.         #  (1) if xc != 1 then for the result to be representable we</font>
<font color="black">1970.         #      need xc**(1/n) &gt;= 2, and hence also xc**|y| &gt;= 2.  So</font>
<font color="black">1971.         #      if |y| &lt;= 1/nbits(xc) then xc &lt; 2**nbits(xc) &lt;=</font>
<font color="black">1972.         #      2**(1/|y|), hence xc**|y| &lt; 2 and the result is not</font>
<font color="black">1973.         #      representable.</font>
<font color="black">1974.         #</font>
<font color="black">1975.         #  (2) if xe != 0, |xe|*(1/n) &gt;= 1, so |xe|*|y| &gt;= 1.  Hence if</font>
<font color="black">1976.         #      |y| &lt; 1/|xe| then the result is not representable.</font>
<font color="black">1977.         #</font>
<font color="black">1978.         # Note that since x is not equal to 1, at least one of (1) and</font>
<font color="black">1979.         # (2) must apply.  Now |y| &lt; 1/nbits(xc) iff |yc|*nbits(xc) &lt;</font>
<font color="black">1980.         # 10**-ye iff len(str(|yc|*nbits(xc)) &lt;= -ye.</font>
<font color="black">1981.         #</font>
<font color="black">1982.         # There's also a limit to how large y can be, at least if it's</font>
<font color="black">1983.         # positive: the normalized result will have coefficient xc**y,</font>
<font color="black">1984.         # so if it's representable then xc**y &lt; 10**p, and y &lt;</font>
<font color="black">1985.         # p/log10(xc).  Hence if y*log10(xc) &gt;= p then the result is</font>
<font color="black">1986.         # not exactly representable.</font>
<font color="black">1987. </font>
<font color="black">1988.         # if len(str(abs(yc*xe)) &lt;= -ye then abs(yc*xe) &lt; 10**-ye,</font>
<font color="black">1989.         # so |y| &lt; 1/xe and the result is not representable.</font>
<font color="black">1990.         # Similarly, len(str(abs(yc)*xc_bits)) &lt;= -ye implies |y|</font>
<font color="black">1991.         # &lt; 1/nbits(xc).</font>
<font color="black">1992. </font>
<font color="red">1993.         x = _WorkRep(self)</font>
<font color="red">1994.         xc, xe = x.int, x.exp</font>
<font color="red">1995.         while xc % 10 == 0:</font>
<font color="red">1996.             xc //= 10</font>
<font color="red">1997.             xe += 1</font>
<font color="black">1998. </font>
<font color="red">1999.         y = _WorkRep(other)</font>
<font color="red">2000.         yc, ye = y.int, y.exp</font>
<font color="red">2001.         while yc % 10 == 0:</font>
<font color="red">2002.             yc //= 10</font>
<font color="red">2003.             ye += 1</font>
<font color="black">2004. </font>
<font color="black">2005.         # case where xc == 1: result is 10**(xe*y), with xe*y</font>
<font color="black">2006.         # required to be an integer</font>
<font color="red">2007.         if xc == 1:</font>
<font color="red">2008.             xe *= yc</font>
<font color="black">2009.             # result is now 10**(xe * 10**ye);  xe * 10**ye must be integral</font>
<font color="red">2010.             while xe % 10 == 0:</font>
<font color="red">2011.                 xe //= 10</font>
<font color="red">2012.                 ye += 1</font>
<font color="red">2013.             if ye &lt; 0:</font>
<font color="red">2014.                 return None</font>
<font color="red">2015.             exponent = xe * 10**ye</font>
<font color="red">2016.             if y.sign == 1:</font>
<font color="red">2017.                 exponent = -exponent</font>
<font color="black">2018.             # if other is a nonnegative integer, use ideal exponent</font>
<font color="red">2019.             if other._isinteger() and other._sign == 0:</font>
<font color="red">2020.                 ideal_exponent = self._exp*int(other)</font>
<font color="red">2021.                 zeros = min(exponent-ideal_exponent, p-1)</font>
<font color="black">2022.             else:</font>
<font color="red">2023.                 zeros = 0</font>
<font color="red">2024.             return _dec_from_triple(0, '1' + '0'*zeros, exponent-zeros)</font>
<font color="black">2025. </font>
<font color="black">2026.         # case where y is negative: xc must be either a power</font>
<font color="black">2027.         # of 2 or a power of 5.</font>
<font color="red">2028.         if y.sign == 1:</font>
<font color="red">2029.             last_digit = xc % 10</font>
<font color="red">2030.             if last_digit in (2,4,6,8):</font>
<font color="black">2031.                 # quick test for power of 2</font>
<font color="red">2032.                 if xc &amp; -xc != xc:</font>
<font color="red">2033.                     return None</font>
<font color="black">2034.                 # now xc is a power of 2; e is its exponent</font>
<font color="red">2035.                 e = _nbits(xc)-1</font>
<font color="black">2036. </font>
<font color="black">2037.                 # We now have:</font>
<font color="black">2038.                 #</font>
<font color="black">2039.                 #   x = 2**e * 10**xe, e &gt; 0, and y &lt; 0.</font>
<font color="black">2040.                 #</font>
<font color="black">2041.                 # The exact result is:</font>
<font color="black">2042.                 #</font>
<font color="black">2043.                 #   x**y = 5**(-e*y) * 10**(e*y + xe*y)</font>
<font color="black">2044.                 #</font>
<font color="black">2045.                 # provided that both e*y and xe*y are integers.  Note that if</font>
<font color="black">2046.                 # 5**(-e*y) &gt;= 10**p, then the result can't be expressed</font>
<font color="black">2047.                 # exactly with p digits of precision.</font>
<font color="black">2048.                 #</font>
<font color="black">2049.                 # Using the above, we can guard against large values of ye.</font>
<font color="black">2050.                 # 93/65 is an upper bound for log(10)/log(5), so if</font>
<font color="black">2051.                 #</font>
<font color="black">2052.                 #   ye &gt;= len(str(93*p//65))</font>
<font color="black">2053.                 #</font>
<font color="black">2054.                 # then</font>
<font color="black">2055.                 #</font>
<font color="black">2056.                 #   -e*y &gt;= -y &gt;= 10**ye &gt; 93*p/65 &gt; p*log(10)/log(5),</font>
<font color="black">2057.                 #</font>
<font color="black">2058.                 # so 5**(-e*y) &gt;= 10**p, and the coefficient of the result</font>
<font color="black">2059.                 # can't be expressed in p digits.</font>
<font color="black">2060. </font>
<font color="black">2061.                 # emax &gt;= largest e such that 5**e &lt; 10**p.</font>
<font color="red">2062.                 emax = p*93//65</font>
<font color="red">2063.                 if ye &gt;= len(str(emax)):</font>
<font color="red">2064.                     return None</font>
<font color="black">2065. </font>
<font color="black">2066.                 # Find -e*y and -xe*y; both must be integers</font>
<font color="red">2067.                 e = _decimal_lshift_exact(e * yc, ye)</font>
<font color="red">2068.                 xe = _decimal_lshift_exact(xe * yc, ye)</font>
<font color="red">2069.                 if e is None or xe is None:</font>
<font color="red">2070.                     return None</font>
<font color="black">2071. </font>
<font color="red">2072.                 if e &gt; emax:</font>
<font color="red">2073.                     return None</font>
<font color="red">2074.                 xc = 5**e</font>
<font color="black">2075. </font>
<font color="red">2076.             elif last_digit == 5:</font>
<font color="black">2077.                 # e &gt;= log_5(xc) if xc is a power of 5; we have</font>
<font color="black">2078.                 # equality all the way up to xc=5**2658</font>
<font color="red">2079.                 e = _nbits(xc)*28//65</font>
<font color="red">2080.                 xc, remainder = divmod(5**e, xc)</font>
<font color="red">2081.                 if remainder:</font>
<font color="red">2082.                     return None</font>
<font color="red">2083.                 while xc % 5 == 0:</font>
<font color="red">2084.                     xc //= 5</font>
<font color="red">2085.                     e -= 1</font>
<font color="black">2086. </font>
<font color="black">2087.                 # Guard against large values of ye, using the same logic as in</font>
<font color="black">2088.                 # the 'xc is a power of 2' branch.  10/3 is an upper bound for</font>
<font color="black">2089.                 # log(10)/log(2).</font>
<font color="red">2090.                 emax = p*10//3</font>
<font color="red">2091.                 if ye &gt;= len(str(emax)):</font>
<font color="red">2092.                     return None</font>
<font color="black">2093. </font>
<font color="red">2094.                 e = _decimal_lshift_exact(e * yc, ye)</font>
<font color="red">2095.                 xe = _decimal_lshift_exact(xe * yc, ye)</font>
<font color="red">2096.                 if e is None or xe is None:</font>
<font color="red">2097.                     return None</font>
<font color="black">2098. </font>
<font color="red">2099.                 if e &gt; emax:</font>
<font color="red">2100.                     return None</font>
<font color="red">2101.                 xc = 2**e</font>
<font color="black">2102.             else:</font>
<font color="red">2103.                 return None</font>
<font color="black">2104. </font>
<font color="red">2105.             if xc &gt;= 10**p:</font>
<font color="red">2106.                 return None</font>
<font color="red">2107.             xe = -e-xe</font>
<font color="red">2108.             return _dec_from_triple(0, str(xc), xe)</font>
<font color="black">2109. </font>
<font color="black">2110.         # now y is positive; find m and n such that y = m/n</font>
<font color="red">2111.         if ye &gt;= 0:</font>
<font color="red">2112.             m, n = yc*10**ye, 1</font>
<font color="black">2113.         else:</font>
<font color="red">2114.             if xe != 0 and len(str(abs(yc*xe))) &lt;= -ye:</font>
<font color="red">2115.                 return None</font>
<font color="red">2116.             xc_bits = _nbits(xc)</font>
<font color="red">2117.             if xc != 1 and len(str(abs(yc)*xc_bits)) &lt;= -ye:</font>
<font color="red">2118.                 return None</font>
<font color="red">2119.             m, n = yc, 10**(-ye)</font>
<font color="red">2120.             while m % 2 == n % 2 == 0:</font>
<font color="red">2121.                 m //= 2</font>
<font color="red">2122.                 n //= 2</font>
<font color="red">2123.             while m % 5 == n % 5 == 0:</font>
<font color="red">2124.                 m //= 5</font>
<font color="red">2125.                 n //= 5</font>
<font color="black">2126. </font>
<font color="black">2127.         # compute nth root of xc*10**xe</font>
<font color="red">2128.         if n &gt; 1:</font>
<font color="black">2129.             # if 1 &lt; xc &lt; 2**n then xc isn't an nth power</font>
<font color="red">2130.             if xc != 1 and xc_bits &lt;= n:</font>
<font color="red">2131.                 return None</font>
<font color="black">2132. </font>
<font color="red">2133.             xe, rem = divmod(xe, n)</font>
<font color="red">2134.             if rem != 0:</font>
<font color="red">2135.                 return None</font>
<font color="black">2136. </font>
<font color="black">2137.             # compute nth root of xc using Newton's method</font>
<font color="red">2138.             a = 1L &lt;&lt; -(-_nbits(xc)//n) # initial estimate</font>
<font color="red">2139.             while True:</font>
<font color="red">2140.                 q, r = divmod(xc, a**(n-1))</font>
<font color="red">2141.                 if a &lt;= q:</font>
<font color="red">2142.                     break</font>
<font color="black">2143.                 else:</font>
<font color="red">2144.                     a = (a*(n-1) + q)//n</font>
<font color="red">2145.             if not (a == q and r == 0):</font>
<font color="red">2146.                 return None</font>
<font color="red">2147.             xc = a</font>
<font color="black">2148. </font>
<font color="black">2149.         # now xc*10**xe is the nth root of the original xc*10**xe</font>
<font color="black">2150.         # compute mth power of xc*10**xe</font>
<font color="black">2151. </font>
<font color="black">2152.         # if m &gt; p*100//_log10_lb(xc) then m &gt; p/log10(xc), hence xc**m &gt;</font>
<font color="black">2153.         # 10**p and the result is not representable.</font>
<font color="red">2154.         if xc &gt; 1 and m &gt; p*100//_log10_lb(xc):</font>
<font color="red">2155.             return None</font>
<font color="red">2156.         xc = xc**m</font>
<font color="red">2157.         xe *= m</font>
<font color="red">2158.         if xc &gt; 10**p:</font>
<font color="red">2159.             return None</font>
<font color="black">2160. </font>
<font color="black">2161.         # by this point the result *is* exactly representable</font>
<font color="black">2162.         # adjust the exponent to get as close as possible to the ideal</font>
<font color="black">2163.         # exponent, if necessary</font>
<font color="red">2164.         str_xc = str(xc)</font>
<font color="red">2165.         if other._isinteger() and other._sign == 0:</font>
<font color="red">2166.             ideal_exponent = self._exp*int(other)</font>
<font color="red">2167.             zeros = min(xe-ideal_exponent, p-len(str_xc))</font>
<font color="black">2168.         else:</font>
<font color="red">2169.             zeros = 0</font>
<font color="red">2170.         return _dec_from_triple(0, str_xc+'0'*zeros, xe-zeros)</font>
<font color="black">2171. </font>
<font color="green">2172.     def __pow__(self, other, modulo=None, context=None):</font>
<font color="black">2173.         &quot;&quot;&quot;Return self ** other [ % modulo].</font>
<font color="black">2174. </font>
<font color="black">2175.         With two arguments, compute self**other.</font>
<font color="black">2176. </font>
<font color="black">2177.         With three arguments, compute (self**other) % modulo.  For the</font>
<font color="black">2178.         three argument form, the following restrictions on the</font>
<font color="black">2179.         arguments hold:</font>
<font color="black">2180. </font>
<font color="black">2181.          - all three arguments must be integral</font>
<font color="black">2182.          - other must be nonnegative</font>
<font color="black">2183.          - either self or other (or both) must be nonzero</font>
<font color="black">2184.          - modulo must be nonzero and must have at most p digits,</font>
<font color="black">2185.            where p is the context precision.</font>
<font color="black">2186. </font>
<font color="black">2187.         If any of these restrictions is violated the InvalidOperation</font>
<font color="black">2188.         flag is raised.</font>
<font color="black">2189. </font>
<font color="black">2190.         The result of pow(self, other, modulo) is identical to the</font>
<font color="black">2191.         result that would be obtained by computing (self**other) %</font>
<font color="black">2192.         modulo with unbounded precision, but is computed more</font>
<font color="black">2193.         efficiently.  It is always exact.</font>
<font color="black">2194.         &quot;&quot;&quot;</font>
<font color="black">2195. </font>
<font color="red">2196.         if modulo is not None:</font>
<font color="red">2197.             return self._power_modulo(other, modulo, context)</font>
<font color="black">2198. </font>
<font color="red">2199.         other = _convert_other(other)</font>
<font color="red">2200.         if other is NotImplemented:</font>
<font color="red">2201.             return other</font>
<font color="black">2202. </font>
<font color="red">2203.         if context is None:</font>
<font color="red">2204.             context = getcontext()</font>
<font color="black">2205. </font>
<font color="black">2206.         # either argument is a NaN =&gt; result is NaN</font>
<font color="red">2207.         ans = self._check_nans(other, context)</font>
<font color="red">2208.         if ans:</font>
<font color="red">2209.             return ans</font>
<font color="black">2210. </font>
<font color="black">2211.         # 0**0 = NaN (!), x**0 = 1 for nonzero x (including +/-Infinity)</font>
<font color="red">2212.         if not other:</font>
<font color="red">2213.             if not self:</font>
<font color="red">2214.                 return context._raise_error(InvalidOperation, '0 ** 0')</font>
<font color="black">2215.             else:</font>
<font color="red">2216.                 return _One</font>
<font color="black">2217. </font>
<font color="black">2218.         # result has sign 1 iff self._sign is 1 and other is an odd integer</font>
<font color="red">2219.         result_sign = 0</font>
<font color="red">2220.         if self._sign == 1:</font>
<font color="red">2221.             if other._isinteger():</font>
<font color="red">2222.                 if not other._iseven():</font>
<font color="red">2223.                     result_sign = 1</font>
<font color="black">2224.             else:</font>
<font color="black">2225.                 # -ve**noninteger = NaN</font>
<font color="black">2226.                 # (-0)**noninteger = 0**noninteger</font>
<font color="red">2227.                 if self:</font>
<font color="red">2228.                     return context._raise_error(InvalidOperation,</font>
<font color="red">2229.                         'x ** y with x negative and y not an integer')</font>
<font color="black">2230.             # negate self, without doing any unwanted rounding</font>
<font color="red">2231.             self = self.copy_negate()</font>
<font color="black">2232. </font>
<font color="black">2233.         # 0**(+ve or Inf)= 0; 0**(-ve or -Inf) = Infinity</font>
<font color="red">2234.         if not self:</font>
<font color="red">2235.             if other._sign == 0:</font>
<font color="red">2236.                 return _dec_from_triple(result_sign, '0', 0)</font>
<font color="black">2237.             else:</font>
<font color="red">2238.                 return _SignedInfinity[result_sign]</font>
<font color="black">2239. </font>
<font color="black">2240.         # Inf**(+ve or Inf) = Inf; Inf**(-ve or -Inf) = 0</font>
<font color="red">2241.         if self._isinfinity():</font>
<font color="red">2242.             if other._sign == 0:</font>
<font color="red">2243.                 return _SignedInfinity[result_sign]</font>
<font color="black">2244.             else:</font>
<font color="red">2245.                 return _dec_from_triple(result_sign, '0', 0)</font>
<font color="black">2246. </font>
<font color="black">2247.         # 1**other = 1, but the choice of exponent and the flags</font>
<font color="black">2248.         # depend on the exponent of self, and on whether other is a</font>
<font color="black">2249.         # positive integer, a negative integer, or neither</font>
<font color="red">2250.         if self == _One:</font>
<font color="red">2251.             if other._isinteger():</font>
<font color="black">2252.                 # exp = max(self._exp*max(int(other), 0),</font>
<font color="black">2253.                 # 1-context.prec) but evaluating int(other) directly</font>
<font color="black">2254.                 # is dangerous until we know other is small (other</font>
<font color="black">2255.                 # could be 1e999999999)</font>
<font color="red">2256.                 if other._sign == 1:</font>
<font color="red">2257.                     multiplier = 0</font>
<font color="red">2258.                 elif other &gt; context.prec:</font>
<font color="red">2259.                     multiplier = context.prec</font>
<font color="black">2260.                 else:</font>
<font color="red">2261.                     multiplier = int(other)</font>
<font color="black">2262. </font>
<font color="red">2263.                 exp = self._exp * multiplier</font>
<font color="red">2264.                 if exp &lt; 1-context.prec:</font>
<font color="red">2265.                     exp = 1-context.prec</font>
<font color="red">2266.                     context._raise_error(Rounded)</font>
<font color="black">2267.             else:</font>
<font color="red">2268.                 context._raise_error(Inexact)</font>
<font color="red">2269.                 context._raise_error(Rounded)</font>
<font color="red">2270.                 exp = 1-context.prec</font>
<font color="black">2271. </font>
<font color="red">2272.             return _dec_from_triple(result_sign, '1'+'0'*-exp, exp)</font>
<font color="black">2273. </font>
<font color="black">2274.         # compute adjusted exponent of self</font>
<font color="red">2275.         self_adj = self.adjusted()</font>
<font color="black">2276. </font>
<font color="black">2277.         # self ** infinity is infinity if self &gt; 1, 0 if self &lt; 1</font>
<font color="black">2278.         # self ** -infinity is infinity if self &lt; 1, 0 if self &gt; 1</font>
<font color="red">2279.         if other._isinfinity():</font>
<font color="red">2280.             if (other._sign == 0) == (self_adj &lt; 0):</font>
<font color="red">2281.                 return _dec_from_triple(result_sign, '0', 0)</font>
<font color="black">2282.             else:</font>
<font color="red">2283.                 return _SignedInfinity[result_sign]</font>
<font color="black">2284. </font>
<font color="black">2285.         # from here on, the result always goes through the call</font>
<font color="black">2286.         # to _fix at the end of this function.</font>
<font color="red">2287.         ans = None</font>
<font color="red">2288.         exact = False</font>
<font color="black">2289. </font>
<font color="black">2290.         # crude test to catch cases of extreme overflow/underflow.  If</font>
<font color="black">2291.         # log10(self)*other &gt;= 10**bound and bound &gt;= len(str(Emax))</font>
<font color="black">2292.         # then 10**bound &gt;= 10**len(str(Emax)) &gt;= Emax+1 and hence</font>
<font color="black">2293.         # self**other &gt;= 10**(Emax+1), so overflow occurs.  The test</font>
<font color="black">2294.         # for underflow is similar.</font>
<font color="red">2295.         bound = self._log10_exp_bound() + other.adjusted()</font>
<font color="red">2296.         if (self_adj &gt;= 0) == (other._sign == 0):</font>
<font color="black">2297.             # self &gt; 1 and other +ve, or self &lt; 1 and other -ve</font>
<font color="black">2298.             # possibility of overflow</font>
<font color="red">2299.             if bound &gt;= len(str(context.Emax)):</font>
<font color="red">2300.                 ans = _dec_from_triple(result_sign, '1', context.Emax+1)</font>
<font color="black">2301.         else:</font>
<font color="black">2302.             # self &gt; 1 and other -ve, or self &lt; 1 and other +ve</font>
<font color="black">2303.             # possibility of underflow to 0</font>
<font color="red">2304.             Etiny = context.Etiny()</font>
<font color="red">2305.             if bound &gt;= len(str(-Etiny)):</font>
<font color="red">2306.                 ans = _dec_from_triple(result_sign, '1', Etiny-1)</font>
<font color="black">2307. </font>
<font color="black">2308.         # try for an exact result with precision +1</font>
<font color="red">2309.         if ans is None:</font>
<font color="red">2310.             ans = self._power_exact(other, context.prec + 1)</font>
<font color="red">2311.             if ans is not None:</font>
<font color="red">2312.                 if result_sign == 1:</font>
<font color="red">2313.                     ans = _dec_from_triple(1, ans._int, ans._exp)</font>
<font color="red">2314.                 exact = True</font>
<font color="black">2315. </font>
<font color="black">2316.         # usual case: inexact result, x**y computed directly as exp(y*log(x))</font>
<font color="red">2317.         if ans is None:</font>
<font color="red">2318.             p = context.prec</font>
<font color="red">2319.             x = _WorkRep(self)</font>
<font color="red">2320.             xc, xe = x.int, x.exp</font>
<font color="red">2321.             y = _WorkRep(other)</font>
<font color="red">2322.             yc, ye = y.int, y.exp</font>
<font color="red">2323.             if y.sign == 1:</font>
<font color="red">2324.                 yc = -yc</font>
<font color="black">2325. </font>
<font color="black">2326.             # compute correctly rounded result:  start with precision +3,</font>
<font color="black">2327.             # then increase precision until result is unambiguously roundable</font>
<font color="red">2328.             extra = 3</font>
<font color="red">2329.             while True:</font>
<font color="red">2330.                 coeff, exp = _dpower(xc, xe, yc, ye, p+extra)</font>
<font color="red">2331.                 if coeff % (5*10**(len(str(coeff))-p-1)):</font>
<font color="red">2332.                     break</font>
<font color="red">2333.                 extra += 3</font>
<font color="black">2334. </font>
<font color="red">2335.             ans = _dec_from_triple(result_sign, str(coeff), exp)</font>
<font color="black">2336. </font>
<font color="black">2337.         # unlike exp, ln and log10, the power function respects the</font>
<font color="black">2338.         # rounding mode; no need to switch to ROUND_HALF_EVEN here</font>
<font color="black">2339. </font>
<font color="black">2340.         # There's a difficulty here when 'other' is not an integer and</font>
<font color="black">2341.         # the result is exact.  In this case, the specification</font>
<font color="black">2342.         # requires that the Inexact flag be raised (in spite of</font>
<font color="black">2343.         # exactness), but since the result is exact _fix won't do this</font>
<font color="black">2344.         # for us.  (Correspondingly, the Underflow signal should also</font>
<font color="black">2345.         # be raised for subnormal results.)  We can't directly raise</font>
<font color="black">2346.         # these signals either before or after calling _fix, since</font>
<font color="black">2347.         # that would violate the precedence for signals.  So we wrap</font>
<font color="black">2348.         # the ._fix call in a temporary context, and reraise</font>
<font color="black">2349.         # afterwards.</font>
<font color="red">2350.         if exact and not other._isinteger():</font>
<font color="black">2351.             # pad with zeros up to length context.prec+1 if necessary; this</font>
<font color="black">2352.             # ensures that the Rounded signal will be raised.</font>
<font color="red">2353.             if len(ans._int) &lt;= context.prec:</font>
<font color="red">2354.                 expdiff = context.prec + 1 - len(ans._int)</font>
<font color="red">2355.                 ans = _dec_from_triple(ans._sign, ans._int+'0'*expdiff,</font>
<font color="red">2356.                                        ans._exp-expdiff)</font>
<font color="black">2357. </font>
<font color="black">2358.             # create a copy of the current context, with cleared flags/traps</font>
<font color="red">2359.             newcontext = context.copy()</font>
<font color="red">2360.             newcontext.clear_flags()</font>
<font color="red">2361.             for exception in _signals:</font>
<font color="red">2362.                 newcontext.traps[exception] = 0</font>
<font color="black">2363. </font>
<font color="black">2364.             # round in the new context</font>
<font color="red">2365.             ans = ans._fix(newcontext)</font>
<font color="black">2366. </font>
<font color="black">2367.             # raise Inexact, and if necessary, Underflow</font>
<font color="red">2368.             newcontext._raise_error(Inexact)</font>
<font color="red">2369.             if newcontext.flags[Subnormal]:</font>
<font color="red">2370.                 newcontext._raise_error(Underflow)</font>
<font color="black">2371. </font>
<font color="black">2372.             # propagate signals to the original context; _fix could</font>
<font color="black">2373.             # have raised any of Overflow, Underflow, Subnormal,</font>
<font color="black">2374.             # Inexact, Rounded, Clamped.  Overflow needs the correct</font>
<font color="black">2375.             # arguments.  Note that the order of the exceptions is</font>
<font color="black">2376.             # important here.</font>
<font color="red">2377.             if newcontext.flags[Overflow]:</font>
<font color="red">2378.                 context._raise_error(Overflow, 'above Emax', ans._sign)</font>
<font color="red">2379.             for exception in Underflow, Subnormal, Inexact, Rounded, Clamped:</font>
<font color="red">2380.                 if newcontext.flags[exception]:</font>
<font color="red">2381.                     context._raise_error(exception)</font>
<font color="black">2382. </font>
<font color="black">2383.         else:</font>
<font color="red">2384.             ans = ans._fix(context)</font>
<font color="black">2385. </font>
<font color="red">2386.         return ans</font>
<font color="black">2387. </font>
<font color="green">2388.     def __rpow__(self, other, context=None):</font>
<font color="black">2389.         &quot;&quot;&quot;Swaps self/other and returns __pow__.&quot;&quot;&quot;</font>
<font color="red">2390.         other = _convert_other(other)</font>
<font color="red">2391.         if other is NotImplemented:</font>
<font color="red">2392.             return other</font>
<font color="red">2393.         return other.__pow__(self, context=context)</font>
<font color="black">2394. </font>
<font color="green">2395.     def normalize(self, context=None):</font>
<font color="black">2396.         &quot;&quot;&quot;Normalize- strip trailing 0s, change anything equal to 0 to 0e0&quot;&quot;&quot;</font>
<font color="black">2397. </font>
<font color="red">2398.         if context is None:</font>
<font color="red">2399.             context = getcontext()</font>
<font color="black">2400. </font>
<font color="red">2401.         if self._is_special:</font>
<font color="red">2402.             ans = self._check_nans(context=context)</font>
<font color="red">2403.             if ans:</font>
<font color="red">2404.                 return ans</font>
<font color="black">2405. </font>
<font color="red">2406.         dup = self._fix(context)</font>
<font color="red">2407.         if dup._isinfinity():</font>
<font color="red">2408.             return dup</font>
<font color="black">2409. </font>
<font color="red">2410.         if not dup:</font>
<font color="red">2411.             return _dec_from_triple(dup._sign, '0', 0)</font>
<font color="red">2412.         exp_max = [context.Emax, context.Etop()][context._clamp]</font>
<font color="red">2413.         end = len(dup._int)</font>
<font color="red">2414.         exp = dup._exp</font>
<font color="red">2415.         while dup._int[end-1] == '0' and exp &lt; exp_max:</font>
<font color="red">2416.             exp += 1</font>
<font color="red">2417.             end -= 1</font>
<font color="red">2418.         return _dec_from_triple(dup._sign, dup._int[:end], exp)</font>
<font color="black">2419. </font>
<font color="green">2420.     def quantize(self, exp, rounding=None, context=None, watchexp=True):</font>
<font color="black">2421.         &quot;&quot;&quot;Quantize self so its exponent is the same as that of exp.</font>
<font color="black">2422. </font>
<font color="black">2423.         Similar to self._rescale(exp._exp) but with error checking.</font>
<font color="black">2424.         &quot;&quot;&quot;</font>
<font color="red">2425.         exp = _convert_other(exp, raiseit=True)</font>
<font color="black">2426. </font>
<font color="red">2427.         if context is None:</font>
<font color="red">2428.             context = getcontext()</font>
<font color="red">2429.         if rounding is None:</font>
<font color="red">2430.             rounding = context.rounding</font>
<font color="black">2431. </font>
<font color="red">2432.         if self._is_special or exp._is_special:</font>
<font color="red">2433.             ans = self._check_nans(exp, context)</font>
<font color="red">2434.             if ans:</font>
<font color="red">2435.                 return ans</font>
<font color="black">2436. </font>
<font color="red">2437.             if exp._isinfinity() or self._isinfinity():</font>
<font color="red">2438.                 if exp._isinfinity() and self._isinfinity():</font>
<font color="red">2439.                     return Decimal(self)  # if both are inf, it is OK</font>
<font color="red">2440.                 return context._raise_error(InvalidOperation,</font>
<font color="red">2441.                                         'quantize with one INF')</font>
<font color="black">2442. </font>
<font color="black">2443.         # if we're not watching exponents, do a simple rescale</font>
<font color="red">2444.         if not watchexp:</font>
<font color="red">2445.             ans = self._rescale(exp._exp, rounding)</font>
<font color="black">2446.             # raise Inexact and Rounded where appropriate</font>
<font color="red">2447.             if ans._exp &gt; self._exp:</font>
<font color="red">2448.                 context._raise_error(Rounded)</font>
<font color="red">2449.                 if ans != self:</font>
<font color="red">2450.                     context._raise_error(Inexact)</font>
<font color="red">2451.             return ans</font>
<font color="black">2452. </font>
<font color="black">2453.         # exp._exp should be between Etiny and Emax</font>
<font color="red">2454.         if not (context.Etiny() &lt;= exp._exp &lt;= context.Emax):</font>
<font color="red">2455.             return context._raise_error(InvalidOperation,</font>
<font color="red">2456.                    'target exponent out of bounds in quantize')</font>
<font color="black">2457. </font>
<font color="red">2458.         if not self:</font>
<font color="red">2459.             ans = _dec_from_triple(self._sign, '0', exp._exp)</font>
<font color="red">2460.             return ans._fix(context)</font>
<font color="black">2461. </font>
<font color="red">2462.         self_adjusted = self.adjusted()</font>
<font color="red">2463.         if self_adjusted &gt; context.Emax:</font>
<font color="red">2464.             return context._raise_error(InvalidOperation,</font>
<font color="red">2465.                                         'exponent of quantize result too large for current context')</font>
<font color="red">2466.         if self_adjusted - exp._exp + 1 &gt; context.prec:</font>
<font color="red">2467.             return context._raise_error(InvalidOperation,</font>
<font color="red">2468.                                         'quantize result has too many digits for current context')</font>
<font color="black">2469. </font>
<font color="red">2470.         ans = self._rescale(exp._exp, rounding)</font>
<font color="red">2471.         if ans.adjusted() &gt; context.Emax:</font>
<font color="red">2472.             return context._raise_error(InvalidOperation,</font>
<font color="red">2473.                                         'exponent of quantize result too large for current context')</font>
<font color="red">2474.         if len(ans._int) &gt; context.prec:</font>
<font color="red">2475.             return context._raise_error(InvalidOperation,</font>
<font color="red">2476.                                         'quantize result has too many digits for current context')</font>
<font color="black">2477. </font>
<font color="black">2478.         # raise appropriate flags</font>
<font color="red">2479.         if ans and ans.adjusted() &lt; context.Emin:</font>
<font color="red">2480.             context._raise_error(Subnormal)</font>
<font color="red">2481.         if ans._exp &gt; self._exp:</font>
<font color="red">2482.             if ans != self:</font>
<font color="red">2483.                 context._raise_error(Inexact)</font>
<font color="red">2484.             context._raise_error(Rounded)</font>
<font color="black">2485. </font>
<font color="black">2486.         # call to fix takes care of any necessary folddown, and</font>
<font color="black">2487.         # signals Clamped if necessary</font>
<font color="red">2488.         ans = ans._fix(context)</font>
<font color="red">2489.         return ans</font>
<font color="black">2490. </font>
<font color="green">2491.     def same_quantum(self, other):</font>
<font color="black">2492.         &quot;&quot;&quot;Return True if self and other have the same exponent; otherwise</font>
<font color="black">2493.         return False.</font>
<font color="black">2494. </font>
<font color="black">2495.         If either operand is a special value, the following rules are used:</font>
<font color="black">2496.            * return True if both operands are infinities</font>
<font color="black">2497.            * return True if both operands are NaNs</font>
<font color="black">2498.            * otherwise, return False.</font>
<font color="black">2499.         &quot;&quot;&quot;</font>
<font color="red">2500.         other = _convert_other(other, raiseit=True)</font>
<font color="red">2501.         if self._is_special or other._is_special:</font>
<font color="red">2502.             return (self.is_nan() and other.is_nan() or</font>
<font color="red">2503.                     self.is_infinite() and other.is_infinite())</font>
<font color="red">2504.         return self._exp == other._exp</font>
<font color="black">2505. </font>
<font color="green">2506.     def _rescale(self, exp, rounding):</font>
<font color="black">2507.         &quot;&quot;&quot;Rescale self so that the exponent is exp, either by padding with zeros</font>
<font color="black">2508.         or by truncating digits, using the given rounding mode.</font>
<font color="black">2509. </font>
<font color="black">2510.         Specials are returned without change.  This operation is</font>
<font color="black">2511.         quiet: it raises no flags, and uses no information from the</font>
<font color="black">2512.         context.</font>
<font color="black">2513. </font>
<font color="black">2514.         exp = exp to scale to (an integer)</font>
<font color="black">2515.         rounding = rounding mode</font>
<font color="black">2516.         &quot;&quot;&quot;</font>
<font color="red">2517.         if self._is_special:</font>
<font color="red">2518.             return Decimal(self)</font>
<font color="red">2519.         if not self:</font>
<font color="red">2520.             return _dec_from_triple(self._sign, '0', exp)</font>
<font color="black">2521. </font>
<font color="red">2522.         if self._exp &gt;= exp:</font>
<font color="black">2523.             # pad answer with zeros if necessary</font>
<font color="red">2524.             return _dec_from_triple(self._sign,</font>
<font color="red">2525.                                         self._int + '0'*(self._exp - exp), exp)</font>
<font color="black">2526. </font>
<font color="black">2527.         # too many digits; round and lose data.  If self.adjusted() &lt;</font>
<font color="black">2528.         # exp-1, replace self by 10**(exp-1) before rounding</font>
<font color="red">2529.         digits = len(self._int) + self._exp - exp</font>
<font color="red">2530.         if digits &lt; 0:</font>
<font color="red">2531.             self = _dec_from_triple(self._sign, '1', exp-1)</font>
<font color="red">2532.             digits = 0</font>
<font color="red">2533.         this_function = self._pick_rounding_function[rounding]</font>
<font color="red">2534.         changed = this_function(self, digits)</font>
<font color="red">2535.         coeff = self._int[:digits] or '0'</font>
<font color="red">2536.         if changed == 1:</font>
<font color="red">2537.             coeff = str(int(coeff)+1)</font>
<font color="red">2538.         return _dec_from_triple(self._sign, coeff, exp)</font>
<font color="black">2539. </font>
<font color="green">2540.     def _round(self, places, rounding):</font>
<font color="black">2541.         &quot;&quot;&quot;Round a nonzero, nonspecial Decimal to a fixed number of</font>
<font color="black">2542.         significant figures, using the given rounding mode.</font>
<font color="black">2543. </font>
<font color="black">2544.         Infinities, NaNs and zeros are returned unaltered.</font>
<font color="black">2545. </font>
<font color="black">2546.         This operation is quiet: it raises no flags, and uses no</font>
<font color="black">2547.         information from the context.</font>
<font color="black">2548. </font>
<font color="black">2549.         &quot;&quot;&quot;</font>
<font color="red">2550.         if places &lt;= 0:</font>
<font color="red">2551.             raise ValueError(&quot;argument should be at least 1 in _round&quot;)</font>
<font color="red">2552.         if self._is_special or not self:</font>
<font color="red">2553.             return Decimal(self)</font>
<font color="red">2554.         ans = self._rescale(self.adjusted()+1-places, rounding)</font>
<font color="black">2555.         # it can happen that the rescale alters the adjusted exponent;</font>
<font color="black">2556.         # for example when rounding 99.97 to 3 significant figures.</font>
<font color="black">2557.         # When this happens we end up with an extra 0 at the end of</font>
<font color="black">2558.         # the number; a second rescale fixes this.</font>
<font color="red">2559.         if ans.adjusted() != self.adjusted():</font>
<font color="red">2560.             ans = ans._rescale(ans.adjusted()+1-places, rounding)</font>
<font color="red">2561.         return ans</font>
<font color="black">2562. </font>
<font color="green">2563.     def to_integral_exact(self, rounding=None, context=None):</font>
<font color="black">2564.         &quot;&quot;&quot;Rounds to a nearby integer.</font>
<font color="black">2565. </font>
<font color="black">2566.         If no rounding mode is specified, take the rounding mode from</font>
<font color="black">2567.         the context.  This method raises the Rounded and Inexact flags</font>
<font color="black">2568.         when appropriate.</font>
<font color="black">2569. </font>
<font color="black">2570.         See also: to_integral_value, which does exactly the same as</font>
<font color="black">2571.         this method except that it doesn't raise Inexact or Rounded.</font>
<font color="black">2572.         &quot;&quot;&quot;</font>
<font color="red">2573.         if self._is_special:</font>
<font color="red">2574.             ans = self._check_nans(context=context)</font>
<font color="red">2575.             if ans:</font>
<font color="red">2576.                 return ans</font>
<font color="red">2577.             return Decimal(self)</font>
<font color="red">2578.         if self._exp &gt;= 0:</font>
<font color="red">2579.             return Decimal(self)</font>
<font color="red">2580.         if not self:</font>
<font color="red">2581.             return _dec_from_triple(self._sign, '0', 0)</font>
<font color="red">2582.         if context is None:</font>
<font color="red">2583.             context = getcontext()</font>
<font color="red">2584.         if rounding is None:</font>
<font color="red">2585.             rounding = context.rounding</font>
<font color="red">2586.         ans = self._rescale(0, rounding)</font>
<font color="red">2587.         if ans != self:</font>
<font color="red">2588.             context._raise_error(Inexact)</font>
<font color="red">2589.         context._raise_error(Rounded)</font>
<font color="red">2590.         return ans</font>
<font color="black">2591. </font>
<font color="green">2592.     def to_integral_value(self, rounding=None, context=None):</font>
<font color="black">2593.         &quot;&quot;&quot;Rounds to the nearest integer, without raising inexact, rounded.&quot;&quot;&quot;</font>
<font color="red">2594.         if context is None:</font>
<font color="red">2595.             context = getcontext()</font>
<font color="red">2596.         if rounding is None:</font>
<font color="red">2597.             rounding = context.rounding</font>
<font color="red">2598.         if self._is_special:</font>
<font color="red">2599.             ans = self._check_nans(context=context)</font>
<font color="red">2600.             if ans:</font>
<font color="red">2601.                 return ans</font>
<font color="red">2602.             return Decimal(self)</font>
<font color="red">2603.         if self._exp &gt;= 0:</font>
<font color="red">2604.             return Decimal(self)</font>
<font color="black">2605.         else:</font>
<font color="red">2606.             return self._rescale(0, rounding)</font>
<font color="black">2607. </font>
<font color="black">2608.     # the method name changed, but we provide also the old one, for compatibility</font>
<font color="green">2609.     to_integral = to_integral_value</font>
<font color="black">2610. </font>
<font color="green">2611.     def sqrt(self, context=None):</font>
<font color="black">2612.         &quot;&quot;&quot;Return the square root of self.&quot;&quot;&quot;</font>
<font color="red">2613.         if context is None:</font>
<font color="red">2614.             context = getcontext()</font>
<font color="black">2615. </font>
<font color="red">2616.         if self._is_special:</font>
<font color="red">2617.             ans = self._check_nans(context=context)</font>
<font color="red">2618.             if ans:</font>
<font color="red">2619.                 return ans</font>
<font color="black">2620. </font>
<font color="red">2621.             if self._isinfinity() and self._sign == 0:</font>
<font color="red">2622.                 return Decimal(self)</font>
<font color="black">2623. </font>
<font color="red">2624.         if not self:</font>
<font color="black">2625.             # exponent = self._exp // 2.  sqrt(-0) = -0</font>
<font color="red">2626.             ans = _dec_from_triple(self._sign, '0', self._exp // 2)</font>
<font color="red">2627.             return ans._fix(context)</font>
<font color="black">2628. </font>
<font color="red">2629.         if self._sign == 1:</font>
<font color="red">2630.             return context._raise_error(InvalidOperation, 'sqrt(-x), x &gt; 0')</font>
<font color="black">2631. </font>
<font color="black">2632.         # At this point self represents a positive number.  Let p be</font>
<font color="black">2633.         # the desired precision and express self in the form c*100**e</font>
<font color="black">2634.         # with c a positive real number and e an integer, c and e</font>
<font color="black">2635.         # being chosen so that 100**(p-1) &lt;= c &lt; 100**p.  Then the</font>
<font color="black">2636.         # (exact) square root of self is sqrt(c)*10**e, and 10**(p-1)</font>
<font color="black">2637.         # &lt;= sqrt(c) &lt; 10**p, so the closest representable Decimal at</font>
<font color="black">2638.         # precision p is n*10**e where n = round_half_even(sqrt(c)),</font>
<font color="black">2639.         # the closest integer to sqrt(c) with the even integer chosen</font>
<font color="black">2640.         # in the case of a tie.</font>
<font color="black">2641.         #</font>
<font color="black">2642.         # To ensure correct rounding in all cases, we use the</font>
<font color="black">2643.         # following trick: we compute the square root to an extra</font>
<font color="black">2644.         # place (precision p+1 instead of precision p), rounding down.</font>
<font color="black">2645.         # Then, if the result is inexact and its last digit is 0 or 5,</font>
<font color="black">2646.         # we increase the last digit to 1 or 6 respectively; if it's</font>
<font color="black">2647.         # exact we leave the last digit alone.  Now the final round to</font>
<font color="black">2648.         # p places (or fewer in the case of underflow) will round</font>
<font color="black">2649.         # correctly and raise the appropriate flags.</font>
<font color="black">2650. </font>
<font color="black">2651.         # use an extra digit of precision</font>
<font color="red">2652.         prec = context.prec+1</font>
<font color="black">2653. </font>
<font color="black">2654.         # write argument in the form c*100**e where e = self._exp//2</font>
<font color="black">2655.         # is the 'ideal' exponent, to be used if the square root is</font>
<font color="black">2656.         # exactly representable.  l is the number of 'digits' of c in</font>
<font color="black">2657.         # base 100, so that 100**(l-1) &lt;= c &lt; 100**l.</font>
<font color="red">2658.         op = _WorkRep(self)</font>
<font color="red">2659.         e = op.exp &gt;&gt; 1</font>
<font color="red">2660.         if op.exp &amp; 1:</font>
<font color="red">2661.             c = op.int * 10</font>
<font color="red">2662.             l = (len(self._int) &gt;&gt; 1) + 1</font>
<font color="black">2663.         else:</font>
<font color="red">2664.             c = op.int</font>
<font color="red">2665.             l = len(self._int)+1 &gt;&gt; 1</font>
<font color="black">2666. </font>
<font color="black">2667.         # rescale so that c has exactly prec base 100 'digits'</font>
<font color="red">2668.         shift = prec-l</font>
<font color="red">2669.         if shift &gt;= 0:</font>
<font color="red">2670.             c *= 100**shift</font>
<font color="red">2671.             exact = True</font>
<font color="black">2672.         else:</font>
<font color="red">2673.             c, remainder = divmod(c, 100**-shift)</font>
<font color="red">2674.             exact = not remainder</font>
<font color="red">2675.         e -= shift</font>
<font color="black">2676. </font>
<font color="black">2677.         # find n = floor(sqrt(c)) using Newton's method</font>
<font color="red">2678.         n = 10**prec</font>
<font color="red">2679.         while True:</font>
<font color="red">2680.             q = c//n</font>
<font color="red">2681.             if n &lt;= q:</font>
<font color="red">2682.                 break</font>
<font color="black">2683.             else:</font>
<font color="red">2684.                 n = n + q &gt;&gt; 1</font>
<font color="red">2685.         exact = exact and n*n == c</font>
<font color="black">2686. </font>
<font color="red">2687.         if exact:</font>
<font color="black">2688.             # result is exact; rescale to use ideal exponent e</font>
<font color="red">2689.             if shift &gt;= 0:</font>
<font color="black">2690.                 # assert n % 10**shift == 0</font>
<font color="red">2691.                 n //= 10**shift</font>
<font color="black">2692.             else:</font>
<font color="red">2693.                 n *= 10**-shift</font>
<font color="red">2694.             e += shift</font>
<font color="black">2695.         else:</font>
<font color="black">2696.             # result is not exact; fix last digit as described above</font>
<font color="red">2697.             if n % 5 == 0:</font>
<font color="red">2698.                 n += 1</font>
<font color="black">2699. </font>
<font color="red">2700.         ans = _dec_from_triple(0, str(n), e)</font>
<font color="black">2701. </font>
<font color="black">2702.         # round, and fit to current context</font>
<font color="red">2703.         context = context._shallow_copy()</font>
<font color="red">2704.         rounding = context._set_rounding(ROUND_HALF_EVEN)</font>
<font color="red">2705.         ans = ans._fix(context)</font>
<font color="red">2706.         context.rounding = rounding</font>
<font color="black">2707. </font>
<font color="red">2708.         return ans</font>
<font color="black">2709. </font>
<font color="green">2710.     def max(self, other, context=None):</font>
<font color="black">2711.         &quot;&quot;&quot;Returns the larger value.</font>
<font color="black">2712. </font>
<font color="black">2713.         Like max(self, other) except if one is not a number, returns</font>
<font color="black">2714.         NaN (and signals if one is sNaN).  Also rounds.</font>
<font color="black">2715.         &quot;&quot;&quot;</font>
<font color="red">2716.         other = _convert_other(other, raiseit=True)</font>
<font color="black">2717. </font>
<font color="red">2718.         if context is None:</font>
<font color="red">2719.             context = getcontext()</font>
<font color="black">2720. </font>
<font color="red">2721.         if self._is_special or other._is_special:</font>
<font color="black">2722.             # If one operand is a quiet NaN and the other is number, then the</font>
<font color="black">2723.             # number is always returned</font>
<font color="red">2724.             sn = self._isnan()</font>
<font color="red">2725.             on = other._isnan()</font>
<font color="red">2726.             if sn or on:</font>
<font color="red">2727.                 if on == 1 and sn == 0:</font>
<font color="red">2728.                     return self._fix(context)</font>
<font color="red">2729.                 if sn == 1 and on == 0:</font>
<font color="red">2730.                     return other._fix(context)</font>
<font color="red">2731.                 return self._check_nans(other, context)</font>
<font color="black">2732. </font>
<font color="red">2733.         c = self._cmp(other)</font>
<font color="red">2734.         if c == 0:</font>
<font color="black">2735.             # If both operands are finite and equal in numerical value</font>
<font color="black">2736.             # then an ordering is applied:</font>
<font color="black">2737.             #</font>
<font color="black">2738.             # If the signs differ then max returns the operand with the</font>
<font color="black">2739.             # positive sign and min returns the operand with the negative sign</font>
<font color="black">2740.             #</font>
<font color="black">2741.             # If the signs are the same then the exponent is used to select</font>
<font color="black">2742.             # the result.  This is exactly the ordering used in compare_total.</font>
<font color="red">2743.             c = self.compare_total(other)</font>
<font color="black">2744. </font>
<font color="red">2745.         if c == -1:</font>
<font color="red">2746.             ans = other</font>
<font color="black">2747.         else:</font>
<font color="red">2748.             ans = self</font>
<font color="black">2749. </font>
<font color="red">2750.         return ans._fix(context)</font>
<font color="black">2751. </font>
<font color="green">2752.     def min(self, other, context=None):</font>
<font color="black">2753.         &quot;&quot;&quot;Returns the smaller value.</font>
<font color="black">2754. </font>
<font color="black">2755.         Like min(self, other) except if one is not a number, returns</font>
<font color="black">2756.         NaN (and signals if one is sNaN).  Also rounds.</font>
<font color="black">2757.         &quot;&quot;&quot;</font>
<font color="red">2758.         other = _convert_other(other, raiseit=True)</font>
<font color="black">2759. </font>
<font color="red">2760.         if context is None:</font>
<font color="red">2761.             context = getcontext()</font>
<font color="black">2762. </font>
<font color="red">2763.         if self._is_special or other._is_special:</font>
<font color="black">2764.             # If one operand is a quiet NaN and the other is number, then the</font>
<font color="black">2765.             # number is always returned</font>
<font color="red">2766.             sn = self._isnan()</font>
<font color="red">2767.             on = other._isnan()</font>
<font color="red">2768.             if sn or on:</font>
<font color="red">2769.                 if on == 1 and sn == 0:</font>
<font color="red">2770.                     return self._fix(context)</font>
<font color="red">2771.                 if sn == 1 and on == 0:</font>
<font color="red">2772.                     return other._fix(context)</font>
<font color="red">2773.                 return self._check_nans(other, context)</font>
<font color="black">2774. </font>
<font color="red">2775.         c = self._cmp(other)</font>
<font color="red">2776.         if c == 0:</font>
<font color="red">2777.             c = self.compare_total(other)</font>
<font color="black">2778. </font>
<font color="red">2779.         if c == -1:</font>
<font color="red">2780.             ans = self</font>
<font color="black">2781.         else:</font>
<font color="red">2782.             ans = other</font>
<font color="black">2783. </font>
<font color="red">2784.         return ans._fix(context)</font>
<font color="black">2785. </font>
<font color="green">2786.     def _isinteger(self):</font>
<font color="black">2787.         &quot;&quot;&quot;Returns whether self is an integer&quot;&quot;&quot;</font>
<font color="red">2788.         if self._is_special:</font>
<font color="red">2789.             return False</font>
<font color="red">2790.         if self._exp &gt;= 0:</font>
<font color="red">2791.             return True</font>
<font color="red">2792.         rest = self._int[self._exp:]</font>
<font color="red">2793.         return rest == '0'*len(rest)</font>
<font color="black">2794. </font>
<font color="green">2795.     def _iseven(self):</font>
<font color="black">2796.         &quot;&quot;&quot;Returns True if self is even.  Assumes self is an integer.&quot;&quot;&quot;</font>
<font color="red">2797.         if not self or self._exp &gt; 0:</font>
<font color="red">2798.             return True</font>
<font color="red">2799.         return self._int[-1+self._exp] in '02468'</font>
<font color="black">2800. </font>
<font color="green">2801.     def adjusted(self):</font>
<font color="black">2802.         &quot;&quot;&quot;Return the adjusted exponent of self&quot;&quot;&quot;</font>
<font color="red">2803.         try:</font>
<font color="red">2804.             return self._exp + len(self._int) - 1</font>
<font color="black">2805.         # If NaN or Infinity, self._exp is string</font>
<font color="red">2806.         except TypeError:</font>
<font color="red">2807.             return 0</font>
<font color="black">2808. </font>
<font color="green">2809.     def canonical(self, context=None):</font>
<font color="black">2810.         &quot;&quot;&quot;Returns the same Decimal object.</font>
<font color="black">2811. </font>
<font color="black">2812.         As we do not have different encodings for the same number, the</font>
<font color="black">2813.         received object already is in its canonical form.</font>
<font color="black">2814.         &quot;&quot;&quot;</font>
<font color="red">2815.         return self</font>
<font color="black">2816. </font>
<font color="green">2817.     def compare_signal(self, other, context=None):</font>
<font color="black">2818.         &quot;&quot;&quot;Compares self to the other operand numerically.</font>
<font color="black">2819. </font>
<font color="black">2820.         It's pretty much like compare(), but all NaNs signal, with signaling</font>
<font color="black">2821.         NaNs taking precedence over quiet NaNs.</font>
<font color="black">2822.         &quot;&quot;&quot;</font>
<font color="red">2823.         other = _convert_other(other, raiseit = True)</font>
<font color="red">2824.         ans = self._compare_check_nans(other, context)</font>
<font color="red">2825.         if ans:</font>
<font color="red">2826.             return ans</font>
<font color="red">2827.         return self.compare(other, context=context)</font>
<font color="black">2828. </font>
<font color="green">2829.     def compare_total(self, other):</font>
<font color="black">2830.         &quot;&quot;&quot;Compares self to other using the abstract representations.</font>
<font color="black">2831. </font>
<font color="black">2832.         This is not like the standard compare, which use their numerical</font>
<font color="black">2833.         value. Note that a total ordering is defined for all possible abstract</font>
<font color="black">2834.         representations.</font>
<font color="black">2835.         &quot;&quot;&quot;</font>
<font color="red">2836.         other = _convert_other(other, raiseit=True)</font>
<font color="black">2837. </font>
<font color="black">2838.         # if one is negative and the other is positive, it's easy</font>
<font color="red">2839.         if self._sign and not other._sign:</font>
<font color="red">2840.             return _NegativeOne</font>
<font color="red">2841.         if not self._sign and other._sign:</font>
<font color="red">2842.             return _One</font>
<font color="red">2843.         sign = self._sign</font>
<font color="black">2844. </font>
<font color="black">2845.         # let's handle both NaN types</font>
<font color="red">2846.         self_nan = self._isnan()</font>
<font color="red">2847.         other_nan = other._isnan()</font>
<font color="red">2848.         if self_nan or other_nan:</font>
<font color="red">2849.             if self_nan == other_nan:</font>
<font color="black">2850.                 # compare payloads as though they're integers</font>
<font color="red">2851.                 self_key = len(self._int), self._int</font>
<font color="red">2852.                 other_key = len(other._int), other._int</font>
<font color="red">2853.                 if self_key &lt; other_key:</font>
<font color="red">2854.                     if sign:</font>
<font color="red">2855.                         return _One</font>
<font color="black">2856.                     else:</font>
<font color="red">2857.                         return _NegativeOne</font>
<font color="red">2858.                 if self_key &gt; other_key:</font>
<font color="red">2859.                     if sign:</font>
<font color="red">2860.                         return _NegativeOne</font>
<font color="black">2861.                     else:</font>
<font color="red">2862.                         return _One</font>
<font color="red">2863.                 return _Zero</font>
<font color="black">2864. </font>
<font color="red">2865.             if sign:</font>
<font color="red">2866.                 if self_nan == 1:</font>
<font color="red">2867.                     return _NegativeOne</font>
<font color="red">2868.                 if other_nan == 1:</font>
<font color="red">2869.                     return _One</font>
<font color="red">2870.                 if self_nan == 2:</font>
<font color="red">2871.                     return _NegativeOne</font>
<font color="red">2872.                 if other_nan == 2:</font>
<font color="red">2873.                     return _One</font>
<font color="black">2874.             else:</font>
<font color="red">2875.                 if self_nan == 1:</font>
<font color="red">2876.                     return _One</font>
<font color="red">2877.                 if other_nan == 1:</font>
<font color="red">2878.                     return _NegativeOne</font>
<font color="red">2879.                 if self_nan == 2:</font>
<font color="red">2880.                     return _One</font>
<font color="red">2881.                 if other_nan == 2:</font>
<font color="red">2882.                     return _NegativeOne</font>
<font color="black">2883. </font>
<font color="red">2884.         if self &lt; other:</font>
<font color="red">2885.             return _NegativeOne</font>
<font color="red">2886.         if self &gt; other:</font>
<font color="red">2887.             return _One</font>
<font color="black">2888. </font>
<font color="red">2889.         if self._exp &lt; other._exp:</font>
<font color="red">2890.             if sign:</font>
<font color="red">2891.                 return _One</font>
<font color="black">2892.             else:</font>
<font color="red">2893.                 return _NegativeOne</font>
<font color="red">2894.         if self._exp &gt; other._exp:</font>
<font color="red">2895.             if sign:</font>
<font color="red">2896.                 return _NegativeOne</font>
<font color="black">2897.             else:</font>
<font color="red">2898.                 return _One</font>
<font color="red">2899.         return _Zero</font>
<font color="black">2900. </font>
<font color="black">2901. </font>
<font color="green">2902.     def compare_total_mag(self, other):</font>
<font color="black">2903.         &quot;&quot;&quot;Compares self to other using abstract repr., ignoring sign.</font>
<font color="black">2904. </font>
<font color="black">2905.         Like compare_total, but with operand's sign ignored and assumed to be 0.</font>
<font color="black">2906.         &quot;&quot;&quot;</font>
<font color="red">2907.         other = _convert_other(other, raiseit=True)</font>
<font color="black">2908. </font>
<font color="red">2909.         s = self.copy_abs()</font>
<font color="red">2910.         o = other.copy_abs()</font>
<font color="red">2911.         return s.compare_total(o)</font>
<font color="black">2912. </font>
<font color="green">2913.     def copy_abs(self):</font>
<font color="black">2914.         &quot;&quot;&quot;Returns a copy with the sign set to 0. &quot;&quot;&quot;</font>
<font color="red">2915.         return _dec_from_triple(0, self._int, self._exp, self._is_special)</font>
<font color="black">2916. </font>
<font color="green">2917.     def copy_negate(self):</font>
<font color="black">2918.         &quot;&quot;&quot;Returns a copy with the sign inverted.&quot;&quot;&quot;</font>
<font color="red">2919.         if self._sign:</font>
<font color="red">2920.             return _dec_from_triple(0, self._int, self._exp, self._is_special)</font>
<font color="black">2921.         else:</font>
<font color="red">2922.             return _dec_from_triple(1, self._int, self._exp, self._is_special)</font>
<font color="black">2923. </font>
<font color="green">2924.     def copy_sign(self, other):</font>
<font color="black">2925.         &quot;&quot;&quot;Returns self with the sign of other.&quot;&quot;&quot;</font>
<font color="red">2926.         other = _convert_other(other, raiseit=True)</font>
<font color="red">2927.         return _dec_from_triple(other._sign, self._int,</font>
<font color="red">2928.                                 self._exp, self._is_special)</font>
<font color="black">2929. </font>
<font color="green">2930.     def exp(self, context=None):</font>
<font color="black">2931.         &quot;&quot;&quot;Returns e ** self.&quot;&quot;&quot;</font>
<font color="black">2932. </font>
<font color="red">2933.         if context is None:</font>
<font color="red">2934.             context = getcontext()</font>
<font color="black">2935. </font>
<font color="black">2936.         # exp(NaN) = NaN</font>
<font color="red">2937.         ans = self._check_nans(context=context)</font>
<font color="red">2938.         if ans:</font>
<font color="red">2939.             return ans</font>
<font color="black">2940. </font>
<font color="black">2941.         # exp(-Infinity) = 0</font>
<font color="red">2942.         if self._isinfinity() == -1:</font>
<font color="red">2943.             return _Zero</font>
<font color="black">2944. </font>
<font color="black">2945.         # exp(0) = 1</font>
<font color="red">2946.         if not self:</font>
<font color="red">2947.             return _One</font>
<font color="black">2948. </font>
<font color="black">2949.         # exp(Infinity) = Infinity</font>
<font color="red">2950.         if self._isinfinity() == 1:</font>
<font color="red">2951.             return Decimal(self)</font>
<font color="black">2952. </font>
<font color="black">2953.         # the result is now guaranteed to be inexact (the true</font>
<font color="black">2954.         # mathematical result is transcendental). There's no need to</font>
<font color="black">2955.         # raise Rounded and Inexact here---they'll always be raised as</font>
<font color="black">2956.         # a result of the call to _fix.</font>
<font color="red">2957.         p = context.prec</font>
<font color="red">2958.         adj = self.adjusted()</font>
<font color="black">2959. </font>
<font color="black">2960.         # we only need to do any computation for quite a small range</font>
<font color="black">2961.         # of adjusted exponents---for example, -29 &lt;= adj &lt;= 10 for</font>
<font color="black">2962.         # the default context.  For smaller exponent the result is</font>
<font color="black">2963.         # indistinguishable from 1 at the given precision, while for</font>
<font color="black">2964.         # larger exponent the result either overflows or underflows.</font>
<font color="red">2965.         if self._sign == 0 and adj &gt; len(str((context.Emax+1)*3)):</font>
<font color="black">2966.             # overflow</font>
<font color="red">2967.             ans = _dec_from_triple(0, '1', context.Emax+1)</font>
<font color="red">2968.         elif self._sign == 1 and adj &gt; len(str((-context.Etiny()+1)*3)):</font>
<font color="black">2969.             # underflow to 0</font>
<font color="red">2970.             ans = _dec_from_triple(0, '1', context.Etiny()-1)</font>
<font color="red">2971.         elif self._sign == 0 and adj &lt; -p:</font>
<font color="black">2972.             # p+1 digits; final round will raise correct flags</font>
<font color="red">2973.             ans = _dec_from_triple(0, '1' + '0'*(p-1) + '1', -p)</font>
<font color="red">2974.         elif self._sign == 1 and adj &lt; -p-1:</font>
<font color="black">2975.             # p+1 digits; final round will raise correct flags</font>
<font color="red">2976.             ans = _dec_from_triple(0, '9'*(p+1), -p-1)</font>
<font color="black">2977.         # general case</font>
<font color="black">2978.         else:</font>
<font color="red">2979.             op = _WorkRep(self)</font>
<font color="red">2980.             c, e = op.int, op.exp</font>
<font color="red">2981.             if op.sign == 1:</font>
<font color="red">2982.                 c = -c</font>
<font color="black">2983. </font>
<font color="black">2984.             # compute correctly rounded result: increase precision by</font>
<font color="black">2985.             # 3 digits at a time until we get an unambiguously</font>
<font color="black">2986.             # roundable result</font>
<font color="red">2987.             extra = 3</font>
<font color="red">2988.             while True:</font>
<font color="red">2989.                 coeff, exp = _dexp(c, e, p+extra)</font>
<font color="red">2990.                 if coeff % (5*10**(len(str(coeff))-p-1)):</font>
<font color="red">2991.                     break</font>
<font color="red">2992.                 extra += 3</font>
<font color="black">2993. </font>
<font color="red">2994.             ans = _dec_from_triple(0, str(coeff), exp)</font>
<font color="black">2995. </font>
<font color="black">2996.         # at this stage, ans should round correctly with *any*</font>
<font color="black">2997.         # rounding mode, not just with ROUND_HALF_EVEN</font>
<font color="red">2998.         context = context._shallow_copy()</font>
<font color="red">2999.         rounding = context._set_rounding(ROUND_HALF_EVEN)</font>
<font color="red">3000.         ans = ans._fix(context)</font>
<font color="red">3001.         context.rounding = rounding</font>
<font color="black">3002. </font>
<font color="red">3003.         return ans</font>
<font color="black">3004. </font>
<font color="green">3005.     def is_canonical(self):</font>
<font color="black">3006.         &quot;&quot;&quot;Return True if self is canonical; otherwise return False.</font>
<font color="black">3007. </font>
<font color="black">3008.         Currently, the encoding of a Decimal instance is always</font>
<font color="black">3009.         canonical, so this method returns True for any Decimal.</font>
<font color="black">3010.         &quot;&quot;&quot;</font>
<font color="red">3011.         return True</font>
<font color="black">3012. </font>
<font color="green">3013.     def is_finite(self):</font>
<font color="black">3014.         &quot;&quot;&quot;Return True if self is finite; otherwise return False.</font>
<font color="black">3015. </font>
<font color="black">3016.         A Decimal instance is considered finite if it is neither</font>
<font color="black">3017.         infinite nor a NaN.</font>
<font color="black">3018.         &quot;&quot;&quot;</font>
<font color="red">3019.         return not self._is_special</font>
<font color="black">3020. </font>
<font color="green">3021.     def is_infinite(self):</font>
<font color="black">3022.         &quot;&quot;&quot;Return True if self is infinite; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3023.         return self._exp == 'F'</font>
<font color="black">3024. </font>
<font color="green">3025.     def is_nan(self):</font>
<font color="black">3026.         &quot;&quot;&quot;Return True if self is a qNaN or sNaN; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3027.         return self._exp in ('n', 'N')</font>
<font color="black">3028. </font>
<font color="green">3029.     def is_normal(self, context=None):</font>
<font color="black">3030.         &quot;&quot;&quot;Return True if self is a normal number; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3031.         if self._is_special or not self:</font>
<font color="red">3032.             return False</font>
<font color="red">3033.         if context is None:</font>
<font color="red">3034.             context = getcontext()</font>
<font color="red">3035.         return context.Emin &lt;= self.adjusted()</font>
<font color="black">3036. </font>
<font color="green">3037.     def is_qnan(self):</font>
<font color="black">3038.         &quot;&quot;&quot;Return True if self is a quiet NaN; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3039.         return self._exp == 'n'</font>
<font color="black">3040. </font>
<font color="green">3041.     def is_signed(self):</font>
<font color="black">3042.         &quot;&quot;&quot;Return True if self is negative; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3043.         return self._sign == 1</font>
<font color="black">3044. </font>
<font color="green">3045.     def is_snan(self):</font>
<font color="black">3046.         &quot;&quot;&quot;Return True if self is a signaling NaN; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3047.         return self._exp == 'N'</font>
<font color="black">3048. </font>
<font color="green">3049.     def is_subnormal(self, context=None):</font>
<font color="black">3050.         &quot;&quot;&quot;Return True if self is subnormal; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3051.         if self._is_special or not self:</font>
<font color="red">3052.             return False</font>
<font color="red">3053.         if context is None:</font>
<font color="red">3054.             context = getcontext()</font>
<font color="red">3055.         return self.adjusted() &lt; context.Emin</font>
<font color="black">3056. </font>
<font color="green">3057.     def is_zero(self):</font>
<font color="black">3058.         &quot;&quot;&quot;Return True if self is a zero; otherwise return False.&quot;&quot;&quot;</font>
<font color="red">3059.         return not self._is_special and self._int == '0'</font>
<font color="black">3060. </font>
<font color="green">3061.     def _ln_exp_bound(self):</font>
<font color="black">3062.         &quot;&quot;&quot;Compute a lower bound for the adjusted exponent of self.ln().</font>
<font color="black">3063.         In other words, compute r such that self.ln() &gt;= 10**r.  Assumes</font>
<font color="black">3064.         that self is finite and positive and that self != 1.</font>
<font color="black">3065.         &quot;&quot;&quot;</font>
<font color="black">3066. </font>
<font color="black">3067.         # for 0.1 &lt;= x &lt;= 10 we use the inequalities 1-1/x &lt;= ln(x) &lt;= x-1</font>
<font color="red">3068.         adj = self._exp + len(self._int) - 1</font>
<font color="red">3069.         if adj &gt;= 1:</font>
<font color="black">3070.             # argument &gt;= 10; we use 23/10 = 2.3 as a lower bound for ln(10)</font>
<font color="red">3071.             return len(str(adj*23//10)) - 1</font>
<font color="red">3072.         if adj &lt;= -2:</font>
<font color="black">3073.             # argument &lt;= 0.1</font>
<font color="red">3074.             return len(str((-1-adj)*23//10)) - 1</font>
<font color="red">3075.         op = _WorkRep(self)</font>
<font color="red">3076.         c, e = op.int, op.exp</font>
<font color="red">3077.         if adj == 0:</font>
<font color="black">3078.             # 1 &lt; self &lt; 10</font>
<font color="red">3079.             num = str(c-10**-e)</font>
<font color="red">3080.             den = str(c)</font>
<font color="red">3081.             return len(num) - len(den) - (num &lt; den)</font>
<font color="black">3082.         # adj == -1, 0.1 &lt;= self &lt; 1</font>
<font color="red">3083.         return e + len(str(10**-e - c)) - 1</font>
<font color="black">3084. </font>
<font color="black">3085. </font>
<font color="green">3086.     def ln(self, context=None):</font>
<font color="black">3087.         &quot;&quot;&quot;Returns the natural (base e) logarithm of self.&quot;&quot;&quot;</font>
<font color="black">3088. </font>
<font color="red">3089.         if context is None:</font>
<font color="red">3090.             context = getcontext()</font>
<font color="black">3091. </font>
<font color="black">3092.         # ln(NaN) = NaN</font>
<font color="red">3093.         ans = self._check_nans(context=context)</font>
<font color="red">3094.         if ans:</font>
<font color="red">3095.             return ans</font>
<font color="black">3096. </font>
<font color="black">3097.         # ln(0.0) == -Infinity</font>
<font color="red">3098.         if not self:</font>
<font color="red">3099.             return _NegativeInfinity</font>
<font color="black">3100. </font>
<font color="black">3101.         # ln(Infinity) = Infinity</font>
<font color="red">3102.         if self._isinfinity() == 1:</font>
<font color="red">3103.             return _Infinity</font>
<font color="black">3104. </font>
<font color="black">3105.         # ln(1.0) == 0.0</font>
<font color="red">3106.         if self == _One:</font>
<font color="red">3107.             return _Zero</font>
<font color="black">3108. </font>
<font color="black">3109.         # ln(negative) raises InvalidOperation</font>
<font color="red">3110.         if self._sign == 1:</font>
<font color="red">3111.             return context._raise_error(InvalidOperation,</font>
<font color="red">3112.                                         'ln of a negative value')</font>
<font color="black">3113. </font>
<font color="black">3114.         # result is irrational, so necessarily inexact</font>
<font color="red">3115.         op = _WorkRep(self)</font>
<font color="red">3116.         c, e = op.int, op.exp</font>
<font color="red">3117.         p = context.prec</font>
<font color="black">3118. </font>
<font color="black">3119.         # correctly rounded result: repeatedly increase precision by 3</font>
<font color="black">3120.         # until we get an unambiguously roundable result</font>
<font color="red">3121.         places = p - self._ln_exp_bound() + 2 # at least p+3 places</font>
<font color="red">3122.         while True:</font>
<font color="red">3123.             coeff = _dlog(c, e, places)</font>
<font color="black">3124.             # assert len(str(abs(coeff)))-p &gt;= 1</font>
<font color="red">3125.             if coeff % (5*10**(len(str(abs(coeff)))-p-1)):</font>
<font color="red">3126.                 break</font>
<font color="red">3127.             places += 3</font>
<font color="red">3128.         ans = _dec_from_triple(int(coeff&lt;0), str(abs(coeff)), -places)</font>
<font color="black">3129. </font>
<font color="red">3130.         context = context._shallow_copy()</font>
<font color="red">3131.         rounding = context._set_rounding(ROUND_HALF_EVEN)</font>
<font color="red">3132.         ans = ans._fix(context)</font>
<font color="red">3133.         context.rounding = rounding</font>
<font color="red">3134.         return ans</font>
<font color="black">3135. </font>
<font color="green">3136.     def _log10_exp_bound(self):</font>
<font color="black">3137.         &quot;&quot;&quot;Compute a lower bound for the adjusted exponent of self.log10().</font>
<font color="black">3138.         In other words, find r such that self.log10() &gt;= 10**r.</font>
<font color="black">3139.         Assumes that self is finite and positive and that self != 1.</font>
<font color="black">3140.         &quot;&quot;&quot;</font>
<font color="black">3141. </font>
<font color="black">3142.         # For x &gt;= 10 or x &lt; 0.1 we only need a bound on the integer</font>
<font color="black">3143.         # part of log10(self), and this comes directly from the</font>
<font color="black">3144.         # exponent of x.  For 0.1 &lt;= x &lt;= 10 we use the inequalities</font>
<font color="black">3145.         # 1-1/x &lt;= log(x) &lt;= x-1. If x &gt; 1 we have |log10(x)| &gt;</font>
<font color="black">3146.         # (1-1/x)/2.31 &gt; 0.  If x &lt; 1 then |log10(x)| &gt; (1-x)/2.31 &gt; 0</font>
<font color="black">3147. </font>
<font color="red">3148.         adj = self._exp + len(self._int) - 1</font>
<font color="red">3149.         if adj &gt;= 1:</font>
<font color="black">3150.             # self &gt;= 10</font>
<font color="red">3151.             return len(str(adj))-1</font>
<font color="red">3152.         if adj &lt;= -2:</font>
<font color="black">3153.             # self &lt; 0.1</font>
<font color="red">3154.             return len(str(-1-adj))-1</font>
<font color="red">3155.         op = _WorkRep(self)</font>
<font color="red">3156.         c, e = op.int, op.exp</font>
<font color="red">3157.         if adj == 0:</font>
<font color="black">3158.             # 1 &lt; self &lt; 10</font>
<font color="red">3159.             num = str(c-10**-e)</font>
<font color="red">3160.             den = str(231*c)</font>
<font color="red">3161.             return len(num) - len(den) - (num &lt; den) + 2</font>
<font color="black">3162.         # adj == -1, 0.1 &lt;= self &lt; 1</font>
<font color="red">3163.         num = str(10**-e-c)</font>
<font color="red">3164.         return len(num) + e - (num &lt; &quot;231&quot;) - 1</font>
<font color="black">3165. </font>
<font color="green">3166.     def log10(self, context=None):</font>
<font color="black">3167.         &quot;&quot;&quot;Returns the base 10 logarithm of self.&quot;&quot;&quot;</font>
<font color="black">3168. </font>
<font color="red">3169.         if context is None:</font>
<font color="red">3170.             context = getcontext()</font>
<font color="black">3171. </font>
<font color="black">3172.         # log10(NaN) = NaN</font>
<font color="red">3173.         ans = self._check_nans(context=context)</font>
<font color="red">3174.         if ans:</font>
<font color="red">3175.             return ans</font>
<font color="black">3176. </font>
<font color="black">3177.         # log10(0.0) == -Infinity</font>
<font color="red">3178.         if not self:</font>
<font color="red">3179.             return _NegativeInfinity</font>
<font color="black">3180. </font>
<font color="black">3181.         # log10(Infinity) = Infinity</font>
<font color="red">3182.         if self._isinfinity() == 1:</font>
<font color="red">3183.             return _Infinity</font>
<font color="black">3184. </font>
<font color="black">3185.         # log10(negative or -Infinity) raises InvalidOperation</font>
<font color="red">3186.         if self._sign == 1:</font>
<font color="red">3187.             return context._raise_error(InvalidOperation,</font>
<font color="red">3188.                                         'log10 of a negative value')</font>
<font color="black">3189. </font>
<font color="black">3190.         # log10(10**n) = n</font>
<font color="red">3191.         if self._int[0] == '1' and self._int[1:] == '0'*(len(self._int) - 1):</font>
<font color="black">3192.             # answer may need rounding</font>
<font color="red">3193.             ans = Decimal(self._exp + len(self._int) - 1)</font>
<font color="black">3194.         else:</font>
<font color="black">3195.             # result is irrational, so necessarily inexact</font>
<font color="red">3196.             op = _WorkRep(self)</font>
<font color="red">3197.             c, e = op.int, op.exp</font>
<font color="red">3198.             p = context.prec</font>
<font color="black">3199. </font>
<font color="black">3200.             # correctly rounded result: repeatedly increase precision</font>
<font color="black">3201.             # until result is unambiguously roundable</font>
<font color="red">3202.             places = p-self._log10_exp_bound()+2</font>
<font color="red">3203.             while True:</font>
<font color="red">3204.                 coeff = _dlog10(c, e, places)</font>
<font color="black">3205.                 # assert len(str(abs(coeff)))-p &gt;= 1</font>
<font color="red">3206.                 if coeff % (5*10**(len(str(abs(coeff)))-p-1)):</font>
<font color="red">3207.                     break</font>
<font color="red">3208.                 places += 3</font>
<font color="red">3209.             ans = _dec_from_triple(int(coeff&lt;0), str(abs(coeff)), -places)</font>
<font color="black">3210. </font>
<font color="red">3211.         context = context._shallow_copy()</font>
<font color="red">3212.         rounding = context._set_rounding(ROUND_HALF_EVEN)</font>
<font color="red">3213.         ans = ans._fix(context)</font>
<font color="red">3214.         context.rounding = rounding</font>
<font color="red">3215.         return ans</font>
<font color="black">3216. </font>
<font color="green">3217.     def logb(self, context=None):</font>
<font color="black">3218.         &quot;&quot;&quot; Returns the exponent of the magnitude of self's MSD.</font>
<font color="black">3219. </font>
<font color="black">3220.         The result is the integer which is the exponent of the magnitude</font>
<font color="black">3221.         of the most significant digit of self (as though it were truncated</font>
<font color="black">3222.         to a single digit while maintaining the value of that digit and</font>
<font color="black">3223.         without limiting the resulting exponent).</font>
<font color="black">3224.         &quot;&quot;&quot;</font>
<font color="black">3225.         # logb(NaN) = NaN</font>
<font color="red">3226.         ans = self._check_nans(context=context)</font>
<font color="red">3227.         if ans:</font>
<font color="red">3228.             return ans</font>
<font color="black">3229. </font>
<font color="red">3230.         if context is None:</font>
<font color="red">3231.             context = getcontext()</font>
<font color="black">3232. </font>
<font color="black">3233.         # logb(+/-Inf) = +Inf</font>
<font color="red">3234.         if self._isinfinity():</font>
<font color="red">3235.             return _Infinity</font>
<font color="black">3236. </font>
<font color="black">3237.         # logb(0) = -Inf, DivisionByZero</font>
<font color="red">3238.         if not self:</font>
<font color="red">3239.             return context._raise_error(DivisionByZero, 'logb(0)', 1)</font>
<font color="black">3240. </font>
<font color="black">3241.         # otherwise, simply return the adjusted exponent of self, as a</font>
<font color="black">3242.         # Decimal.  Note that no attempt is made to fit the result</font>
<font color="black">3243.         # into the current context.</font>
<font color="red">3244.         ans = Decimal(self.adjusted())</font>
<font color="red">3245.         return ans._fix(context)</font>
<font color="black">3246. </font>
<font color="green">3247.     def _islogical(self):</font>
<font color="black">3248.         &quot;&quot;&quot;Return True if self is a logical operand.</font>
<font color="black">3249. </font>
<font color="black">3250.         For being logical, it must be a finite number with a sign of 0,</font>
<font color="black">3251.         an exponent of 0, and a coefficient whose digits must all be</font>
<font color="black">3252.         either 0 or 1.</font>
<font color="black">3253.         &quot;&quot;&quot;</font>
<font color="red">3254.         if self._sign != 0 or self._exp != 0:</font>
<font color="red">3255.             return False</font>
<font color="red">3256.         for dig in self._int:</font>
<font color="red">3257.             if dig not in '01':</font>
<font color="red">3258.                 return False</font>
<font color="red">3259.         return True</font>
<font color="black">3260. </font>
<font color="green">3261.     def _fill_logical(self, context, opa, opb):</font>
<font color="red">3262.         dif = context.prec - len(opa)</font>
<font color="red">3263.         if dif &gt; 0:</font>
<font color="red">3264.             opa = '0'*dif + opa</font>
<font color="red">3265.         elif dif &lt; 0:</font>
<font color="red">3266.             opa = opa[-context.prec:]</font>
<font color="red">3267.         dif = context.prec - len(opb)</font>
<font color="red">3268.         if dif &gt; 0:</font>
<font color="red">3269.             opb = '0'*dif + opb</font>
<font color="red">3270.         elif dif &lt; 0:</font>
<font color="red">3271.             opb = opb[-context.prec:]</font>
<font color="red">3272.         return opa, opb</font>
<font color="black">3273. </font>
<font color="green">3274.     def logical_and(self, other, context=None):</font>
<font color="black">3275.         &quot;&quot;&quot;Applies an 'and' operation between self and other's digits.&quot;&quot;&quot;</font>
<font color="red">3276.         if context is None:</font>
<font color="red">3277.             context = getcontext()</font>
<font color="black">3278. </font>
<font color="red">3279.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3280. </font>
<font color="red">3281.         if not self._islogical() or not other._islogical():</font>
<font color="red">3282.             return context._raise_error(InvalidOperation)</font>
<font color="black">3283. </font>
<font color="black">3284.         # fill to context.prec</font>
<font color="red">3285.         (opa, opb) = self._fill_logical(context, self._int, other._int)</font>
<font color="black">3286. </font>
<font color="black">3287.         # make the operation, and clean starting zeroes</font>
<font color="red">3288.         result = &quot;&quot;.join([str(int(a)&amp;int(b)) for a,b in zip(opa,opb)])</font>
<font color="red">3289.         return _dec_from_triple(0, result.lstrip('0') or '0', 0)</font>
<font color="black">3290. </font>
<font color="green">3291.     def logical_invert(self, context=None):</font>
<font color="black">3292.         &quot;&quot;&quot;Invert all its digits.&quot;&quot;&quot;</font>
<font color="red">3293.         if context is None:</font>
<font color="red">3294.             context = getcontext()</font>
<font color="red">3295.         return self.logical_xor(_dec_from_triple(0,'1'*context.prec,0),</font>
<font color="red">3296.                                 context)</font>
<font color="black">3297. </font>
<font color="green">3298.     def logical_or(self, other, context=None):</font>
<font color="black">3299.         &quot;&quot;&quot;Applies an 'or' operation between self and other's digits.&quot;&quot;&quot;</font>
<font color="red">3300.         if context is None:</font>
<font color="red">3301.             context = getcontext()</font>
<font color="black">3302. </font>
<font color="red">3303.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3304. </font>
<font color="red">3305.         if not self._islogical() or not other._islogical():</font>
<font color="red">3306.             return context._raise_error(InvalidOperation)</font>
<font color="black">3307. </font>
<font color="black">3308.         # fill to context.prec</font>
<font color="red">3309.         (opa, opb) = self._fill_logical(context, self._int, other._int)</font>
<font color="black">3310. </font>
<font color="black">3311.         # make the operation, and clean starting zeroes</font>
<font color="red">3312.         result = &quot;&quot;.join([str(int(a)|int(b)) for a,b in zip(opa,opb)])</font>
<font color="red">3313.         return _dec_from_triple(0, result.lstrip('0') or '0', 0)</font>
<font color="black">3314. </font>
<font color="green">3315.     def logical_xor(self, other, context=None):</font>
<font color="black">3316.         &quot;&quot;&quot;Applies an 'xor' operation between self and other's digits.&quot;&quot;&quot;</font>
<font color="red">3317.         if context is None:</font>
<font color="red">3318.             context = getcontext()</font>
<font color="black">3319. </font>
<font color="red">3320.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3321. </font>
<font color="red">3322.         if not self._islogical() or not other._islogical():</font>
<font color="red">3323.             return context._raise_error(InvalidOperation)</font>
<font color="black">3324. </font>
<font color="black">3325.         # fill to context.prec</font>
<font color="red">3326.         (opa, opb) = self._fill_logical(context, self._int, other._int)</font>
<font color="black">3327. </font>
<font color="black">3328.         # make the operation, and clean starting zeroes</font>
<font color="red">3329.         result = &quot;&quot;.join([str(int(a)^int(b)) for a,b in zip(opa,opb)])</font>
<font color="red">3330.         return _dec_from_triple(0, result.lstrip('0') or '0', 0)</font>
<font color="black">3331. </font>
<font color="green">3332.     def max_mag(self, other, context=None):</font>
<font color="black">3333.         &quot;&quot;&quot;Compares the values numerically with their sign ignored.&quot;&quot;&quot;</font>
<font color="red">3334.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3335. </font>
<font color="red">3336.         if context is None:</font>
<font color="red">3337.             context = getcontext()</font>
<font color="black">3338. </font>
<font color="red">3339.         if self._is_special or other._is_special:</font>
<font color="black">3340.             # If one operand is a quiet NaN and the other is number, then the</font>
<font color="black">3341.             # number is always returned</font>
<font color="red">3342.             sn = self._isnan()</font>
<font color="red">3343.             on = other._isnan()</font>
<font color="red">3344.             if sn or on:</font>
<font color="red">3345.                 if on == 1 and sn == 0:</font>
<font color="red">3346.                     return self._fix(context)</font>
<font color="red">3347.                 if sn == 1 and on == 0:</font>
<font color="red">3348.                     return other._fix(context)</font>
<font color="red">3349.                 return self._check_nans(other, context)</font>
<font color="black">3350. </font>
<font color="red">3351.         c = self.copy_abs()._cmp(other.copy_abs())</font>
<font color="red">3352.         if c == 0:</font>
<font color="red">3353.             c = self.compare_total(other)</font>
<font color="black">3354. </font>
<font color="red">3355.         if c == -1:</font>
<font color="red">3356.             ans = other</font>
<font color="black">3357.         else:</font>
<font color="red">3358.             ans = self</font>
<font color="black">3359. </font>
<font color="red">3360.         return ans._fix(context)</font>
<font color="black">3361. </font>
<font color="green">3362.     def min_mag(self, other, context=None):</font>
<font color="black">3363.         &quot;&quot;&quot;Compares the values numerically with their sign ignored.&quot;&quot;&quot;</font>
<font color="red">3364.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3365. </font>
<font color="red">3366.         if context is None:</font>
<font color="red">3367.             context = getcontext()</font>
<font color="black">3368. </font>
<font color="red">3369.         if self._is_special or other._is_special:</font>
<font color="black">3370.             # If one operand is a quiet NaN and the other is number, then the</font>
<font color="black">3371.             # number is always returned</font>
<font color="red">3372.             sn = self._isnan()</font>
<font color="red">3373.             on = other._isnan()</font>
<font color="red">3374.             if sn or on:</font>
<font color="red">3375.                 if on == 1 and sn == 0:</font>
<font color="red">3376.                     return self._fix(context)</font>
<font color="red">3377.                 if sn == 1 and on == 0:</font>
<font color="red">3378.                     return other._fix(context)</font>
<font color="red">3379.                 return self._check_nans(other, context)</font>
<font color="black">3380. </font>
<font color="red">3381.         c = self.copy_abs()._cmp(other.copy_abs())</font>
<font color="red">3382.         if c == 0:</font>
<font color="red">3383.             c = self.compare_total(other)</font>
<font color="black">3384. </font>
<font color="red">3385.         if c == -1:</font>
<font color="red">3386.             ans = self</font>
<font color="black">3387.         else:</font>
<font color="red">3388.             ans = other</font>
<font color="black">3389. </font>
<font color="red">3390.         return ans._fix(context)</font>
<font color="black">3391. </font>
<font color="green">3392.     def next_minus(self, context=None):</font>
<font color="black">3393.         &quot;&quot;&quot;Returns the largest representable number smaller than itself.&quot;&quot;&quot;</font>
<font color="red">3394.         if context is None:</font>
<font color="red">3395.             context = getcontext()</font>
<font color="black">3396. </font>
<font color="red">3397.         ans = self._check_nans(context=context)</font>
<font color="red">3398.         if ans:</font>
<font color="red">3399.             return ans</font>
<font color="black">3400. </font>
<font color="red">3401.         if self._isinfinity() == -1:</font>
<font color="red">3402.             return _NegativeInfinity</font>
<font color="red">3403.         if self._isinfinity() == 1:</font>
<font color="red">3404.             return _dec_from_triple(0, '9'*context.prec, context.Etop())</font>
<font color="black">3405. </font>
<font color="red">3406.         context = context.copy()</font>
<font color="red">3407.         context._set_rounding(ROUND_FLOOR)</font>
<font color="red">3408.         context._ignore_all_flags()</font>
<font color="red">3409.         new_self = self._fix(context)</font>
<font color="red">3410.         if new_self != self:</font>
<font color="red">3411.             return new_self</font>
<font color="red">3412.         return self.__sub__(_dec_from_triple(0, '1', context.Etiny()-1),</font>
<font color="red">3413.                             context)</font>
<font color="black">3414. </font>
<font color="green">3415.     def next_plus(self, context=None):</font>
<font color="black">3416.         &quot;&quot;&quot;Returns the smallest representable number larger than itself.&quot;&quot;&quot;</font>
<font color="red">3417.         if context is None:</font>
<font color="red">3418.             context = getcontext()</font>
<font color="black">3419. </font>
<font color="red">3420.         ans = self._check_nans(context=context)</font>
<font color="red">3421.         if ans:</font>
<font color="red">3422.             return ans</font>
<font color="black">3423. </font>
<font color="red">3424.         if self._isinfinity() == 1:</font>
<font color="red">3425.             return _Infinity</font>
<font color="red">3426.         if self._isinfinity() == -1:</font>
<font color="red">3427.             return _dec_from_triple(1, '9'*context.prec, context.Etop())</font>
<font color="black">3428. </font>
<font color="red">3429.         context = context.copy()</font>
<font color="red">3430.         context._set_rounding(ROUND_CEILING)</font>
<font color="red">3431.         context._ignore_all_flags()</font>
<font color="red">3432.         new_self = self._fix(context)</font>
<font color="red">3433.         if new_self != self:</font>
<font color="red">3434.             return new_self</font>
<font color="red">3435.         return self.__add__(_dec_from_triple(0, '1', context.Etiny()-1),</font>
<font color="red">3436.                             context)</font>
<font color="black">3437. </font>
<font color="green">3438.     def next_toward(self, other, context=None):</font>
<font color="black">3439.         &quot;&quot;&quot;Returns the number closest to self, in the direction towards other.</font>
<font color="black">3440. </font>
<font color="black">3441.         The result is the closest representable number to self</font>
<font color="black">3442.         (excluding self) that is in the direction towards other,</font>
<font color="black">3443.         unless both have the same value.  If the two operands are</font>
<font color="black">3444.         numerically equal, then the result is a copy of self with the</font>
<font color="black">3445.         sign set to be the same as the sign of other.</font>
<font color="black">3446.         &quot;&quot;&quot;</font>
<font color="red">3447.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3448. </font>
<font color="red">3449.         if context is None:</font>
<font color="red">3450.             context = getcontext()</font>
<font color="black">3451. </font>
<font color="red">3452.         ans = self._check_nans(other, context)</font>
<font color="red">3453.         if ans:</font>
<font color="red">3454.             return ans</font>
<font color="black">3455. </font>
<font color="red">3456.         comparison = self._cmp(other)</font>
<font color="red">3457.         if comparison == 0:</font>
<font color="red">3458.             return self.copy_sign(other)</font>
<font color="black">3459. </font>
<font color="red">3460.         if comparison == -1:</font>
<font color="red">3461.             ans = self.next_plus(context)</font>
<font color="black">3462.         else: # comparison == 1</font>
<font color="red">3463.             ans = self.next_minus(context)</font>
<font color="black">3464. </font>
<font color="black">3465.         # decide which flags to raise using value of ans</font>
<font color="red">3466.         if ans._isinfinity():</font>
<font color="red">3467.             context._raise_error(Overflow,</font>
<font color="red">3468.                                  'Infinite result from next_toward',</font>
<font color="red">3469.                                  ans._sign)</font>
<font color="red">3470.             context._raise_error(Inexact)</font>
<font color="red">3471.             context._raise_error(Rounded)</font>
<font color="red">3472.         elif ans.adjusted() &lt; context.Emin:</font>
<font color="red">3473.             context._raise_error(Underflow)</font>
<font color="red">3474.             context._raise_error(Subnormal)</font>
<font color="red">3475.             context._raise_error(Inexact)</font>
<font color="red">3476.             context._raise_error(Rounded)</font>
<font color="black">3477.             # if precision == 1 then we don't raise Clamped for a</font>
<font color="black">3478.             # result 0E-Etiny.</font>
<font color="red">3479.             if not ans:</font>
<font color="red">3480.                 context._raise_error(Clamped)</font>
<font color="black">3481. </font>
<font color="red">3482.         return ans</font>
<font color="black">3483. </font>
<font color="green">3484.     def number_class(self, context=None):</font>
<font color="black">3485.         &quot;&quot;&quot;Returns an indication of the class of self.</font>
<font color="black">3486. </font>
<font color="black">3487.         The class is one of the following strings:</font>
<font color="black">3488.           sNaN</font>
<font color="black">3489.           NaN</font>
<font color="black">3490.           -Infinity</font>
<font color="black">3491.           -Normal</font>
<font color="black">3492.           -Subnormal</font>
<font color="black">3493.           -Zero</font>
<font color="black">3494.           +Zero</font>
<font color="black">3495.           +Subnormal</font>
<font color="black">3496.           +Normal</font>
<font color="black">3497.           +Infinity</font>
<font color="black">3498.         &quot;&quot;&quot;</font>
<font color="red">3499.         if self.is_snan():</font>
<font color="red">3500.             return &quot;sNaN&quot;</font>
<font color="red">3501.         if self.is_qnan():</font>
<font color="red">3502.             return &quot;NaN&quot;</font>
<font color="red">3503.         inf = self._isinfinity()</font>
<font color="red">3504.         if inf == 1:</font>
<font color="red">3505.             return &quot;+Infinity&quot;</font>
<font color="red">3506.         if inf == -1:</font>
<font color="red">3507.             return &quot;-Infinity&quot;</font>
<font color="red">3508.         if self.is_zero():</font>
<font color="red">3509.             if self._sign:</font>
<font color="red">3510.                 return &quot;-Zero&quot;</font>
<font color="black">3511.             else:</font>
<font color="red">3512.                 return &quot;+Zero&quot;</font>
<font color="red">3513.         if context is None:</font>
<font color="red">3514.             context = getcontext()</font>
<font color="red">3515.         if self.is_subnormal(context=context):</font>
<font color="red">3516.             if self._sign:</font>
<font color="red">3517.                 return &quot;-Subnormal&quot;</font>
<font color="black">3518.             else:</font>
<font color="red">3519.                 return &quot;+Subnormal&quot;</font>
<font color="black">3520.         # just a normal, regular, boring number, :)</font>
<font color="red">3521.         if self._sign:</font>
<font color="red">3522.             return &quot;-Normal&quot;</font>
<font color="black">3523.         else:</font>
<font color="red">3524.             return &quot;+Normal&quot;</font>
<font color="black">3525. </font>
<font color="green">3526.     def radix(self):</font>
<font color="black">3527.         &quot;&quot;&quot;Just returns 10, as this is Decimal, :)&quot;&quot;&quot;</font>
<font color="red">3528.         return Decimal(10)</font>
<font color="black">3529. </font>
<font color="green">3530.     def rotate(self, other, context=None):</font>
<font color="black">3531.         &quot;&quot;&quot;Returns a rotated copy of self, value-of-other times.&quot;&quot;&quot;</font>
<font color="red">3532.         if context is None:</font>
<font color="red">3533.             context = getcontext()</font>
<font color="black">3534. </font>
<font color="red">3535.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3536. </font>
<font color="red">3537.         ans = self._check_nans(other, context)</font>
<font color="red">3538.         if ans:</font>
<font color="red">3539.             return ans</font>
<font color="black">3540. </font>
<font color="red">3541.         if other._exp != 0:</font>
<font color="red">3542.             return context._raise_error(InvalidOperation)</font>
<font color="red">3543.         if not (-context.prec &lt;= int(other) &lt;= context.prec):</font>
<font color="red">3544.             return context._raise_error(InvalidOperation)</font>
<font color="black">3545. </font>
<font color="red">3546.         if self._isinfinity():</font>
<font color="red">3547.             return Decimal(self)</font>
<font color="black">3548. </font>
<font color="black">3549.         # get values, pad if necessary</font>
<font color="red">3550.         torot = int(other)</font>
<font color="red">3551.         rotdig = self._int</font>
<font color="red">3552.         topad = context.prec - len(rotdig)</font>
<font color="red">3553.         if topad &gt; 0:</font>
<font color="red">3554.             rotdig = '0'*topad + rotdig</font>
<font color="red">3555.         elif topad &lt; 0:</font>
<font color="red">3556.             rotdig = rotdig[-topad:]</font>
<font color="black">3557. </font>
<font color="black">3558.         # let's rotate!</font>
<font color="red">3559.         rotated = rotdig[torot:] + rotdig[:torot]</font>
<font color="red">3560.         return _dec_from_triple(self._sign,</font>
<font color="red">3561.                                 rotated.lstrip('0') or '0', self._exp)</font>
<font color="black">3562. </font>
<font color="green">3563.     def scaleb(self, other, context=None):</font>
<font color="black">3564.         &quot;&quot;&quot;Returns self operand after adding the second value to its exp.&quot;&quot;&quot;</font>
<font color="red">3565.         if context is None:</font>
<font color="red">3566.             context = getcontext()</font>
<font color="black">3567. </font>
<font color="red">3568.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3569. </font>
<font color="red">3570.         ans = self._check_nans(other, context)</font>
<font color="red">3571.         if ans:</font>
<font color="red">3572.             return ans</font>
<font color="black">3573. </font>
<font color="red">3574.         if other._exp != 0:</font>
<font color="red">3575.             return context._raise_error(InvalidOperation)</font>
<font color="red">3576.         liminf = -2 * (context.Emax + context.prec)</font>
<font color="red">3577.         limsup =  2 * (context.Emax + context.prec)</font>
<font color="red">3578.         if not (liminf &lt;= int(other) &lt;= limsup):</font>
<font color="red">3579.             return context._raise_error(InvalidOperation)</font>
<font color="black">3580. </font>
<font color="red">3581.         if self._isinfinity():</font>
<font color="red">3582.             return Decimal(self)</font>
<font color="black">3583. </font>
<font color="red">3584.         d = _dec_from_triple(self._sign, self._int, self._exp + int(other))</font>
<font color="red">3585.         d = d._fix(context)</font>
<font color="red">3586.         return d</font>
<font color="black">3587. </font>
<font color="green">3588.     def shift(self, other, context=None):</font>
<font color="black">3589.         &quot;&quot;&quot;Returns a shifted copy of self, value-of-other times.&quot;&quot;&quot;</font>
<font color="red">3590.         if context is None:</font>
<font color="red">3591.             context = getcontext()</font>
<font color="black">3592. </font>
<font color="red">3593.         other = _convert_other(other, raiseit=True)</font>
<font color="black">3594. </font>
<font color="red">3595.         ans = self._check_nans(other, context)</font>
<font color="red">3596.         if ans:</font>
<font color="red">3597.             return ans</font>
<font color="black">3598. </font>
<font color="red">3599.         if other._exp != 0:</font>
<font color="red">3600.             return context._raise_error(InvalidOperation)</font>
<font color="red">3601.         if not (-context.prec &lt;= int(other) &lt;= context.prec):</font>
<font color="red">3602.             return context._raise_error(InvalidOperation)</font>
<font color="black">3603. </font>
<font color="red">3604.         if self._isinfinity():</font>
<font color="red">3605.             return Decimal(self)</font>
<font color="black">3606. </font>
<font color="black">3607.         # get values, pad if necessary</font>
<font color="red">3608.         torot = int(other)</font>
<font color="red">3609.         rotdig = self._int</font>
<font color="red">3610.         topad = context.prec - len(rotdig)</font>
<font color="red">3611.         if topad &gt; 0:</font>
<font color="red">3612.             rotdig = '0'*topad + rotdig</font>
<font color="red">3613.         elif topad &lt; 0:</font>
<font color="red">3614.             rotdig = rotdig[-topad:]</font>
<font color="black">3615. </font>
<font color="black">3616.         # let's shift!</font>
<font color="red">3617.         if torot &lt; 0:</font>
<font color="red">3618.             shifted = rotdig[:torot]</font>
<font color="black">3619.         else:</font>
<font color="red">3620.             shifted = rotdig + '0'*torot</font>
<font color="red">3621.             shifted = shifted[-context.prec:]</font>
<font color="black">3622. </font>
<font color="red">3623.         return _dec_from_triple(self._sign,</font>
<font color="red">3624.                                     shifted.lstrip('0') or '0', self._exp)</font>
<font color="black">3625. </font>
<font color="black">3626.     # Support for pickling, copy, and deepcopy</font>
<font color="green">3627.     def __reduce__(self):</font>
<font color="red">3628.         return (self.__class__, (str(self),))</font>
<font color="black">3629. </font>
<font color="green">3630.     def __copy__(self):</font>
<font color="red">3631.         if type(self) is Decimal:</font>
<font color="red">3632.             return self     # I'm immutable; therefore I am my own clone</font>
<font color="red">3633.         return self.__class__(str(self))</font>
<font color="black">3634. </font>
<font color="green">3635.     def __deepcopy__(self, memo):</font>
<font color="red">3636.         if type(self) is Decimal:</font>
<font color="red">3637.             return self     # My components are also immutable</font>
<font color="red">3638.         return self.__class__(str(self))</font>
<font color="black">3639. </font>
<font color="black">3640.     # PEP 3101 support.  the _localeconv keyword argument should be</font>
<font color="black">3641.     # considered private: it's provided for ease of testing only.</font>
<font color="green">3642.     def __format__(self, specifier, context=None, _localeconv=None):</font>
<font color="black">3643.         &quot;&quot;&quot;Format a Decimal instance according to the given specifier.</font>
<font color="black">3644. </font>
<font color="black">3645.         The specifier should be a standard format specifier, with the</font>
<font color="black">3646.         form described in PEP 3101.  Formatting types 'e', 'E', 'f',</font>
<font color="black">3647.         'F', 'g', 'G', 'n' and '%' are supported.  If the formatting</font>
<font color="black">3648.         type is omitted it defaults to 'g' or 'G', depending on the</font>
<font color="black">3649.         value of context.capitals.</font>
<font color="black">3650.         &quot;&quot;&quot;</font>
<font color="black">3651. </font>
<font color="black">3652.         # Note: PEP 3101 says that if the type is not present then</font>
<font color="black">3653.         # there should be at least one digit after the decimal point.</font>
<font color="black">3654.         # We take the liberty of ignoring this requirement for</font>
<font color="black">3655.         # Decimal---it's presumably there to make sure that</font>
<font color="black">3656.         # format(float, '') behaves similarly to str(float).</font>
<font color="red">3657.         if context is None:</font>
<font color="red">3658.             context = getcontext()</font>
<font color="black">3659. </font>
<font color="red">3660.         spec = _parse_format_specifier(specifier, _localeconv=_localeconv)</font>
<font color="black">3661. </font>
<font color="black">3662.         # special values don't care about the type or precision</font>
<font color="red">3663.         if self._is_special:</font>
<font color="red">3664.             sign = _format_sign(self._sign, spec)</font>
<font color="red">3665.             body = str(self.copy_abs())</font>
<font color="red">3666.             if spec['type'] == '%':</font>
<font color="red">3667.                 body += '%'</font>
<font color="red">3668.             return _format_align(sign, body, spec)</font>
<font color="black">3669. </font>
<font color="black">3670.         # a type of None defaults to 'g' or 'G', depending on context</font>
<font color="red">3671.         if spec['type'] is None:</font>
<font color="red">3672.             spec['type'] = ['g', 'G'][context.capitals]</font>
<font color="black">3673. </font>
<font color="black">3674.         # if type is '%', adjust exponent of self accordingly</font>
<font color="red">3675.         if spec['type'] == '%':</font>
<font color="red">3676.             self = _dec_from_triple(self._sign, self._int, self._exp+2)</font>
<font color="black">3677. </font>
<font color="black">3678.         # round if necessary, taking rounding mode from the context</font>
<font color="red">3679.         rounding = context.rounding</font>
<font color="red">3680.         precision = spec['precision']</font>
<font color="red">3681.         if precision is not None:</font>
<font color="red">3682.             if spec['type'] in 'eE':</font>
<font color="red">3683.                 self = self._round(precision+1, rounding)</font>
<font color="red">3684.             elif spec['type'] in 'fF%':</font>
<font color="red">3685.                 self = self._rescale(-precision, rounding)</font>
<font color="red">3686.             elif spec['type'] in 'gG' and len(self._int) &gt; precision:</font>
<font color="red">3687.                 self = self._round(precision, rounding)</font>
<font color="black">3688.         # special case: zeros with a positive exponent can't be</font>
<font color="black">3689.         # represented in fixed point; rescale them to 0e0.</font>
<font color="red">3690.         if not self and self._exp &gt; 0 and spec['type'] in 'fF%':</font>
<font color="red">3691.             self = self._rescale(0, rounding)</font>
<font color="black">3692. </font>
<font color="black">3693.         # figure out placement of the decimal point</font>
<font color="red">3694.         leftdigits = self._exp + len(self._int)</font>
<font color="red">3695.         if spec['type'] in 'eE':</font>
<font color="red">3696.             if not self and precision is not None:</font>
<font color="red">3697.                 dotplace = 1 - precision</font>
<font color="black">3698.             else:</font>
<font color="red">3699.                 dotplace = 1</font>
<font color="red">3700.         elif spec['type'] in 'fF%':</font>
<font color="red">3701.             dotplace = leftdigits</font>
<font color="red">3702.         elif spec['type'] in 'gG':</font>
<font color="red">3703.             if self._exp &lt;= 0 and leftdigits &gt; -6:</font>
<font color="red">3704.                 dotplace = leftdigits</font>
<font color="black">3705.             else:</font>
<font color="red">3706.                 dotplace = 1</font>
<font color="black">3707. </font>
<font color="black">3708.         # find digits before and after decimal point, and get exponent</font>
<font color="red">3709.         if dotplace &lt; 0:</font>
<font color="red">3710.             intpart = '0'</font>
<font color="red">3711.             fracpart = '0'*(-dotplace) + self._int</font>
<font color="red">3712.         elif dotplace &gt; len(self._int):</font>
<font color="red">3713.             intpart = self._int + '0'*(dotplace-len(self._int))</font>
<font color="red">3714.             fracpart = ''</font>
<font color="black">3715.         else:</font>
<font color="red">3716.             intpart = self._int[:dotplace] or '0'</font>
<font color="red">3717.             fracpart = self._int[dotplace:]</font>
<font color="red">3718.         exp = leftdigits-dotplace</font>
<font color="black">3719. </font>
<font color="black">3720.         # done with the decimal-specific stuff;  hand over the rest</font>
<font color="black">3721.         # of the formatting to the _format_number function</font>
<font color="red">3722.         return _format_number(self._sign, intpart, fracpart, exp, spec)</font>
<font color="black">3723. </font>
<font color="green">3724. def _dec_from_triple(sign, coefficient, exponent, special=False):</font>
<font color="black">3725.     &quot;&quot;&quot;Create a decimal instance directly, without any validation,</font>
<font color="black">3726.     normalization (e.g. removal of leading zeros) or argument</font>
<font color="black">3727.     conversion.</font>
<font color="black">3728. </font>
<font color="black">3729.     This function is for *internal use only*.</font>
<font color="black">3730.     &quot;&quot;&quot;</font>
<font color="black">3731. </font>
<font color="red">3732.     self = object.__new__(Decimal)</font>
<font color="red">3733.     self._sign = sign</font>
<font color="red">3734.     self._int = coefficient</font>
<font color="red">3735.     self._exp = exponent</font>
<font color="red">3736.     self._is_special = special</font>
<font color="black">3737. </font>
<font color="red">3738.     return self</font>
<font color="black">3739. </font>
<font color="black">3740. # Register Decimal as a kind of Number (an abstract base class).</font>
<font color="black">3741. # However, do not register it as Real (because Decimals are not</font>
<font color="black">3742. # interoperable with floats).</font>
<font color="green">3743. _numbers.Number.register(Decimal)</font>
<font color="black">3744. </font>
<font color="black">3745. </font>
<font color="black">3746. ##### Context class #######################################################</font>
<font color="black">3747. </font>
<font color="green">3748. class _ContextManager(object):</font>
<font color="black">3749.     &quot;&quot;&quot;Context manager class to support localcontext().</font>
<font color="black">3750. </font>
<font color="black">3751.       Sets a copy of the supplied context in __enter__() and restores</font>
<font color="black">3752.       the previous decimal context in __exit__()</font>
<font color="green">3753.     &quot;&quot;&quot;</font>
<font color="green">3754.     def __init__(self, new_context):</font>
<font color="red">3755.         self.new_context = new_context.copy()</font>
<font color="green">3756.     def __enter__(self):</font>
<font color="red">3757.         self.saved_context = getcontext()</font>
<font color="red">3758.         setcontext(self.new_context)</font>
<font color="red">3759.         return self.new_context</font>
<font color="green">3760.     def __exit__(self, t, v, tb):</font>
<font color="red">3761.         setcontext(self.saved_context)</font>
<font color="black">3762. </font>
<font color="green">3763. class Context(object):</font>
<font color="black">3764.     &quot;&quot;&quot;Contains the context for a Decimal instance.</font>
<font color="black">3765. </font>
<font color="black">3766.     Contains:</font>
<font color="black">3767.     prec - precision (for use in rounding, division, square roots..)</font>
<font color="black">3768.     rounding - rounding type (how you round)</font>
<font color="black">3769.     traps - If traps[exception] = 1, then the exception is</font>
<font color="black">3770.                     raised when it is caused.  Otherwise, a value is</font>
<font color="black">3771.                     substituted in.</font>
<font color="black">3772.     flags  - When an exception is caused, flags[exception] is set.</font>
<font color="black">3773.              (Whether or not the trap_enabler is set)</font>
<font color="black">3774.              Should be reset by user of Decimal instance.</font>
<font color="black">3775.     Emin -   Minimum exponent</font>
<font color="black">3776.     Emax -   Maximum exponent</font>
<font color="black">3777.     capitals -      If 1, 1*10^1 is printed as 1E+1.</font>
<font color="black">3778.                     If 0, printed as 1e1</font>
<font color="black">3779.     _clamp - If 1, change exponents if too high (Default 0)</font>
<font color="green">3780.     &quot;&quot;&quot;</font>
<font color="black">3781. </font>
<font color="green">3782.     def __init__(self, prec=None, rounding=None,</font>
<font color="green">3783.                  traps=None, flags=None,</font>
<font color="green">3784.                  Emin=None, Emax=None,</font>
<font color="green">3785.                  capitals=None, _clamp=0,</font>
<font color="green">3786.                  _ignored_flags=None):</font>
<font color="black">3787.         # Set defaults; for everything except flags and _ignored_flags,</font>
<font color="black">3788.         # inherit from DefaultContext.</font>
<font color="green">3789.         try:</font>
<font color="green">3790.             dc = DefaultContext</font>
<font color="green">3791.         except NameError:</font>
<font color="green">3792.             pass</font>
<font color="black">3793. </font>
<font color="green">3794.         self.prec = prec if prec is not None else dc.prec</font>
<font color="green">3795.         self.rounding = rounding if rounding is not None else dc.rounding</font>
<font color="green">3796.         self.Emin = Emin if Emin is not None else dc.Emin</font>
<font color="green">3797.         self.Emax = Emax if Emax is not None else dc.Emax</font>
<font color="green">3798.         self.capitals = capitals if capitals is not None else dc.capitals</font>
<font color="green">3799.         self._clamp = _clamp if _clamp is not None else dc._clamp</font>
<font color="black">3800. </font>
<font color="green">3801.         if _ignored_flags is None:</font>
<font color="green">3802.             self._ignored_flags = []</font>
<font color="black">3803.         else:</font>
<font color="red">3804.             self._ignored_flags = _ignored_flags</font>
<font color="black">3805. </font>
<font color="green">3806.         if traps is None:</font>
<font color="red">3807.             self.traps = dc.traps.copy()</font>
<font color="green">3808.         elif not isinstance(traps, dict):</font>
<font color="green">3809.             self.traps = dict((s, int(s in traps)) for s in _signals)</font>
<font color="black">3810.         else:</font>
<font color="red">3811.             self.traps = traps</font>
<font color="black">3812. </font>
<font color="green">3813.         if flags is None:</font>
<font color="red">3814.             self.flags = dict.fromkeys(_signals, 0)</font>
<font color="green">3815.         elif not isinstance(flags, dict):</font>
<font color="green">3816.             self.flags = dict((s, int(s in flags)) for s in _signals)</font>
<font color="black">3817.         else:</font>
<font color="red">3818.             self.flags = flags</font>
<font color="black">3819. </font>
<font color="green">3820.     def __repr__(self):</font>
<font color="black">3821.         &quot;&quot;&quot;Show the current context.&quot;&quot;&quot;</font>
<font color="red">3822.         s = []</font>
<font color="red">3823.         s.append('Context(prec=%(prec)d, rounding=%(rounding)s, '</font>
<font color="black">3824.                  'Emin=%(Emin)d, Emax=%(Emax)d, capitals=%(capitals)d'</font>
<font color="red">3825.                  % vars(self))</font>
<font color="red">3826.         names = [f.__name__ for f, v in self.flags.items() if v]</font>
<font color="red">3827.         s.append('flags=[' + ', '.join(names) + ']')</font>
<font color="red">3828.         names = [t.__name__ for t, v in self.traps.items() if v]</font>
<font color="red">3829.         s.append('traps=[' + ', '.join(names) + ']')</font>
<font color="red">3830.         return ', '.join(s) + ')'</font>
<font color="black">3831. </font>
<font color="green">3832.     def clear_flags(self):</font>
<font color="black">3833.         &quot;&quot;&quot;Reset all flags to zero&quot;&quot;&quot;</font>
<font color="red">3834.         for flag in self.flags:</font>
<font color="red">3835.             self.flags[flag] = 0</font>
<font color="black">3836. </font>
<font color="green">3837.     def _shallow_copy(self):</font>
<font color="black">3838.         &quot;&quot;&quot;Returns a shallow copy from self.&quot;&quot;&quot;</font>
<font color="red">3839.         nc = Context(self.prec, self.rounding, self.traps,</font>
<font color="red">3840.                      self.flags, self.Emin, self.Emax,</font>
<font color="red">3841.                      self.capitals, self._clamp, self._ignored_flags)</font>
<font color="red">3842.         return nc</font>
<font color="black">3843. </font>
<font color="green">3844.     def copy(self):</font>
<font color="black">3845.         &quot;&quot;&quot;Returns a deep copy from self.&quot;&quot;&quot;</font>
<font color="red">3846.         nc = Context(self.prec, self.rounding, self.traps.copy(),</font>
<font color="red">3847.                      self.flags.copy(), self.Emin, self.Emax,</font>
<font color="red">3848.                      self.capitals, self._clamp, self._ignored_flags)</font>
<font color="red">3849.         return nc</font>
<font color="green">3850.     __copy__ = copy</font>
<font color="black">3851. </font>
<font color="green">3852.     def _raise_error(self, condition, explanation = None, *args):</font>
<font color="black">3853.         &quot;&quot;&quot;Handles an error</font>
<font color="black">3854. </font>
<font color="black">3855.         If the flag is in _ignored_flags, returns the default response.</font>
<font color="black">3856.         Otherwise, it sets the flag, then, if the corresponding</font>
<font color="black">3857.         trap_enabler is set, it reraises the exception.  Otherwise, it returns</font>
<font color="black">3858.         the default value after setting the flag.</font>
<font color="black">3859.         &quot;&quot;&quot;</font>
<font color="red">3860.         error = _condition_map.get(condition, condition)</font>
<font color="red">3861.         if error in self._ignored_flags:</font>
<font color="black">3862.             # Don't touch the flag</font>
<font color="red">3863.             return error().handle(self, *args)</font>
<font color="black">3864. </font>
<font color="red">3865.         self.flags[error] = 1</font>
<font color="red">3866.         if not self.traps[error]:</font>
<font color="black">3867.             # The errors define how to handle themselves.</font>
<font color="red">3868.             return condition().handle(self, *args)</font>
<font color="black">3869. </font>
<font color="black">3870.         # Errors should only be risked on copies of the context</font>
<font color="black">3871.         # self._ignored_flags = []</font>
<font color="red">3872.         raise error(explanation)</font>
<font color="black">3873. </font>
<font color="green">3874.     def _ignore_all_flags(self):</font>
<font color="black">3875.         &quot;&quot;&quot;Ignore all flags, if they are raised&quot;&quot;&quot;</font>
<font color="red">3876.         return self._ignore_flags(*_signals)</font>
<font color="black">3877. </font>
<font color="green">3878.     def _ignore_flags(self, *flags):</font>
<font color="black">3879.         &quot;&quot;&quot;Ignore the flags, if they are raised&quot;&quot;&quot;</font>
<font color="black">3880.         # Do not mutate-- This way, copies of a context leave the original</font>
<font color="black">3881.         # alone.</font>
<font color="red">3882.         self._ignored_flags = (self._ignored_flags + list(flags))</font>
<font color="red">3883.         return list(flags)</font>
<font color="black">3884. </font>
<font color="green">3885.     def _regard_flags(self, *flags):</font>
<font color="black">3886.         &quot;&quot;&quot;Stop ignoring the flags, if they are raised&quot;&quot;&quot;</font>
<font color="red">3887.         if flags and isinstance(flags[0], (tuple,list)):</font>
<font color="red">3888.             flags = flags[0]</font>
<font color="red">3889.         for flag in flags:</font>
<font color="red">3890.             self._ignored_flags.remove(flag)</font>
<font color="black">3891. </font>
<font color="black">3892.     # We inherit object.__hash__, so we must deny this explicitly</font>
<font color="green">3893.     __hash__ = None</font>
<font color="black">3894. </font>
<font color="green">3895.     def Etiny(self):</font>
<font color="black">3896.         &quot;&quot;&quot;Returns Etiny (= Emin - prec + 1)&quot;&quot;&quot;</font>
<font color="red">3897.         return int(self.Emin - self.prec + 1)</font>
<font color="black">3898. </font>
<font color="green">3899.     def Etop(self):</font>
<font color="black">3900.         &quot;&quot;&quot;Returns maximum exponent (= Emax - prec + 1)&quot;&quot;&quot;</font>
<font color="red">3901.         return int(self.Emax - self.prec + 1)</font>
<font color="black">3902. </font>
<font color="green">3903.     def _set_rounding(self, type):</font>
<font color="black">3904.         &quot;&quot;&quot;Sets the rounding type.</font>
<font color="black">3905. </font>
<font color="black">3906.         Sets the rounding type, and returns the current (previous)</font>
<font color="black">3907.         rounding type.  Often used like:</font>
<font color="black">3908. </font>
<font color="black">3909.         context = context.copy()</font>
<font color="black">3910.         # so you don't change the calling context</font>
<font color="black">3911.         # if an error occurs in the middle.</font>
<font color="black">3912.         rounding = context._set_rounding(ROUND_UP)</font>
<font color="black">3913.         val = self.__sub__(other, context=context)</font>
<font color="black">3914.         context._set_rounding(rounding)</font>
<font color="black">3915. </font>
<font color="black">3916.         This will make it round up for that operation.</font>
<font color="black">3917.         &quot;&quot;&quot;</font>
<font color="red">3918.         rounding = self.rounding</font>
<font color="red">3919.         self.rounding= type</font>
<font color="red">3920.         return rounding</font>
<font color="black">3921. </font>
<font color="green">3922.     def create_decimal(self, num='0'):</font>
<font color="black">3923.         &quot;&quot;&quot;Creates a new Decimal instance but using self as context.</font>
<font color="black">3924. </font>
<font color="black">3925.         This method implements the to-number operation of the</font>
<font color="black">3926.         IBM Decimal specification.&quot;&quot;&quot;</font>
<font color="black">3927. </font>
<font color="red">3928.         if isinstance(num, basestring) and num != num.strip():</font>
<font color="red">3929.             return self._raise_error(ConversionSyntax,</font>
<font color="red">3930.                                      &quot;no trailing or leading whitespace is &quot;</font>
<font color="black">3931.                                      &quot;permitted.&quot;)</font>
<font color="black">3932. </font>
<font color="red">3933.         d = Decimal(num, context=self)</font>
<font color="red">3934.         if d._isnan() and len(d._int) &gt; self.prec - self._clamp:</font>
<font color="red">3935.             return self._raise_error(ConversionSyntax,</font>
<font color="red">3936.                                      &quot;diagnostic info too long in NaN&quot;)</font>
<font color="red">3937.         return d._fix(self)</font>
<font color="black">3938. </font>
<font color="green">3939.     def create_decimal_from_float(self, f):</font>
<font color="black">3940.         &quot;&quot;&quot;Creates a new Decimal instance from a float but rounding using self</font>
<font color="black">3941.         as the context.</font>
<font color="black">3942. </font>
<font color="black">3943.         &gt;&gt;&gt; context = Context(prec=5, rounding=ROUND_DOWN)</font>
<font color="black">3944.         &gt;&gt;&gt; context.create_decimal_from_float(3.1415926535897932)</font>
<font color="black">3945.         Decimal('3.1415')</font>
<font color="black">3946.         &gt;&gt;&gt; context = Context(prec=5, traps=[Inexact])</font>
<font color="black">3947.         &gt;&gt;&gt; context.create_decimal_from_float(3.1415926535897932)</font>
<font color="black">3948.         Traceback (most recent call last):</font>
<font color="black">3949.             ...</font>
<font color="black">3950.         Inexact: None</font>
<font color="black">3951. </font>
<font color="black">3952.         &quot;&quot;&quot;</font>
<font color="red">3953.         d = Decimal.from_float(f)       # An exact conversion</font>
<font color="red">3954.         return d._fix(self)             # Apply the context rounding</font>
<font color="black">3955. </font>
<font color="black">3956.     # Methods</font>
<font color="green">3957.     def abs(self, a):</font>
<font color="black">3958.         &quot;&quot;&quot;Returns the absolute value of the operand.</font>
<font color="black">3959. </font>
<font color="black">3960.         If the operand is negative, the result is the same as using the minus</font>
<font color="black">3961.         operation on the operand.  Otherwise, the result is the same as using</font>
<font color="black">3962.         the plus operation on the operand.</font>
<font color="black">3963. </font>
<font color="black">3964.         &gt;&gt;&gt; ExtendedContext.abs(Decimal('2.1'))</font>
<font color="black">3965.         Decimal('2.1')</font>
<font color="black">3966.         &gt;&gt;&gt; ExtendedContext.abs(Decimal('-100'))</font>
<font color="black">3967.         Decimal('100')</font>
<font color="black">3968.         &gt;&gt;&gt; ExtendedContext.abs(Decimal('101.5'))</font>
<font color="black">3969.         Decimal('101.5')</font>
<font color="black">3970.         &gt;&gt;&gt; ExtendedContext.abs(Decimal('-101.5'))</font>
<font color="black">3971.         Decimal('101.5')</font>
<font color="black">3972.         &gt;&gt;&gt; ExtendedContext.abs(-1)</font>
<font color="black">3973.         Decimal('1')</font>
<font color="black">3974.         &quot;&quot;&quot;</font>
<font color="red">3975.         a = _convert_other(a, raiseit=True)</font>
<font color="red">3976.         return a.__abs__(context=self)</font>
<font color="black">3977. </font>
<font color="green">3978.     def add(self, a, b):</font>
<font color="black">3979.         &quot;&quot;&quot;Return the sum of the two operands.</font>
<font color="black">3980. </font>
<font color="black">3981.         &gt;&gt;&gt; ExtendedContext.add(Decimal('12'), Decimal('7.00'))</font>
<font color="black">3982.         Decimal('19.00')</font>
<font color="black">3983.         &gt;&gt;&gt; ExtendedContext.add(Decimal('1E+2'), Decimal('1.01E+4'))</font>
<font color="black">3984.         Decimal('1.02E+4')</font>
<font color="black">3985.         &gt;&gt;&gt; ExtendedContext.add(1, Decimal(2))</font>
<font color="black">3986.         Decimal('3')</font>
<font color="black">3987.         &gt;&gt;&gt; ExtendedContext.add(Decimal(8), 5)</font>
<font color="black">3988.         Decimal('13')</font>
<font color="black">3989.         &gt;&gt;&gt; ExtendedContext.add(5, 5)</font>
<font color="black">3990.         Decimal('10')</font>
<font color="black">3991.         &quot;&quot;&quot;</font>
<font color="red">3992.         a = _convert_other(a, raiseit=True)</font>
<font color="red">3993.         r = a.__add__(b, context=self)</font>
<font color="red">3994.         if r is NotImplemented:</font>
<font color="red">3995.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">3996.         else:</font>
<font color="red">3997.             return r</font>
<font color="black">3998. </font>
<font color="green">3999.     def _apply(self, a):</font>
<font color="red">4000.         return str(a._fix(self))</font>
<font color="black">4001. </font>
<font color="green">4002.     def canonical(self, a):</font>
<font color="black">4003.         &quot;&quot;&quot;Returns the same Decimal object.</font>
<font color="black">4004. </font>
<font color="black">4005.         As we do not have different encodings for the same number, the</font>
<font color="black">4006.         received object already is in its canonical form.</font>
<font color="black">4007. </font>
<font color="black">4008.         &gt;&gt;&gt; ExtendedContext.canonical(Decimal('2.50'))</font>
<font color="black">4009.         Decimal('2.50')</font>
<font color="black">4010.         &quot;&quot;&quot;</font>
<font color="red">4011.         return a.canonical(context=self)</font>
<font color="black">4012. </font>
<font color="green">4013.     def compare(self, a, b):</font>
<font color="black">4014.         &quot;&quot;&quot;Compares values numerically.</font>
<font color="black">4015. </font>
<font color="black">4016.         If the signs of the operands differ, a value representing each operand</font>
<font color="black">4017.         ('-1' if the operand is less than zero, '0' if the operand is zero or</font>
<font color="black">4018.         negative zero, or '1' if the operand is greater than zero) is used in</font>
<font color="black">4019.         place of that operand for the comparison instead of the actual</font>
<font color="black">4020.         operand.</font>
<font color="black">4021. </font>
<font color="black">4022.         The comparison is then effected by subtracting the second operand from</font>
<font color="black">4023.         the first and then returning a value according to the result of the</font>
<font color="black">4024.         subtraction: '-1' if the result is less than zero, '0' if the result is</font>
<font color="black">4025.         zero or negative zero, or '1' if the result is greater than zero.</font>
<font color="black">4026. </font>
<font color="black">4027.         &gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('3'))</font>
<font color="black">4028.         Decimal('-1')</font>
<font color="black">4029.         &gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('2.1'))</font>
<font color="black">4030.         Decimal('0')</font>
<font color="black">4031.         &gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('2.10'))</font>
<font color="black">4032.         Decimal('0')</font>
<font color="black">4033.         &gt;&gt;&gt; ExtendedContext.compare(Decimal('3'), Decimal('2.1'))</font>
<font color="black">4034.         Decimal('1')</font>
<font color="black">4035.         &gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('-3'))</font>
<font color="black">4036.         Decimal('1')</font>
<font color="black">4037.         &gt;&gt;&gt; ExtendedContext.compare(Decimal('-3'), Decimal('2.1'))</font>
<font color="black">4038.         Decimal('-1')</font>
<font color="black">4039.         &gt;&gt;&gt; ExtendedContext.compare(1, 2)</font>
<font color="black">4040.         Decimal('-1')</font>
<font color="black">4041.         &gt;&gt;&gt; ExtendedContext.compare(Decimal(1), 2)</font>
<font color="black">4042.         Decimal('-1')</font>
<font color="black">4043.         &gt;&gt;&gt; ExtendedContext.compare(1, Decimal(2))</font>
<font color="black">4044.         Decimal('-1')</font>
<font color="black">4045.         &quot;&quot;&quot;</font>
<font color="red">4046.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4047.         return a.compare(b, context=self)</font>
<font color="black">4048. </font>
<font color="green">4049.     def compare_signal(self, a, b):</font>
<font color="black">4050.         &quot;&quot;&quot;Compares the values of the two operands numerically.</font>
<font color="black">4051. </font>
<font color="black">4052.         It's pretty much like compare(), but all NaNs signal, with signaling</font>
<font color="black">4053.         NaNs taking precedence over quiet NaNs.</font>
<font color="black">4054. </font>
<font color="black">4055.         &gt;&gt;&gt; c = ExtendedContext</font>
<font color="black">4056.         &gt;&gt;&gt; c.compare_signal(Decimal('2.1'), Decimal('3'))</font>
<font color="black">4057.         Decimal('-1')</font>
<font color="black">4058.         &gt;&gt;&gt; c.compare_signal(Decimal('2.1'), Decimal('2.1'))</font>
<font color="black">4059.         Decimal('0')</font>
<font color="black">4060.         &gt;&gt;&gt; c.flags[InvalidOperation] = 0</font>
<font color="black">4061.         &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black">4062.         0</font>
<font color="black">4063.         &gt;&gt;&gt; c.compare_signal(Decimal('NaN'), Decimal('2.1'))</font>
<font color="black">4064.         Decimal('NaN')</font>
<font color="black">4065.         &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black">4066.         1</font>
<font color="black">4067.         &gt;&gt;&gt; c.flags[InvalidOperation] = 0</font>
<font color="black">4068.         &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black">4069.         0</font>
<font color="black">4070.         &gt;&gt;&gt; c.compare_signal(Decimal('sNaN'), Decimal('2.1'))</font>
<font color="black">4071.         Decimal('NaN')</font>
<font color="black">4072.         &gt;&gt;&gt; print c.flags[InvalidOperation]</font>
<font color="black">4073.         1</font>
<font color="black">4074.         &gt;&gt;&gt; c.compare_signal(-1, 2)</font>
<font color="black">4075.         Decimal('-1')</font>
<font color="black">4076.         &gt;&gt;&gt; c.compare_signal(Decimal(-1), 2)</font>
<font color="black">4077.         Decimal('-1')</font>
<font color="black">4078.         &gt;&gt;&gt; c.compare_signal(-1, Decimal(2))</font>
<font color="black">4079.         Decimal('-1')</font>
<font color="black">4080.         &quot;&quot;&quot;</font>
<font color="red">4081.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4082.         return a.compare_signal(b, context=self)</font>
<font color="black">4083. </font>
<font color="green">4084.     def compare_total(self, a, b):</font>
<font color="black">4085.         &quot;&quot;&quot;Compares two operands using their abstract representation.</font>
<font color="black">4086. </font>
<font color="black">4087.         This is not like the standard compare, which use their numerical</font>
<font color="black">4088.         value. Note that a total ordering is defined for all possible abstract</font>
<font color="black">4089.         representations.</font>
<font color="black">4090. </font>
<font color="black">4091.         &gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.73'), Decimal('127.9'))</font>
<font color="black">4092.         Decimal('-1')</font>
<font color="black">4093.         &gt;&gt;&gt; ExtendedContext.compare_total(Decimal('-127'),  Decimal('12'))</font>
<font color="black">4094.         Decimal('-1')</font>
<font color="black">4095.         &gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.3'))</font>
<font color="black">4096.         Decimal('-1')</font>
<font color="black">4097.         &gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.30'))</font>
<font color="black">4098.         Decimal('0')</font>
<font color="black">4099.         &gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.3'),  Decimal('12.300'))</font>
<font color="black">4100.         Decimal('1')</font>
<font color="black">4101.         &gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.3'),  Decimal('NaN'))</font>
<font color="black">4102.         Decimal('-1')</font>
<font color="black">4103.         &gt;&gt;&gt; ExtendedContext.compare_total(1, 2)</font>
<font color="black">4104.         Decimal('-1')</font>
<font color="black">4105.         &gt;&gt;&gt; ExtendedContext.compare_total(Decimal(1), 2)</font>
<font color="black">4106.         Decimal('-1')</font>
<font color="black">4107.         &gt;&gt;&gt; ExtendedContext.compare_total(1, Decimal(2))</font>
<font color="black">4108.         Decimal('-1')</font>
<font color="black">4109.         &quot;&quot;&quot;</font>
<font color="red">4110.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4111.         return a.compare_total(b)</font>
<font color="black">4112. </font>
<font color="green">4113.     def compare_total_mag(self, a, b):</font>
<font color="black">4114.         &quot;&quot;&quot;Compares two operands using their abstract representation ignoring sign.</font>
<font color="black">4115. </font>
<font color="black">4116.         Like compare_total, but with operand's sign ignored and assumed to be 0.</font>
<font color="black">4117.         &quot;&quot;&quot;</font>
<font color="red">4118.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4119.         return a.compare_total_mag(b)</font>
<font color="black">4120. </font>
<font color="green">4121.     def copy_abs(self, a):</font>
<font color="black">4122.         &quot;&quot;&quot;Returns a copy of the operand with the sign set to 0.</font>
<font color="black">4123. </font>
<font color="black">4124.         &gt;&gt;&gt; ExtendedContext.copy_abs(Decimal('2.1'))</font>
<font color="black">4125.         Decimal('2.1')</font>
<font color="black">4126.         &gt;&gt;&gt; ExtendedContext.copy_abs(Decimal('-100'))</font>
<font color="black">4127.         Decimal('100')</font>
<font color="black">4128.         &gt;&gt;&gt; ExtendedContext.copy_abs(-1)</font>
<font color="black">4129.         Decimal('1')</font>
<font color="black">4130.         &quot;&quot;&quot;</font>
<font color="red">4131.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4132.         return a.copy_abs()</font>
<font color="black">4133. </font>
<font color="green">4134.     def copy_decimal(self, a):</font>
<font color="black">4135.         &quot;&quot;&quot;Returns a copy of the decimal object.</font>
<font color="black">4136. </font>
<font color="black">4137.         &gt;&gt;&gt; ExtendedContext.copy_decimal(Decimal('2.1'))</font>
<font color="black">4138.         Decimal('2.1')</font>
<font color="black">4139.         &gt;&gt;&gt; ExtendedContext.copy_decimal(Decimal('-1.00'))</font>
<font color="black">4140.         Decimal('-1.00')</font>
<font color="black">4141.         &gt;&gt;&gt; ExtendedContext.copy_decimal(1)</font>
<font color="black">4142.         Decimal('1')</font>
<font color="black">4143.         &quot;&quot;&quot;</font>
<font color="red">4144.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4145.         return Decimal(a)</font>
<font color="black">4146. </font>
<font color="green">4147.     def copy_negate(self, a):</font>
<font color="black">4148.         &quot;&quot;&quot;Returns a copy of the operand with the sign inverted.</font>
<font color="black">4149. </font>
<font color="black">4150.         &gt;&gt;&gt; ExtendedContext.copy_negate(Decimal('101.5'))</font>
<font color="black">4151.         Decimal('-101.5')</font>
<font color="black">4152.         &gt;&gt;&gt; ExtendedContext.copy_negate(Decimal('-101.5'))</font>
<font color="black">4153.         Decimal('101.5')</font>
<font color="black">4154.         &gt;&gt;&gt; ExtendedContext.copy_negate(1)</font>
<font color="black">4155.         Decimal('-1')</font>
<font color="black">4156.         &quot;&quot;&quot;</font>
<font color="red">4157.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4158.         return a.copy_negate()</font>
<font color="black">4159. </font>
<font color="green">4160.     def copy_sign(self, a, b):</font>
<font color="black">4161.         &quot;&quot;&quot;Copies the second operand's sign to the first one.</font>
<font color="black">4162. </font>
<font color="black">4163.         In detail, it returns a copy of the first operand with the sign</font>
<font color="black">4164.         equal to the sign of the second operand.</font>
<font color="black">4165. </font>
<font color="black">4166.         &gt;&gt;&gt; ExtendedContext.copy_sign(Decimal( '1.50'), Decimal('7.33'))</font>
<font color="black">4167.         Decimal('1.50')</font>
<font color="black">4168.         &gt;&gt;&gt; ExtendedContext.copy_sign(Decimal('-1.50'), Decimal('7.33'))</font>
<font color="black">4169.         Decimal('1.50')</font>
<font color="black">4170.         &gt;&gt;&gt; ExtendedContext.copy_sign(Decimal( '1.50'), Decimal('-7.33'))</font>
<font color="black">4171.         Decimal('-1.50')</font>
<font color="black">4172.         &gt;&gt;&gt; ExtendedContext.copy_sign(Decimal('-1.50'), Decimal('-7.33'))</font>
<font color="black">4173.         Decimal('-1.50')</font>
<font color="black">4174.         &gt;&gt;&gt; ExtendedContext.copy_sign(1, -2)</font>
<font color="black">4175.         Decimal('-1')</font>
<font color="black">4176.         &gt;&gt;&gt; ExtendedContext.copy_sign(Decimal(1), -2)</font>
<font color="black">4177.         Decimal('-1')</font>
<font color="black">4178.         &gt;&gt;&gt; ExtendedContext.copy_sign(1, Decimal(-2))</font>
<font color="black">4179.         Decimal('-1')</font>
<font color="black">4180.         &quot;&quot;&quot;</font>
<font color="red">4181.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4182.         return a.copy_sign(b)</font>
<font color="black">4183. </font>
<font color="green">4184.     def divide(self, a, b):</font>
<font color="black">4185.         &quot;&quot;&quot;Decimal division in a specified context.</font>
<font color="black">4186. </font>
<font color="black">4187.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('1'), Decimal('3'))</font>
<font color="black">4188.         Decimal('0.333333333')</font>
<font color="black">4189.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('2'), Decimal('3'))</font>
<font color="black">4190.         Decimal('0.666666667')</font>
<font color="black">4191.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('5'), Decimal('2'))</font>
<font color="black">4192.         Decimal('2.5')</font>
<font color="black">4193.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('1'), Decimal('10'))</font>
<font color="black">4194.         Decimal('0.1')</font>
<font color="black">4195.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('12'), Decimal('12'))</font>
<font color="black">4196.         Decimal('1')</font>
<font color="black">4197.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('8.00'), Decimal('2'))</font>
<font color="black">4198.         Decimal('4.00')</font>
<font color="black">4199.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('2.400'), Decimal('2.0'))</font>
<font color="black">4200.         Decimal('1.20')</font>
<font color="black">4201.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('1000'), Decimal('100'))</font>
<font color="black">4202.         Decimal('10')</font>
<font color="black">4203.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('1000'), Decimal('1'))</font>
<font color="black">4204.         Decimal('1000')</font>
<font color="black">4205.         &gt;&gt;&gt; ExtendedContext.divide(Decimal('2.40E+6'), Decimal('2'))</font>
<font color="black">4206.         Decimal('1.20E+6')</font>
<font color="black">4207.         &gt;&gt;&gt; ExtendedContext.divide(5, 5)</font>
<font color="black">4208.         Decimal('1')</font>
<font color="black">4209.         &gt;&gt;&gt; ExtendedContext.divide(Decimal(5), 5)</font>
<font color="black">4210.         Decimal('1')</font>
<font color="black">4211.         &gt;&gt;&gt; ExtendedContext.divide(5, Decimal(5))</font>
<font color="black">4212.         Decimal('1')</font>
<font color="black">4213.         &quot;&quot;&quot;</font>
<font color="red">4214.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4215.         r = a.__div__(b, context=self)</font>
<font color="red">4216.         if r is NotImplemented:</font>
<font color="red">4217.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">4218.         else:</font>
<font color="red">4219.             return r</font>
<font color="black">4220. </font>
<font color="green">4221.     def divide_int(self, a, b):</font>
<font color="black">4222.         &quot;&quot;&quot;Divides two numbers and returns the integer part of the result.</font>
<font color="black">4223. </font>
<font color="black">4224.         &gt;&gt;&gt; ExtendedContext.divide_int(Decimal('2'), Decimal('3'))</font>
<font color="black">4225.         Decimal('0')</font>
<font color="black">4226.         &gt;&gt;&gt; ExtendedContext.divide_int(Decimal('10'), Decimal('3'))</font>
<font color="black">4227.         Decimal('3')</font>
<font color="black">4228.         &gt;&gt;&gt; ExtendedContext.divide_int(Decimal('1'), Decimal('0.3'))</font>
<font color="black">4229.         Decimal('3')</font>
<font color="black">4230.         &gt;&gt;&gt; ExtendedContext.divide_int(10, 3)</font>
<font color="black">4231.         Decimal('3')</font>
<font color="black">4232.         &gt;&gt;&gt; ExtendedContext.divide_int(Decimal(10), 3)</font>
<font color="black">4233.         Decimal('3')</font>
<font color="black">4234.         &gt;&gt;&gt; ExtendedContext.divide_int(10, Decimal(3))</font>
<font color="black">4235.         Decimal('3')</font>
<font color="black">4236.         &quot;&quot;&quot;</font>
<font color="red">4237.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4238.         r = a.__floordiv__(b, context=self)</font>
<font color="red">4239.         if r is NotImplemented:</font>
<font color="red">4240.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">4241.         else:</font>
<font color="red">4242.             return r</font>
<font color="black">4243. </font>
<font color="green">4244.     def divmod(self, a, b):</font>
<font color="black">4245.         &quot;&quot;&quot;Return (a // b, a % b).</font>
<font color="black">4246. </font>
<font color="black">4247.         &gt;&gt;&gt; ExtendedContext.divmod(Decimal(8), Decimal(3))</font>
<font color="black">4248.         (Decimal('2'), Decimal('2'))</font>
<font color="black">4249.         &gt;&gt;&gt; ExtendedContext.divmod(Decimal(8), Decimal(4))</font>
<font color="black">4250.         (Decimal('2'), Decimal('0'))</font>
<font color="black">4251.         &gt;&gt;&gt; ExtendedContext.divmod(8, 4)</font>
<font color="black">4252.         (Decimal('2'), Decimal('0'))</font>
<font color="black">4253.         &gt;&gt;&gt; ExtendedContext.divmod(Decimal(8), 4)</font>
<font color="black">4254.         (Decimal('2'), Decimal('0'))</font>
<font color="black">4255.         &gt;&gt;&gt; ExtendedContext.divmod(8, Decimal(4))</font>
<font color="black">4256.         (Decimal('2'), Decimal('0'))</font>
<font color="black">4257.         &quot;&quot;&quot;</font>
<font color="red">4258.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4259.         r = a.__divmod__(b, context=self)</font>
<font color="red">4260.         if r is NotImplemented:</font>
<font color="red">4261.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">4262.         else:</font>
<font color="red">4263.             return r</font>
<font color="black">4264. </font>
<font color="green">4265.     def exp(self, a):</font>
<font color="black">4266.         &quot;&quot;&quot;Returns e ** a.</font>
<font color="black">4267. </font>
<font color="black">4268.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4269.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4270.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4271.         &gt;&gt;&gt; c.exp(Decimal('-Infinity'))</font>
<font color="black">4272.         Decimal('0')</font>
<font color="black">4273.         &gt;&gt;&gt; c.exp(Decimal('-1'))</font>
<font color="black">4274.         Decimal('0.367879441')</font>
<font color="black">4275.         &gt;&gt;&gt; c.exp(Decimal('0'))</font>
<font color="black">4276.         Decimal('1')</font>
<font color="black">4277.         &gt;&gt;&gt; c.exp(Decimal('1'))</font>
<font color="black">4278.         Decimal('2.71828183')</font>
<font color="black">4279.         &gt;&gt;&gt; c.exp(Decimal('0.693147181'))</font>
<font color="black">4280.         Decimal('2.00000000')</font>
<font color="black">4281.         &gt;&gt;&gt; c.exp(Decimal('+Infinity'))</font>
<font color="black">4282.         Decimal('Infinity')</font>
<font color="black">4283.         &gt;&gt;&gt; c.exp(10)</font>
<font color="black">4284.         Decimal('22026.4658')</font>
<font color="black">4285.         &quot;&quot;&quot;</font>
<font color="red">4286.         a =_convert_other(a, raiseit=True)</font>
<font color="red">4287.         return a.exp(context=self)</font>
<font color="black">4288. </font>
<font color="green">4289.     def fma(self, a, b, c):</font>
<font color="black">4290.         &quot;&quot;&quot;Returns a multiplied by b, plus c.</font>
<font color="black">4291. </font>
<font color="black">4292.         The first two operands are multiplied together, using multiply,</font>
<font color="black">4293.         the third operand is then added to the result of that</font>
<font color="black">4294.         multiplication, using add, all with only one final rounding.</font>
<font color="black">4295. </font>
<font color="black">4296.         &gt;&gt;&gt; ExtendedContext.fma(Decimal('3'), Decimal('5'), Decimal('7'))</font>
<font color="black">4297.         Decimal('22')</font>
<font color="black">4298.         &gt;&gt;&gt; ExtendedContext.fma(Decimal('3'), Decimal('-5'), Decimal('7'))</font>
<font color="black">4299.         Decimal('-8')</font>
<font color="black">4300.         &gt;&gt;&gt; ExtendedContext.fma(Decimal('888565290'), Decimal('1557.96930'), Decimal('-86087.7578'))</font>
<font color="black">4301.         Decimal('1.38435736E+12')</font>
<font color="black">4302.         &gt;&gt;&gt; ExtendedContext.fma(1, 3, 4)</font>
<font color="black">4303.         Decimal('7')</font>
<font color="black">4304.         &gt;&gt;&gt; ExtendedContext.fma(1, Decimal(3), 4)</font>
<font color="black">4305.         Decimal('7')</font>
<font color="black">4306.         &gt;&gt;&gt; ExtendedContext.fma(1, 3, Decimal(4))</font>
<font color="black">4307.         Decimal('7')</font>
<font color="black">4308.         &quot;&quot;&quot;</font>
<font color="red">4309.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4310.         return a.fma(b, c, context=self)</font>
<font color="black">4311. </font>
<font color="green">4312.     def is_canonical(self, a):</font>
<font color="black">4313.         &quot;&quot;&quot;Return True if the operand is canonical; otherwise return False.</font>
<font color="black">4314. </font>
<font color="black">4315.         Currently, the encoding of a Decimal instance is always</font>
<font color="black">4316.         canonical, so this method returns True for any Decimal.</font>
<font color="black">4317. </font>
<font color="black">4318.         &gt;&gt;&gt; ExtendedContext.is_canonical(Decimal('2.50'))</font>
<font color="black">4319.         True</font>
<font color="black">4320.         &quot;&quot;&quot;</font>
<font color="red">4321.         return a.is_canonical()</font>
<font color="black">4322. </font>
<font color="green">4323.     def is_finite(self, a):</font>
<font color="black">4324.         &quot;&quot;&quot;Return True if the operand is finite; otherwise return False.</font>
<font color="black">4325. </font>
<font color="black">4326.         A Decimal instance is considered finite if it is neither</font>
<font color="black">4327.         infinite nor a NaN.</font>
<font color="black">4328. </font>
<font color="black">4329.         &gt;&gt;&gt; ExtendedContext.is_finite(Decimal('2.50'))</font>
<font color="black">4330.         True</font>
<font color="black">4331.         &gt;&gt;&gt; ExtendedContext.is_finite(Decimal('-0.3'))</font>
<font color="black">4332.         True</font>
<font color="black">4333.         &gt;&gt;&gt; ExtendedContext.is_finite(Decimal('0'))</font>
<font color="black">4334.         True</font>
<font color="black">4335.         &gt;&gt;&gt; ExtendedContext.is_finite(Decimal('Inf'))</font>
<font color="black">4336.         False</font>
<font color="black">4337.         &gt;&gt;&gt; ExtendedContext.is_finite(Decimal('NaN'))</font>
<font color="black">4338.         False</font>
<font color="black">4339.         &gt;&gt;&gt; ExtendedContext.is_finite(1)</font>
<font color="black">4340.         True</font>
<font color="black">4341.         &quot;&quot;&quot;</font>
<font color="red">4342.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4343.         return a.is_finite()</font>
<font color="black">4344. </font>
<font color="green">4345.     def is_infinite(self, a):</font>
<font color="black">4346.         &quot;&quot;&quot;Return True if the operand is infinite; otherwise return False.</font>
<font color="black">4347. </font>
<font color="black">4348.         &gt;&gt;&gt; ExtendedContext.is_infinite(Decimal('2.50'))</font>
<font color="black">4349.         False</font>
<font color="black">4350.         &gt;&gt;&gt; ExtendedContext.is_infinite(Decimal('-Inf'))</font>
<font color="black">4351.         True</font>
<font color="black">4352.         &gt;&gt;&gt; ExtendedContext.is_infinite(Decimal('NaN'))</font>
<font color="black">4353.         False</font>
<font color="black">4354.         &gt;&gt;&gt; ExtendedContext.is_infinite(1)</font>
<font color="black">4355.         False</font>
<font color="black">4356.         &quot;&quot;&quot;</font>
<font color="red">4357.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4358.         return a.is_infinite()</font>
<font color="black">4359. </font>
<font color="green">4360.     def is_nan(self, a):</font>
<font color="black">4361.         &quot;&quot;&quot;Return True if the operand is a qNaN or sNaN;</font>
<font color="black">4362.         otherwise return False.</font>
<font color="black">4363. </font>
<font color="black">4364.         &gt;&gt;&gt; ExtendedContext.is_nan(Decimal('2.50'))</font>
<font color="black">4365.         False</font>
<font color="black">4366.         &gt;&gt;&gt; ExtendedContext.is_nan(Decimal('NaN'))</font>
<font color="black">4367.         True</font>
<font color="black">4368.         &gt;&gt;&gt; ExtendedContext.is_nan(Decimal('-sNaN'))</font>
<font color="black">4369.         True</font>
<font color="black">4370.         &gt;&gt;&gt; ExtendedContext.is_nan(1)</font>
<font color="black">4371.         False</font>
<font color="black">4372.         &quot;&quot;&quot;</font>
<font color="red">4373.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4374.         return a.is_nan()</font>
<font color="black">4375. </font>
<font color="green">4376.     def is_normal(self, a):</font>
<font color="black">4377.         &quot;&quot;&quot;Return True if the operand is a normal number;</font>
<font color="black">4378.         otherwise return False.</font>
<font color="black">4379. </font>
<font color="black">4380.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4381.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4382.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4383.         &gt;&gt;&gt; c.is_normal(Decimal('2.50'))</font>
<font color="black">4384.         True</font>
<font color="black">4385.         &gt;&gt;&gt; c.is_normal(Decimal('0.1E-999'))</font>
<font color="black">4386.         False</font>
<font color="black">4387.         &gt;&gt;&gt; c.is_normal(Decimal('0.00'))</font>
<font color="black">4388.         False</font>
<font color="black">4389.         &gt;&gt;&gt; c.is_normal(Decimal('-Inf'))</font>
<font color="black">4390.         False</font>
<font color="black">4391.         &gt;&gt;&gt; c.is_normal(Decimal('NaN'))</font>
<font color="black">4392.         False</font>
<font color="black">4393.         &gt;&gt;&gt; c.is_normal(1)</font>
<font color="black">4394.         True</font>
<font color="black">4395.         &quot;&quot;&quot;</font>
<font color="red">4396.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4397.         return a.is_normal(context=self)</font>
<font color="black">4398. </font>
<font color="green">4399.     def is_qnan(self, a):</font>
<font color="black">4400.         &quot;&quot;&quot;Return True if the operand is a quiet NaN; otherwise return False.</font>
<font color="black">4401. </font>
<font color="black">4402.         &gt;&gt;&gt; ExtendedContext.is_qnan(Decimal('2.50'))</font>
<font color="black">4403.         False</font>
<font color="black">4404.         &gt;&gt;&gt; ExtendedContext.is_qnan(Decimal('NaN'))</font>
<font color="black">4405.         True</font>
<font color="black">4406.         &gt;&gt;&gt; ExtendedContext.is_qnan(Decimal('sNaN'))</font>
<font color="black">4407.         False</font>
<font color="black">4408.         &gt;&gt;&gt; ExtendedContext.is_qnan(1)</font>
<font color="black">4409.         False</font>
<font color="black">4410.         &quot;&quot;&quot;</font>
<font color="red">4411.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4412.         return a.is_qnan()</font>
<font color="black">4413. </font>
<font color="green">4414.     def is_signed(self, a):</font>
<font color="black">4415.         &quot;&quot;&quot;Return True if the operand is negative; otherwise return False.</font>
<font color="black">4416. </font>
<font color="black">4417.         &gt;&gt;&gt; ExtendedContext.is_signed(Decimal('2.50'))</font>
<font color="black">4418.         False</font>
<font color="black">4419.         &gt;&gt;&gt; ExtendedContext.is_signed(Decimal('-12'))</font>
<font color="black">4420.         True</font>
<font color="black">4421.         &gt;&gt;&gt; ExtendedContext.is_signed(Decimal('-0'))</font>
<font color="black">4422.         True</font>
<font color="black">4423.         &gt;&gt;&gt; ExtendedContext.is_signed(8)</font>
<font color="black">4424.         False</font>
<font color="black">4425.         &gt;&gt;&gt; ExtendedContext.is_signed(-8)</font>
<font color="black">4426.         True</font>
<font color="black">4427.         &quot;&quot;&quot;</font>
<font color="red">4428.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4429.         return a.is_signed()</font>
<font color="black">4430. </font>
<font color="green">4431.     def is_snan(self, a):</font>
<font color="black">4432.         &quot;&quot;&quot;Return True if the operand is a signaling NaN;</font>
<font color="black">4433.         otherwise return False.</font>
<font color="black">4434. </font>
<font color="black">4435.         &gt;&gt;&gt; ExtendedContext.is_snan(Decimal('2.50'))</font>
<font color="black">4436.         False</font>
<font color="black">4437.         &gt;&gt;&gt; ExtendedContext.is_snan(Decimal('NaN'))</font>
<font color="black">4438.         False</font>
<font color="black">4439.         &gt;&gt;&gt; ExtendedContext.is_snan(Decimal('sNaN'))</font>
<font color="black">4440.         True</font>
<font color="black">4441.         &gt;&gt;&gt; ExtendedContext.is_snan(1)</font>
<font color="black">4442.         False</font>
<font color="black">4443.         &quot;&quot;&quot;</font>
<font color="red">4444.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4445.         return a.is_snan()</font>
<font color="black">4446. </font>
<font color="green">4447.     def is_subnormal(self, a):</font>
<font color="black">4448.         &quot;&quot;&quot;Return True if the operand is subnormal; otherwise return False.</font>
<font color="black">4449. </font>
<font color="black">4450.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4451.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4452.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4453.         &gt;&gt;&gt; c.is_subnormal(Decimal('2.50'))</font>
<font color="black">4454.         False</font>
<font color="black">4455.         &gt;&gt;&gt; c.is_subnormal(Decimal('0.1E-999'))</font>
<font color="black">4456.         True</font>
<font color="black">4457.         &gt;&gt;&gt; c.is_subnormal(Decimal('0.00'))</font>
<font color="black">4458.         False</font>
<font color="black">4459.         &gt;&gt;&gt; c.is_subnormal(Decimal('-Inf'))</font>
<font color="black">4460.         False</font>
<font color="black">4461.         &gt;&gt;&gt; c.is_subnormal(Decimal('NaN'))</font>
<font color="black">4462.         False</font>
<font color="black">4463.         &gt;&gt;&gt; c.is_subnormal(1)</font>
<font color="black">4464.         False</font>
<font color="black">4465.         &quot;&quot;&quot;</font>
<font color="red">4466.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4467.         return a.is_subnormal(context=self)</font>
<font color="black">4468. </font>
<font color="green">4469.     def is_zero(self, a):</font>
<font color="black">4470.         &quot;&quot;&quot;Return True if the operand is a zero; otherwise return False.</font>
<font color="black">4471. </font>
<font color="black">4472.         &gt;&gt;&gt; ExtendedContext.is_zero(Decimal('0'))</font>
<font color="black">4473.         True</font>
<font color="black">4474.         &gt;&gt;&gt; ExtendedContext.is_zero(Decimal('2.50'))</font>
<font color="black">4475.         False</font>
<font color="black">4476.         &gt;&gt;&gt; ExtendedContext.is_zero(Decimal('-0E+2'))</font>
<font color="black">4477.         True</font>
<font color="black">4478.         &gt;&gt;&gt; ExtendedContext.is_zero(1)</font>
<font color="black">4479.         False</font>
<font color="black">4480.         &gt;&gt;&gt; ExtendedContext.is_zero(0)</font>
<font color="black">4481.         True</font>
<font color="black">4482.         &quot;&quot;&quot;</font>
<font color="red">4483.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4484.         return a.is_zero()</font>
<font color="black">4485. </font>
<font color="green">4486.     def ln(self, a):</font>
<font color="black">4487.         &quot;&quot;&quot;Returns the natural (base e) logarithm of the operand.</font>
<font color="black">4488. </font>
<font color="black">4489.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4490.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4491.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4492.         &gt;&gt;&gt; c.ln(Decimal('0'))</font>
<font color="black">4493.         Decimal('-Infinity')</font>
<font color="black">4494.         &gt;&gt;&gt; c.ln(Decimal('1.000'))</font>
<font color="black">4495.         Decimal('0')</font>
<font color="black">4496.         &gt;&gt;&gt; c.ln(Decimal('2.71828183'))</font>
<font color="black">4497.         Decimal('1.00000000')</font>
<font color="black">4498.         &gt;&gt;&gt; c.ln(Decimal('10'))</font>
<font color="black">4499.         Decimal('2.30258509')</font>
<font color="black">4500.         &gt;&gt;&gt; c.ln(Decimal('+Infinity'))</font>
<font color="black">4501.         Decimal('Infinity')</font>
<font color="black">4502.         &gt;&gt;&gt; c.ln(1)</font>
<font color="black">4503.         Decimal('0')</font>
<font color="black">4504.         &quot;&quot;&quot;</font>
<font color="red">4505.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4506.         return a.ln(context=self)</font>
<font color="black">4507. </font>
<font color="green">4508.     def log10(self, a):</font>
<font color="black">4509.         &quot;&quot;&quot;Returns the base 10 logarithm of the operand.</font>
<font color="black">4510. </font>
<font color="black">4511.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4512.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4513.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4514.         &gt;&gt;&gt; c.log10(Decimal('0'))</font>
<font color="black">4515.         Decimal('-Infinity')</font>
<font color="black">4516.         &gt;&gt;&gt; c.log10(Decimal('0.001'))</font>
<font color="black">4517.         Decimal('-3')</font>
<font color="black">4518.         &gt;&gt;&gt; c.log10(Decimal('1.000'))</font>
<font color="black">4519.         Decimal('0')</font>
<font color="black">4520.         &gt;&gt;&gt; c.log10(Decimal('2'))</font>
<font color="black">4521.         Decimal('0.301029996')</font>
<font color="black">4522.         &gt;&gt;&gt; c.log10(Decimal('10'))</font>
<font color="black">4523.         Decimal('1')</font>
<font color="black">4524.         &gt;&gt;&gt; c.log10(Decimal('70'))</font>
<font color="black">4525.         Decimal('1.84509804')</font>
<font color="black">4526.         &gt;&gt;&gt; c.log10(Decimal('+Infinity'))</font>
<font color="black">4527.         Decimal('Infinity')</font>
<font color="black">4528.         &gt;&gt;&gt; c.log10(0)</font>
<font color="black">4529.         Decimal('-Infinity')</font>
<font color="black">4530.         &gt;&gt;&gt; c.log10(1)</font>
<font color="black">4531.         Decimal('0')</font>
<font color="black">4532.         &quot;&quot;&quot;</font>
<font color="red">4533.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4534.         return a.log10(context=self)</font>
<font color="black">4535. </font>
<font color="green">4536.     def logb(self, a):</font>
<font color="black">4537.         &quot;&quot;&quot; Returns the exponent of the magnitude of the operand's MSD.</font>
<font color="black">4538. </font>
<font color="black">4539.         The result is the integer which is the exponent of the magnitude</font>
<font color="black">4540.         of the most significant digit of the operand (as though the</font>
<font color="black">4541.         operand were truncated to a single digit while maintaining the</font>
<font color="black">4542.         value of that digit and without limiting the resulting exponent).</font>
<font color="black">4543. </font>
<font color="black">4544.         &gt;&gt;&gt; ExtendedContext.logb(Decimal('250'))</font>
<font color="black">4545.         Decimal('2')</font>
<font color="black">4546.         &gt;&gt;&gt; ExtendedContext.logb(Decimal('2.50'))</font>
<font color="black">4547.         Decimal('0')</font>
<font color="black">4548.         &gt;&gt;&gt; ExtendedContext.logb(Decimal('0.03'))</font>
<font color="black">4549.         Decimal('-2')</font>
<font color="black">4550.         &gt;&gt;&gt; ExtendedContext.logb(Decimal('0'))</font>
<font color="black">4551.         Decimal('-Infinity')</font>
<font color="black">4552.         &gt;&gt;&gt; ExtendedContext.logb(1)</font>
<font color="black">4553.         Decimal('0')</font>
<font color="black">4554.         &gt;&gt;&gt; ExtendedContext.logb(10)</font>
<font color="black">4555.         Decimal('1')</font>
<font color="black">4556.         &gt;&gt;&gt; ExtendedContext.logb(100)</font>
<font color="black">4557.         Decimal('2')</font>
<font color="black">4558.         &quot;&quot;&quot;</font>
<font color="red">4559.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4560.         return a.logb(context=self)</font>
<font color="black">4561. </font>
<font color="green">4562.     def logical_and(self, a, b):</font>
<font color="black">4563.         &quot;&quot;&quot;Applies the logical operation 'and' between each operand's digits.</font>
<font color="black">4564. </font>
<font color="black">4565.         The operands must be both logical numbers.</font>
<font color="black">4566. </font>
<font color="black">4567.         &gt;&gt;&gt; ExtendedContext.logical_and(Decimal('0'), Decimal('0'))</font>
<font color="black">4568.         Decimal('0')</font>
<font color="black">4569.         &gt;&gt;&gt; ExtendedContext.logical_and(Decimal('0'), Decimal('1'))</font>
<font color="black">4570.         Decimal('0')</font>
<font color="black">4571.         &gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1'), Decimal('0'))</font>
<font color="black">4572.         Decimal('0')</font>
<font color="black">4573.         &gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1'), Decimal('1'))</font>
<font color="black">4574.         Decimal('1')</font>
<font color="black">4575.         &gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1100'), Decimal('1010'))</font>
<font color="black">4576.         Decimal('1000')</font>
<font color="black">4577.         &gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1111'), Decimal('10'))</font>
<font color="black">4578.         Decimal('10')</font>
<font color="black">4579.         &gt;&gt;&gt; ExtendedContext.logical_and(110, 1101)</font>
<font color="black">4580.         Decimal('100')</font>
<font color="black">4581.         &gt;&gt;&gt; ExtendedContext.logical_and(Decimal(110), 1101)</font>
<font color="black">4582.         Decimal('100')</font>
<font color="black">4583.         &gt;&gt;&gt; ExtendedContext.logical_and(110, Decimal(1101))</font>
<font color="black">4584.         Decimal('100')</font>
<font color="black">4585.         &quot;&quot;&quot;</font>
<font color="red">4586.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4587.         return a.logical_and(b, context=self)</font>
<font color="black">4588. </font>
<font color="green">4589.     def logical_invert(self, a):</font>
<font color="black">4590.         &quot;&quot;&quot;Invert all the digits in the operand.</font>
<font color="black">4591. </font>
<font color="black">4592.         The operand must be a logical number.</font>
<font color="black">4593. </font>
<font color="black">4594.         &gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('0'))</font>
<font color="black">4595.         Decimal('111111111')</font>
<font color="black">4596.         &gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('1'))</font>
<font color="black">4597.         Decimal('111111110')</font>
<font color="black">4598.         &gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('111111111'))</font>
<font color="black">4599.         Decimal('0')</font>
<font color="black">4600.         &gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('101010101'))</font>
<font color="black">4601.         Decimal('10101010')</font>
<font color="black">4602.         &gt;&gt;&gt; ExtendedContext.logical_invert(1101)</font>
<font color="black">4603.         Decimal('111110010')</font>
<font color="black">4604.         &quot;&quot;&quot;</font>
<font color="red">4605.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4606.         return a.logical_invert(context=self)</font>
<font color="black">4607. </font>
<font color="green">4608.     def logical_or(self, a, b):</font>
<font color="black">4609.         &quot;&quot;&quot;Applies the logical operation 'or' between each operand's digits.</font>
<font color="black">4610. </font>
<font color="black">4611.         The operands must be both logical numbers.</font>
<font color="black">4612. </font>
<font color="black">4613.         &gt;&gt;&gt; ExtendedContext.logical_or(Decimal('0'), Decimal('0'))</font>
<font color="black">4614.         Decimal('0')</font>
<font color="black">4615.         &gt;&gt;&gt; ExtendedContext.logical_or(Decimal('0'), Decimal('1'))</font>
<font color="black">4616.         Decimal('1')</font>
<font color="black">4617.         &gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1'), Decimal('0'))</font>
<font color="black">4618.         Decimal('1')</font>
<font color="black">4619.         &gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1'), Decimal('1'))</font>
<font color="black">4620.         Decimal('1')</font>
<font color="black">4621.         &gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1100'), Decimal('1010'))</font>
<font color="black">4622.         Decimal('1110')</font>
<font color="black">4623.         &gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1110'), Decimal('10'))</font>
<font color="black">4624.         Decimal('1110')</font>
<font color="black">4625.         &gt;&gt;&gt; ExtendedContext.logical_or(110, 1101)</font>
<font color="black">4626.         Decimal('1111')</font>
<font color="black">4627.         &gt;&gt;&gt; ExtendedContext.logical_or(Decimal(110), 1101)</font>
<font color="black">4628.         Decimal('1111')</font>
<font color="black">4629.         &gt;&gt;&gt; ExtendedContext.logical_or(110, Decimal(1101))</font>
<font color="black">4630.         Decimal('1111')</font>
<font color="black">4631.         &quot;&quot;&quot;</font>
<font color="red">4632.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4633.         return a.logical_or(b, context=self)</font>
<font color="black">4634. </font>
<font color="green">4635.     def logical_xor(self, a, b):</font>
<font color="black">4636.         &quot;&quot;&quot;Applies the logical operation 'xor' between each operand's digits.</font>
<font color="black">4637. </font>
<font color="black">4638.         The operands must be both logical numbers.</font>
<font color="black">4639. </font>
<font color="black">4640.         &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('0'), Decimal('0'))</font>
<font color="black">4641.         Decimal('0')</font>
<font color="black">4642.         &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('0'), Decimal('1'))</font>
<font color="black">4643.         Decimal('1')</font>
<font color="black">4644.         &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1'), Decimal('0'))</font>
<font color="black">4645.         Decimal('1')</font>
<font color="black">4646.         &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1'), Decimal('1'))</font>
<font color="black">4647.         Decimal('0')</font>
<font color="black">4648.         &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1100'), Decimal('1010'))</font>
<font color="black">4649.         Decimal('110')</font>
<font color="black">4650.         &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1111'), Decimal('10'))</font>
<font color="black">4651.         Decimal('1101')</font>
<font color="black">4652.         &gt;&gt;&gt; ExtendedContext.logical_xor(110, 1101)</font>
<font color="black">4653.         Decimal('1011')</font>
<font color="black">4654.         &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal(110), 1101)</font>
<font color="black">4655.         Decimal('1011')</font>
<font color="black">4656.         &gt;&gt;&gt; ExtendedContext.logical_xor(110, Decimal(1101))</font>
<font color="black">4657.         Decimal('1011')</font>
<font color="black">4658.         &quot;&quot;&quot;</font>
<font color="red">4659.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4660.         return a.logical_xor(b, context=self)</font>
<font color="black">4661. </font>
<font color="green">4662.     def max(self, a, b):</font>
<font color="black">4663.         &quot;&quot;&quot;max compares two values numerically and returns the maximum.</font>
<font color="black">4664. </font>
<font color="black">4665.         If either operand is a NaN then the general rules apply.</font>
<font color="black">4666.         Otherwise, the operands are compared as though by the compare</font>
<font color="black">4667.         operation.  If they are numerically equal then the left-hand operand</font>
<font color="black">4668.         is chosen as the result.  Otherwise the maximum (closer to positive</font>
<font color="black">4669.         infinity) of the two operands is chosen as the result.</font>
<font color="black">4670. </font>
<font color="black">4671.         &gt;&gt;&gt; ExtendedContext.max(Decimal('3'), Decimal('2'))</font>
<font color="black">4672.         Decimal('3')</font>
<font color="black">4673.         &gt;&gt;&gt; ExtendedContext.max(Decimal('-10'), Decimal('3'))</font>
<font color="black">4674.         Decimal('3')</font>
<font color="black">4675.         &gt;&gt;&gt; ExtendedContext.max(Decimal('1.0'), Decimal('1'))</font>
<font color="black">4676.         Decimal('1')</font>
<font color="black">4677.         &gt;&gt;&gt; ExtendedContext.max(Decimal('7'), Decimal('NaN'))</font>
<font color="black">4678.         Decimal('7')</font>
<font color="black">4679.         &gt;&gt;&gt; ExtendedContext.max(1, 2)</font>
<font color="black">4680.         Decimal('2')</font>
<font color="black">4681.         &gt;&gt;&gt; ExtendedContext.max(Decimal(1), 2)</font>
<font color="black">4682.         Decimal('2')</font>
<font color="black">4683.         &gt;&gt;&gt; ExtendedContext.max(1, Decimal(2))</font>
<font color="black">4684.         Decimal('2')</font>
<font color="black">4685.         &quot;&quot;&quot;</font>
<font color="red">4686.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4687.         return a.max(b, context=self)</font>
<font color="black">4688. </font>
<font color="green">4689.     def max_mag(self, a, b):</font>
<font color="black">4690.         &quot;&quot;&quot;Compares the values numerically with their sign ignored.</font>
<font color="black">4691. </font>
<font color="black">4692.         &gt;&gt;&gt; ExtendedContext.max_mag(Decimal('7'), Decimal('NaN'))</font>
<font color="black">4693.         Decimal('7')</font>
<font color="black">4694.         &gt;&gt;&gt; ExtendedContext.max_mag(Decimal('7'), Decimal('-10'))</font>
<font color="black">4695.         Decimal('-10')</font>
<font color="black">4696.         &gt;&gt;&gt; ExtendedContext.max_mag(1, -2)</font>
<font color="black">4697.         Decimal('-2')</font>
<font color="black">4698.         &gt;&gt;&gt; ExtendedContext.max_mag(Decimal(1), -2)</font>
<font color="black">4699.         Decimal('-2')</font>
<font color="black">4700.         &gt;&gt;&gt; ExtendedContext.max_mag(1, Decimal(-2))</font>
<font color="black">4701.         Decimal('-2')</font>
<font color="black">4702.         &quot;&quot;&quot;</font>
<font color="red">4703.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4704.         return a.max_mag(b, context=self)</font>
<font color="black">4705. </font>
<font color="green">4706.     def min(self, a, b):</font>
<font color="black">4707.         &quot;&quot;&quot;min compares two values numerically and returns the minimum.</font>
<font color="black">4708. </font>
<font color="black">4709.         If either operand is a NaN then the general rules apply.</font>
<font color="black">4710.         Otherwise, the operands are compared as though by the compare</font>
<font color="black">4711.         operation.  If they are numerically equal then the left-hand operand</font>
<font color="black">4712.         is chosen as the result.  Otherwise the minimum (closer to negative</font>
<font color="black">4713.         infinity) of the two operands is chosen as the result.</font>
<font color="black">4714. </font>
<font color="black">4715.         &gt;&gt;&gt; ExtendedContext.min(Decimal('3'), Decimal('2'))</font>
<font color="black">4716.         Decimal('2')</font>
<font color="black">4717.         &gt;&gt;&gt; ExtendedContext.min(Decimal('-10'), Decimal('3'))</font>
<font color="black">4718.         Decimal('-10')</font>
<font color="black">4719.         &gt;&gt;&gt; ExtendedContext.min(Decimal('1.0'), Decimal('1'))</font>
<font color="black">4720.         Decimal('1.0')</font>
<font color="black">4721.         &gt;&gt;&gt; ExtendedContext.min(Decimal('7'), Decimal('NaN'))</font>
<font color="black">4722.         Decimal('7')</font>
<font color="black">4723.         &gt;&gt;&gt; ExtendedContext.min(1, 2)</font>
<font color="black">4724.         Decimal('1')</font>
<font color="black">4725.         &gt;&gt;&gt; ExtendedContext.min(Decimal(1), 2)</font>
<font color="black">4726.         Decimal('1')</font>
<font color="black">4727.         &gt;&gt;&gt; ExtendedContext.min(1, Decimal(29))</font>
<font color="black">4728.         Decimal('1')</font>
<font color="black">4729.         &quot;&quot;&quot;</font>
<font color="red">4730.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4731.         return a.min(b, context=self)</font>
<font color="black">4732. </font>
<font color="green">4733.     def min_mag(self, a, b):</font>
<font color="black">4734.         &quot;&quot;&quot;Compares the values numerically with their sign ignored.</font>
<font color="black">4735. </font>
<font color="black">4736.         &gt;&gt;&gt; ExtendedContext.min_mag(Decimal('3'), Decimal('-2'))</font>
<font color="black">4737.         Decimal('-2')</font>
<font color="black">4738.         &gt;&gt;&gt; ExtendedContext.min_mag(Decimal('-3'), Decimal('NaN'))</font>
<font color="black">4739.         Decimal('-3')</font>
<font color="black">4740.         &gt;&gt;&gt; ExtendedContext.min_mag(1, -2)</font>
<font color="black">4741.         Decimal('1')</font>
<font color="black">4742.         &gt;&gt;&gt; ExtendedContext.min_mag(Decimal(1), -2)</font>
<font color="black">4743.         Decimal('1')</font>
<font color="black">4744.         &gt;&gt;&gt; ExtendedContext.min_mag(1, Decimal(-2))</font>
<font color="black">4745.         Decimal('1')</font>
<font color="black">4746.         &quot;&quot;&quot;</font>
<font color="red">4747.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4748.         return a.min_mag(b, context=self)</font>
<font color="black">4749. </font>
<font color="green">4750.     def minus(self, a):</font>
<font color="black">4751.         &quot;&quot;&quot;Minus corresponds to unary prefix minus in Python.</font>
<font color="black">4752. </font>
<font color="black">4753.         The operation is evaluated using the same rules as subtract; the</font>
<font color="black">4754.         operation minus(a) is calculated as subtract('0', a) where the '0'</font>
<font color="black">4755.         has the same exponent as the operand.</font>
<font color="black">4756. </font>
<font color="black">4757.         &gt;&gt;&gt; ExtendedContext.minus(Decimal('1.3'))</font>
<font color="black">4758.         Decimal('-1.3')</font>
<font color="black">4759.         &gt;&gt;&gt; ExtendedContext.minus(Decimal('-1.3'))</font>
<font color="black">4760.         Decimal('1.3')</font>
<font color="black">4761.         &gt;&gt;&gt; ExtendedContext.minus(1)</font>
<font color="black">4762.         Decimal('-1')</font>
<font color="black">4763.         &quot;&quot;&quot;</font>
<font color="red">4764.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4765.         return a.__neg__(context=self)</font>
<font color="black">4766. </font>
<font color="green">4767.     def multiply(self, a, b):</font>
<font color="black">4768.         &quot;&quot;&quot;multiply multiplies two operands.</font>
<font color="black">4769. </font>
<font color="black">4770.         If either operand is a special value then the general rules apply.</font>
<font color="black">4771.         Otherwise, the operands are multiplied together</font>
<font color="black">4772.         ('long multiplication'), resulting in a number which may be as long as</font>
<font color="black">4773.         the sum of the lengths of the two operands.</font>
<font color="black">4774. </font>
<font color="black">4775.         &gt;&gt;&gt; ExtendedContext.multiply(Decimal('1.20'), Decimal('3'))</font>
<font color="black">4776.         Decimal('3.60')</font>
<font color="black">4777.         &gt;&gt;&gt; ExtendedContext.multiply(Decimal('7'), Decimal('3'))</font>
<font color="black">4778.         Decimal('21')</font>
<font color="black">4779.         &gt;&gt;&gt; ExtendedContext.multiply(Decimal('0.9'), Decimal('0.8'))</font>
<font color="black">4780.         Decimal('0.72')</font>
<font color="black">4781.         &gt;&gt;&gt; ExtendedContext.multiply(Decimal('0.9'), Decimal('-0'))</font>
<font color="black">4782.         Decimal('-0.0')</font>
<font color="black">4783.         &gt;&gt;&gt; ExtendedContext.multiply(Decimal('654321'), Decimal('654321'))</font>
<font color="black">4784.         Decimal('4.28135971E+11')</font>
<font color="black">4785.         &gt;&gt;&gt; ExtendedContext.multiply(7, 7)</font>
<font color="black">4786.         Decimal('49')</font>
<font color="black">4787.         &gt;&gt;&gt; ExtendedContext.multiply(Decimal(7), 7)</font>
<font color="black">4788.         Decimal('49')</font>
<font color="black">4789.         &gt;&gt;&gt; ExtendedContext.multiply(7, Decimal(7))</font>
<font color="black">4790.         Decimal('49')</font>
<font color="black">4791.         &quot;&quot;&quot;</font>
<font color="red">4792.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4793.         r = a.__mul__(b, context=self)</font>
<font color="red">4794.         if r is NotImplemented:</font>
<font color="red">4795.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">4796.         else:</font>
<font color="red">4797.             return r</font>
<font color="black">4798. </font>
<font color="green">4799.     def next_minus(self, a):</font>
<font color="black">4800.         &quot;&quot;&quot;Returns the largest representable number smaller than a.</font>
<font color="black">4801. </font>
<font color="black">4802.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4803.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4804.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4805.         &gt;&gt;&gt; ExtendedContext.next_minus(Decimal('1'))</font>
<font color="black">4806.         Decimal('0.999999999')</font>
<font color="black">4807.         &gt;&gt;&gt; c.next_minus(Decimal('1E-1007'))</font>
<font color="black">4808.         Decimal('0E-1007')</font>
<font color="black">4809.         &gt;&gt;&gt; ExtendedContext.next_minus(Decimal('-1.00000003'))</font>
<font color="black">4810.         Decimal('-1.00000004')</font>
<font color="black">4811.         &gt;&gt;&gt; c.next_minus(Decimal('Infinity'))</font>
<font color="black">4812.         Decimal('9.99999999E+999')</font>
<font color="black">4813.         &gt;&gt;&gt; c.next_minus(1)</font>
<font color="black">4814.         Decimal('0.999999999')</font>
<font color="black">4815.         &quot;&quot;&quot;</font>
<font color="red">4816.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4817.         return a.next_minus(context=self)</font>
<font color="black">4818. </font>
<font color="green">4819.     def next_plus(self, a):</font>
<font color="black">4820.         &quot;&quot;&quot;Returns the smallest representable number larger than a.</font>
<font color="black">4821. </font>
<font color="black">4822.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4823.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4824.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4825.         &gt;&gt;&gt; ExtendedContext.next_plus(Decimal('1'))</font>
<font color="black">4826.         Decimal('1.00000001')</font>
<font color="black">4827.         &gt;&gt;&gt; c.next_plus(Decimal('-1E-1007'))</font>
<font color="black">4828.         Decimal('-0E-1007')</font>
<font color="black">4829.         &gt;&gt;&gt; ExtendedContext.next_plus(Decimal('-1.00000003'))</font>
<font color="black">4830.         Decimal('-1.00000002')</font>
<font color="black">4831.         &gt;&gt;&gt; c.next_plus(Decimal('-Infinity'))</font>
<font color="black">4832.         Decimal('-9.99999999E+999')</font>
<font color="black">4833.         &gt;&gt;&gt; c.next_plus(1)</font>
<font color="black">4834.         Decimal('1.00000001')</font>
<font color="black">4835.         &quot;&quot;&quot;</font>
<font color="red">4836.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4837.         return a.next_plus(context=self)</font>
<font color="black">4838. </font>
<font color="green">4839.     def next_toward(self, a, b):</font>
<font color="black">4840.         &quot;&quot;&quot;Returns the number closest to a, in direction towards b.</font>
<font color="black">4841. </font>
<font color="black">4842.         The result is the closest representable number from the first</font>
<font color="black">4843.         operand (but not the first operand) that is in the direction</font>
<font color="black">4844.         towards the second operand, unless the operands have the same</font>
<font color="black">4845.         value.</font>
<font color="black">4846. </font>
<font color="black">4847.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4848.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4849.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4850.         &gt;&gt;&gt; c.next_toward(Decimal('1'), Decimal('2'))</font>
<font color="black">4851.         Decimal('1.00000001')</font>
<font color="black">4852.         &gt;&gt;&gt; c.next_toward(Decimal('-1E-1007'), Decimal('1'))</font>
<font color="black">4853.         Decimal('-0E-1007')</font>
<font color="black">4854.         &gt;&gt;&gt; c.next_toward(Decimal('-1.00000003'), Decimal('0'))</font>
<font color="black">4855.         Decimal('-1.00000002')</font>
<font color="black">4856.         &gt;&gt;&gt; c.next_toward(Decimal('1'), Decimal('0'))</font>
<font color="black">4857.         Decimal('0.999999999')</font>
<font color="black">4858.         &gt;&gt;&gt; c.next_toward(Decimal('1E-1007'), Decimal('-100'))</font>
<font color="black">4859.         Decimal('0E-1007')</font>
<font color="black">4860.         &gt;&gt;&gt; c.next_toward(Decimal('-1.00000003'), Decimal('-10'))</font>
<font color="black">4861.         Decimal('-1.00000004')</font>
<font color="black">4862.         &gt;&gt;&gt; c.next_toward(Decimal('0.00'), Decimal('-0.0000'))</font>
<font color="black">4863.         Decimal('-0.00')</font>
<font color="black">4864.         &gt;&gt;&gt; c.next_toward(0, 1)</font>
<font color="black">4865.         Decimal('1E-1007')</font>
<font color="black">4866.         &gt;&gt;&gt; c.next_toward(Decimal(0), 1)</font>
<font color="black">4867.         Decimal('1E-1007')</font>
<font color="black">4868.         &gt;&gt;&gt; c.next_toward(0, Decimal(1))</font>
<font color="black">4869.         Decimal('1E-1007')</font>
<font color="black">4870.         &quot;&quot;&quot;</font>
<font color="red">4871.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4872.         return a.next_toward(b, context=self)</font>
<font color="black">4873. </font>
<font color="green">4874.     def normalize(self, a):</font>
<font color="black">4875.         &quot;&quot;&quot;normalize reduces an operand to its simplest form.</font>
<font color="black">4876. </font>
<font color="black">4877.         Essentially a plus operation with all trailing zeros removed from the</font>
<font color="black">4878.         result.</font>
<font color="black">4879. </font>
<font color="black">4880.         &gt;&gt;&gt; ExtendedContext.normalize(Decimal('2.1'))</font>
<font color="black">4881.         Decimal('2.1')</font>
<font color="black">4882.         &gt;&gt;&gt; ExtendedContext.normalize(Decimal('-2.0'))</font>
<font color="black">4883.         Decimal('-2')</font>
<font color="black">4884.         &gt;&gt;&gt; ExtendedContext.normalize(Decimal('1.200'))</font>
<font color="black">4885.         Decimal('1.2')</font>
<font color="black">4886.         &gt;&gt;&gt; ExtendedContext.normalize(Decimal('-120'))</font>
<font color="black">4887.         Decimal('-1.2E+2')</font>
<font color="black">4888.         &gt;&gt;&gt; ExtendedContext.normalize(Decimal('120.00'))</font>
<font color="black">4889.         Decimal('1.2E+2')</font>
<font color="black">4890.         &gt;&gt;&gt; ExtendedContext.normalize(Decimal('0.00'))</font>
<font color="black">4891.         Decimal('0')</font>
<font color="black">4892.         &gt;&gt;&gt; ExtendedContext.normalize(6)</font>
<font color="black">4893.         Decimal('6')</font>
<font color="black">4894.         &quot;&quot;&quot;</font>
<font color="red">4895.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4896.         return a.normalize(context=self)</font>
<font color="black">4897. </font>
<font color="green">4898.     def number_class(self, a):</font>
<font color="black">4899.         &quot;&quot;&quot;Returns an indication of the class of the operand.</font>
<font color="black">4900. </font>
<font color="black">4901.         The class is one of the following strings:</font>
<font color="black">4902.           -sNaN</font>
<font color="black">4903.           -NaN</font>
<font color="black">4904.           -Infinity</font>
<font color="black">4905.           -Normal</font>
<font color="black">4906.           -Subnormal</font>
<font color="black">4907.           -Zero</font>
<font color="black">4908.           +Zero</font>
<font color="black">4909.           +Subnormal</font>
<font color="black">4910.           +Normal</font>
<font color="black">4911.           +Infinity</font>
<font color="black">4912. </font>
<font color="black">4913.         &gt;&gt;&gt; c = Context(ExtendedContext)</font>
<font color="black">4914.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4915.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4916.         &gt;&gt;&gt; c.number_class(Decimal('Infinity'))</font>
<font color="black">4917.         '+Infinity'</font>
<font color="black">4918.         &gt;&gt;&gt; c.number_class(Decimal('1E-10'))</font>
<font color="black">4919.         '+Normal'</font>
<font color="black">4920.         &gt;&gt;&gt; c.number_class(Decimal('2.50'))</font>
<font color="black">4921.         '+Normal'</font>
<font color="black">4922.         &gt;&gt;&gt; c.number_class(Decimal('0.1E-999'))</font>
<font color="black">4923.         '+Subnormal'</font>
<font color="black">4924.         &gt;&gt;&gt; c.number_class(Decimal('0'))</font>
<font color="black">4925.         '+Zero'</font>
<font color="black">4926.         &gt;&gt;&gt; c.number_class(Decimal('-0'))</font>
<font color="black">4927.         '-Zero'</font>
<font color="black">4928.         &gt;&gt;&gt; c.number_class(Decimal('-0.1E-999'))</font>
<font color="black">4929.         '-Subnormal'</font>
<font color="black">4930.         &gt;&gt;&gt; c.number_class(Decimal('-1E-10'))</font>
<font color="black">4931.         '-Normal'</font>
<font color="black">4932.         &gt;&gt;&gt; c.number_class(Decimal('-2.50'))</font>
<font color="black">4933.         '-Normal'</font>
<font color="black">4934.         &gt;&gt;&gt; c.number_class(Decimal('-Infinity'))</font>
<font color="black">4935.         '-Infinity'</font>
<font color="black">4936.         &gt;&gt;&gt; c.number_class(Decimal('NaN'))</font>
<font color="black">4937.         'NaN'</font>
<font color="black">4938.         &gt;&gt;&gt; c.number_class(Decimal('-NaN'))</font>
<font color="black">4939.         'NaN'</font>
<font color="black">4940.         &gt;&gt;&gt; c.number_class(Decimal('sNaN'))</font>
<font color="black">4941.         'sNaN'</font>
<font color="black">4942.         &gt;&gt;&gt; c.number_class(123)</font>
<font color="black">4943.         '+Normal'</font>
<font color="black">4944.         &quot;&quot;&quot;</font>
<font color="red">4945.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4946.         return a.number_class(context=self)</font>
<font color="black">4947. </font>
<font color="green">4948.     def plus(self, a):</font>
<font color="black">4949.         &quot;&quot;&quot;Plus corresponds to unary prefix plus in Python.</font>
<font color="black">4950. </font>
<font color="black">4951.         The operation is evaluated using the same rules as add; the</font>
<font color="black">4952.         operation plus(a) is calculated as add('0', a) where the '0'</font>
<font color="black">4953.         has the same exponent as the operand.</font>
<font color="black">4954. </font>
<font color="black">4955.         &gt;&gt;&gt; ExtendedContext.plus(Decimal('1.3'))</font>
<font color="black">4956.         Decimal('1.3')</font>
<font color="black">4957.         &gt;&gt;&gt; ExtendedContext.plus(Decimal('-1.3'))</font>
<font color="black">4958.         Decimal('-1.3')</font>
<font color="black">4959.         &gt;&gt;&gt; ExtendedContext.plus(-1)</font>
<font color="black">4960.         Decimal('-1')</font>
<font color="black">4961.         &quot;&quot;&quot;</font>
<font color="red">4962.         a = _convert_other(a, raiseit=True)</font>
<font color="red">4963.         return a.__pos__(context=self)</font>
<font color="black">4964. </font>
<font color="green">4965.     def power(self, a, b, modulo=None):</font>
<font color="black">4966.         &quot;&quot;&quot;Raises a to the power of b, to modulo if given.</font>
<font color="black">4967. </font>
<font color="black">4968.         With two arguments, compute a**b.  If a is negative then b</font>
<font color="black">4969.         must be integral.  The result will be inexact unless b is</font>
<font color="black">4970.         integral and the result is finite and can be expressed exactly</font>
<font color="black">4971.         in 'precision' digits.</font>
<font color="black">4972. </font>
<font color="black">4973.         With three arguments, compute (a**b) % modulo.  For the</font>
<font color="black">4974.         three argument form, the following restrictions on the</font>
<font color="black">4975.         arguments hold:</font>
<font color="black">4976. </font>
<font color="black">4977.          - all three arguments must be integral</font>
<font color="black">4978.          - b must be nonnegative</font>
<font color="black">4979.          - at least one of a or b must be nonzero</font>
<font color="black">4980.          - modulo must be nonzero and have at most 'precision' digits</font>
<font color="black">4981. </font>
<font color="black">4982.         The result of pow(a, b, modulo) is identical to the result</font>
<font color="black">4983.         that would be obtained by computing (a**b) % modulo with</font>
<font color="black">4984.         unbounded precision, but is computed more efficiently.  It is</font>
<font color="black">4985.         always exact.</font>
<font color="black">4986. </font>
<font color="black">4987.         &gt;&gt;&gt; c = ExtendedContext.copy()</font>
<font color="black">4988.         &gt;&gt;&gt; c.Emin = -999</font>
<font color="black">4989.         &gt;&gt;&gt; c.Emax = 999</font>
<font color="black">4990.         &gt;&gt;&gt; c.power(Decimal('2'), Decimal('3'))</font>
<font color="black">4991.         Decimal('8')</font>
<font color="black">4992.         &gt;&gt;&gt; c.power(Decimal('-2'), Decimal('3'))</font>
<font color="black">4993.         Decimal('-8')</font>
<font color="black">4994.         &gt;&gt;&gt; c.power(Decimal('2'), Decimal('-3'))</font>
<font color="black">4995.         Decimal('0.125')</font>
<font color="black">4996.         &gt;&gt;&gt; c.power(Decimal('1.7'), Decimal('8'))</font>
<font color="black">4997.         Decimal('69.7575744')</font>
<font color="black">4998.         &gt;&gt;&gt; c.power(Decimal('10'), Decimal('0.301029996'))</font>
<font color="black">4999.         Decimal('2.00000000')</font>
<font color="black">5000.         &gt;&gt;&gt; c.power(Decimal('Infinity'), Decimal('-1'))</font>
<font color="black">5001.         Decimal('0')</font>
<font color="black">5002.         &gt;&gt;&gt; c.power(Decimal('Infinity'), Decimal('0'))</font>
<font color="black">5003.         Decimal('1')</font>
<font color="black">5004.         &gt;&gt;&gt; c.power(Decimal('Infinity'), Decimal('1'))</font>
<font color="black">5005.         Decimal('Infinity')</font>
<font color="black">5006.         &gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('-1'))</font>
<font color="black">5007.         Decimal('-0')</font>
<font color="black">5008.         &gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('0'))</font>
<font color="black">5009.         Decimal('1')</font>
<font color="black">5010.         &gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('1'))</font>
<font color="black">5011.         Decimal('-Infinity')</font>
<font color="black">5012.         &gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('2'))</font>
<font color="black">5013.         Decimal('Infinity')</font>
<font color="black">5014.         &gt;&gt;&gt; c.power(Decimal('0'), Decimal('0'))</font>
<font color="black">5015.         Decimal('NaN')</font>
<font color="black">5016. </font>
<font color="black">5017.         &gt;&gt;&gt; c.power(Decimal('3'), Decimal('7'), Decimal('16'))</font>
<font color="black">5018.         Decimal('11')</font>
<font color="black">5019.         &gt;&gt;&gt; c.power(Decimal('-3'), Decimal('7'), Decimal('16'))</font>
<font color="black">5020.         Decimal('-11')</font>
<font color="black">5021.         &gt;&gt;&gt; c.power(Decimal('-3'), Decimal('8'), Decimal('16'))</font>
<font color="black">5022.         Decimal('1')</font>
<font color="black">5023.         &gt;&gt;&gt; c.power(Decimal('3'), Decimal('7'), Decimal('-16'))</font>
<font color="black">5024.         Decimal('11')</font>
<font color="black">5025.         &gt;&gt;&gt; c.power(Decimal('23E12345'), Decimal('67E189'), Decimal('123456789'))</font>
<font color="black">5026.         Decimal('11729830')</font>
<font color="black">5027.         &gt;&gt;&gt; c.power(Decimal('-0'), Decimal('17'), Decimal('1729'))</font>
<font color="black">5028.         Decimal('-0')</font>
<font color="black">5029.         &gt;&gt;&gt; c.power(Decimal('-23'), Decimal('0'), Decimal('65537'))</font>
<font color="black">5030.         Decimal('1')</font>
<font color="black">5031.         &gt;&gt;&gt; ExtendedContext.power(7, 7)</font>
<font color="black">5032.         Decimal('823543')</font>
<font color="black">5033.         &gt;&gt;&gt; ExtendedContext.power(Decimal(7), 7)</font>
<font color="black">5034.         Decimal('823543')</font>
<font color="black">5035.         &gt;&gt;&gt; ExtendedContext.power(7, Decimal(7), 2)</font>
<font color="black">5036.         Decimal('1')</font>
<font color="black">5037.         &quot;&quot;&quot;</font>
<font color="red">5038.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5039.         r = a.__pow__(b, modulo, context=self)</font>
<font color="red">5040.         if r is NotImplemented:</font>
<font color="red">5041.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">5042.         else:</font>
<font color="red">5043.             return r</font>
<font color="black">5044. </font>
<font color="green">5045.     def quantize(self, a, b):</font>
<font color="black">5046.         &quot;&quot;&quot;Returns a value equal to 'a' (rounded), having the exponent of 'b'.</font>
<font color="black">5047. </font>
<font color="black">5048.         The coefficient of the result is derived from that of the left-hand</font>
<font color="black">5049.         operand.  It may be rounded using the current rounding setting (if the</font>
<font color="black">5050.         exponent is being increased), multiplied by a positive power of ten (if</font>
<font color="black">5051.         the exponent is being decreased), or is unchanged (if the exponent is</font>
<font color="black">5052.         already equal to that of the right-hand operand).</font>
<font color="black">5053. </font>
<font color="black">5054.         Unlike other operations, if the length of the coefficient after the</font>
<font color="black">5055.         quantize operation would be greater than precision then an Invalid</font>
<font color="black">5056.         operation condition is raised.  This guarantees that, unless there is</font>
<font color="black">5057.         an error condition, the exponent of the result of a quantize is always</font>
<font color="black">5058.         equal to that of the right-hand operand.</font>
<font color="black">5059. </font>
<font color="black">5060.         Also unlike other operations, quantize will never raise Underflow, even</font>
<font color="black">5061.         if the result is subnormal and inexact.</font>
<font color="black">5062. </font>
<font color="black">5063.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('0.001'))</font>
<font color="black">5064.         Decimal('2.170')</font>
<font color="black">5065.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('0.01'))</font>
<font color="black">5066.         Decimal('2.17')</font>
<font color="black">5067.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('0.1'))</font>
<font color="black">5068.         Decimal('2.2')</font>
<font color="black">5069.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+0'))</font>
<font color="black">5070.         Decimal('2')</font>
<font color="black">5071.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+1'))</font>
<font color="black">5072.         Decimal('0E+1')</font>
<font color="black">5073.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('-Inf'), Decimal('Infinity'))</font>
<font color="black">5074.         Decimal('-Infinity')</font>
<font color="black">5075.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('2'), Decimal('Infinity'))</font>
<font color="black">5076.         Decimal('NaN')</font>
<font color="black">5077.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('-0.1'), Decimal('1'))</font>
<font color="black">5078.         Decimal('-0')</font>
<font color="black">5079.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('-0'), Decimal('1e+5'))</font>
<font color="black">5080.         Decimal('-0E+5')</font>
<font color="black">5081.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('+35236450.6'), Decimal('1e-2'))</font>
<font color="black">5082.         Decimal('NaN')</font>
<font color="black">5083.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('-35236450.6'), Decimal('1e-2'))</font>
<font color="black">5084.         Decimal('NaN')</font>
<font color="black">5085.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e-1'))</font>
<font color="black">5086.         Decimal('217.0')</font>
<font color="black">5087.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e-0'))</font>
<font color="black">5088.         Decimal('217')</font>
<font color="black">5089.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e+1'))</font>
<font color="black">5090.         Decimal('2.2E+2')</font>
<font color="black">5091.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e+2'))</font>
<font color="black">5092.         Decimal('2E+2')</font>
<font color="black">5093.         &gt;&gt;&gt; ExtendedContext.quantize(1, 2)</font>
<font color="black">5094.         Decimal('1')</font>
<font color="black">5095.         &gt;&gt;&gt; ExtendedContext.quantize(Decimal(1), 2)</font>
<font color="black">5096.         Decimal('1')</font>
<font color="black">5097.         &gt;&gt;&gt; ExtendedContext.quantize(1, Decimal(2))</font>
<font color="black">5098.         Decimal('1')</font>
<font color="black">5099.         &quot;&quot;&quot;</font>
<font color="red">5100.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5101.         return a.quantize(b, context=self)</font>
<font color="black">5102. </font>
<font color="green">5103.     def radix(self):</font>
<font color="black">5104.         &quot;&quot;&quot;Just returns 10, as this is Decimal, :)</font>
<font color="black">5105. </font>
<font color="black">5106.         &gt;&gt;&gt; ExtendedContext.radix()</font>
<font color="black">5107.         Decimal('10')</font>
<font color="black">5108.         &quot;&quot;&quot;</font>
<font color="red">5109.         return Decimal(10)</font>
<font color="black">5110. </font>
<font color="green">5111.     def remainder(self, a, b):</font>
<font color="black">5112.         &quot;&quot;&quot;Returns the remainder from integer division.</font>
<font color="black">5113. </font>
<font color="black">5114.         The result is the residue of the dividend after the operation of</font>
<font color="black">5115.         calculating integer division as described for divide-integer, rounded</font>
<font color="black">5116.         to precision digits if necessary.  The sign of the result, if</font>
<font color="black">5117.         non-zero, is the same as that of the original dividend.</font>
<font color="black">5118. </font>
<font color="black">5119.         This operation will fail under the same conditions as integer division</font>
<font color="black">5120.         (that is, if integer division on the same two operands would fail, the</font>
<font color="black">5121.         remainder cannot be calculated).</font>
<font color="black">5122. </font>
<font color="black">5123.         &gt;&gt;&gt; ExtendedContext.remainder(Decimal('2.1'), Decimal('3'))</font>
<font color="black">5124.         Decimal('2.1')</font>
<font color="black">5125.         &gt;&gt;&gt; ExtendedContext.remainder(Decimal('10'), Decimal('3'))</font>
<font color="black">5126.         Decimal('1')</font>
<font color="black">5127.         &gt;&gt;&gt; ExtendedContext.remainder(Decimal('-10'), Decimal('3'))</font>
<font color="black">5128.         Decimal('-1')</font>
<font color="black">5129.         &gt;&gt;&gt; ExtendedContext.remainder(Decimal('10.2'), Decimal('1'))</font>
<font color="black">5130.         Decimal('0.2')</font>
<font color="black">5131.         &gt;&gt;&gt; ExtendedContext.remainder(Decimal('10'), Decimal('0.3'))</font>
<font color="black">5132.         Decimal('0.1')</font>
<font color="black">5133.         &gt;&gt;&gt; ExtendedContext.remainder(Decimal('3.6'), Decimal('1.3'))</font>
<font color="black">5134.         Decimal('1.0')</font>
<font color="black">5135.         &gt;&gt;&gt; ExtendedContext.remainder(22, 6)</font>
<font color="black">5136.         Decimal('4')</font>
<font color="black">5137.         &gt;&gt;&gt; ExtendedContext.remainder(Decimal(22), 6)</font>
<font color="black">5138.         Decimal('4')</font>
<font color="black">5139.         &gt;&gt;&gt; ExtendedContext.remainder(22, Decimal(6))</font>
<font color="black">5140.         Decimal('4')</font>
<font color="black">5141.         &quot;&quot;&quot;</font>
<font color="red">5142.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5143.         r = a.__mod__(b, context=self)</font>
<font color="red">5144.         if r is NotImplemented:</font>
<font color="red">5145.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">5146.         else:</font>
<font color="red">5147.             return r</font>
<font color="black">5148. </font>
<font color="green">5149.     def remainder_near(self, a, b):</font>
<font color="black">5150.         &quot;&quot;&quot;Returns to be &quot;a - b * n&quot;, where n is the integer nearest the exact</font>
<font color="black">5151.         value of &quot;x / b&quot; (if two integers are equally near then the even one</font>
<font color="black">5152.         is chosen).  If the result is equal to 0 then its sign will be the</font>
<font color="black">5153.         sign of a.</font>
<font color="black">5154. </font>
<font color="black">5155.         This operation will fail under the same conditions as integer division</font>
<font color="black">5156.         (that is, if integer division on the same two operands would fail, the</font>
<font color="black">5157.         remainder cannot be calculated).</font>
<font color="black">5158. </font>
<font color="black">5159.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('2.1'), Decimal('3'))</font>
<font color="black">5160.         Decimal('-0.9')</font>
<font color="black">5161.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10'), Decimal('6'))</font>
<font color="black">5162.         Decimal('-2')</font>
<font color="black">5163.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10'), Decimal('3'))</font>
<font color="black">5164.         Decimal('1')</font>
<font color="black">5165.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('-10'), Decimal('3'))</font>
<font color="black">5166.         Decimal('-1')</font>
<font color="black">5167.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10.2'), Decimal('1'))</font>
<font color="black">5168.         Decimal('0.2')</font>
<font color="black">5169.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10'), Decimal('0.3'))</font>
<font color="black">5170.         Decimal('0.1')</font>
<font color="black">5171.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('3.6'), Decimal('1.3'))</font>
<font color="black">5172.         Decimal('-0.3')</font>
<font color="black">5173.         &gt;&gt;&gt; ExtendedContext.remainder_near(3, 11)</font>
<font color="black">5174.         Decimal('3')</font>
<font color="black">5175.         &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal(3), 11)</font>
<font color="black">5176.         Decimal('3')</font>
<font color="black">5177.         &gt;&gt;&gt; ExtendedContext.remainder_near(3, Decimal(11))</font>
<font color="black">5178.         Decimal('3')</font>
<font color="black">5179.         &quot;&quot;&quot;</font>
<font color="red">5180.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5181.         return a.remainder_near(b, context=self)</font>
<font color="black">5182. </font>
<font color="green">5183.     def rotate(self, a, b):</font>
<font color="black">5184.         &quot;&quot;&quot;Returns a rotated copy of a, b times.</font>
<font color="black">5185. </font>
<font color="black">5186.         The coefficient of the result is a rotated copy of the digits in</font>
<font color="black">5187.         the coefficient of the first operand.  The number of places of</font>
<font color="black">5188.         rotation is taken from the absolute value of the second operand,</font>
<font color="black">5189.         with the rotation being to the left if the second operand is</font>
<font color="black">5190.         positive or to the right otherwise.</font>
<font color="black">5191. </font>
<font color="black">5192.         &gt;&gt;&gt; ExtendedContext.rotate(Decimal('34'), Decimal('8'))</font>
<font color="black">5193.         Decimal('400000003')</font>
<font color="black">5194.         &gt;&gt;&gt; ExtendedContext.rotate(Decimal('12'), Decimal('9'))</font>
<font color="black">5195.         Decimal('12')</font>
<font color="black">5196.         &gt;&gt;&gt; ExtendedContext.rotate(Decimal('123456789'), Decimal('-2'))</font>
<font color="black">5197.         Decimal('891234567')</font>
<font color="black">5198.         &gt;&gt;&gt; ExtendedContext.rotate(Decimal('123456789'), Decimal('0'))</font>
<font color="black">5199.         Decimal('123456789')</font>
<font color="black">5200.         &gt;&gt;&gt; ExtendedContext.rotate(Decimal('123456789'), Decimal('+2'))</font>
<font color="black">5201.         Decimal('345678912')</font>
<font color="black">5202.         &gt;&gt;&gt; ExtendedContext.rotate(1333333, 1)</font>
<font color="black">5203.         Decimal('13333330')</font>
<font color="black">5204.         &gt;&gt;&gt; ExtendedContext.rotate(Decimal(1333333), 1)</font>
<font color="black">5205.         Decimal('13333330')</font>
<font color="black">5206.         &gt;&gt;&gt; ExtendedContext.rotate(1333333, Decimal(1))</font>
<font color="black">5207.         Decimal('13333330')</font>
<font color="black">5208.         &quot;&quot;&quot;</font>
<font color="red">5209.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5210.         return a.rotate(b, context=self)</font>
<font color="black">5211. </font>
<font color="green">5212.     def same_quantum(self, a, b):</font>
<font color="black">5213.         &quot;&quot;&quot;Returns True if the two operands have the same exponent.</font>
<font color="black">5214. </font>
<font color="black">5215.         The result is never affected by either the sign or the coefficient of</font>
<font color="black">5216.         either operand.</font>
<font color="black">5217. </font>
<font color="black">5218.         &gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.001'))</font>
<font color="black">5219.         False</font>
<font color="black">5220.         &gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.01'))</font>
<font color="black">5221.         True</font>
<font color="black">5222.         &gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('2.17'), Decimal('1'))</font>
<font color="black">5223.         False</font>
<font color="black">5224.         &gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('Inf'), Decimal('-Inf'))</font>
<font color="black">5225.         True</font>
<font color="black">5226.         &gt;&gt;&gt; ExtendedContext.same_quantum(10000, -1)</font>
<font color="black">5227.         True</font>
<font color="black">5228.         &gt;&gt;&gt; ExtendedContext.same_quantum(Decimal(10000), -1)</font>
<font color="black">5229.         True</font>
<font color="black">5230.         &gt;&gt;&gt; ExtendedContext.same_quantum(10000, Decimal(-1))</font>
<font color="black">5231.         True</font>
<font color="black">5232.         &quot;&quot;&quot;</font>
<font color="red">5233.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5234.         return a.same_quantum(b)</font>
<font color="black">5235. </font>
<font color="green">5236.     def scaleb (self, a, b):</font>
<font color="black">5237.         &quot;&quot;&quot;Returns the first operand after adding the second value its exp.</font>
<font color="black">5238. </font>
<font color="black">5239.         &gt;&gt;&gt; ExtendedContext.scaleb(Decimal('7.50'), Decimal('-2'))</font>
<font color="black">5240.         Decimal('0.0750')</font>
<font color="black">5241.         &gt;&gt;&gt; ExtendedContext.scaleb(Decimal('7.50'), Decimal('0'))</font>
<font color="black">5242.         Decimal('7.50')</font>
<font color="black">5243.         &gt;&gt;&gt; ExtendedContext.scaleb(Decimal('7.50'), Decimal('3'))</font>
<font color="black">5244.         Decimal('7.50E+3')</font>
<font color="black">5245.         &gt;&gt;&gt; ExtendedContext.scaleb(1, 4)</font>
<font color="black">5246.         Decimal('1E+4')</font>
<font color="black">5247.         &gt;&gt;&gt; ExtendedContext.scaleb(Decimal(1), 4)</font>
<font color="black">5248.         Decimal('1E+4')</font>
<font color="black">5249.         &gt;&gt;&gt; ExtendedContext.scaleb(1, Decimal(4))</font>
<font color="black">5250.         Decimal('1E+4')</font>
<font color="black">5251.         &quot;&quot;&quot;</font>
<font color="red">5252.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5253.         return a.scaleb(b, context=self)</font>
<font color="black">5254. </font>
<font color="green">5255.     def shift(self, a, b):</font>
<font color="black">5256.         &quot;&quot;&quot;Returns a shifted copy of a, b times.</font>
<font color="black">5257. </font>
<font color="black">5258.         The coefficient of the result is a shifted copy of the digits</font>
<font color="black">5259.         in the coefficient of the first operand.  The number of places</font>
<font color="black">5260.         to shift is taken from the absolute value of the second operand,</font>
<font color="black">5261.         with the shift being to the left if the second operand is</font>
<font color="black">5262.         positive or to the right otherwise.  Digits shifted into the</font>
<font color="black">5263.         coefficient are zeros.</font>
<font color="black">5264. </font>
<font color="black">5265.         &gt;&gt;&gt; ExtendedContext.shift(Decimal('34'), Decimal('8'))</font>
<font color="black">5266.         Decimal('400000000')</font>
<font color="black">5267.         &gt;&gt;&gt; ExtendedContext.shift(Decimal('12'), Decimal('9'))</font>
<font color="black">5268.         Decimal('0')</font>
<font color="black">5269.         &gt;&gt;&gt; ExtendedContext.shift(Decimal('123456789'), Decimal('-2'))</font>
<font color="black">5270.         Decimal('1234567')</font>
<font color="black">5271.         &gt;&gt;&gt; ExtendedContext.shift(Decimal('123456789'), Decimal('0'))</font>
<font color="black">5272.         Decimal('123456789')</font>
<font color="black">5273.         &gt;&gt;&gt; ExtendedContext.shift(Decimal('123456789'), Decimal('+2'))</font>
<font color="black">5274.         Decimal('345678900')</font>
<font color="black">5275.         &gt;&gt;&gt; ExtendedContext.shift(88888888, 2)</font>
<font color="black">5276.         Decimal('888888800')</font>
<font color="black">5277.         &gt;&gt;&gt; ExtendedContext.shift(Decimal(88888888), 2)</font>
<font color="black">5278.         Decimal('888888800')</font>
<font color="black">5279.         &gt;&gt;&gt; ExtendedContext.shift(88888888, Decimal(2))</font>
<font color="black">5280.         Decimal('888888800')</font>
<font color="black">5281.         &quot;&quot;&quot;</font>
<font color="red">5282.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5283.         return a.shift(b, context=self)</font>
<font color="black">5284. </font>
<font color="green">5285.     def sqrt(self, a):</font>
<font color="black">5286.         &quot;&quot;&quot;Square root of a non-negative number to context precision.</font>
<font color="black">5287. </font>
<font color="black">5288.         If the result must be inexact, it is rounded using the round-half-even</font>
<font color="black">5289.         algorithm.</font>
<font color="black">5290. </font>
<font color="black">5291.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('0'))</font>
<font color="black">5292.         Decimal('0')</font>
<font color="black">5293.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('-0'))</font>
<font color="black">5294.         Decimal('-0')</font>
<font color="black">5295.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('0.39'))</font>
<font color="black">5296.         Decimal('0.624499800')</font>
<font color="black">5297.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('100'))</font>
<font color="black">5298.         Decimal('10')</font>
<font color="black">5299.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('1'))</font>
<font color="black">5300.         Decimal('1')</font>
<font color="black">5301.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('1.0'))</font>
<font color="black">5302.         Decimal('1.0')</font>
<font color="black">5303.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('1.00'))</font>
<font color="black">5304.         Decimal('1.0')</font>
<font color="black">5305.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('7'))</font>
<font color="black">5306.         Decimal('2.64575131')</font>
<font color="black">5307.         &gt;&gt;&gt; ExtendedContext.sqrt(Decimal('10'))</font>
<font color="black">5308.         Decimal('3.16227766')</font>
<font color="black">5309.         &gt;&gt;&gt; ExtendedContext.sqrt(2)</font>
<font color="black">5310.         Decimal('1.41421356')</font>
<font color="black">5311.         &gt;&gt;&gt; ExtendedContext.prec</font>
<font color="black">5312.         9</font>
<font color="black">5313.         &quot;&quot;&quot;</font>
<font color="red">5314.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5315.         return a.sqrt(context=self)</font>
<font color="black">5316. </font>
<font color="green">5317.     def subtract(self, a, b):</font>
<font color="black">5318.         &quot;&quot;&quot;Return the difference between the two operands.</font>
<font color="black">5319. </font>
<font color="black">5320.         &gt;&gt;&gt; ExtendedContext.subtract(Decimal('1.3'), Decimal('1.07'))</font>
<font color="black">5321.         Decimal('0.23')</font>
<font color="black">5322.         &gt;&gt;&gt; ExtendedContext.subtract(Decimal('1.3'), Decimal('1.30'))</font>
<font color="black">5323.         Decimal('0.00')</font>
<font color="black">5324.         &gt;&gt;&gt; ExtendedContext.subtract(Decimal('1.3'), Decimal('2.07'))</font>
<font color="black">5325.         Decimal('-0.77')</font>
<font color="black">5326.         &gt;&gt;&gt; ExtendedContext.subtract(8, 5)</font>
<font color="black">5327.         Decimal('3')</font>
<font color="black">5328.         &gt;&gt;&gt; ExtendedContext.subtract(Decimal(8), 5)</font>
<font color="black">5329.         Decimal('3')</font>
<font color="black">5330.         &gt;&gt;&gt; ExtendedContext.subtract(8, Decimal(5))</font>
<font color="black">5331.         Decimal('3')</font>
<font color="black">5332.         &quot;&quot;&quot;</font>
<font color="red">5333.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5334.         r = a.__sub__(b, context=self)</font>
<font color="red">5335.         if r is NotImplemented:</font>
<font color="red">5336.             raise TypeError(&quot;Unable to convert %s to Decimal&quot; % b)</font>
<font color="black">5337.         else:</font>
<font color="red">5338.             return r</font>
<font color="black">5339. </font>
<font color="green">5340.     def to_eng_string(self, a):</font>
<font color="black">5341.         &quot;&quot;&quot;Convert to a string, using engineering notation if an exponent is needed.</font>
<font color="black">5342. </font>
<font color="black">5343.         Engineering notation has an exponent which is a multiple of 3.  This</font>
<font color="black">5344.         can leave up to 3 digits to the left of the decimal place and may</font>
<font color="black">5345.         require the addition of either one or two trailing zeros.</font>
<font color="black">5346. </font>
<font color="black">5347.         The operation is not affected by the context.</font>
<font color="black">5348. </font>
<font color="black">5349.         &gt;&gt;&gt; ExtendedContext.to_eng_string(Decimal('123E+1'))</font>
<font color="black">5350.         '1.23E+3'</font>
<font color="black">5351.         &gt;&gt;&gt; ExtendedContext.to_eng_string(Decimal('123E+3'))</font>
<font color="black">5352.         '123E+3'</font>
<font color="black">5353.         &gt;&gt;&gt; ExtendedContext.to_eng_string(Decimal('123E-10'))</font>
<font color="black">5354.         '12.3E-9'</font>
<font color="black">5355.         &gt;&gt;&gt; ExtendedContext.to_eng_string(Decimal('-123E-12'))</font>
<font color="black">5356.         '-123E-12'</font>
<font color="black">5357.         &gt;&gt;&gt; ExtendedContext.to_eng_string(Decimal('7E-7'))</font>
<font color="black">5358.         '700E-9'</font>
<font color="black">5359.         &gt;&gt;&gt; ExtendedContext.to_eng_string(Decimal('7E+1'))</font>
<font color="black">5360.         '70'</font>
<font color="black">5361.         &gt;&gt;&gt; ExtendedContext.to_eng_string(Decimal('0E+1'))</font>
<font color="black">5362.         '0.00E+3'</font>
<font color="black">5363. </font>
<font color="black">5364.         &quot;&quot;&quot;</font>
<font color="red">5365.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5366.         return a.to_eng_string(context=self)</font>
<font color="black">5367. </font>
<font color="green">5368.     def to_sci_string(self, a):</font>
<font color="black">5369.         &quot;&quot;&quot;Converts a number to a string, using scientific notation.</font>
<font color="black">5370. </font>
<font color="black">5371.         The operation is not affected by the context.</font>
<font color="black">5372.         &quot;&quot;&quot;</font>
<font color="red">5373.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5374.         return a.__str__(context=self)</font>
<font color="black">5375. </font>
<font color="green">5376.     def to_integral_exact(self, a):</font>
<font color="black">5377.         &quot;&quot;&quot;Rounds to an integer.</font>
<font color="black">5378. </font>
<font color="black">5379.         When the operand has a negative exponent, the result is the same</font>
<font color="black">5380.         as using the quantize() operation using the given operand as the</font>
<font color="black">5381.         left-hand-operand, 1E+0 as the right-hand-operand, and the precision</font>
<font color="black">5382.         of the operand as the precision setting; Inexact and Rounded flags</font>
<font color="black">5383.         are allowed in this operation.  The rounding mode is taken from the</font>
<font color="black">5384.         context.</font>
<font color="black">5385. </font>
<font color="black">5386.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('2.1'))</font>
<font color="black">5387.         Decimal('2')</font>
<font color="black">5388.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('100'))</font>
<font color="black">5389.         Decimal('100')</font>
<font color="black">5390.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('100.0'))</font>
<font color="black">5391.         Decimal('100')</font>
<font color="black">5392.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('101.5'))</font>
<font color="black">5393.         Decimal('102')</font>
<font color="black">5394.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('-101.5'))</font>
<font color="black">5395.         Decimal('-102')</font>
<font color="black">5396.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('10E+5'))</font>
<font color="black">5397.         Decimal('1.0E+6')</font>
<font color="black">5398.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('7.89E+77'))</font>
<font color="black">5399.         Decimal('7.89E+77')</font>
<font color="black">5400.         &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('-Inf'))</font>
<font color="black">5401.         Decimal('-Infinity')</font>
<font color="black">5402.         &quot;&quot;&quot;</font>
<font color="red">5403.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5404.         return a.to_integral_exact(context=self)</font>
<font color="black">5405. </font>
<font color="green">5406.     def to_integral_value(self, a):</font>
<font color="black">5407.         &quot;&quot;&quot;Rounds to an integer.</font>
<font color="black">5408. </font>
<font color="black">5409.         When the operand has a negative exponent, the result is the same</font>
<font color="black">5410.         as using the quantize() operation using the given operand as the</font>
<font color="black">5411.         left-hand-operand, 1E+0 as the right-hand-operand, and the precision</font>
<font color="black">5412.         of the operand as the precision setting, except that no flags will</font>
<font color="black">5413.         be set.  The rounding mode is taken from the context.</font>
<font color="black">5414. </font>
<font color="black">5415.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('2.1'))</font>
<font color="black">5416.         Decimal('2')</font>
<font color="black">5417.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('100'))</font>
<font color="black">5418.         Decimal('100')</font>
<font color="black">5419.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('100.0'))</font>
<font color="black">5420.         Decimal('100')</font>
<font color="black">5421.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('101.5'))</font>
<font color="black">5422.         Decimal('102')</font>
<font color="black">5423.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('-101.5'))</font>
<font color="black">5424.         Decimal('-102')</font>
<font color="black">5425.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('10E+5'))</font>
<font color="black">5426.         Decimal('1.0E+6')</font>
<font color="black">5427.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('7.89E+77'))</font>
<font color="black">5428.         Decimal('7.89E+77')</font>
<font color="black">5429.         &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('-Inf'))</font>
<font color="black">5430.         Decimal('-Infinity')</font>
<font color="black">5431.         &quot;&quot;&quot;</font>
<font color="red">5432.         a = _convert_other(a, raiseit=True)</font>
<font color="red">5433.         return a.to_integral_value(context=self)</font>
<font color="black">5434. </font>
<font color="black">5435.     # the method name changed, but we provide also the old one, for compatibility</font>
<font color="green">5436.     to_integral = to_integral_value</font>
<font color="black">5437. </font>
<font color="green">5438. class _WorkRep(object):</font>
<font color="green">5439.     __slots__ = ('sign','int','exp')</font>
<font color="black">5440.     # sign: 0 or 1</font>
<font color="black">5441.     # int:  int or long</font>
<font color="black">5442.     # exp:  None, int, or string</font>
<font color="black">5443. </font>
<font color="green">5444.     def __init__(self, value=None):</font>
<font color="red">5445.         if value is None:</font>
<font color="red">5446.             self.sign = None</font>
<font color="red">5447.             self.int = 0</font>
<font color="red">5448.             self.exp = None</font>
<font color="red">5449.         elif isinstance(value, Decimal):</font>
<font color="red">5450.             self.sign = value._sign</font>
<font color="red">5451.             self.int = int(value._int)</font>
<font color="red">5452.             self.exp = value._exp</font>
<font color="black">5453.         else:</font>
<font color="black">5454.             # assert isinstance(value, tuple)</font>
<font color="red">5455.             self.sign = value[0]</font>
<font color="red">5456.             self.int = value[1]</font>
<font color="red">5457.             self.exp = value[2]</font>
<font color="black">5458. </font>
<font color="green">5459.     def __repr__(self):</font>
<font color="red">5460.         return &quot;(%r, %r, %r)&quot; % (self.sign, self.int, self.exp)</font>
<font color="black">5461. </font>
<font color="green">5462.     __str__ = __repr__</font>
<font color="black">5463. </font>
<font color="black">5464. </font>
<font color="black">5465. </font>
<font color="green">5466. def _normalize(op1, op2, prec = 0):</font>
<font color="black">5467.     &quot;&quot;&quot;Normalizes op1, op2 to have the same exp and length of coefficient.</font>
<font color="black">5468. </font>
<font color="black">5469.     Done during addition.</font>
<font color="black">5470.     &quot;&quot;&quot;</font>
<font color="red">5471.     if op1.exp &lt; op2.exp:</font>
<font color="red">5472.         tmp = op2</font>
<font color="red">5473.         other = op1</font>
<font color="black">5474.     else:</font>
<font color="red">5475.         tmp = op1</font>
<font color="red">5476.         other = op2</font>
<font color="black">5477. </font>
<font color="black">5478.     # Let exp = min(tmp.exp - 1, tmp.adjusted() - precision - 1).</font>
<font color="black">5479.     # Then adding 10**exp to tmp has the same effect (after rounding)</font>
<font color="black">5480.     # as adding any positive quantity smaller than 10**exp; similarly</font>
<font color="black">5481.     # for subtraction.  So if other is smaller than 10**exp we replace</font>
<font color="black">5482.     # it with 10**exp.  This avoids tmp.exp - other.exp getting too large.</font>
<font color="red">5483.     tmp_len = len(str(tmp.int))</font>
<font color="red">5484.     other_len = len(str(other.int))</font>
<font color="red">5485.     exp = tmp.exp + min(-1, tmp_len - prec - 2)</font>
<font color="red">5486.     if other_len + other.exp - 1 &lt; exp:</font>
<font color="red">5487.         other.int = 1</font>
<font color="red">5488.         other.exp = exp</font>
<font color="black">5489. </font>
<font color="red">5490.     tmp.int *= 10 ** (tmp.exp - other.exp)</font>
<font color="red">5491.     tmp.exp = other.exp</font>
<font color="red">5492.     return op1, op2</font>
<font color="black">5493. </font>
<font color="black">5494. ##### Integer arithmetic functions used by ln, log10, exp and __pow__ #####</font>
<font color="black">5495. </font>
<font color="black">5496. # This function from Tim Peters was taken from here:</font>
<font color="black">5497. # http://mail.python.org/pipermail/python-list/1999-July/007758.html</font>
<font color="black">5498. # The correction being in the function definition is for speed, and</font>
<font color="black">5499. # the whole function is not resolved with math.log because of avoiding</font>
<font color="black">5500. # the use of floats.</font>
<font color="green">5501. def _nbits(n, correction = {</font>
<font color="green">5502.         '0': 4, '1': 3, '2': 2, '3': 2,</font>
<font color="green">5503.         '4': 1, '5': 1, '6': 1, '7': 1,</font>
<font color="green">5504.         '8': 0, '9': 0, 'a': 0, 'b': 0,</font>
<font color="green">5505.         'c': 0, 'd': 0, 'e': 0, 'f': 0}):</font>
<font color="black">5506.     &quot;&quot;&quot;Number of bits in binary representation of the positive integer n,</font>
<font color="black">5507.     or 0 if n == 0.</font>
<font color="black">5508.     &quot;&quot;&quot;</font>
<font color="red">5509.     if n &lt; 0:</font>
<font color="red">5510.         raise ValueError(&quot;The argument to _nbits should be nonnegative.&quot;)</font>
<font color="red">5511.     hex_n = &quot;%x&quot; % n</font>
<font color="red">5512.     return 4*len(hex_n) - correction[hex_n[0]]</font>
<font color="black">5513. </font>
<font color="green">5514. def _decimal_lshift_exact(n, e):</font>
<font color="black">5515.     &quot;&quot;&quot; Given integers n and e, return n * 10**e if it's an integer, else None.</font>
<font color="black">5516. </font>
<font color="black">5517.     The computation is designed to avoid computing large powers of 10</font>
<font color="black">5518.     unnecessarily.</font>
<font color="black">5519. </font>
<font color="black">5520.     &gt;&gt;&gt; _decimal_lshift_exact(3, 4)</font>
<font color="black">5521.     30000</font>
<font color="black">5522.     &gt;&gt;&gt; _decimal_lshift_exact(300, -999999999)  # returns None</font>
<font color="black">5523. </font>
<font color="black">5524.     &quot;&quot;&quot;</font>
<font color="red">5525.     if n == 0:</font>
<font color="red">5526.         return 0</font>
<font color="red">5527.     elif e &gt;= 0:</font>
<font color="red">5528.         return n * 10**e</font>
<font color="black">5529.     else:</font>
<font color="black">5530.         # val_n = largest power of 10 dividing n.</font>
<font color="red">5531.         str_n = str(abs(n))</font>
<font color="red">5532.         val_n = len(str_n) - len(str_n.rstrip('0'))</font>
<font color="red">5533.         return None if val_n &lt; -e else n // 10**-e</font>
<font color="black">5534. </font>
<font color="green">5535. def _sqrt_nearest(n, a):</font>
<font color="black">5536.     &quot;&quot;&quot;Closest integer to the square root of the positive integer n.  a is</font>
<font color="black">5537.     an initial approximation to the square root.  Any positive integer</font>
<font color="black">5538.     will do for a, but the closer a is to the square root of n the</font>
<font color="black">5539.     faster convergence will be.</font>
<font color="black">5540. </font>
<font color="black">5541.     &quot;&quot;&quot;</font>
<font color="red">5542.     if n &lt;= 0 or a &lt;= 0:</font>
<font color="red">5543.         raise ValueError(&quot;Both arguments to _sqrt_nearest should be positive.&quot;)</font>
<font color="black">5544. </font>
<font color="red">5545.     b=0</font>
<font color="red">5546.     while a != b:</font>
<font color="red">5547.         b, a = a, a--n//a&gt;&gt;1</font>
<font color="red">5548.     return a</font>
<font color="black">5549. </font>
<font color="green">5550. def _rshift_nearest(x, shift):</font>
<font color="black">5551.     &quot;&quot;&quot;Given an integer x and a nonnegative integer shift, return closest</font>
<font color="black">5552.     integer to x / 2**shift; use round-to-even in case of a tie.</font>
<font color="black">5553. </font>
<font color="black">5554.     &quot;&quot;&quot;</font>
<font color="red">5555.     b, q = 1L &lt;&lt; shift, x &gt;&gt; shift</font>
<font color="red">5556.     return q + (2*(x &amp; (b-1)) + (q&amp;1) &gt; b)</font>
<font color="black">5557. </font>
<font color="green">5558. def _div_nearest(a, b):</font>
<font color="black">5559.     &quot;&quot;&quot;Closest integer to a/b, a and b positive integers; rounds to even</font>
<font color="black">5560.     in the case of a tie.</font>
<font color="black">5561. </font>
<font color="black">5562.     &quot;&quot;&quot;</font>
<font color="red">5563.     q, r = divmod(a, b)</font>
<font color="red">5564.     return q + (2*r + (q&amp;1) &gt; b)</font>
<font color="black">5565. </font>
<font color="green">5566. def _ilog(x, M, L = 8):</font>
<font color="black">5567.     &quot;&quot;&quot;Integer approximation to M*log(x/M), with absolute error boundable</font>
<font color="black">5568.     in terms only of x/M.</font>
<font color="black">5569. </font>
<font color="black">5570.     Given positive integers x and M, return an integer approximation to</font>
<font color="black">5571.     M * log(x/M).  For L = 8 and 0.1 &lt;= x/M &lt;= 10 the difference</font>
<font color="black">5572.     between the approximation and the exact result is at most 22.  For</font>
<font color="black">5573.     L = 8 and 1.0 &lt;= x/M &lt;= 10.0 the difference is at most 15.  In</font>
<font color="black">5574.     both cases these are upper bounds on the error; it will usually be</font>
<font color="black">5575.     much smaller.&quot;&quot;&quot;</font>
<font color="black">5576. </font>
<font color="black">5577.     # The basic algorithm is the following: let log1p be the function</font>
<font color="black">5578.     # log1p(x) = log(1+x).  Then log(x/M) = log1p((x-M)/M).  We use</font>
<font color="black">5579.     # the reduction</font>
<font color="black">5580.     #</font>
<font color="black">5581.     #    log1p(y) = 2*log1p(y/(1+sqrt(1+y)))</font>
<font color="black">5582.     #</font>
<font color="black">5583.     # repeatedly until the argument to log1p is small (&lt; 2**-L in</font>
<font color="black">5584.     # absolute value).  For small y we can use the Taylor series</font>
<font color="black">5585.     # expansion</font>
<font color="black">5586.     #</font>
<font color="black">5587.     #    log1p(y) ~ y - y**2/2 + y**3/3 - ... - (-y)**T/T</font>
<font color="black">5588.     #</font>
<font color="black">5589.     # truncating at T such that y**T is small enough.  The whole</font>
<font color="black">5590.     # computation is carried out in a form of fixed-point arithmetic,</font>
<font color="black">5591.     # with a real number z being represented by an integer</font>
<font color="black">5592.     # approximation to z*M.  To avoid loss of precision, the y below</font>
<font color="black">5593.     # is actually an integer approximation to 2**R*y*M, where R is the</font>
<font color="black">5594.     # number of reductions performed so far.</font>
<font color="black">5595. </font>
<font color="red">5596.     y = x-M</font>
<font color="black">5597.     # argument reduction; R = number of reductions performed</font>
<font color="red">5598.     R = 0</font>
<font color="red">5599.     while (R &lt;= L and long(abs(y)) &lt;&lt; L-R &gt;= M or</font>
<font color="red">5600.            R &gt; L and abs(y) &gt;&gt; R-L &gt;= M):</font>
<font color="red">5601.         y = _div_nearest(long(M*y) &lt;&lt; 1,</font>
<font color="red">5602.                          M + _sqrt_nearest(M*(M+_rshift_nearest(y, R)), M))</font>
<font color="red">5603.         R += 1</font>
<font color="black">5604. </font>
<font color="black">5605.     # Taylor series with T terms</font>
<font color="red">5606.     T = -int(-10*len(str(M))//(3*L))</font>
<font color="red">5607.     yshift = _rshift_nearest(y, R)</font>
<font color="red">5608.     w = _div_nearest(M, T)</font>
<font color="red">5609.     for k in xrange(T-1, 0, -1):</font>
<font color="red">5610.         w = _div_nearest(M, k) - _div_nearest(yshift*w, M)</font>
<font color="black">5611. </font>
<font color="red">5612.     return _div_nearest(w*y, M)</font>
<font color="black">5613. </font>
<font color="green">5614. def _dlog10(c, e, p):</font>
<font color="black">5615.     &quot;&quot;&quot;Given integers c, e and p with c &gt; 0, p &gt;= 0, compute an integer</font>
<font color="black">5616.     approximation to 10**p * log10(c*10**e), with an absolute error of</font>
<font color="black">5617.     at most 1.  Assumes that c*10**e is not exactly 1.&quot;&quot;&quot;</font>
<font color="black">5618. </font>
<font color="black">5619.     # increase precision by 2; compensate for this by dividing</font>
<font color="black">5620.     # final result by 100</font>
<font color="red">5621.     p += 2</font>
<font color="black">5622. </font>
<font color="black">5623.     # write c*10**e as d*10**f with either:</font>
<font color="black">5624.     #   f &gt;= 0 and 1 &lt;= d &lt;= 10, or</font>
<font color="black">5625.     #   f &lt;= 0 and 0.1 &lt;= d &lt;= 1.</font>
<font color="black">5626.     # Thus for c*10**e close to 1, f = 0</font>
<font color="red">5627.     l = len(str(c))</font>
<font color="red">5628.     f = e+l - (e+l &gt;= 1)</font>
<font color="black">5629. </font>
<font color="red">5630.     if p &gt; 0:</font>
<font color="red">5631.         M = 10**p</font>
<font color="red">5632.         k = e+p-f</font>
<font color="red">5633.         if k &gt;= 0:</font>
<font color="red">5634.             c *= 10**k</font>
<font color="black">5635.         else:</font>
<font color="red">5636.             c = _div_nearest(c, 10**-k)</font>
<font color="black">5637. </font>
<font color="red">5638.         log_d = _ilog(c, M) # error &lt; 5 + 22 = 27</font>
<font color="red">5639.         log_10 = _log10_digits(p) # error &lt; 1</font>
<font color="red">5640.         log_d = _div_nearest(log_d*M, log_10)</font>
<font color="red">5641.         log_tenpower = f*M # exact</font>
<font color="black">5642.     else:</font>
<font color="red">5643.         log_d = 0  # error &lt; 2.31</font>
<font color="red">5644.         log_tenpower = _div_nearest(f, 10**-p) # error &lt; 0.5</font>
<font color="black">5645. </font>
<font color="red">5646.     return _div_nearest(log_tenpower+log_d, 100)</font>
<font color="black">5647. </font>
<font color="green">5648. def _dlog(c, e, p):</font>
<font color="black">5649.     &quot;&quot;&quot;Given integers c, e and p with c &gt; 0, compute an integer</font>
<font color="black">5650.     approximation to 10**p * log(c*10**e), with an absolute error of</font>
<font color="black">5651.     at most 1.  Assumes that c*10**e is not exactly 1.&quot;&quot;&quot;</font>
<font color="black">5652. </font>
<font color="black">5653.     # Increase precision by 2. The precision increase is compensated</font>
<font color="black">5654.     # for at the end with a division by 100.</font>
<font color="red">5655.     p += 2</font>
<font color="black">5656. </font>
<font color="black">5657.     # rewrite c*10**e as d*10**f with either f &gt;= 0 and 1 &lt;= d &lt;= 10,</font>
<font color="black">5658.     # or f &lt;= 0 and 0.1 &lt;= d &lt;= 1.  Then we can compute 10**p * log(c*10**e)</font>
<font color="black">5659.     # as 10**p * log(d) + 10**p*f * log(10).</font>
<font color="red">5660.     l = len(str(c))</font>
<font color="red">5661.     f = e+l - (e+l &gt;= 1)</font>
<font color="black">5662. </font>
<font color="black">5663.     # compute approximation to 10**p*log(d), with error &lt; 27</font>
<font color="red">5664.     if p &gt; 0:</font>
<font color="red">5665.         k = e+p-f</font>
<font color="red">5666.         if k &gt;= 0:</font>
<font color="red">5667.             c *= 10**k</font>
<font color="black">5668.         else:</font>
<font color="red">5669.             c = _div_nearest(c, 10**-k)  # error of &lt;= 0.5 in c</font>
<font color="black">5670. </font>
<font color="black">5671.         # _ilog magnifies existing error in c by a factor of at most 10</font>
<font color="red">5672.         log_d = _ilog(c, 10**p) # error &lt; 5 + 22 = 27</font>
<font color="black">5673.     else:</font>
<font color="black">5674.         # p &lt;= 0: just approximate the whole thing by 0; error &lt; 2.31</font>
<font color="red">5675.         log_d = 0</font>
<font color="black">5676. </font>
<font color="black">5677.     # compute approximation to f*10**p*log(10), with error &lt; 11.</font>
<font color="red">5678.     if f:</font>
<font color="red">5679.         extra = len(str(abs(f)))-1</font>
<font color="red">5680.         if p + extra &gt;= 0:</font>
<font color="black">5681.             # error in f * _log10_digits(p+extra) &lt; |f| * 1 = |f|</font>
<font color="black">5682.             # after division, error &lt; |f|/10**extra + 0.5 &lt; 10 + 0.5 &lt; 11</font>
<font color="red">5683.             f_log_ten = _div_nearest(f*_log10_digits(p+extra), 10**extra)</font>
<font color="black">5684.         else:</font>
<font color="red">5685.             f_log_ten = 0</font>
<font color="black">5686.     else:</font>
<font color="red">5687.         f_log_ten = 0</font>
<font color="black">5688. </font>
<font color="black">5689.     # error in sum &lt; 11+27 = 38; error after division &lt; 0.38 + 0.5 &lt; 1</font>
<font color="red">5690.     return _div_nearest(f_log_ten + log_d, 100)</font>
<font color="black">5691. </font>
<font color="green">5692. class _Log10Memoize(object):</font>
<font color="black">5693.     &quot;&quot;&quot;Class to compute, store, and allow retrieval of, digits of the</font>
<font color="black">5694.     constant log(10) = 2.302585....  This constant is needed by</font>
<font color="green">5695.     Decimal.ln, Decimal.log10, Decimal.exp and Decimal.__pow__.&quot;&quot;&quot;</font>
<font color="green">5696.     def __init__(self):</font>
<font color="green">5697.         self.digits = &quot;23025850929940456840179914546843642076011014886&quot;</font>
<font color="black">5698. </font>
<font color="green">5699.     def getdigits(self, p):</font>
<font color="black">5700.         &quot;&quot;&quot;Given an integer p &gt;= 0, return floor(10**p)*log(10).</font>
<font color="black">5701. </font>
<font color="black">5702.         For example, self.getdigits(3) returns 2302.</font>
<font color="black">5703.         &quot;&quot;&quot;</font>
<font color="black">5704.         # digits are stored as a string, for quick conversion to</font>
<font color="black">5705.         # integer in the case that we've already computed enough</font>
<font color="black">5706.         # digits; the stored digits should always be correct</font>
<font color="black">5707.         # (truncated, not rounded to nearest).</font>
<font color="red">5708.         if p &lt; 0:</font>
<font color="red">5709.             raise ValueError(&quot;p should be nonnegative&quot;)</font>
<font color="black">5710. </font>
<font color="red">5711.         if p &gt;= len(self.digits):</font>
<font color="black">5712.             # compute p+3, p+6, p+9, ... digits; continue until at</font>
<font color="black">5713.             # least one of the extra digits is nonzero</font>
<font color="red">5714.             extra = 3</font>
<font color="red">5715.             while True:</font>
<font color="black">5716.                 # compute p+extra digits, correct to within 1ulp</font>
<font color="red">5717.                 M = 10**(p+extra+2)</font>
<font color="red">5718.                 digits = str(_div_nearest(_ilog(10*M, M), 100))</font>
<font color="red">5719.                 if digits[-extra:] != '0'*extra:</font>
<font color="red">5720.                     break</font>
<font color="red">5721.                 extra += 3</font>
<font color="black">5722.             # keep all reliable digits so far; remove trailing zeros</font>
<font color="black">5723.             # and next nonzero digit</font>
<font color="red">5724.             self.digits = digits.rstrip('0')[:-1]</font>
<font color="red">5725.         return int(self.digits[:p+1])</font>
<font color="black">5726. </font>
<font color="green">5727. _log10_digits = _Log10Memoize().getdigits</font>
<font color="black">5728. </font>
<font color="green">5729. def _iexp(x, M, L=8):</font>
<font color="black">5730.     &quot;&quot;&quot;Given integers x and M, M &gt; 0, such that x/M is small in absolute</font>
<font color="black">5731.     value, compute an integer approximation to M*exp(x/M).  For 0 &lt;=</font>
<font color="black">5732.     x/M &lt;= 2.4, the absolute error in the result is bounded by 60 (and</font>
<font color="black">5733.     is usually much smaller).&quot;&quot;&quot;</font>
<font color="black">5734. </font>
<font color="black">5735.     # Algorithm: to compute exp(z) for a real number z, first divide z</font>
<font color="black">5736.     # by a suitable power R of 2 so that |z/2**R| &lt; 2**-L.  Then</font>
<font color="black">5737.     # compute expm1(z/2**R) = exp(z/2**R) - 1 using the usual Taylor</font>
<font color="black">5738.     # series</font>
<font color="black">5739.     #</font>
<font color="black">5740.     #     expm1(x) = x + x**2/2! + x**3/3! + ...</font>
<font color="black">5741.     #</font>
<font color="black">5742.     # Now use the identity</font>
<font color="black">5743.     #</font>
<font color="black">5744.     #     expm1(2x) = expm1(x)*(expm1(x)+2)</font>
<font color="black">5745.     #</font>
<font color="black">5746.     # R times to compute the sequence expm1(z/2**R),</font>
<font color="black">5747.     # expm1(z/2**(R-1)), ... , exp(z/2), exp(z).</font>
<font color="black">5748. </font>
<font color="black">5749.     # Find R such that x/2**R/M &lt;= 2**-L</font>
<font color="red">5750.     R = _nbits((long(x)&lt;&lt;L)//M)</font>
<font color="black">5751. </font>
<font color="black">5752.     # Taylor series.  (2**L)**T &gt; M</font>
<font color="red">5753.     T = -int(-10*len(str(M))//(3*L))</font>
<font color="red">5754.     y = _div_nearest(x, T)</font>
<font color="red">5755.     Mshift = long(M)&lt;&lt;R</font>
<font color="red">5756.     for i in xrange(T-1, 0, -1):</font>
<font color="red">5757.         y = _div_nearest(x*(Mshift + y), Mshift * i)</font>
<font color="black">5758. </font>
<font color="black">5759.     # Expansion</font>
<font color="red">5760.     for k in xrange(R-1, -1, -1):</font>
<font color="red">5761.         Mshift = long(M)&lt;&lt;(k+2)</font>
<font color="red">5762.         y = _div_nearest(y*(y+Mshift), Mshift)</font>
<font color="black">5763. </font>
<font color="red">5764.     return M+y</font>
<font color="black">5765. </font>
<font color="green">5766. def _dexp(c, e, p):</font>
<font color="black">5767.     &quot;&quot;&quot;Compute an approximation to exp(c*10**e), with p decimal places of</font>
<font color="black">5768.     precision.</font>
<font color="black">5769. </font>
<font color="black">5770.     Returns integers d, f such that:</font>
<font color="black">5771. </font>
<font color="black">5772.       10**(p-1) &lt;= d &lt;= 10**p, and</font>
<font color="black">5773.       (d-1)*10**f &lt; exp(c*10**e) &lt; (d+1)*10**f</font>
<font color="black">5774. </font>
<font color="black">5775.     In other words, d*10**f is an approximation to exp(c*10**e) with p</font>
<font color="black">5776.     digits of precision, and with an error in d of at most 1.  This is</font>
<font color="black">5777.     almost, but not quite, the same as the error being &lt; 1ulp: when d</font>
<font color="black">5778.     = 10**(p-1) the error could be up to 10 ulp.&quot;&quot;&quot;</font>
<font color="black">5779. </font>
<font color="black">5780.     # we'll call iexp with M = 10**(p+2), giving p+3 digits of precision</font>
<font color="red">5781.     p += 2</font>
<font color="black">5782. </font>
<font color="black">5783.     # compute log(10) with extra precision = adjusted exponent of c*10**e</font>
<font color="red">5784.     extra = max(0, e + len(str(c)) - 1)</font>
<font color="red">5785.     q = p + extra</font>
<font color="black">5786. </font>
<font color="black">5787.     # compute quotient c*10**e/(log(10)) = c*10**(e+q)/(log(10)*10**q),</font>
<font color="black">5788.     # rounding down</font>
<font color="red">5789.     shift = e+q</font>
<font color="red">5790.     if shift &gt;= 0:</font>
<font color="red">5791.         cshift = c*10**shift</font>
<font color="black">5792.     else:</font>
<font color="red">5793.         cshift = c//10**-shift</font>
<font color="red">5794.     quot, rem = divmod(cshift, _log10_digits(q))</font>
<font color="black">5795. </font>
<font color="black">5796.     # reduce remainder back to original precision</font>
<font color="red">5797.     rem = _div_nearest(rem, 10**extra)</font>
<font color="black">5798. </font>
<font color="black">5799.     # error in result of _iexp &lt; 120;  error after division &lt; 0.62</font>
<font color="red">5800.     return _div_nearest(_iexp(rem, 10**p), 1000), quot - p + 3</font>
<font color="black">5801. </font>
<font color="green">5802. def _dpower(xc, xe, yc, ye, p):</font>
<font color="black">5803.     &quot;&quot;&quot;Given integers xc, xe, yc and ye representing Decimals x = xc*10**xe and</font>
<font color="black">5804.     y = yc*10**ye, compute x**y.  Returns a pair of integers (c, e) such that:</font>
<font color="black">5805. </font>
<font color="black">5806.       10**(p-1) &lt;= c &lt;= 10**p, and</font>
<font color="black">5807.       (c-1)*10**e &lt; x**y &lt; (c+1)*10**e</font>
<font color="black">5808. </font>
<font color="black">5809.     in other words, c*10**e is an approximation to x**y with p digits</font>
<font color="black">5810.     of precision, and with an error in c of at most 1.  (This is</font>
<font color="black">5811.     almost, but not quite, the same as the error being &lt; 1ulp: when c</font>
<font color="black">5812.     == 10**(p-1) we can only guarantee error &lt; 10ulp.)</font>
<font color="black">5813. </font>
<font color="black">5814.     We assume that: x is positive and not equal to 1, and y is nonzero.</font>
<font color="black">5815.     &quot;&quot;&quot;</font>
<font color="black">5816. </font>
<font color="black">5817.     # Find b such that 10**(b-1) &lt;= |y| &lt;= 10**b</font>
<font color="red">5818.     b = len(str(abs(yc))) + ye</font>
<font color="black">5819. </font>
<font color="black">5820.     # log(x) = lxc*10**(-p-b-1), to p+b+1 places after the decimal point</font>
<font color="red">5821.     lxc = _dlog(xc, xe, p+b+1)</font>
<font color="black">5822. </font>
<font color="black">5823.     # compute product y*log(x) = yc*lxc*10**(-p-b-1+ye) = pc*10**(-p-1)</font>
<font color="red">5824.     shift = ye-b</font>
<font color="red">5825.     if shift &gt;= 0:</font>
<font color="red">5826.         pc = lxc*yc*10**shift</font>
<font color="black">5827.     else:</font>
<font color="red">5828.         pc = _div_nearest(lxc*yc, 10**-shift)</font>
<font color="black">5829. </font>
<font color="red">5830.     if pc == 0:</font>
<font color="black">5831.         # we prefer a result that isn't exactly 1; this makes it</font>
<font color="black">5832.         # easier to compute a correctly rounded result in __pow__</font>
<font color="red">5833.         if ((len(str(xc)) + xe &gt;= 1) == (yc &gt; 0)): # if x**y &gt; 1:</font>
<font color="red">5834.             coeff, exp = 10**(p-1)+1, 1-p</font>
<font color="black">5835.         else:</font>
<font color="red">5836.             coeff, exp = 10**p-1, -p</font>
<font color="black">5837.     else:</font>
<font color="red">5838.         coeff, exp = _dexp(pc, -(p+1), p+1)</font>
<font color="red">5839.         coeff = _div_nearest(coeff, 10)</font>
<font color="red">5840.         exp += 1</font>
<font color="black">5841. </font>
<font color="red">5842.     return coeff, exp</font>
<font color="black">5843. </font>
<font color="green">5844. def _log10_lb(c, correction = {</font>
<font color="green">5845.         '1': 100, '2': 70, '3': 53, '4': 40, '5': 31,</font>
<font color="green">5846.         '6': 23, '7': 16, '8': 10, '9': 5}):</font>
<font color="black">5847.     &quot;&quot;&quot;Compute a lower bound for 100*log10(c) for a positive integer c.&quot;&quot;&quot;</font>
<font color="red">5848.     if c &lt;= 0:</font>
<font color="red">5849.         raise ValueError(&quot;The argument to _log10_lb should be nonnegative.&quot;)</font>
<font color="red">5850.     str_c = str(c)</font>
<font color="red">5851.     return 100*len(str_c) - correction[str_c[0]]</font>
<font color="black">5852. </font>
<font color="black">5853. ##### Helper Functions ####################################################</font>
<font color="black">5854. </font>
<font color="green">5855. def _convert_other(other, raiseit=False, allow_float=False):</font>
<font color="black">5856.     &quot;&quot;&quot;Convert other to Decimal.</font>
<font color="black">5857. </font>
<font color="black">5858.     Verifies that it's ok to use in an implicit construction.</font>
<font color="black">5859.     If allow_float is true, allow conversion from float;  this</font>
<font color="black">5860.     is used in the comparison methods (__eq__ and friends).</font>
<font color="black">5861. </font>
<font color="black">5862.     &quot;&quot;&quot;</font>
<font color="red">5863.     if isinstance(other, Decimal):</font>
<font color="red">5864.         return other</font>
<font color="red">5865.     if isinstance(other, (int, long)):</font>
<font color="red">5866.         return Decimal(other)</font>
<font color="red">5867.     if allow_float and isinstance(other, float):</font>
<font color="red">5868.         return Decimal.from_float(other)</font>
<font color="black">5869. </font>
<font color="red">5870.     if raiseit:</font>
<font color="red">5871.         raise TypeError(&quot;Unable to convert %s to Decimal&quot; % other)</font>
<font color="red">5872.     return NotImplemented</font>
<font color="black">5873. </font>
<font color="black">5874. ##### Setup Specific Contexts ############################################</font>
<font color="black">5875. </font>
<font color="black">5876. # The default context prototype used by Context()</font>
<font color="black">5877. # Is mutable, so that new contexts can have different default values</font>
<font color="black">5878. </font>
<font color="green">5879. DefaultContext = Context(</font>
<font color="green">5880.         prec=28, rounding=ROUND_HALF_EVEN,</font>
<font color="green">5881.         traps=[DivisionByZero, Overflow, InvalidOperation],</font>
<font color="green">5882.         flags=[],</font>
<font color="green">5883.         Emax=999999999,</font>
<font color="green">5884.         Emin=-999999999,</font>
<font color="green">5885.         capitals=1</font>
<font color="black">5886. )</font>
<font color="black">5887. </font>
<font color="black">5888. # Pre-made alternate contexts offered by the specification</font>
<font color="black">5889. # Don't change these; the user should be able to select these</font>
<font color="black">5890. # contexts and be able to reproduce results from other implementations</font>
<font color="black">5891. # of the spec.</font>
<font color="black">5892. </font>
<font color="green">5893. BasicContext = Context(</font>
<font color="green">5894.         prec=9, rounding=ROUND_HALF_UP,</font>
<font color="green">5895.         traps=[DivisionByZero, Overflow, InvalidOperation, Clamped, Underflow],</font>
<font color="green">5896.         flags=[],</font>
<font color="black">5897. )</font>
<font color="black">5898. </font>
<font color="green">5899. ExtendedContext = Context(</font>
<font color="green">5900.         prec=9, rounding=ROUND_HALF_EVEN,</font>
<font color="green">5901.         traps=[],</font>
<font color="green">5902.         flags=[],</font>
<font color="black">5903. )</font>
<font color="black">5904. </font>
<font color="black">5905. </font>
<font color="black">5906. ##### crud for parsing strings #############################################</font>
<font color="black">5907. #</font>
<font color="black">5908. # Regular expression used for parsing numeric strings.  Additional</font>
<font color="black">5909. # comments:</font>
<font color="black">5910. #</font>
<font color="black">5911. # 1. Uncomment the two '\s*' lines to allow leading and/or trailing</font>
<font color="black">5912. # whitespace.  But note that the specification disallows whitespace in</font>
<font color="black">5913. # a numeric string.</font>
<font color="black">5914. #</font>
<font color="black">5915. # 2. For finite numbers (not infinities and NaNs) the body of the</font>
<font color="black">5916. # number between the optional sign and the optional exponent must have</font>
<font color="black">5917. # at least one decimal digit, possibly after the decimal point.  The</font>
<font color="black">5918. # lookahead expression '(?=\d|\.\d)' checks this.</font>
<font color="black">5919. </font>
<font color="green">5920. import re</font>
<font color="green">5921. _parser = re.compile(r&quot;&quot;&quot;        # A numeric string consists of:</font>
<font color="black">5922. #    \s*</font>
<font color="black">5923.     (?P&lt;sign&gt;[-+])?              # an optional sign, followed by either...</font>
<font color="black">5924.     (</font>
<font color="black">5925.         (?=\d|\.\d)              # ...a number (with at least one digit)</font>
<font color="black">5926.         (?P&lt;int&gt;\d*)             # having a (possibly empty) integer part</font>
<font color="black">5927.         (\.(?P&lt;frac&gt;\d*))?       # followed by an optional fractional part</font>
<font color="black">5928.         (E(?P&lt;exp&gt;[-+]?\d+))?    # followed by an optional exponent, or...</font>
<font color="black">5929.     |</font>
<font color="black">5930.         Inf(inity)?              # ...an infinity, or...</font>
<font color="black">5931.     |</font>
<font color="black">5932.         (?P&lt;signal&gt;s)?           # ...an (optionally signaling)</font>
<font color="black">5933.         NaN                      # NaN</font>
<font color="black">5934.         (?P&lt;diag&gt;\d*)            # with (possibly empty) diagnostic info.</font>
<font color="black">5935.     )</font>
<font color="black">5936. #    \s*</font>
<font color="black">5937.     \Z</font>
<font color="green">5938. &quot;&quot;&quot;, re.VERBOSE | re.IGNORECASE | re.UNICODE).match</font>
<font color="black">5939. </font>
<font color="green">5940. _all_zeros = re.compile('0*$').match</font>
<font color="green">5941. _exact_half = re.compile('50*$').match</font>
<font color="black">5942. </font>
<font color="black">5943. ##### PEP3101 support functions ##############################################</font>
<font color="black">5944. # The functions in this section have little to do with the Decimal</font>
<font color="black">5945. # class, and could potentially be reused or adapted for other pure</font>
<font color="black">5946. # Python numeric classes that want to implement __format__</font>
<font color="black">5947. #</font>
<font color="black">5948. # A format specifier for Decimal looks like:</font>
<font color="black">5949. #</font>
<font color="black">5950. #   [[fill]align][sign][0][minimumwidth][,][.precision][type]</font>
<font color="black">5951. </font>
<font color="green">5952. _parse_format_specifier_regex = re.compile(r&quot;&quot;&quot;\A</font>
<font color="black">5953. (?:</font>
<font color="black">5954.    (?P&lt;fill&gt;.)?</font>
<font color="black">5955.    (?P&lt;align&gt;[&lt;&gt;=^])</font>
<font color="black">5956. )?</font>
<font color="black">5957. (?P&lt;sign&gt;[-+ ])?</font>
<font color="black">5958. (?P&lt;zeropad&gt;0)?</font>
<font color="black">5959. (?P&lt;minimumwidth&gt;(?!0)\d+)?</font>
<font color="black">5960. (?P&lt;thousands_sep&gt;,)?</font>
<font color="black">5961. (?:\.(?P&lt;precision&gt;0|(?!0)\d+))?</font>
<font color="black">5962. (?P&lt;type&gt;[eEfFgGn%])?</font>
<font color="black">5963. \Z</font>
<font color="green">5964. &quot;&quot;&quot;, re.VERBOSE)</font>
<font color="black">5965. </font>
<font color="green">5966. del re</font>
<font color="black">5967. </font>
<font color="black">5968. # The locale module is only needed for the 'n' format specifier.  The</font>
<font color="black">5969. # rest of the PEP 3101 code functions quite happily without it, so we</font>
<font color="black">5970. # don't care too much if locale isn't present.</font>
<font color="green">5971. try:</font>
<font color="green">5972.     import locale as _locale</font>
<font color="red">5973. except ImportError:</font>
<font color="red">5974.     pass</font>
<font color="black">5975. </font>
<font color="green">5976. def _parse_format_specifier(format_spec, _localeconv=None):</font>
<font color="black">5977.     &quot;&quot;&quot;Parse and validate a format specifier.</font>
<font color="black">5978. </font>
<font color="black">5979.     Turns a standard numeric format specifier into a dict, with the</font>
<font color="black">5980.     following entries:</font>
<font color="black">5981. </font>
<font color="black">5982.       fill: fill character to pad field to minimum width</font>
<font color="black">5983.       align: alignment type, either '&lt;', '&gt;', '=' or '^'</font>
<font color="black">5984.       sign: either '+', '-' or ' '</font>
<font color="black">5985.       minimumwidth: nonnegative integer giving minimum width</font>
<font color="black">5986.       zeropad: boolean, indicating whether to pad with zeros</font>
<font color="black">5987.       thousands_sep: string to use as thousands separator, or ''</font>
<font color="black">5988.       grouping: grouping for thousands separators, in format</font>
<font color="black">5989.         used by localeconv</font>
<font color="black">5990.       decimal_point: string to use for decimal point</font>
<font color="black">5991.       precision: nonnegative integer giving precision, or None</font>
<font color="black">5992.       type: one of the characters 'eEfFgG%', or None</font>
<font color="black">5993.       unicode: boolean (always True for Python 3.x)</font>
<font color="black">5994. </font>
<font color="black">5995.     &quot;&quot;&quot;</font>
<font color="red">5996.     m = _parse_format_specifier_regex.match(format_spec)</font>
<font color="red">5997.     if m is None:</font>
<font color="red">5998.         raise ValueError(&quot;Invalid format specifier: &quot; + format_spec)</font>
<font color="black">5999. </font>
<font color="black">6000.     # get the dictionary</font>
<font color="red">6001.     format_dict = m.groupdict()</font>
<font color="black">6002. </font>
<font color="black">6003.     # zeropad; defaults for fill and alignment.  If zero padding</font>
<font color="black">6004.     # is requested, the fill and align fields should be absent.</font>
<font color="red">6005.     fill = format_dict['fill']</font>
<font color="red">6006.     align = format_dict['align']</font>
<font color="red">6007.     format_dict['zeropad'] = (format_dict['zeropad'] is not None)</font>
<font color="red">6008.     if format_dict['zeropad']:</font>
<font color="red">6009.         if fill is not None:</font>
<font color="red">6010.             raise ValueError(&quot;Fill character conflicts with '0'&quot;</font>
<font color="red">6011.                              &quot; in format specifier: &quot; + format_spec)</font>
<font color="red">6012.         if align is not None:</font>
<font color="red">6013.             raise ValueError(&quot;Alignment conflicts with '0' in &quot;</font>
<font color="red">6014.                              &quot;format specifier: &quot; + format_spec)</font>
<font color="red">6015.     format_dict['fill'] = fill or ' '</font>
<font color="black">6016.     # PEP 3101 originally specified that the default alignment should</font>
<font color="black">6017.     # be left;  it was later agreed that right-aligned makes more sense</font>
<font color="black">6018.     # for numeric types.  See http://bugs.python.org/issue6857.</font>
<font color="red">6019.     format_dict['align'] = align or '&gt;'</font>
<font color="black">6020. </font>
<font color="black">6021.     # default sign handling: '-' for negative, '' for positive</font>
<font color="red">6022.     if format_dict['sign'] is None:</font>
<font color="red">6023.         format_dict['sign'] = '-'</font>
<font color="black">6024. </font>
<font color="black">6025.     # minimumwidth defaults to 0; precision remains None if not given</font>
<font color="red">6026.     format_dict['minimumwidth'] = int(format_dict['minimumwidth'] or '0')</font>
<font color="red">6027.     if format_dict['precision'] is not None:</font>
<font color="red">6028.         format_dict['precision'] = int(format_dict['precision'])</font>
<font color="black">6029. </font>
<font color="black">6030.     # if format type is 'g' or 'G' then a precision of 0 makes little</font>
<font color="black">6031.     # sense; convert it to 1.  Same if format type is unspecified.</font>
<font color="red">6032.     if format_dict['precision'] == 0:</font>
<font color="red">6033.         if format_dict['type'] is None or format_dict['type'] in 'gG':</font>
<font color="red">6034.             format_dict['precision'] = 1</font>
<font color="black">6035. </font>
<font color="black">6036.     # determine thousands separator, grouping, and decimal separator, and</font>
<font color="black">6037.     # add appropriate entries to format_dict</font>
<font color="red">6038.     if format_dict['type'] == 'n':</font>
<font color="black">6039.         # apart from separators, 'n' behaves just like 'g'</font>
<font color="red">6040.         format_dict['type'] = 'g'</font>
<font color="red">6041.         if _localeconv is None:</font>
<font color="red">6042.             _localeconv = _locale.localeconv()</font>
<font color="red">6043.         if format_dict['thousands_sep'] is not None:</font>
<font color="red">6044.             raise ValueError(&quot;Explicit thousands separator conflicts with &quot;</font>
<font color="red">6045.                              &quot;'n' type in format specifier: &quot; + format_spec)</font>
<font color="red">6046.         format_dict['thousands_sep'] = _localeconv['thousands_sep']</font>
<font color="red">6047.         format_dict['grouping'] = _localeconv['grouping']</font>
<font color="red">6048.         format_dict['decimal_point'] = _localeconv['decimal_point']</font>
<font color="black">6049.     else:</font>
<font color="red">6050.         if format_dict['thousands_sep'] is None:</font>
<font color="red">6051.             format_dict['thousands_sep'] = ''</font>
<font color="red">6052.         format_dict['grouping'] = [3, 0]</font>
<font color="red">6053.         format_dict['decimal_point'] = '.'</font>
<font color="black">6054. </font>
<font color="black">6055.     # record whether return type should be str or unicode</font>
<font color="red">6056.     try:</font>
<font color="red">6057.         format_dict['unicode'] = isinstance(format_spec, unicode)</font>
<font color="red">6058.     except NameError:</font>
<font color="red">6059.         format_dict['unicode'] = False</font>
<font color="black">6060. </font>
<font color="red">6061.     return format_dict</font>
<font color="black">6062. </font>
<font color="green">6063. def _format_align(sign, body, spec):</font>
<font color="black">6064.     &quot;&quot;&quot;Given an unpadded, non-aligned numeric string 'body' and sign</font>
<font color="black">6065.     string 'sign', add padding and alignment conforming to the given</font>
<font color="black">6066.     format specifier dictionary 'spec' (as produced by</font>
<font color="black">6067.     parse_format_specifier).</font>
<font color="black">6068. </font>
<font color="black">6069.     Also converts result to unicode if necessary.</font>
<font color="black">6070. </font>
<font color="black">6071.     &quot;&quot;&quot;</font>
<font color="black">6072.     # how much extra space do we have to play with?</font>
<font color="red">6073.     minimumwidth = spec['minimumwidth']</font>
<font color="red">6074.     fill = spec['fill']</font>
<font color="red">6075.     padding = fill*(minimumwidth - len(sign) - len(body))</font>
<font color="black">6076. </font>
<font color="red">6077.     align = spec['align']</font>
<font color="red">6078.     if align == '&lt;':</font>
<font color="red">6079.         result = sign + body + padding</font>
<font color="red">6080.     elif align == '&gt;':</font>
<font color="red">6081.         result = padding + sign + body</font>
<font color="red">6082.     elif align == '=':</font>
<font color="red">6083.         result = sign + padding + body</font>
<font color="red">6084.     elif align == '^':</font>
<font color="red">6085.         half = len(padding)//2</font>
<font color="red">6086.         result = padding[:half] + sign + body + padding[half:]</font>
<font color="black">6087.     else:</font>
<font color="red">6088.         raise ValueError('Unrecognised alignment field')</font>
<font color="black">6089. </font>
<font color="black">6090.     # make sure that result is unicode if necessary</font>
<font color="red">6091.     if spec['unicode']:</font>
<font color="red">6092.         result = unicode(result)</font>
<font color="black">6093. </font>
<font color="red">6094.     return result</font>
<font color="black">6095. </font>
<font color="green">6096. def _group_lengths(grouping):</font>
<font color="black">6097.     &quot;&quot;&quot;Convert a localeconv-style grouping into a (possibly infinite)</font>
<font color="black">6098.     iterable of integers representing group lengths.</font>
<font color="black">6099. </font>
<font color="black">6100.     &quot;&quot;&quot;</font>
<font color="black">6101.     # The result from localeconv()['grouping'], and the input to this</font>
<font color="black">6102.     # function, should be a list of integers in one of the</font>
<font color="black">6103.     # following three forms:</font>
<font color="black">6104.     #</font>
<font color="black">6105.     #   (1) an empty list, or</font>
<font color="black">6106.     #   (2) nonempty list of positive integers + [0]</font>
<font color="black">6107.     #   (3) list of positive integers + [locale.CHAR_MAX], or</font>
<font color="black">6108. </font>
<font color="red">6109.     from itertools import chain, repeat</font>
<font color="red">6110.     if not grouping:</font>
<font color="red">6111.         return []</font>
<font color="red">6112.     elif grouping[-1] == 0 and len(grouping) &gt;= 2:</font>
<font color="red">6113.         return chain(grouping[:-1], repeat(grouping[-2]))</font>
<font color="red">6114.     elif grouping[-1] == _locale.CHAR_MAX:</font>
<font color="red">6115.         return grouping[:-1]</font>
<font color="black">6116.     else:</font>
<font color="red">6117.         raise ValueError('unrecognised format for grouping')</font>
<font color="black">6118. </font>
<font color="green">6119. def _insert_thousands_sep(digits, spec, min_width=1):</font>
<font color="black">6120.     &quot;&quot;&quot;Insert thousands separators into a digit string.</font>
<font color="black">6121. </font>
<font color="black">6122.     spec is a dictionary whose keys should include 'thousands_sep' and</font>
<font color="black">6123.     'grouping'; typically it's the result of parsing the format</font>
<font color="black">6124.     specifier using _parse_format_specifier.</font>
<font color="black">6125. </font>
<font color="black">6126.     The min_width keyword argument gives the minimum length of the</font>
<font color="black">6127.     result, which will be padded on the left with zeros if necessary.</font>
<font color="black">6128. </font>
<font color="black">6129.     If necessary, the zero padding adds an extra '0' on the left to</font>
<font color="black">6130.     avoid a leading thousands separator.  For example, inserting</font>
<font color="black">6131.     commas every three digits in '123456', with min_width=8, gives</font>
<font color="black">6132.     '0,123,456', even though that has length 9.</font>
<font color="black">6133. </font>
<font color="black">6134.     &quot;&quot;&quot;</font>
<font color="black">6135. </font>
<font color="red">6136.     sep = spec['thousands_sep']</font>
<font color="red">6137.     grouping = spec['grouping']</font>
<font color="black">6138. </font>
<font color="red">6139.     groups = []</font>
<font color="red">6140.     for l in _group_lengths(grouping):</font>
<font color="red">6141.         if l &lt;= 0:</font>
<font color="red">6142.             raise ValueError(&quot;group length should be positive&quot;)</font>
<font color="black">6143.         # max(..., 1) forces at least 1 digit to the left of a separator</font>
<font color="red">6144.         l = min(max(len(digits), min_width, 1), l)</font>
<font color="red">6145.         groups.append('0'*(l - len(digits)) + digits[-l:])</font>
<font color="red">6146.         digits = digits[:-l]</font>
<font color="red">6147.         min_width -= l</font>
<font color="red">6148.         if not digits and min_width &lt;= 0:</font>
<font color="red">6149.             break</font>
<font color="red">6150.         min_width -= len(sep)</font>
<font color="black">6151.     else:</font>
<font color="red">6152.         l = max(len(digits), min_width, 1)</font>
<font color="red">6153.         groups.append('0'*(l - len(digits)) + digits[-l:])</font>
<font color="red">6154.     return sep.join(reversed(groups))</font>
<font color="black">6155. </font>
<font color="green">6156. def _format_sign(is_negative, spec):</font>
<font color="black">6157.     &quot;&quot;&quot;Determine sign character.&quot;&quot;&quot;</font>
<font color="black">6158. </font>
<font color="red">6159.     if is_negative:</font>
<font color="red">6160.         return '-'</font>
<font color="red">6161.     elif spec['sign'] in ' +':</font>
<font color="red">6162.         return spec['sign']</font>
<font color="black">6163.     else:</font>
<font color="red">6164.         return ''</font>
<font color="black">6165. </font>
<font color="green">6166. def _format_number(is_negative, intpart, fracpart, exp, spec):</font>
<font color="black">6167.     &quot;&quot;&quot;Format a number, given the following data:</font>
<font color="black">6168. </font>
<font color="black">6169.     is_negative: true if the number is negative, else false</font>
<font color="black">6170.     intpart: string of digits that must appear before the decimal point</font>
<font color="black">6171.     fracpart: string of digits that must come after the point</font>
<font color="black">6172.     exp: exponent, as an integer</font>
<font color="black">6173.     spec: dictionary resulting from parsing the format specifier</font>
<font color="black">6174. </font>
<font color="black">6175.     This function uses the information in spec to:</font>
<font color="black">6176.       insert separators (decimal separator and thousands separators)</font>
<font color="black">6177.       format the sign</font>
<font color="black">6178.       format the exponent</font>
<font color="black">6179.       add trailing '%' for the '%' type</font>
<font color="black">6180.       zero-pad if necessary</font>
<font color="black">6181.       fill and align if necessary</font>
<font color="black">6182.     &quot;&quot;&quot;</font>
<font color="black">6183. </font>
<font color="red">6184.     sign = _format_sign(is_negative, spec)</font>
<font color="black">6185. </font>
<font color="red">6186.     if fracpart:</font>
<font color="red">6187.         fracpart = spec['decimal_point'] + fracpart</font>
<font color="black">6188. </font>
<font color="red">6189.     if exp != 0 or spec['type'] in 'eE':</font>
<font color="red">6190.         echar = {'E': 'E', 'e': 'e', 'G': 'E', 'g': 'e'}[spec['type']]</font>
<font color="red">6191.         fracpart += &quot;{0}{1:+}&quot;.format(echar, exp)</font>
<font color="red">6192.     if spec['type'] == '%':</font>
<font color="red">6193.         fracpart += '%'</font>
<font color="black">6194. </font>
<font color="red">6195.     if spec['zeropad']:</font>
<font color="red">6196.         min_width = spec['minimumwidth'] - len(fracpart) - len(sign)</font>
<font color="black">6197.     else:</font>
<font color="red">6198.         min_width = 0</font>
<font color="red">6199.     intpart = _insert_thousands_sep(intpart, spec, min_width)</font>
<font color="black">6200. </font>
<font color="red">6201.     return _format_align(sign, intpart+fracpart, spec)</font>
<font color="black">6202. </font>
<font color="black">6203. </font>
<font color="black">6204. ##### Useful Constants (internal use only) ################################</font>
<font color="black">6205. </font>
<font color="black">6206. # Reusable defaults</font>
<font color="green">6207. _Infinity = Decimal('Inf')</font>
<font color="green">6208. _NegativeInfinity = Decimal('-Inf')</font>
<font color="green">6209. _NaN = Decimal('NaN')</font>
<font color="green">6210. _Zero = Decimal(0)</font>
<font color="green">6211. _One = Decimal(1)</font>
<font color="green">6212. _NegativeOne = Decimal(-1)</font>
<font color="black">6213. </font>
<font color="black">6214. # _SignedInfinity[sign] is infinity w/ that sign</font>
<font color="green">6215. _SignedInfinity = (_Infinity, _NegativeInfinity)</font>
<font color="black">6216. </font>
<font color="black">6217. </font>
<font color="black">6218. </font>
<font color="green">6219. if __name__ == '__main__':</font>
<font color="red">6220.     import doctest, sys</font>
<font color="red">6221.     doctest.testmod(sys.modules[__name__])</font>
</pre>

