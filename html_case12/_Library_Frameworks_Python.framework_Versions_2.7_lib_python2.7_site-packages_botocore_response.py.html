source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/response.py</b><br>


file stats: <b>50 lines, 17 executed: 34.0% covered</b>
<pre>
<font color="black">   1. # Copyright (c) 2012-2013 Mitch Garnaat http://garnaat.org/</font>
<font color="black">   2. # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   3. #</font>
<font color="black">   4. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   5. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   6. # the License is located at</font>
<font color="black">   7. #</font>
<font color="black">   8. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   9. #</font>
<font color="black">  10. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  11. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  12. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  13. # language governing permissions and limitations under the License.</font>
<font color="black">  14. </font>
<font color="green">  15. import sys</font>
<font color="green">  16. import xml.etree.cElementTree</font>
<font color="green">  17. import logging</font>
<font color="black">  18. </font>
<font color="green">  19. from botocore import ScalarTypes</font>
<font color="green">  20. from botocore.hooks import first_non_none_response</font>
<font color="green">  21. from botocore.compat import json, set_socket_timeout, XMLParseError</font>
<font color="green">  22. from botocore.exceptions import IncompleteReadError</font>
<font color="green">  23. from botocore import parsers</font>
<font color="black">  24. </font>
<font color="black">  25. </font>
<font color="green">  26. logger = logging.getLogger(__name__)</font>
<font color="black">  27. </font>
<font color="black">  28. </font>
<font color="green">  29. class StreamingBody(object):</font>
<font color="black">  30.     &quot;&quot;&quot;Wrapper class for an http response body.</font>
<font color="black">  31. </font>
<font color="black">  32.     This provides a few additional conveniences that do not exist</font>
<font color="black">  33.     in the urllib3 model:</font>
<font color="black">  34. </font>
<font color="black">  35.         * Set the timeout on the socket (i.e read() timeouts)</font>
<font color="black">  36.         * Auto validation of content length, if the amount of bytes</font>
<font color="black">  37.           we read does not match the content length, an exception</font>
<font color="black">  38.           is raised.</font>
<font color="black">  39. </font>
<font color="green">  40.     &quot;&quot;&quot;</font>
<font color="green">  41.     def __init__(self, raw_stream, content_length):</font>
<font color="red">  42.         self._raw_stream = raw_stream</font>
<font color="red">  43.         self._content_length = content_length</font>
<font color="red">  44.         self._amount_read = 0</font>
<font color="black">  45. </font>
<font color="green">  46.     def set_socket_timeout(self, timeout):</font>
<font color="black">  47.         &quot;&quot;&quot;Set the timeout seconds on the socket.&quot;&quot;&quot;</font>
<font color="black">  48.         # The problem we're trying to solve is to prevent .read() calls from</font>
<font color="black">  49.         # hanging.  This can happen in rare cases.  What we'd like to ideally</font>
<font color="black">  50.         # do is set a timeout on the .read() call so that callers can retry</font>
<font color="black">  51.         # the request.</font>
<font color="black">  52.         # Unfortunately, this isn't currently possible in requests.</font>
<font color="black">  53.         # See: https://github.com/kennethreitz/requests/issues/1803</font>
<font color="black">  54.         # So what we're going to do is reach into the guts of the stream and</font>
<font color="black">  55.         # grab the socket object, which we can set the timeout on.  We're</font>
<font color="black">  56.         # putting in a check here so in case this interface goes away, we'll</font>
<font color="black">  57.         # know.</font>
<font color="red">  58.         try:</font>
<font color="black">  59.             # To further complicate things, the way to grab the</font>
<font color="black">  60.             # underlying socket object from an HTTPResponse is different</font>
<font color="black">  61.             # in py2 and py3.  So this code has been pushed to botocore.compat.</font>
<font color="red">  62.             set_socket_timeout(self._raw_stream, timeout)</font>
<font color="red">  63.         except AttributeError:</font>
<font color="red">  64.             logger.error(&quot;Cannot access the socket object of &quot;</font>
<font color="black">  65.                          &quot;a streaming response.  It's possible &quot;</font>
<font color="red">  66.                          &quot;the interface has changed.&quot;, exc_info=True)</font>
<font color="red">  67.             raise</font>
<font color="black">  68. </font>
<font color="green">  69.     def read(self, amt=None):</font>
<font color="black">  70.         &quot;&quot;&quot;Read at most amt bytes from the stream.</font>
<font color="black">  71. </font>
<font color="black">  72.         If the amt argument is omitted, read all data.</font>
<font color="black">  73.         &quot;&quot;&quot;</font>
<font color="red">  74.         chunk = self._raw_stream.read(amt)</font>
<font color="red">  75.         self._amount_read += len(chunk)</font>
<font color="red">  76.         if amt is None or (not chunk and amt &gt; 0):</font>
<font color="black">  77.             # If the server sends empty contents or</font>
<font color="black">  78.             # we ask to read all of the contents, then we know</font>
<font color="black">  79.             # we need to verify the content length.</font>
<font color="red">  80.             self._verify_content_length()</font>
<font color="red">  81.         return chunk</font>
<font color="black">  82. </font>
<font color="green">  83.     def _verify_content_length(self):</font>
<font color="black">  84.         # See: https://github.com/kennethreitz/requests/issues/1855</font>
<font color="black">  85.         # Basically, our http library doesn't do this for us, so we have</font>
<font color="black">  86.         # to do this ourself.</font>
<font color="red">  87.         if self._content_length is not None and \</font>
<font color="red">  88.                 self._amount_read != int(self._content_length):</font>
<font color="red">  89.             raise IncompleteReadError(</font>
<font color="red">  90.                 actual_bytes=self._amount_read,</font>
<font color="red">  91.                 expected_bytes=int(self._content_length))</font>
<font color="black">  92. </font>
<font color="green">  93.     def close(self):</font>
<font color="black">  94.         &quot;&quot;&quot;Close the underlying http response stream.&quot;&quot;&quot;</font>
<font color="red">  95.         self._raw_stream.close()</font>
<font color="black">  96. </font>
<font color="black">  97. </font>
<font color="green">  98. def get_response(operation_model, http_response):</font>
<font color="red">  99.     protocol = operation_model.metadata['protocol']</font>
<font color="red"> 100.     response_dict = {</font>
<font color="red"> 101.         'headers': http_response.headers,</font>
<font color="red"> 102.         'status_code': http_response.status_code,</font>
<font color="black"> 103.     }</font>
<font color="black"> 104.     # TODO: Unfortunately, we have to have error logic here.</font>
<font color="black"> 105.     # If it looks like an error, in the streaming response case we</font>
<font color="black"> 106.     # need to actually grab the contents.</font>
<font color="red"> 107.     if response_dict['status_code'] &gt;= 300:</font>
<font color="red"> 108.         response_dict['body'] = http_response.content</font>
<font color="red"> 109.     elif operation_model.has_streaming_output:</font>
<font color="red"> 110.         response_dict['body'] = StreamingBody(</font>
<font color="red"> 111.             http_response.raw, response_dict['headers'].get('content-length'))</font>
<font color="black"> 112.     else:</font>
<font color="red"> 113.         response_dict['body'] = http_response.content</font>
<font color="black"> 114. </font>
<font color="red"> 115.     parser = parsers.create_parser(protocol)</font>
<font color="red"> 116.     return http_response, parser.parse(response_dict,</font>
<font color="red"> 117.                                        operation_model.output_shape)</font>
</pre>

