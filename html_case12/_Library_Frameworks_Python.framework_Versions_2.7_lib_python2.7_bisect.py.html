source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/bisect.py</b><br>


file stats: <b>47 lines, 9 executed: 19.1% covered</b>
<pre>
<font color="green">   1. &quot;&quot;&quot;Bisection algorithms.&quot;&quot;&quot;</font>
<font color="black">   2. </font>
<font color="green">   3. def insort_right(a, x, lo=0, hi=None):</font>
<font color="black">   4.     &quot;&quot;&quot;Insert item x in list a, and keep it sorted assuming a is sorted.</font>
<font color="black">   5. </font>
<font color="black">   6.     If x is already in a, insert it to the right of the rightmost x.</font>
<font color="black">   7. </font>
<font color="black">   8.     Optional args lo (default 0) and hi (default len(a)) bound the</font>
<font color="black">   9.     slice of a to be searched.</font>
<font color="black">  10.     &quot;&quot;&quot;</font>
<font color="black">  11. </font>
<font color="red">  12.     if lo &lt; 0:</font>
<font color="red">  13.         raise ValueError('lo must be non-negative')</font>
<font color="red">  14.     if hi is None:</font>
<font color="red">  15.         hi = len(a)</font>
<font color="red">  16.     while lo &lt; hi:</font>
<font color="red">  17.         mid = (lo+hi)//2</font>
<font color="red">  18.         if x &lt; a[mid]: hi = mid</font>
<font color="red">  19.         else: lo = mid+1</font>
<font color="red">  20.     a.insert(lo, x)</font>
<font color="black">  21. </font>
<font color="green">  22. insort = insort_right   # backward compatibility</font>
<font color="black">  23. </font>
<font color="green">  24. def bisect_right(a, x, lo=0, hi=None):</font>
<font color="black">  25.     &quot;&quot;&quot;Return the index where to insert item x in list a, assuming a is sorted.</font>
<font color="black">  26. </font>
<font color="black">  27.     The return value i is such that all e in a[:i] have e &lt;= x, and all e in</font>
<font color="black">  28.     a[i:] have e &gt; x.  So if x already appears in the list, a.insert(x) will</font>
<font color="black">  29.     insert just after the rightmost x already there.</font>
<font color="black">  30. </font>
<font color="black">  31.     Optional args lo (default 0) and hi (default len(a)) bound the</font>
<font color="black">  32.     slice of a to be searched.</font>
<font color="black">  33.     &quot;&quot;&quot;</font>
<font color="black">  34. </font>
<font color="red">  35.     if lo &lt; 0:</font>
<font color="red">  36.         raise ValueError('lo must be non-negative')</font>
<font color="red">  37.     if hi is None:</font>
<font color="red">  38.         hi = len(a)</font>
<font color="red">  39.     while lo &lt; hi:</font>
<font color="red">  40.         mid = (lo+hi)//2</font>
<font color="red">  41.         if x &lt; a[mid]: hi = mid</font>
<font color="red">  42.         else: lo = mid+1</font>
<font color="red">  43.     return lo</font>
<font color="black">  44. </font>
<font color="green">  45. bisect = bisect_right   # backward compatibility</font>
<font color="black">  46. </font>
<font color="green">  47. def insort_left(a, x, lo=0, hi=None):</font>
<font color="black">  48.     &quot;&quot;&quot;Insert item x in list a, and keep it sorted assuming a is sorted.</font>
<font color="black">  49. </font>
<font color="black">  50.     If x is already in a, insert it to the left of the leftmost x.</font>
<font color="black">  51. </font>
<font color="black">  52.     Optional args lo (default 0) and hi (default len(a)) bound the</font>
<font color="black">  53.     slice of a to be searched.</font>
<font color="black">  54.     &quot;&quot;&quot;</font>
<font color="black">  55. </font>
<font color="red">  56.     if lo &lt; 0:</font>
<font color="red">  57.         raise ValueError('lo must be non-negative')</font>
<font color="red">  58.     if hi is None:</font>
<font color="red">  59.         hi = len(a)</font>
<font color="red">  60.     while lo &lt; hi:</font>
<font color="red">  61.         mid = (lo+hi)//2</font>
<font color="red">  62.         if a[mid] &lt; x: lo = mid+1</font>
<font color="red">  63.         else: hi = mid</font>
<font color="red">  64.     a.insert(lo, x)</font>
<font color="black">  65. </font>
<font color="black">  66. </font>
<font color="green">  67. def bisect_left(a, x, lo=0, hi=None):</font>
<font color="black">  68.     &quot;&quot;&quot;Return the index where to insert item x in list a, assuming a is sorted.</font>
<font color="black">  69. </font>
<font color="black">  70.     The return value i is such that all e in a[:i] have e &lt; x, and all e in</font>
<font color="black">  71.     a[i:] have e &gt;= x.  So if x already appears in the list, a.insert(x) will</font>
<font color="black">  72.     insert just before the leftmost x already there.</font>
<font color="black">  73. </font>
<font color="black">  74.     Optional args lo (default 0) and hi (default len(a)) bound the</font>
<font color="black">  75.     slice of a to be searched.</font>
<font color="black">  76.     &quot;&quot;&quot;</font>
<font color="black">  77. </font>
<font color="red">  78.     if lo &lt; 0:</font>
<font color="red">  79.         raise ValueError('lo must be non-negative')</font>
<font color="red">  80.     if hi is None:</font>
<font color="red">  81.         hi = len(a)</font>
<font color="red">  82.     while lo &lt; hi:</font>
<font color="red">  83.         mid = (lo+hi)//2</font>
<font color="red">  84.         if a[mid] &lt; x: lo = mid+1</font>
<font color="red">  85.         else: hi = mid</font>
<font color="red">  86.     return lo</font>
<font color="black">  87. </font>
<font color="black">  88. # Overwrite above definitions with a fast C implementation</font>
<font color="green">  89. try:</font>
<font color="green">  90.     from _bisect import *</font>
<font color="red">  91. except ImportError:</font>
<font color="red">  92.     pass</font>
</pre>

