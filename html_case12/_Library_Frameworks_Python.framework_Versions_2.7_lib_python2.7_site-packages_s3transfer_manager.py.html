source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/s3transfer/manager.py</b><br>


file stats: <b>293 lines, 103 executed: 35.2% covered</b>
<pre>
<font color="black">   1. # Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="green">  13. import copy</font>
<font color="green">  14. import logging</font>
<font color="green">  15. import threading</font>
<font color="black">  16. </font>
<font color="green">  17. from botocore.compat import six</font>
<font color="black">  18. </font>
<font color="green">  19. from s3transfer.utils import get_callbacks</font>
<font color="green">  20. from s3transfer.utils import signal_transferring</font>
<font color="green">  21. from s3transfer.utils import signal_not_transferring</font>
<font color="green">  22. from s3transfer.utils import CallArgs</font>
<font color="green">  23. from s3transfer.utils import OSUtils</font>
<font color="green">  24. from s3transfer.utils import TaskSemaphore</font>
<font color="green">  25. from s3transfer.utils import SlidingWindowSemaphore</font>
<font color="green">  26. from s3transfer.exceptions import CancelledError</font>
<font color="green">  27. from s3transfer.exceptions import FatalError</font>
<font color="green">  28. from s3transfer.futures import IN_MEMORY_DOWNLOAD_TAG</font>
<font color="green">  29. from s3transfer.futures import IN_MEMORY_UPLOAD_TAG</font>
<font color="green">  30. from s3transfer.futures import BoundedExecutor</font>
<font color="green">  31. from s3transfer.futures import TransferFuture</font>
<font color="green">  32. from s3transfer.futures import TransferMeta</font>
<font color="green">  33. from s3transfer.futures import TransferCoordinator</font>
<font color="green">  34. from s3transfer.download import DownloadSubmissionTask</font>
<font color="green">  35. from s3transfer.upload import UploadSubmissionTask</font>
<font color="green">  36. from s3transfer.copies import CopySubmissionTask</font>
<font color="green">  37. from s3transfer.delete import DeleteSubmissionTask</font>
<font color="green">  38. from s3transfer.bandwidth import LeakyBucket</font>
<font color="green">  39. from s3transfer.bandwidth import BandwidthLimiter</font>
<font color="black">  40. </font>
<font color="green">  41. KB = 1024</font>
<font color="green">  42. MB = KB * KB</font>
<font color="green">  43. logger = logging.getLogger(__name__)</font>
<font color="black">  44. </font>
<font color="black">  45. </font>
<font color="green">  46. class TransferConfig(object):</font>
<font color="black">  47.     def __init__(self,</font>
<font color="green">  48.                  multipart_threshold=8 * MB,</font>
<font color="green">  49.                  multipart_chunksize=8 * MB,</font>
<font color="green">  50.                  max_request_concurrency=10,</font>
<font color="green">  51.                  max_submission_concurrency=5,</font>
<font color="green">  52.                  max_request_queue_size=1000,</font>
<font color="green">  53.                  max_submission_queue_size=1000,</font>
<font color="green">  54.                  max_io_queue_size=1000,</font>
<font color="green">  55.                  io_chunksize=256 * KB,</font>
<font color="green">  56.                  num_download_attempts=5,</font>
<font color="green">  57.                  max_in_memory_upload_chunks=10,</font>
<font color="green">  58.                  max_in_memory_download_chunks=10,</font>
<font color="green">  59.                  max_bandwidth=None):</font>
<font color="black">  60.         &quot;&quot;&quot;Configurations for the transfer mangager</font>
<font color="black">  61. </font>
<font color="black">  62.         :param multipart_threshold: The threshold for which multipart</font>
<font color="black">  63.             transfers occur.</font>
<font color="black">  64. </font>
<font color="black">  65.         :param max_request_concurrency: The maximum number of S3 API</font>
<font color="black">  66.             transfer-related requests that can happen at a time.</font>
<font color="black">  67. </font>
<font color="black">  68.         :param max_submission_concurrency: The maximum number of threads</font>
<font color="black">  69.             processing a call to a TransferManager method. Processing a</font>
<font color="black">  70.             call usually entails determining which S3 API requests that need</font>
<font color="black">  71.             to be enqueued, but does **not** entail making any of the</font>
<font color="black">  72.             S3 API data transfering requests needed to perform the transfer.</font>
<font color="black">  73.             The threads controlled by ``max_request_concurrency`` is</font>
<font color="black">  74.             responsible for that.</font>
<font color="black">  75. </font>
<font color="black">  76.         :param multipart_chunksize: The size of each transfer if a request</font>
<font color="black">  77.             becomes a multipart transfer.</font>
<font color="black">  78. </font>
<font color="black">  79.         :param max_request_queue_size: The maximum amount of S3 API requests</font>
<font color="black">  80.             that can be queued at a time. A value of zero means that there</font>
<font color="black">  81.             is no maximum.</font>
<font color="black">  82. </font>
<font color="black">  83.         :param max_submission_queue_size: The maximum amount of</font>
<font color="black">  84.             TransferManager method calls that can be queued at a time. A value</font>
<font color="black">  85.             of zero means that there is no maximum.</font>
<font color="black">  86. </font>
<font color="black">  87.         :param max_io_queue_size: The maximum amount of read parts that</font>
<font color="black">  88.             can be queued to be written to disk per download. A value of zero</font>
<font color="black">  89.             means that there is no maximum. The default size for each element</font>
<font color="black">  90.             in this queue is 8 KB.</font>
<font color="black">  91. </font>
<font color="black">  92.         :param io_chunksize: The max size of each chunk in the io queue.</font>
<font color="black">  93.             Currently, this is size used when reading from the downloaded</font>
<font color="black">  94.             stream as well.</font>
<font color="black">  95. </font>
<font color="black">  96.         :param num_download_attempts: The number of download attempts that</font>
<font color="black">  97.             will be tried upon errors with downloading an object in S3. Note</font>
<font color="black">  98.             that these retries account for errors that occur when streamming</font>
<font color="black">  99.             down the data from s3 (i.e. socket errors and read timeouts that</font>
<font color="black"> 100.             occur after recieving an OK response from s3).</font>
<font color="black"> 101.             Other retryable exceptions such as throttling errors and 5xx errors</font>
<font color="black"> 102.             are already retried by botocore (this default is 5). The</font>
<font color="black"> 103.             ``num_download_attempts`` does not take into account the</font>
<font color="black"> 104.             number of exceptions retried by botocore.</font>
<font color="black"> 105. </font>
<font color="black"> 106.         :param max_in_memory_upload_chunks: The number of chunks that can</font>
<font color="black"> 107.             be stored in memory at a time for all ongoing upload requests.</font>
<font color="black"> 108.             This pertains to chunks of data that need to be stored in memory</font>
<font color="black"> 109.             during an upload if the data is sourced from a file-like object.</font>
<font color="black"> 110.             The total maximum memory footprint due to a in-memory upload</font>
<font color="black"> 111.             chunks is roughly equal to:</font>
<font color="black"> 112. </font>
<font color="black"> 113.                 max_in_memory_upload_chunks * multipart_chunksize</font>
<font color="black"> 114.                 + max_submission_concurrency * multipart_chunksize</font>
<font color="black"> 115. </font>
<font color="black"> 116.             ``max_submission_concurrency`` has an affect on this value because</font>
<font color="black"> 117.             for each thread pulling data off of a file-like object, they may</font>
<font color="black"> 118.             be waiting with a single read chunk to be submitted for upload</font>
<font color="black"> 119.             because the ``max_in_memory_upload_chunks`` value has been reached</font>
<font color="black"> 120.             by the threads making the upload request.</font>
<font color="black"> 121. </font>
<font color="black"> 122.         :param max_in_memory_download_chunks: The number of chunks that can</font>
<font color="black"> 123.             be buffered in memory and **not** in the io queue at a time for all</font>
<font color="black"> 124.             ongoing dowload requests. This pertains specifically to file-like</font>
<font color="black"> 125.             objects that cannot be seeked. The total maximum memory footprint</font>
<font color="black"> 126.             due to a in-memory download chunks is roughly equal to:</font>
<font color="black"> 127. </font>
<font color="black"> 128.                 max_in_memory_download_chunks * multipart_chunksize</font>
<font color="black"> 129. </font>
<font color="black"> 130.         :param max_bandwidth: The maximum bandwidth that will be consumed</font>
<font color="black"> 131.             in uploading and downloading file content. The value is in terms of</font>
<font color="black"> 132.             bytes per second.</font>
<font color="black"> 133.         &quot;&quot;&quot;</font>
<font color="red"> 134.         self.multipart_threshold = multipart_threshold</font>
<font color="red"> 135.         self.multipart_chunksize = multipart_chunksize</font>
<font color="red"> 136.         self.max_request_concurrency = max_request_concurrency</font>
<font color="red"> 137.         self.max_submission_concurrency = max_submission_concurrency</font>
<font color="red"> 138.         self.max_request_queue_size = max_request_queue_size</font>
<font color="red"> 139.         self.max_submission_queue_size = max_submission_queue_size</font>
<font color="red"> 140.         self.max_io_queue_size = max_io_queue_size</font>
<font color="red"> 141.         self.io_chunksize = io_chunksize</font>
<font color="red"> 142.         self.num_download_attempts = num_download_attempts</font>
<font color="red"> 143.         self.max_in_memory_upload_chunks = max_in_memory_upload_chunks</font>
<font color="red"> 144.         self.max_in_memory_download_chunks = max_in_memory_download_chunks</font>
<font color="red"> 145.         self.max_bandwidth = max_bandwidth</font>
<font color="red"> 146.         self._validate_attrs_are_nonzero()</font>
<font color="black"> 147. </font>
<font color="green"> 148.     def _validate_attrs_are_nonzero(self):</font>
<font color="red"> 149.         for attr, attr_val, in self.__dict__.items():</font>
<font color="red"> 150.             if attr_val is not None and attr_val &lt;= 0:</font>
<font color="red"> 151.                 raise ValueError(</font>
<font color="red"> 152.                     'Provided parameter %s of value %s must be greater than '</font>
<font color="red"> 153.                     '0.' % (attr, attr_val))</font>
<font color="black"> 154. </font>
<font color="black"> 155. </font>
<font color="green"> 156. class TransferManager(object):</font>
<font color="black"> 157.     ALLOWED_DOWNLOAD_ARGS = [</font>
<font color="green"> 158.         'VersionId',</font>
<font color="green"> 159.         'SSECustomerAlgorithm',</font>
<font color="green"> 160.         'SSECustomerKey',</font>
<font color="green"> 161.         'SSECustomerKeyMD5',</font>
<font color="green"> 162.         'RequestPayer',</font>
<font color="black"> 163.     ]</font>
<font color="black"> 164. </font>
<font color="black"> 165.     ALLOWED_UPLOAD_ARGS = [</font>
<font color="green"> 166.         'ACL',</font>
<font color="green"> 167.         'CacheControl',</font>
<font color="green"> 168.         'ContentDisposition',</font>
<font color="green"> 169.         'ContentEncoding',</font>
<font color="green"> 170.         'ContentLanguage',</font>
<font color="green"> 171.         'ContentType',</font>
<font color="green"> 172.         'Expires',</font>
<font color="green"> 173.         'GrantFullControl',</font>
<font color="green"> 174.         'GrantRead',</font>
<font color="green"> 175.         'GrantReadACP',</font>
<font color="green"> 176.         'GrantWriteACP',</font>
<font color="green"> 177.         'Metadata',</font>
<font color="green"> 178.         'RequestPayer',</font>
<font color="green"> 179.         'ServerSideEncryption',</font>
<font color="green"> 180.         'StorageClass',</font>
<font color="green"> 181.         'SSECustomerAlgorithm',</font>
<font color="green"> 182.         'SSECustomerKey',</font>
<font color="green"> 183.         'SSECustomerKeyMD5',</font>
<font color="green"> 184.         'SSEKMSKeyId',</font>
<font color="green"> 185.         'WebsiteRedirectLocation'</font>
<font color="black"> 186.     ]</font>
<font color="black"> 187. </font>
<font color="green"> 188.     ALLOWED_COPY_ARGS = ALLOWED_UPLOAD_ARGS + [</font>
<font color="green"> 189.         'CopySourceIfMatch',</font>
<font color="green"> 190.         'CopySourceIfModifiedSince',</font>
<font color="green"> 191.         'CopySourceIfNoneMatch',</font>
<font color="green"> 192.         'CopySourceIfUnmodifiedSince',</font>
<font color="green"> 193.         'CopySourceSSECustomerAlgorithm',</font>
<font color="green"> 194.         'CopySourceSSECustomerKey',</font>
<font color="green"> 195.         'CopySourceSSECustomerKeyMD5',</font>
<font color="green"> 196.         'MetadataDirective'</font>
<font color="black"> 197.     ]</font>
<font color="black"> 198. </font>
<font color="black"> 199.     ALLOWED_DELETE_ARGS = [</font>
<font color="green"> 200.         'MFA',</font>
<font color="green"> 201.         'VersionId',</font>
<font color="green"> 202.         'RequestPayer',</font>
<font color="black"> 203.     ]</font>
<font color="black"> 204. </font>
<font color="green"> 205.     def __init__(self, client, config=None, osutil=None, executor_cls=None):</font>
<font color="black"> 206.         &quot;&quot;&quot;A transfer manager interface for Amazon S3</font>
<font color="black"> 207. </font>
<font color="black"> 208.         :param client: Client to be used by the manager</font>
<font color="black"> 209.         :param config: TransferConfig to associate specific configurations</font>
<font color="black"> 210.         :param osutil: OSUtils object to use for os-related behavior when</font>
<font color="black"> 211.             using with transfer manager.</font>
<font color="black"> 212. </font>
<font color="black"> 213.         :type executor_cls: s3transfer.futures.BaseExecutor</font>
<font color="black"> 214.         :param executor_cls: The class of executor to use with the transfer</font>
<font color="black"> 215.             manager. By default, concurrent.futures.ThreadPoolExecutor is used.</font>
<font color="black"> 216.         &quot;&quot;&quot;</font>
<font color="red"> 217.         self._client = client</font>
<font color="red"> 218.         self._config = config</font>
<font color="red"> 219.         if config is None:</font>
<font color="red"> 220.             self._config = TransferConfig()</font>
<font color="red"> 221.         self._osutil = osutil</font>
<font color="red"> 222.         if osutil is None:</font>
<font color="red"> 223.             self._osutil = OSUtils()</font>
<font color="red"> 224.         self._coordinator_controller = TransferCoordinatorController()</font>
<font color="black"> 225.         # A counter to create unique id's for each transfer submitted.</font>
<font color="red"> 226.         self._id_counter = 0</font>
<font color="black"> 227. </font>
<font color="black"> 228.         # The executor responsible for making S3 API transfer requests</font>
<font color="red"> 229.         self._request_executor = BoundedExecutor(</font>
<font color="red"> 230.             max_size=self._config.max_request_queue_size,</font>
<font color="red"> 231.             max_num_threads=self._config.max_request_concurrency,</font>
<font color="red"> 232.             tag_semaphores={</font>
<font color="red"> 233.                 IN_MEMORY_UPLOAD_TAG: TaskSemaphore(</font>
<font color="red"> 234.                     self._config.max_in_memory_upload_chunks),</font>
<font color="red"> 235.                 IN_MEMORY_DOWNLOAD_TAG: SlidingWindowSemaphore(</font>
<font color="red"> 236.                     self._config.max_in_memory_download_chunks)</font>
<font color="black"> 237.             },</font>
<font color="red"> 238.             executor_cls=executor_cls</font>
<font color="black"> 239.         )</font>
<font color="black"> 240. </font>
<font color="black"> 241.         # The executor responsible for submitting the necessary tasks to</font>
<font color="black"> 242.         # perform the desired transfer</font>
<font color="red"> 243.         self._submission_executor = BoundedExecutor(</font>
<font color="red"> 244.             max_size=self._config.max_submission_queue_size,</font>
<font color="red"> 245.             max_num_threads=self._config.max_submission_concurrency,</font>
<font color="red"> 246.             executor_cls=executor_cls</font>
<font color="black"> 247. </font>
<font color="black"> 248.         )</font>
<font color="black"> 249. </font>
<font color="black"> 250.         # There is one thread available for writing to disk. It will handle</font>
<font color="black"> 251.         # downloads for all files.</font>
<font color="red"> 252.         self._io_executor = BoundedExecutor(</font>
<font color="red"> 253.             max_size=self._config.max_io_queue_size,</font>
<font color="red"> 254.             max_num_threads=1,</font>
<font color="red"> 255.             executor_cls=executor_cls</font>
<font color="black"> 256.         )</font>
<font color="black"> 257. </font>
<font color="black"> 258.         # The component responsible for limiting bandwidth usage if it</font>
<font color="black"> 259.         # is configured.</font>
<font color="red"> 260.         self._bandwidth_limiter = None</font>
<font color="red"> 261.         if self._config.max_bandwidth is not None:</font>
<font color="red"> 262.             logger.debug(</font>
<font color="red"> 263.                 'Setting max_bandwidth to %s', self._config.max_bandwidth)</font>
<font color="red"> 264.             leaky_bucket = LeakyBucket(self._config.max_bandwidth)</font>
<font color="red"> 265.             self._bandwidth_limiter = BandwidthLimiter(leaky_bucket)</font>
<font color="black"> 266. </font>
<font color="red"> 267.         self._register_handlers()</font>
<font color="black"> 268. </font>
<font color="green"> 269.     def upload(self, fileobj, bucket, key, extra_args=None, subscribers=None):</font>
<font color="black"> 270.         &quot;&quot;&quot;Uploads a file to S3</font>
<font color="black"> 271. </font>
<font color="black"> 272.         :type fileobj: str or seekable file-like object</font>
<font color="black"> 273.         :param fileobj: The name of a file to upload or a seekable file-like</font>
<font color="black"> 274.             object to upload. It is recommended to use a filename because</font>
<font color="black"> 275.             file-like objects may result in higher memory usage.</font>
<font color="black"> 276. </font>
<font color="black"> 277.         :type bucket: str</font>
<font color="black"> 278.         :param bucket: The name of the bucket to upload to</font>
<font color="black"> 279. </font>
<font color="black"> 280.         :type key: str</font>
<font color="black"> 281.         :param key: The name of the key to upload to</font>
<font color="black"> 282. </font>
<font color="black"> 283.         :type extra_args: dict</font>
<font color="black"> 284.         :param extra_args: Extra arguments that may be passed to the</font>
<font color="black"> 285.             client operation</font>
<font color="black"> 286. </font>
<font color="black"> 287.         :type subscribers: list(s3transfer.subscribers.BaseSubscriber)</font>
<font color="black"> 288.         :param subscribers: The list of subscribers to be invoked in the</font>
<font color="black"> 289.             order provided based on the event emit during the process of</font>
<font color="black"> 290.             the transfer request.</font>
<font color="black"> 291. </font>
<font color="black"> 292.         :rtype: s3transfer.futures.TransferFuture</font>
<font color="black"> 293.         :returns: Transfer future representing the upload</font>
<font color="black"> 294.         &quot;&quot;&quot;</font>
<font color="red"> 295.         if extra_args is None:</font>
<font color="red"> 296.             extra_args = {}</font>
<font color="red"> 297.         if subscribers is None:</font>
<font color="red"> 298.             subscribers = []</font>
<font color="red"> 299.         self._validate_all_known_args(extra_args, self.ALLOWED_UPLOAD_ARGS)</font>
<font color="red"> 300.         call_args = CallArgs(</font>
<font color="red"> 301.             fileobj=fileobj, bucket=bucket, key=key, extra_args=extra_args,</font>
<font color="red"> 302.             subscribers=subscribers</font>
<font color="black"> 303.         )</font>
<font color="red"> 304.         extra_main_kwargs = {}</font>
<font color="red"> 305.         if self._bandwidth_limiter:</font>
<font color="red"> 306.             extra_main_kwargs['bandwidth_limiter'] = self._bandwidth_limiter</font>
<font color="red"> 307.         return self._submit_transfer(</font>
<font color="red"> 308.             call_args, UploadSubmissionTask, extra_main_kwargs)</font>
<font color="black"> 309. </font>
<font color="green"> 310.     def download(self, bucket, key, fileobj, extra_args=None,</font>
<font color="green"> 311.                  subscribers=None):</font>
<font color="black"> 312.         &quot;&quot;&quot;Downloads a file from S3</font>
<font color="black"> 313. </font>
<font color="black"> 314.         :type bucket: str</font>
<font color="black"> 315.         :param bucket: The name of the bucket to download from</font>
<font color="black"> 316. </font>
<font color="black"> 317.         :type key: str</font>
<font color="black"> 318.         :param key: The name of the key to download from</font>
<font color="black"> 319. </font>
<font color="black"> 320.         :type fileobj: str</font>
<font color="black"> 321.         :param fileobj: The name of a file to download to.</font>
<font color="black"> 322. </font>
<font color="black"> 323.         :type extra_args: dict</font>
<font color="black"> 324.         :param extra_args: Extra arguments that may be passed to the</font>
<font color="black"> 325.             client operation</font>
<font color="black"> 326. </font>
<font color="black"> 327.         :type subscribers: list(s3transfer.subscribers.BaseSubscriber)</font>
<font color="black"> 328.         :param subscribers: The list of subscribers to be invoked in the</font>
<font color="black"> 329.             order provided based on the event emit during the process of</font>
<font color="black"> 330.             the transfer request.</font>
<font color="black"> 331. </font>
<font color="black"> 332.         :rtype: s3transfer.futures.TransferFuture</font>
<font color="black"> 333.         :returns: Transfer future representing the download</font>
<font color="black"> 334.         &quot;&quot;&quot;</font>
<font color="red"> 335.         if extra_args is None:</font>
<font color="red"> 336.             extra_args = {}</font>
<font color="red"> 337.         if subscribers is None:</font>
<font color="red"> 338.             subscribers = []</font>
<font color="red"> 339.         self._validate_all_known_args(extra_args, self.ALLOWED_DOWNLOAD_ARGS)</font>
<font color="red"> 340.         call_args = CallArgs(</font>
<font color="red"> 341.             bucket=bucket, key=key, fileobj=fileobj, extra_args=extra_args,</font>
<font color="red"> 342.             subscribers=subscribers</font>
<font color="black"> 343.         )</font>
<font color="red"> 344.         extra_main_kwargs = {'io_executor': self._io_executor}</font>
<font color="red"> 345.         if self._bandwidth_limiter:</font>
<font color="red"> 346.             extra_main_kwargs['bandwidth_limiter'] = self._bandwidth_limiter</font>
<font color="red"> 347.         return self._submit_transfer(</font>
<font color="red"> 348.             call_args, DownloadSubmissionTask, extra_main_kwargs)</font>
<font color="black"> 349. </font>
<font color="green"> 350.     def copy(self, copy_source, bucket, key, extra_args=None,</font>
<font color="green"> 351.              subscribers=None, source_client=None):</font>
<font color="black"> 352.         &quot;&quot;&quot;Copies a file in S3</font>
<font color="black"> 353. </font>
<font color="black"> 354.         :type copy_source: dict</font>
<font color="black"> 355.         :param copy_source: The name of the source bucket, key name of the</font>
<font color="black"> 356.             source object, and optional version ID of the source object. The</font>
<font color="black"> 357.             dictionary format is:</font>
<font color="black"> 358.             ``{'Bucket': 'bucket', 'Key': 'key', 'VersionId': 'id'}``. Note</font>
<font color="black"> 359.             that the ``VersionId`` key is optional and may be omitted.</font>
<font color="black"> 360. </font>
<font color="black"> 361.         :type bucket: str</font>
<font color="black"> 362.         :param bucket: The name of the bucket to copy to</font>
<font color="black"> 363. </font>
<font color="black"> 364.         :type key: str</font>
<font color="black"> 365.         :param key: The name of the key to copy to</font>
<font color="black"> 366. </font>
<font color="black"> 367.         :type extra_args: dict</font>
<font color="black"> 368.         :param extra_args: Extra arguments that may be passed to the</font>
<font color="black"> 369.             client operation</font>
<font color="black"> 370. </font>
<font color="black"> 371.         :type subscribers: a list of subscribers</font>
<font color="black"> 372.         :param subscribers: The list of subscribers to be invoked in the</font>
<font color="black"> 373.             order provided based on the event emit during the process of</font>
<font color="black"> 374.             the transfer request.</font>
<font color="black"> 375. </font>
<font color="black"> 376.         :type source_client: botocore or boto3 Client</font>
<font color="black"> 377.         :param source_client: The client to be used for operation that</font>
<font color="black"> 378.             may happen at the source object. For example, this client is</font>
<font color="black"> 379.             used for the head_object that determines the size of the copy.</font>
<font color="black"> 380.             If no client is provided, the transfer manager's client is used</font>
<font color="black"> 381.             as the client for the source object.</font>
<font color="black"> 382. </font>
<font color="black"> 383.         :rtype: s3transfer.futures.TransferFuture</font>
<font color="black"> 384.         :returns: Transfer future representing the copy</font>
<font color="black"> 385.         &quot;&quot;&quot;</font>
<font color="red"> 386.         if extra_args is None:</font>
<font color="red"> 387.             extra_args = {}</font>
<font color="red"> 388.         if subscribers is None:</font>
<font color="red"> 389.             subscribers = []</font>
<font color="red"> 390.         if source_client is None:</font>
<font color="red"> 391.             source_client = self._client</font>
<font color="red"> 392.         self._validate_all_known_args(extra_args, self.ALLOWED_COPY_ARGS)</font>
<font color="red"> 393.         call_args = CallArgs(</font>
<font color="red"> 394.             copy_source=copy_source, bucket=bucket, key=key,</font>
<font color="red"> 395.             extra_args=extra_args, subscribers=subscribers,</font>
<font color="red"> 396.             source_client=source_client</font>
<font color="black"> 397.         )</font>
<font color="red"> 398.         return self._submit_transfer(call_args, CopySubmissionTask)</font>
<font color="black"> 399. </font>
<font color="green"> 400.     def delete(self, bucket, key, extra_args=None, subscribers=None):</font>
<font color="black"> 401.         &quot;&quot;&quot;Delete an S3 object.</font>
<font color="black"> 402. </font>
<font color="black"> 403.         :type bucket: str</font>
<font color="black"> 404.         :param bucket: The name of the bucket.</font>
<font color="black"> 405. </font>
<font color="black"> 406.         :type key: str</font>
<font color="black"> 407.         :param key: The name of the S3 object to delete.</font>
<font color="black"> 408. </font>
<font color="black"> 409.         :type extra_args: dict</font>
<font color="black"> 410.         :param extra_args: Extra arguments that may be passed to the</font>
<font color="black"> 411.             DeleteObject call.</font>
<font color="black"> 412. </font>
<font color="black"> 413.         :type subscribers: list</font>
<font color="black"> 414.         :param subscribers: A list of subscribers to be invoked during the</font>
<font color="black"> 415.             process of the transfer request.  Note that the ``on_progress``</font>
<font color="black"> 416.             callback is not invoked during object deletion.</font>
<font color="black"> 417. </font>
<font color="black"> 418.         :rtype: s3transfer.futures.TransferFuture</font>
<font color="black"> 419.         :return: Transfer future representing the deletion.</font>
<font color="black"> 420. </font>
<font color="black"> 421.         &quot;&quot;&quot;</font>
<font color="red"> 422.         if extra_args is None:</font>
<font color="red"> 423.             extra_args = {}</font>
<font color="red"> 424.         if subscribers is None:</font>
<font color="red"> 425.             subscribers = []</font>
<font color="red"> 426.         self._validate_all_known_args(extra_args, self.ALLOWED_DELETE_ARGS)</font>
<font color="red"> 427.         call_args = CallArgs(</font>
<font color="red"> 428.             bucket=bucket, key=key, extra_args=extra_args,</font>
<font color="red"> 429.             subscribers=subscribers</font>
<font color="black"> 430.         )</font>
<font color="red"> 431.         return self._submit_transfer(call_args, DeleteSubmissionTask)</font>
<font color="black"> 432. </font>
<font color="green"> 433.     def _validate_all_known_args(self, actual, allowed):</font>
<font color="red"> 434.         for kwarg in actual:</font>
<font color="red"> 435.             if kwarg not in allowed:</font>
<font color="red"> 436.                 raise ValueError(</font>
<font color="red"> 437.                     &quot;Invalid extra_args key '%s', &quot;</font>
<font color="black"> 438.                     &quot;must be one of: %s&quot; % (</font>
<font color="red"> 439.                         kwarg, ', '.join(allowed)))</font>
<font color="black"> 440. </font>
<font color="black"> 441.     def _submit_transfer(self, call_args, submission_task_cls,</font>
<font color="green"> 442.                          extra_main_kwargs=None):</font>
<font color="red"> 443.         if not extra_main_kwargs:</font>
<font color="red"> 444.             extra_main_kwargs = {}</font>
<font color="black"> 445. </font>
<font color="black"> 446.         # Create a TransferFuture to return back to the user</font>
<font color="red"> 447.         transfer_future, components = self._get_future_with_components(</font>
<font color="red"> 448.             call_args)</font>
<font color="black"> 449. </font>
<font color="black"> 450.         # Add any provided done callbacks to the created transfer future</font>
<font color="black"> 451.         # to be invoked on the transfer future being complete.</font>
<font color="red"> 452.         for callback in get_callbacks(transfer_future, 'done'):</font>
<font color="red"> 453.             components['coordinator'].add_done_callback(callback)</font>
<font color="black"> 454. </font>
<font color="black"> 455.         # Get the main kwargs needed to instantiate the submission task</font>
<font color="red"> 456.         main_kwargs = self._get_submission_task_main_kwargs(</font>
<font color="red"> 457.             transfer_future, extra_main_kwargs)</font>
<font color="black"> 458. </font>
<font color="black"> 459.         # Submit a SubmissionTask that will submit all of the necessary</font>
<font color="black"> 460.         # tasks needed to complete the S3 transfer.</font>
<font color="red"> 461.         self._submission_executor.submit(</font>
<font color="red"> 462.             submission_task_cls(</font>
<font color="red"> 463.                 transfer_coordinator=components['coordinator'],</font>
<font color="red"> 464.                 main_kwargs=main_kwargs</font>
<font color="black"> 465.             )</font>
<font color="black"> 466.         )</font>
<font color="black"> 467. </font>
<font color="black"> 468.         # Increment the unique id counter for future transfer requests</font>
<font color="red"> 469.         self._id_counter += 1</font>
<font color="black"> 470. </font>
<font color="red"> 471.         return transfer_future</font>
<font color="black"> 472. </font>
<font color="green"> 473.     def _get_future_with_components(self, call_args):</font>
<font color="red"> 474.         transfer_id = self._id_counter</font>
<font color="black"> 475.         # Creates a new transfer future along with its components</font>
<font color="red"> 476.         transfer_coordinator = TransferCoordinator(transfer_id=transfer_id)</font>
<font color="black"> 477.         # Track the transfer coordinator for transfers to manage.</font>
<font color="red"> 478.         self._coordinator_controller.add_transfer_coordinator(</font>
<font color="red"> 479.             transfer_coordinator)</font>
<font color="black"> 480.         # Also make sure that the transfer coordinator is removed once</font>
<font color="black"> 481.         # the transfer completes so it does not stick around in memory.</font>
<font color="red"> 482.         transfer_coordinator.add_done_callback(</font>
<font color="red"> 483.             self._coordinator_controller.remove_transfer_coordinator,</font>
<font color="red"> 484.             transfer_coordinator)</font>
<font color="red"> 485.         components = {</font>
<font color="red"> 486.             'meta': TransferMeta(call_args, transfer_id=transfer_id),</font>
<font color="red"> 487.             'coordinator': transfer_coordinator</font>
<font color="black"> 488.         }</font>
<font color="red"> 489.         transfer_future = TransferFuture(**components)</font>
<font color="red"> 490.         return transfer_future, components</font>
<font color="black"> 491. </font>
<font color="green"> 492.     def _get_submission_task_main_kwargs(</font>
<font color="black"> 493.             self, transfer_future, extra_main_kwargs):</font>
<font color="red"> 494.         main_kwargs = {</font>
<font color="red"> 495.             'client': self._client,</font>
<font color="red"> 496.             'config': self._config,</font>
<font color="red"> 497.             'osutil': self._osutil,</font>
<font color="red"> 498.             'request_executor': self._request_executor,</font>
<font color="red"> 499.             'transfer_future': transfer_future</font>
<font color="black"> 500.         }</font>
<font color="red"> 501.         main_kwargs.update(extra_main_kwargs)</font>
<font color="red"> 502.         return main_kwargs</font>
<font color="black"> 503. </font>
<font color="green"> 504.     def _register_handlers(self):</font>
<font color="black"> 505.         # Register handlers to enable/disable callbacks on uploads.</font>
<font color="red"> 506.         event_name = 'request-created.s3'</font>
<font color="red"> 507.         self._client.meta.events.register_first(</font>
<font color="red"> 508.             event_name, signal_not_transferring,</font>
<font color="red"> 509.             unique_id='s3upload-not-transferring')</font>
<font color="red"> 510.         self._client.meta.events.register_last(</font>
<font color="red"> 511.             event_name, signal_transferring,</font>
<font color="red"> 512.             unique_id='s3upload-transferring')</font>
<font color="black"> 513. </font>
<font color="green"> 514.     def __enter__(self):</font>
<font color="red"> 515.         return self</font>
<font color="black"> 516. </font>
<font color="green"> 517.     def __exit__(self, exc_type, exc_value, *args):</font>
<font color="red"> 518.         cancel = False</font>
<font color="red"> 519.         cancel_msg = ''</font>
<font color="red"> 520.         cancel_exc_type = FatalError</font>
<font color="black"> 521.         # If a exception was raised in the context handler, signal to cancel</font>
<font color="black"> 522.         # all of the inprogress futures in the shutdown.</font>
<font color="red"> 523.         if exc_type:</font>
<font color="red"> 524.             cancel = True</font>
<font color="red"> 525.             cancel_msg = six.text_type(exc_value)</font>
<font color="red"> 526.             if not cancel_msg:</font>
<font color="red"> 527.                 cancel_msg = repr(exc_value)</font>
<font color="black"> 528.             # If it was a KeyboardInterrupt, the cancellation was initiated</font>
<font color="black"> 529.             # by the user.</font>
<font color="red"> 530.             if isinstance(exc_value, KeyboardInterrupt):</font>
<font color="red"> 531.                 cancel_exc_type = CancelledError</font>
<font color="red"> 532.         self._shutdown(cancel, cancel_msg, cancel_exc_type)</font>
<font color="black"> 533. </font>
<font color="green"> 534.     def shutdown(self, cancel=False, cancel_msg=''):</font>
<font color="black"> 535.         &quot;&quot;&quot;Shutdown the TransferManager</font>
<font color="black"> 536. </font>
<font color="black"> 537.         It will wait till all transfers complete before it completely shuts</font>
<font color="black"> 538.         down.</font>
<font color="black"> 539. </font>
<font color="black"> 540.         :type cancel: boolean</font>
<font color="black"> 541.         :param cancel: If True, calls TransferFuture.cancel() for</font>
<font color="black"> 542.             all in-progress in transfers. This is useful if you want the</font>
<font color="black"> 543.             shutdown to happen quicker.</font>
<font color="black"> 544. </font>
<font color="black"> 545.         :type cancel_msg: str</font>
<font color="black"> 546.         :param cancel_msg: The message to specify if canceling all in-progress</font>
<font color="black"> 547.             transfers.</font>
<font color="black"> 548.         &quot;&quot;&quot;</font>
<font color="red"> 549.         self._shutdown(cancel, cancel, cancel_msg)</font>
<font color="black"> 550. </font>
<font color="green"> 551.     def _shutdown(self, cancel, cancel_msg, exc_type=CancelledError):</font>
<font color="red"> 552.         if cancel:</font>
<font color="black"> 553.             # Cancel all in-flight transfers if requested, before waiting</font>
<font color="black"> 554.             # for them to complete.</font>
<font color="red"> 555.             self._coordinator_controller.cancel(cancel_msg, exc_type)</font>
<font color="red"> 556.         try:</font>
<font color="black"> 557.             # Wait until there are no more in-progress transfers. This is</font>
<font color="black"> 558.             # wrapped in a try statement because this can be interrupted</font>
<font color="black"> 559.             # with a KeyboardInterrupt that needs to be caught.</font>
<font color="red"> 560.             self._coordinator_controller.wait()</font>
<font color="red"> 561.         except KeyboardInterrupt:</font>
<font color="black"> 562.             # If not errors were raised in the try block, the cancel should</font>
<font color="black"> 563.             # have no coordinators it needs to run cancel on. If there was</font>
<font color="black"> 564.             # an error raised in the try statement we want to cancel all of</font>
<font color="black"> 565.             # the inflight transfers before shutting down to speed that</font>
<font color="black"> 566.             # process up.</font>
<font color="red"> 567.             self._coordinator_controller.cancel('KeyboardInterrupt()')</font>
<font color="red"> 568.             raise</font>
<font color="black"> 569.         finally:</font>
<font color="black"> 570.             # Shutdown all of the executors.</font>
<font color="red"> 571.             self._submission_executor.shutdown()</font>
<font color="red"> 572.             self._request_executor.shutdown()</font>
<font color="red"> 573.             self._io_executor.shutdown()</font>
<font color="black"> 574. </font>
<font color="black"> 575. </font>
<font color="green"> 576. class TransferCoordinatorController(object):</font>
<font color="green"> 577.     def __init__(self):</font>
<font color="black"> 578.         &quot;&quot;&quot;Abstraction to control all transfer coordinators</font>
<font color="black"> 579. </font>
<font color="black"> 580.         This abstraction allows the manager to wait for inprogress transfers</font>
<font color="black"> 581.         to complete and cancel all inprogress transfers.</font>
<font color="black"> 582.         &quot;&quot;&quot;</font>
<font color="red"> 583.         self._lock = threading.Lock()</font>
<font color="red"> 584.         self._tracked_transfer_coordinators = set()</font>
<font color="black"> 585. </font>
<font color="green"> 586.     @property</font>
<font color="black"> 587.     def tracked_transfer_coordinators(self):</font>
<font color="black"> 588.         &quot;&quot;&quot;The set of transfer coordinators being tracked&quot;&quot;&quot;</font>
<font color="red"> 589.         with self._lock:</font>
<font color="black"> 590.             # We return a copy because the set is mutable and if you were to</font>
<font color="black"> 591.             # iterate over the set, it may be changing in length due to</font>
<font color="black"> 592.             # additions and removals of transfer coordinators.</font>
<font color="red"> 593.             return copy.copy(self._tracked_transfer_coordinators)</font>
<font color="black"> 594. </font>
<font color="green"> 595.     def add_transfer_coordinator(self, transfer_coordinator):</font>
<font color="black"> 596.         &quot;&quot;&quot;Adds a transfer coordinator of a transfer to be canceled if needed</font>
<font color="black"> 597. </font>
<font color="black"> 598.         :type transfer_coordinator: s3transfer.futures.TransferCoordinator</font>
<font color="black"> 599.         :param transfer_coordinator: The transfer coordinator for the</font>
<font color="black"> 600.             particular transfer</font>
<font color="black"> 601.         &quot;&quot;&quot;</font>
<font color="red"> 602.         with self._lock:</font>
<font color="red"> 603.             self._tracked_transfer_coordinators.add(transfer_coordinator)</font>
<font color="black"> 604. </font>
<font color="green"> 605.     def remove_transfer_coordinator(self, transfer_coordinator):</font>
<font color="black"> 606.         &quot;&quot;&quot;Remove a transfer coordinator from cancelation consideration</font>
<font color="black"> 607. </font>
<font color="black"> 608.         Typically, this method is invoked by the transfer coordinator itself</font>
<font color="black"> 609.         to remove its self when it completes its transfer.</font>
<font color="black"> 610. </font>
<font color="black"> 611.         :type transfer_coordinator: s3transfer.futures.TransferCoordinator</font>
<font color="black"> 612.         :param transfer_coordinator: The transfer coordinator for the</font>
<font color="black"> 613.             particular transfer</font>
<font color="black"> 614.         &quot;&quot;&quot;</font>
<font color="red"> 615.         with self._lock:</font>
<font color="red"> 616.             self._tracked_transfer_coordinators.remove(transfer_coordinator)</font>
<font color="black"> 617. </font>
<font color="green"> 618.     def cancel(self, msg='', exc_type=CancelledError):</font>
<font color="black"> 619.         &quot;&quot;&quot;Cancels all inprogress transfers</font>
<font color="black"> 620. </font>
<font color="black"> 621.         This cancels the inprogress transfers by calling cancel() on all</font>
<font color="black"> 622.         tracked transfer coordinators.</font>
<font color="black"> 623. </font>
<font color="black"> 624.         :param msg: The message to pass on to each transfer coordinator that</font>
<font color="black"> 625.             gets cancelled.</font>
<font color="black"> 626. </font>
<font color="black"> 627.         :param exc_type: The type of exception to set for the cancellation</font>
<font color="black"> 628.         &quot;&quot;&quot;</font>
<font color="red"> 629.         for transfer_coordinator in self.tracked_transfer_coordinators:</font>
<font color="red"> 630.             transfer_coordinator.cancel(msg, exc_type)</font>
<font color="black"> 631. </font>
<font color="green"> 632.     def wait(self):</font>
<font color="black"> 633.         &quot;&quot;&quot;Wait until there are no more inprogress transfers</font>
<font color="black"> 634. </font>
<font color="black"> 635.         This will not stop when failures are encountered and not propogate any</font>
<font color="black"> 636.         of these errors from failed transfers, but it can be interrupted with</font>
<font color="black"> 637.         a KeyboardInterrupt.</font>
<font color="black"> 638.         &quot;&quot;&quot;</font>
<font color="red"> 639.         try:</font>
<font color="red"> 640.             transfer_coordinator = None</font>
<font color="red"> 641.             for transfer_coordinator in self.tracked_transfer_coordinators:</font>
<font color="red"> 642.                 transfer_coordinator.result()</font>
<font color="red"> 643.         except KeyboardInterrupt:</font>
<font color="red"> 644.             logger.debug('Received KeyboardInterrupt in wait()')</font>
<font color="black"> 645.             # If Keyboard interrupt is raised while waiting for</font>
<font color="black"> 646.             # the result, then exit out of the wait and raise the</font>
<font color="black"> 647.             # exception</font>
<font color="red"> 648.             if transfer_coordinator:</font>
<font color="red"> 649.                 logger.debug(</font>
<font color="red"> 650.                     'On KeyboardInterrupt was waiting for %s',</font>
<font color="red"> 651.                     transfer_coordinator)</font>
<font color="red"> 652.             raise</font>
<font color="red"> 653.         except Exception:</font>
<font color="black"> 654.             # A general exception could have been thrown because</font>
<font color="black"> 655.             # of result(). We just want to ignore this and continue</font>
<font color="black"> 656.             # because we at least know that the transfer coordinator</font>
<font color="black"> 657.             # has completed.</font>
<font color="red"> 658.             pass</font>
</pre>

