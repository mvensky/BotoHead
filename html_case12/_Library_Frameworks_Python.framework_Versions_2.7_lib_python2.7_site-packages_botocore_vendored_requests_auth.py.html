source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/auth.py</b><br>


file stats: <b>141 lines, 30 executed: 21.3% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. </font>
<font color="black">   3. &quot;&quot;&quot;</font>
<font color="black">   4. requests.auth</font>
<font color="black">   5. ~~~~~~~~~~~~~</font>
<font color="black">   6. </font>
<font color="black">   7. This module contains the authentication handlers for Requests.</font>
<font color="green">   8. &quot;&quot;&quot;</font>
<font color="black">   9. </font>
<font color="green">  10. import os</font>
<font color="green">  11. import re</font>
<font color="green">  12. import time</font>
<font color="green">  13. import hashlib</font>
<font color="black">  14. </font>
<font color="green">  15. from base64 import b64encode</font>
<font color="black">  16. </font>
<font color="green">  17. from .compat import urlparse, str</font>
<font color="green">  18. from .cookies import extract_cookies_to_jar</font>
<font color="green">  19. from .utils import parse_dict_header, to_native_string</font>
<font color="green">  20. from .status_codes import codes</font>
<font color="black">  21. </font>
<font color="green">  22. CONTENT_TYPE_FORM_URLENCODED = 'application/x-www-form-urlencoded'</font>
<font color="green">  23. CONTENT_TYPE_MULTI_PART = 'multipart/form-data'</font>
<font color="black">  24. </font>
<font color="black">  25. </font>
<font color="green">  26. def _basic_auth_str(username, password):</font>
<font color="black">  27.     &quot;&quot;&quot;Returns a Basic Auth string.&quot;&quot;&quot;</font>
<font color="black">  28. </font>
<font color="red">  29.     authstr = 'Basic ' + to_native_string(</font>
<font color="red">  30.         b64encode(('%s:%s' % (username, password)).encode('latin1')).strip()</font>
<font color="black">  31.     )</font>
<font color="black">  32. </font>
<font color="red">  33.     return authstr</font>
<font color="black">  34. </font>
<font color="black">  35. </font>
<font color="green">  36. class AuthBase(object):</font>
<font color="green">  37.     &quot;&quot;&quot;Base class that all auth implementations derive from&quot;&quot;&quot;</font>
<font color="black">  38. </font>
<font color="green">  39.     def __call__(self, r):</font>
<font color="red">  40.         raise NotImplementedError('Auth hooks must be callable.')</font>
<font color="black">  41. </font>
<font color="black">  42. </font>
<font color="green">  43. class HTTPBasicAuth(AuthBase):</font>
<font color="green">  44.     &quot;&quot;&quot;Attaches HTTP Basic Authentication to the given Request object.&quot;&quot;&quot;</font>
<font color="green">  45.     def __init__(self, username, password):</font>
<font color="red">  46.         self.username = username</font>
<font color="red">  47.         self.password = password</font>
<font color="black">  48. </font>
<font color="green">  49.     def __call__(self, r):</font>
<font color="red">  50.         r.headers['Authorization'] = _basic_auth_str(self.username, self.password)</font>
<font color="red">  51.         return r</font>
<font color="black">  52. </font>
<font color="black">  53. </font>
<font color="green">  54. class HTTPProxyAuth(HTTPBasicAuth):</font>
<font color="green">  55.     &quot;&quot;&quot;Attaches HTTP Proxy Authentication to a given Request object.&quot;&quot;&quot;</font>
<font color="green">  56.     def __call__(self, r):</font>
<font color="red">  57.         r.headers['Proxy-Authorization'] = _basic_auth_str(self.username, self.password)</font>
<font color="red">  58.         return r</font>
<font color="black">  59. </font>
<font color="black">  60. </font>
<font color="green">  61. class HTTPDigestAuth(AuthBase):</font>
<font color="green">  62.     &quot;&quot;&quot;Attaches HTTP Digest Authentication to the given Request object.&quot;&quot;&quot;</font>
<font color="green">  63.     def __init__(self, username, password):</font>
<font color="red">  64.         self.username = username</font>
<font color="red">  65.         self.password = password</font>
<font color="red">  66.         self.last_nonce = ''</font>
<font color="red">  67.         self.nonce_count = 0</font>
<font color="red">  68.         self.chal = {}</font>
<font color="red">  69.         self.pos = None</font>
<font color="red">  70.         self.num_401_calls = 1</font>
<font color="black">  71. </font>
<font color="green">  72.     def build_digest_header(self, method, url):</font>
<font color="black">  73. </font>
<font color="red">  74.         realm = self.chal['realm']</font>
<font color="red">  75.         nonce = self.chal['nonce']</font>
<font color="red">  76.         qop = self.chal.get('qop')</font>
<font color="red">  77.         algorithm = self.chal.get('algorithm')</font>
<font color="red">  78.         opaque = self.chal.get('opaque')</font>
<font color="black">  79. </font>
<font color="red">  80.         if algorithm is None:</font>
<font color="red">  81.             _algorithm = 'MD5'</font>
<font color="black">  82.         else:</font>
<font color="red">  83.             _algorithm = algorithm.upper()</font>
<font color="black">  84.         # lambdas assume digest modules are imported at the top level</font>
<font color="red">  85.         if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':</font>
<font color="red">  86.             def md5_utf8(x):</font>
<font color="red">  87.                 if isinstance(x, str):</font>
<font color="red">  88.                     x = x.encode('utf-8')</font>
<font color="red">  89.                 return hashlib.md5(x).hexdigest()</font>
<font color="red">  90.             hash_utf8 = md5_utf8</font>
<font color="red">  91.         elif _algorithm == 'SHA':</font>
<font color="red">  92.             def sha_utf8(x):</font>
<font color="red">  93.                 if isinstance(x, str):</font>
<font color="red">  94.                     x = x.encode('utf-8')</font>
<font color="red">  95.                 return hashlib.sha1(x).hexdigest()</font>
<font color="red">  96.             hash_utf8 = sha_utf8</font>
<font color="black">  97. </font>
<font color="red">  98.         KD = lambda s, d: hash_utf8(&quot;%s:%s&quot; % (s, d))</font>
<font color="black">  99. </font>
<font color="red"> 100.         if hash_utf8 is None:</font>
<font color="red"> 101.             return None</font>
<font color="black"> 102. </font>
<font color="black"> 103.         # XXX not implemented yet</font>
<font color="red"> 104.         entdig = None</font>
<font color="red"> 105.         p_parsed = urlparse(url)</font>
<font color="black"> 106.         #: path is request-uri defined in RFC 2616 which should not be empty</font>
<font color="red"> 107.         path = p_parsed.path or &quot;/&quot;</font>
<font color="red"> 108.         if p_parsed.query:</font>
<font color="red"> 109.             path += '?' + p_parsed.query</font>
<font color="black"> 110. </font>
<font color="red"> 111.         A1 = '%s:%s:%s' % (self.username, realm, self.password)</font>
<font color="red"> 112.         A2 = '%s:%s' % (method, path)</font>
<font color="black"> 113. </font>
<font color="red"> 114.         HA1 = hash_utf8(A1)</font>
<font color="red"> 115.         HA2 = hash_utf8(A2)</font>
<font color="black"> 116. </font>
<font color="red"> 117.         if nonce == self.last_nonce:</font>
<font color="red"> 118.             self.nonce_count += 1</font>
<font color="black"> 119.         else:</font>
<font color="red"> 120.             self.nonce_count = 1</font>
<font color="red"> 121.         ncvalue = '%08x' % self.nonce_count</font>
<font color="red"> 122.         s = str(self.nonce_count).encode('utf-8')</font>
<font color="red"> 123.         s += nonce.encode('utf-8')</font>
<font color="red"> 124.         s += time.ctime().encode('utf-8')</font>
<font color="red"> 125.         s += os.urandom(8)</font>
<font color="black"> 126. </font>
<font color="red"> 127.         cnonce = (hashlib.sha1(s).hexdigest()[:16])</font>
<font color="red"> 128.         if _algorithm == 'MD5-SESS':</font>
<font color="red"> 129.             HA1 = hash_utf8('%s:%s:%s' % (HA1, nonce, cnonce))</font>
<font color="black"> 130. </font>
<font color="red"> 131.         if qop is None:</font>
<font color="red"> 132.             respdig = KD(HA1, &quot;%s:%s&quot; % (nonce, HA2))</font>
<font color="red"> 133.         elif qop == 'auth' or 'auth' in qop.split(','):</font>
<font color="red"> 134.             noncebit = &quot;%s:%s:%s:%s:%s&quot; % (</font>
<font color="red"> 135.                 nonce, ncvalue, cnonce, 'auth', HA2</font>
<font color="black"> 136.                 )</font>
<font color="red"> 137.             respdig = KD(HA1, noncebit)</font>
<font color="black"> 138.         else:</font>
<font color="black"> 139.             # XXX handle auth-int.</font>
<font color="red"> 140.             return None</font>
<font color="black"> 141. </font>
<font color="red"> 142.         self.last_nonce = nonce</font>
<font color="black"> 143. </font>
<font color="black"> 144.         # XXX should the partial digests be encoded too?</font>
<font color="red"> 145.         base = 'username=&quot;%s&quot;, realm=&quot;%s&quot;, nonce=&quot;%s&quot;, uri=&quot;%s&quot;, ' \</font>
<font color="red"> 146.                'response=&quot;%s&quot;' % (self.username, realm, nonce, path, respdig)</font>
<font color="red"> 147.         if opaque:</font>
<font color="red"> 148.             base += ', opaque=&quot;%s&quot;' % opaque</font>
<font color="red"> 149.         if algorithm:</font>
<font color="red"> 150.             base += ', algorithm=&quot;%s&quot;' % algorithm</font>
<font color="red"> 151.         if entdig:</font>
<font color="red"> 152.             base += ', digest=&quot;%s&quot;' % entdig</font>
<font color="red"> 153.         if qop:</font>
<font color="red"> 154.             base += ', qop=&quot;auth&quot;, nc=%s, cnonce=&quot;%s&quot;' % (ncvalue, cnonce)</font>
<font color="black"> 155. </font>
<font color="red"> 156.         return 'Digest %s' % (base)</font>
<font color="black"> 157. </font>
<font color="green"> 158.     def handle_redirect(self, r, **kwargs):</font>
<font color="black"> 159.         &quot;&quot;&quot;Reset num_401_calls counter on redirects.&quot;&quot;&quot;</font>
<font color="red"> 160.         if r.is_redirect:</font>
<font color="red"> 161.             self.num_401_calls = 1</font>
<font color="black"> 162. </font>
<font color="green"> 163.     def handle_401(self, r, **kwargs):</font>
<font color="black"> 164.         &quot;&quot;&quot;Takes the given response and tries digest-auth, if needed.&quot;&quot;&quot;</font>
<font color="black"> 165. </font>
<font color="red"> 166.         if self.pos is not None:</font>
<font color="black"> 167.             # Rewind the file position indicator of the body to where</font>
<font color="black"> 168.             # it was to resend the request.</font>
<font color="red"> 169.             r.request.body.seek(self.pos)</font>
<font color="red"> 170.         num_401_calls = getattr(self, 'num_401_calls', 1)</font>
<font color="red"> 171.         s_auth = r.headers.get('www-authenticate', '')</font>
<font color="black"> 172. </font>
<font color="red"> 173.         if 'digest' in s_auth.lower() and num_401_calls &lt; 2:</font>
<font color="black"> 174. </font>
<font color="red"> 175.             self.num_401_calls += 1</font>
<font color="red"> 176.             pat = re.compile(r'digest ', flags=re.IGNORECASE)</font>
<font color="red"> 177.             self.chal = parse_dict_header(pat.sub('', s_auth, count=1))</font>
<font color="black"> 178. </font>
<font color="black"> 179.             # Consume content and release the original connection</font>
<font color="black"> 180.             # to allow our new request to reuse the same one.</font>
<font color="red"> 181.             r.content</font>
<font color="red"> 182.             r.raw.release_conn()</font>
<font color="red"> 183.             prep = r.request.copy()</font>
<font color="red"> 184.             extract_cookies_to_jar(prep._cookies, r.request, r.raw)</font>
<font color="red"> 185.             prep.prepare_cookies(prep._cookies)</font>
<font color="black"> 186. </font>
<font color="red"> 187.             prep.headers['Authorization'] = self.build_digest_header(</font>
<font color="red"> 188.                 prep.method, prep.url)</font>
<font color="red"> 189.             _r = r.connection.send(prep, **kwargs)</font>
<font color="red"> 190.             _r.history.append(r)</font>
<font color="red"> 191.             _r.request = prep</font>
<font color="black"> 192. </font>
<font color="red"> 193.             return _r</font>
<font color="black"> 194. </font>
<font color="red"> 195.         self.num_401_calls = 1</font>
<font color="red"> 196.         return r</font>
<font color="black"> 197. </font>
<font color="green"> 198.     def __call__(self, r):</font>
<font color="black"> 199.         # If we have a saved nonce, skip the 401</font>
<font color="red"> 200.         if self.last_nonce:</font>
<font color="red"> 201.             r.headers['Authorization'] = self.build_digest_header(r.method, r.url)</font>
<font color="red"> 202.         try:</font>
<font color="red"> 203.             self.pos = r.body.tell()</font>
<font color="red"> 204.         except AttributeError:</font>
<font color="black"> 205.             # In the case of HTTPDigestAuth being reused and the body of</font>
<font color="black"> 206.             # the previous request was a file-like object, pos has the</font>
<font color="black"> 207.             # file position of the previous body. Ensure it's set to</font>
<font color="black"> 208.             # None.</font>
<font color="red"> 209.             self.pos = None</font>
<font color="red"> 210.         r.register_hook('response', self.handle_401)</font>
<font color="red"> 211.         r.register_hook('response', self.handle_redirect)</font>
<font color="red"> 212.         return r</font>
</pre>

