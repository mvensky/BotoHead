source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/packages/urllib3/response.py</b><br>


file stats: <b>254 lines, 154 executed: 60.6% covered</b>
<pre>
<font color="green">   1. try:</font>
<font color="green">   2.     import http.client as httplib</font>
<font color="green">   3. except ImportError:</font>
<font color="green">   4.     import httplib</font>
<font color="green">   5. import zlib</font>
<font color="green">   6. import io</font>
<font color="green">   7. from socket import timeout as SocketTimeout</font>
<font color="black">   8. </font>
<font color="green">   9. from ._collections import HTTPHeaderDict</font>
<font color="green">  10. from .exceptions import (</font>
<font color="black">  11.     ProtocolError, DecodeError, ReadTimeoutError, ResponseNotChunked</font>
<font color="black">  12. )</font>
<font color="green">  13. from .packages.six import string_types as basestring, binary_type, PY3</font>
<font color="green">  14. from .connection import HTTPException, BaseSSLError</font>
<font color="green">  15. from .util.response import is_fp_closed</font>
<font color="black">  16. </font>
<font color="black">  17. </font>
<font color="green">  18. class DeflateDecoder(object):</font>
<font color="black">  19. </font>
<font color="green">  20.     def __init__(self):</font>
<font color="red">  21.         self._first_try = True</font>
<font color="red">  22.         self._data = binary_type()</font>
<font color="red">  23.         self._obj = zlib.decompressobj()</font>
<font color="black">  24. </font>
<font color="green">  25.     def __getattr__(self, name):</font>
<font color="red">  26.         return getattr(self._obj, name)</font>
<font color="black">  27. </font>
<font color="green">  28.     def decompress(self, data):</font>
<font color="red">  29.         if not data:</font>
<font color="red">  30.             return data</font>
<font color="black">  31. </font>
<font color="red">  32.         if not self._first_try:</font>
<font color="red">  33.             return self._obj.decompress(data)</font>
<font color="black">  34. </font>
<font color="red">  35.         self._data += data</font>
<font color="red">  36.         try:</font>
<font color="red">  37.             return self._obj.decompress(data)</font>
<font color="red">  38.         except zlib.error:</font>
<font color="red">  39.             self._first_try = False</font>
<font color="red">  40.             self._obj = zlib.decompressobj(-zlib.MAX_WBITS)</font>
<font color="red">  41.             try:</font>
<font color="red">  42.                 return self.decompress(self._data)</font>
<font color="black">  43.             finally:</font>
<font color="red">  44.                 self._data = None</font>
<font color="black">  45. </font>
<font color="black">  46. </font>
<font color="green">  47. class GzipDecoder(object):</font>
<font color="black">  48. </font>
<font color="green">  49.     def __init__(self):</font>
<font color="red">  50.         self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)</font>
<font color="black">  51. </font>
<font color="green">  52.     def __getattr__(self, name):</font>
<font color="red">  53.         return getattr(self._obj, name)</font>
<font color="black">  54. </font>
<font color="green">  55.     def decompress(self, data):</font>
<font color="red">  56.         if not data:</font>
<font color="red">  57.             return data</font>
<font color="red">  58.         return self._obj.decompress(data)</font>
<font color="black">  59. </font>
<font color="black">  60. </font>
<font color="green">  61. def _get_decoder(mode):</font>
<font color="red">  62.     if mode == 'gzip':</font>
<font color="red">  63.         return GzipDecoder()</font>
<font color="black">  64. </font>
<font color="red">  65.     return DeflateDecoder()</font>
<font color="black">  66. </font>
<font color="black">  67. </font>
<font color="green">  68. class HTTPResponse(io.IOBase):</font>
<font color="black">  69.     &quot;&quot;&quot;</font>
<font color="black">  70.     HTTP Response container.</font>
<font color="black">  71. </font>
<font color="black">  72.     Backwards-compatible to httplib's HTTPResponse but the response ``body`` is</font>
<font color="black">  73.     loaded and decoded on-demand when the ``data`` property is accessed.  This</font>
<font color="black">  74.     class is also compatible with the Python standard library's :mod:`io`</font>
<font color="black">  75.     module, and can hence be treated as a readable object in the context of that</font>
<font color="black">  76.     framework.</font>
<font color="black">  77. </font>
<font color="black">  78.     Extra parameters for behaviour not present in httplib.HTTPResponse:</font>
<font color="black">  79. </font>
<font color="black">  80.     :param preload_content:</font>
<font color="black">  81.         If True, the response's body will be preloaded during construction.</font>
<font color="black">  82. </font>
<font color="black">  83.     :param decode_content:</font>
<font color="black">  84.         If True, attempts to decode specific content-encoding's based on headers</font>
<font color="black">  85.         (like 'gzip' and 'deflate') will be skipped and raw data will be used</font>
<font color="black">  86.         instead.</font>
<font color="black">  87. </font>
<font color="black">  88.     :param original_response:</font>
<font color="black">  89.         When this HTTPResponse wrapper is generated from an httplib.HTTPResponse</font>
<font color="black">  90.         object, it's convenient to include the original for debug purposes. It's</font>
<font color="black">  91.         otherwise unused.</font>
<font color="green">  92.     &quot;&quot;&quot;</font>
<font color="black">  93. </font>
<font color="green">  94.     CONTENT_DECODERS = ['gzip', 'deflate']</font>
<font color="green">  95.     REDIRECT_STATUSES = [301, 302, 303, 307, 308]</font>
<font color="black">  96. </font>
<font color="green">  97.     def __init__(self, body='', headers=None, status=0, version=0, reason=None,</font>
<font color="green">  98.                  strict=0, preload_content=True, decode_content=True,</font>
<font color="green">  99.                  original_response=None, pool=None, connection=None):</font>
<font color="black"> 100. </font>
<font color="green"> 101.         if isinstance(headers, HTTPHeaderDict):</font>
<font color="green"> 102.             self.headers = headers</font>
<font color="black"> 103.         else:</font>
<font color="red"> 104.             self.headers = HTTPHeaderDict(headers)</font>
<font color="green"> 105.         self.status = status</font>
<font color="green"> 106.         self.version = version</font>
<font color="green"> 107.         self.reason = reason</font>
<font color="green"> 108.         self.strict = strict</font>
<font color="green"> 109.         self.decode_content = decode_content</font>
<font color="black"> 110. </font>
<font color="green"> 111.         self._decoder = None</font>
<font color="green"> 112.         self._body = None</font>
<font color="green"> 113.         self._fp = None</font>
<font color="green"> 114.         self._original_response = original_response</font>
<font color="green"> 115.         self._fp_bytes_read = 0</font>
<font color="black"> 116. </font>
<font color="green"> 117.         if body and isinstance(body, (basestring, binary_type)):</font>
<font color="red"> 118.             self._body = body</font>
<font color="black"> 119. </font>
<font color="green"> 120.         self._pool = pool</font>
<font color="green"> 121.         self._connection = connection</font>
<font color="black"> 122. </font>
<font color="green"> 123.         if hasattr(body, 'read'):</font>
<font color="green"> 124.             self._fp = body</font>
<font color="black"> 125. </font>
<font color="black"> 126.         # Are we using the chunked-style of transfer encoding?</font>
<font color="green"> 127.         self.chunked = False</font>
<font color="green"> 128.         self.chunk_left = None</font>
<font color="green"> 129.         tr_enc = self.headers.get('transfer-encoding', '').lower()</font>
<font color="black"> 130.         # Don't incur the penalty of creating a list and then discarding it</font>
<font color="green"> 131.         encodings = (enc.strip() for enc in tr_enc.split(&quot;,&quot;))</font>
<font color="green"> 132.         if &quot;chunked&quot; in encodings:</font>
<font color="green"> 133.             self.chunked = True</font>
<font color="black"> 134. </font>
<font color="black"> 135.         # We certainly don't want to preload content when the response is chunked.</font>
<font color="green"> 136.         if not self.chunked and preload_content and not self._body:</font>
<font color="red"> 137.             self._body = self.read(decode_content=decode_content)</font>
<font color="black"> 138. </font>
<font color="green"> 139.     def get_redirect_location(self):</font>
<font color="black"> 140.         &quot;&quot;&quot;</font>
<font color="black"> 141.         Should we redirect and where to?</font>
<font color="black"> 142. </font>
<font color="black"> 143.         :returns: Truthy redirect location string if we got a redirect status</font>
<font color="black"> 144.             code and valid location. ``None`` if redirect status and no</font>
<font color="black"> 145.             location. ``False`` if not a redirect status code.</font>
<font color="black"> 146.         &quot;&quot;&quot;</font>
<font color="red"> 147.         if self.status in self.REDIRECT_STATUSES:</font>
<font color="red"> 148.             return self.headers.get('location')</font>
<font color="black"> 149. </font>
<font color="red"> 150.         return False</font>
<font color="black"> 151. </font>
<font color="green"> 152.     def release_conn(self):</font>
<font color="green"> 153.         if not self._pool or not self._connection:</font>
<font color="red"> 154.             return</font>
<font color="black"> 155. </font>
<font color="green"> 156.         self._pool._put_conn(self._connection)</font>
<font color="green"> 157.         self._connection = None</font>
<font color="black"> 158. </font>
<font color="green"> 159.     @property</font>
<font color="black"> 160.     def data(self):</font>
<font color="black"> 161.         # For backwords-compat with earlier urllib3 0.4 and earlier.</font>
<font color="red"> 162.         if self._body:</font>
<font color="red"> 163.             return self._body</font>
<font color="black"> 164. </font>
<font color="red"> 165.         if self._fp:</font>
<font color="red"> 166.             return self.read(cache_content=True)</font>
<font color="black"> 167. </font>
<font color="green"> 168.     def tell(self):</font>
<font color="black"> 169.         &quot;&quot;&quot;</font>
<font color="black"> 170.         Obtain the number of bytes pulled over the wire so far. May differ from</font>
<font color="black"> 171.         the amount of content returned by :meth:``HTTPResponse.read`` if bytes</font>
<font color="black"> 172.         are encoded on the wire (e.g, compressed).</font>
<font color="black"> 173.         &quot;&quot;&quot;</font>
<font color="red"> 174.         return self._fp_bytes_read</font>
<font color="black"> 175. </font>
<font color="green"> 176.     def _init_decoder(self):</font>
<font color="black"> 177.         &quot;&quot;&quot;</font>
<font color="black"> 178.         Set-up the _decoder attribute if necessar.</font>
<font color="black"> 179.         &quot;&quot;&quot;</font>
<font color="black"> 180.         # Note: content-encoding value should be case-insensitive, per RFC 7230</font>
<font color="black"> 181.         # Section 3.2</font>
<font color="green"> 182.         content_encoding = self.headers.get('content-encoding', '').lower()</font>
<font color="green"> 183.         if self._decoder is None and content_encoding in self.CONTENT_DECODERS:</font>
<font color="red"> 184.             self._decoder = _get_decoder(content_encoding)</font>
<font color="black"> 185. </font>
<font color="green"> 186.     def _decode(self, data, decode_content, flush_decoder):</font>
<font color="black"> 187.         &quot;&quot;&quot;</font>
<font color="black"> 188.         Decode the data passed in and potentially flush the decoder.</font>
<font color="black"> 189.         &quot;&quot;&quot;</font>
<font color="green"> 190.         try:</font>
<font color="green"> 191.             if decode_content and self._decoder:</font>
<font color="red"> 192.                 data = self._decoder.decompress(data)</font>
<font color="red"> 193.         except (IOError, zlib.error) as e:</font>
<font color="red"> 194.             content_encoding = self.headers.get('content-encoding', '').lower()</font>
<font color="red"> 195.             raise DecodeError(</font>
<font color="red"> 196.                 &quot;Received response with content-encoding: %s, but &quot;</font>
<font color="red"> 197.                 &quot;failed to decode it.&quot; % content_encoding, e)</font>
<font color="black"> 198. </font>
<font color="green"> 199.         if flush_decoder and decode_content and self._decoder:</font>
<font color="red"> 200.             buf = self._decoder.decompress(binary_type())</font>
<font color="red"> 201.             data += buf + self._decoder.flush()</font>
<font color="black"> 202. </font>
<font color="green"> 203.         return data</font>
<font color="black"> 204. </font>
<font color="green"> 205.     def read(self, amt=None, decode_content=None, cache_content=False):</font>
<font color="black"> 206.         &quot;&quot;&quot;</font>
<font color="black"> 207.         Similar to :meth:`httplib.HTTPResponse.read`, but with two additional</font>
<font color="black"> 208.         parameters: ``decode_content`` and ``cache_content``.</font>
<font color="black"> 209. </font>
<font color="black"> 210.         :param amt:</font>
<font color="black"> 211.             How much of the content to read. If specified, caching is skipped</font>
<font color="black"> 212.             because it doesn't make sense to cache partial content as the full</font>
<font color="black"> 213.             response.</font>
<font color="black"> 214. </font>
<font color="black"> 215.         :param decode_content:</font>
<font color="black"> 216.             If True, will attempt to decode the body based on the</font>
<font color="black"> 217.             'content-encoding' header.</font>
<font color="black"> 218. </font>
<font color="black"> 219.         :param cache_content:</font>
<font color="black"> 220.             If True, will save the returned data such that the same result is</font>
<font color="black"> 221.             returned despite of the state of the underlying file object. This</font>
<font color="black"> 222.             is useful if you want the ``.data`` property to continue working</font>
<font color="black"> 223.             after having ``.read()`` the file object. (Overridden if ``amt`` is</font>
<font color="black"> 224.             set.)</font>
<font color="black"> 225.         &quot;&quot;&quot;</font>
<font color="green"> 226.         self._init_decoder()</font>
<font color="green"> 227.         if decode_content is None:</font>
<font color="red"> 228.             decode_content = self.decode_content</font>
<font color="black"> 229. </font>
<font color="green"> 230.         if self._fp is None:</font>
<font color="red"> 231.             return</font>
<font color="black"> 232. </font>
<font color="green"> 233.         flush_decoder = False</font>
<font color="black"> 234. </font>
<font color="green"> 235.         try:</font>
<font color="green"> 236.             try:</font>
<font color="green"> 237.                 if amt is None:</font>
<font color="black"> 238.                     # cStringIO doesn't like amt=None</font>
<font color="red"> 239.                     data = self._fp.read()</font>
<font color="red"> 240.                     flush_decoder = True</font>
<font color="black"> 241.                 else:</font>
<font color="green"> 242.                     cache_content = False</font>
<font color="green"> 243.                     data = self._fp.read(amt)</font>
<font color="green"> 244.                     if amt != 0 and not data:  # Platform-specific: Buggy versions of Python.</font>
<font color="black"> 245.                         # Close the connection when no data is returned</font>
<font color="black"> 246.                         #</font>
<font color="black"> 247.                         # This is redundant to what httplib/http.client _should_</font>
<font color="black"> 248.                         # already do.  However, versions of python released before</font>
<font color="black"> 249.                         # December 15, 2012 (http://bugs.python.org/issue16298) do</font>
<font color="black"> 250.                         # not properly close the connection in all cases. There is</font>
<font color="black"> 251.                         # no harm in redundantly calling close.</font>
<font color="green"> 252.                         self._fp.close()</font>
<font color="green"> 253.                         flush_decoder = True</font>
<font color="black"> 254. </font>
<font color="red"> 255.             except SocketTimeout:</font>
<font color="black"> 256.                 # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but</font>
<font color="black"> 257.                 # there is yet no clean way to get at it from this context.</font>
<font color="red"> 258.                 raise ReadTimeoutError(self._pool, None, 'Read timed out.')</font>
<font color="black"> 259. </font>
<font color="red"> 260.             except BaseSSLError as e:</font>
<font color="black"> 261.                 # FIXME: Is there a better way to differentiate between SSLErrors?</font>
<font color="red"> 262.                 if 'read operation timed out' not in str(e):  # Defensive:</font>
<font color="black"> 263.                     # This shouldn't happen but just in case we're missing an edge</font>
<font color="black"> 264.                     # case, let's avoid swallowing SSL errors.</font>
<font color="red"> 265.                     raise</font>
<font color="black"> 266. </font>
<font color="red"> 267.                 raise ReadTimeoutError(self._pool, None, 'Read timed out.')</font>
<font color="black"> 268. </font>
<font color="red"> 269.             except HTTPException as e:</font>
<font color="black"> 270.                 # This includes IncompleteRead.</font>
<font color="red"> 271.                 raise ProtocolError('Connection broken: %r' % e, e)</font>
<font color="black"> 272. </font>
<font color="green"> 273.             self._fp_bytes_read += len(data)</font>
<font color="black"> 274. </font>
<font color="green"> 275.             data = self._decode(data, decode_content, flush_decoder)</font>
<font color="black"> 276. </font>
<font color="green"> 277.             if cache_content:</font>
<font color="red"> 278.                 self._body = data</font>
<font color="black"> 279. </font>
<font color="green"> 280.             return data</font>
<font color="black"> 281. </font>
<font color="black"> 282.         finally:</font>
<font color="green"> 283.             if self._original_response and self._original_response.isclosed():</font>
<font color="green"> 284.                 self.release_conn()</font>
<font color="black"> 285. </font>
<font color="green"> 286.     def stream(self, amt=2**16, decode_content=None):</font>
<font color="black"> 287.         &quot;&quot;&quot;</font>
<font color="black"> 288.         A generator wrapper for the read() method. A call will block until</font>
<font color="black"> 289.         ``amt`` bytes have been read from the connection or until the</font>
<font color="black"> 290.         connection is closed.</font>
<font color="black"> 291. </font>
<font color="black"> 292.         :param amt:</font>
<font color="black"> 293.             How much of the content to read. The generator will return up to</font>
<font color="black"> 294.             much data per iteration, but may return less. This is particularly</font>
<font color="black"> 295.             likely when using compressed data. However, the empty string will</font>
<font color="black"> 296.             never be returned.</font>
<font color="black"> 297. </font>
<font color="black"> 298.         :param decode_content:</font>
<font color="black"> 299.             If True, will attempt to decode the body based on the</font>
<font color="black"> 300.             'content-encoding' header.</font>
<font color="black"> 301.         &quot;&quot;&quot;</font>
<font color="green"> 302.         if self.chunked:</font>
<font color="green"> 303.             for line in self.read_chunked(amt, decode_content=decode_content):</font>
<font color="green"> 304.                 yield line</font>
<font color="black"> 305.         else:</font>
<font color="green"> 306.             while not is_fp_closed(self._fp):</font>
<font color="green"> 307.                 data = self.read(amt=amt, decode_content=decode_content)</font>
<font color="black"> 308. </font>
<font color="green"> 309.                 if data:</font>
<font color="red"> 310.                     yield data</font>
<font color="black"> 311. </font>
<font color="green"> 312.     @classmethod</font>
<font color="black"> 313.     def from_httplib(ResponseCls, r, **response_kw):</font>
<font color="black"> 314.         &quot;&quot;&quot;</font>
<font color="black"> 315.         Given an :class:`httplib.HTTPResponse` instance ``r``, return a</font>
<font color="black"> 316.         corresponding :class:`urllib3.response.HTTPResponse` object.</font>
<font color="black"> 317. </font>
<font color="black"> 318.         Remaining parameters are passed to the HTTPResponse constructor, along</font>
<font color="black"> 319.         with ``original_response=r``.</font>
<font color="black"> 320.         &quot;&quot;&quot;</font>
<font color="green"> 321.         headers = r.msg</font>
<font color="green"> 322.         if not isinstance(headers, HTTPHeaderDict):</font>
<font color="green"> 323.             if PY3: # Python 3</font>
<font color="red"> 324.                 headers = HTTPHeaderDict(headers.items())</font>
<font color="black"> 325.             else: # Python 2</font>
<font color="green"> 326.                 headers = HTTPHeaderDict.from_httplib(headers)</font>
<font color="black"> 327. </font>
<font color="black"> 328.         # HTTPResponse objects in Python 3 don't have a .strict attribute</font>
<font color="green"> 329.         strict = getattr(r, 'strict', 0)</font>
<font color="green"> 330.         resp = ResponseCls(body=r,</font>
<font color="green"> 331.                            headers=headers,</font>
<font color="green"> 332.                            status=r.status,</font>
<font color="green"> 333.                            version=r.version,</font>
<font color="green"> 334.                            reason=r.reason,</font>
<font color="green"> 335.                            strict=strict,</font>
<font color="green"> 336.                            original_response=r,</font>
<font color="green"> 337.                            **response_kw)</font>
<font color="green"> 338.         return resp</font>
<font color="black"> 339. </font>
<font color="black"> 340.     # Backwards-compatibility methods for httplib.HTTPResponse</font>
<font color="green"> 341.     def getheaders(self):</font>
<font color="red"> 342.         return self.headers</font>
<font color="black"> 343. </font>
<font color="green"> 344.     def getheader(self, name, default=None):</font>
<font color="red"> 345.         return self.headers.get(name, default)</font>
<font color="black"> 346. </font>
<font color="black"> 347.     # Overrides from io.IOBase</font>
<font color="green"> 348.     def close(self):</font>
<font color="red"> 349.         if not self.closed:</font>
<font color="red"> 350.             self._fp.close()</font>
<font color="black"> 351. </font>
<font color="green"> 352.     @property</font>
<font color="black"> 353.     def closed(self):</font>
<font color="green"> 354.         if self._fp is None:</font>
<font color="red"> 355.             return True</font>
<font color="green"> 356.         elif hasattr(self._fp, 'closed'):</font>
<font color="red"> 357.             return self._fp.closed</font>
<font color="green"> 358.         elif hasattr(self._fp, 'isclosed'):  # Python 2</font>
<font color="green"> 359.             return self._fp.isclosed()</font>
<font color="black"> 360.         else:</font>
<font color="red"> 361.             return True</font>
<font color="black"> 362. </font>
<font color="green"> 363.     def fileno(self):</font>
<font color="red"> 364.         if self._fp is None:</font>
<font color="red"> 365.             raise IOError(&quot;HTTPResponse has no file to get a fileno from&quot;)</font>
<font color="red"> 366.         elif hasattr(self._fp, &quot;fileno&quot;):</font>
<font color="red"> 367.             return self._fp.fileno()</font>
<font color="black"> 368.         else:</font>
<font color="red"> 369.             raise IOError(&quot;The file-like object this HTTPResponse is wrapped &quot;</font>
<font color="black"> 370.                           &quot;around has no file descriptor&quot;)</font>
<font color="black"> 371. </font>
<font color="green"> 372.     def flush(self):</font>
<font color="red"> 373.         if self._fp is not None and hasattr(self._fp, 'flush'):</font>
<font color="red"> 374.             return self._fp.flush()</font>
<font color="black"> 375. </font>
<font color="green"> 376.     def readable(self):</font>
<font color="black"> 377.         # This method is required for `io` module compatibility.</font>
<font color="red"> 378.         return True</font>
<font color="black"> 379. </font>
<font color="green"> 380.     def readinto(self, b):</font>
<font color="black"> 381.         # This method is required for `io` module compatibility.</font>
<font color="red"> 382.         temp = self.read(len(b))</font>
<font color="red"> 383.         if len(temp) == 0:</font>
<font color="red"> 384.             return 0</font>
<font color="black"> 385.         else:</font>
<font color="red"> 386.             b[:len(temp)] = temp</font>
<font color="red"> 387.             return len(temp)</font>
<font color="black"> 388. </font>
<font color="green"> 389.     def _update_chunk_length(self):</font>
<font color="black"> 390.         # First, we'll figure out length of a chunk and then</font>
<font color="black"> 391.         # we'll try to read it from socket.</font>
<font color="green"> 392.         if self.chunk_left is not None:</font>
<font color="red"> 393.             return</font>
<font color="green"> 394.         line = self._fp.fp.readline()</font>
<font color="green"> 395.         line = line.split(b';', 1)[0]</font>
<font color="green"> 396.         try:</font>
<font color="green"> 397.             self.chunk_left = int(line, 16)</font>
<font color="red"> 398.         except ValueError:</font>
<font color="black"> 399.             # Invalid chunked protocol response, abort.</font>
<font color="red"> 400.             self.close()</font>
<font color="red"> 401.             raise httplib.IncompleteRead(line)</font>
<font color="black"> 402. </font>
<font color="green"> 403.     def _handle_chunk(self, amt):</font>
<font color="green"> 404.         returned_chunk = None</font>
<font color="green"> 405.         if amt is None:</font>
<font color="red"> 406.             chunk = self._fp._safe_read(self.chunk_left)</font>
<font color="red"> 407.             returned_chunk = chunk</font>
<font color="red"> 408.             self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.</font>
<font color="red"> 409.             self.chunk_left = None</font>
<font color="green"> 410.         elif amt &lt; self.chunk_left:</font>
<font color="red"> 411.             value = self._fp._safe_read(amt)</font>
<font color="red"> 412.             self.chunk_left = self.chunk_left - amt</font>
<font color="red"> 413.             returned_chunk = value</font>
<font color="green"> 414.         elif amt == self.chunk_left:</font>
<font color="red"> 415.             value = self._fp._safe_read(amt)</font>
<font color="red"> 416.             self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.</font>
<font color="red"> 417.             self.chunk_left = None</font>
<font color="red"> 418.             returned_chunk = value</font>
<font color="black"> 419.         else:  # amt &gt; self.chunk_left</font>
<font color="green"> 420.             returned_chunk = self._fp._safe_read(self.chunk_left)</font>
<font color="green"> 421.             self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.</font>
<font color="green"> 422.             self.chunk_left = None</font>
<font color="green"> 423.         return returned_chunk</font>
<font color="black"> 424. </font>
<font color="green"> 425.     def read_chunked(self, amt=None, decode_content=None):</font>
<font color="black"> 426.         &quot;&quot;&quot;</font>
<font color="black"> 427.         Similar to :meth:`HTTPResponse.read`, but with an additional</font>
<font color="black"> 428.         parameter: ``decode_content``.</font>
<font color="black"> 429. </font>
<font color="black"> 430.         :param decode_content:</font>
<font color="black"> 431.             If True, will attempt to decode the body based on the</font>
<font color="black"> 432.             'content-encoding' header.</font>
<font color="black"> 433.         &quot;&quot;&quot;</font>
<font color="green"> 434.         self._init_decoder()</font>
<font color="black"> 435.         # FIXME: Rewrite this method and make it a class with a better structured logic.</font>
<font color="green"> 436.         if not self.chunked:</font>
<font color="red"> 437.             raise ResponseNotChunked(&quot;Response is not chunked. &quot;</font>
<font color="black"> 438.                 &quot;Header 'transfer-encoding: chunked' is missing.&quot;)</font>
<font color="black"> 439. </font>
<font color="green"> 440.         if self._original_response and self._original_response._method.upper() == 'HEAD':</font>
<font color="black"> 441.             # Don't bother reading the body of a HEAD request.</font>
<font color="black"> 442.             # FIXME: Can we do this somehow without accessing private httplib _method?</font>
<font color="red"> 443.             self._original_response.close()</font>
<font color="red"> 444.             return</font>
<font color="black"> 445. </font>
<font color="green"> 446.         while True:</font>
<font color="green"> 447.             self._update_chunk_length()</font>
<font color="green"> 448.             if self.chunk_left == 0:</font>
<font color="green"> 449.                 break</font>
<font color="green"> 450.             chunk = self._handle_chunk(amt)</font>
<font color="green"> 451.             yield self._decode(chunk, decode_content=decode_content,</font>
<font color="green"> 452.                                flush_decoder=True)</font>
<font color="black"> 453. </font>
<font color="black"> 454.         # Chunk content ends with \r\n: discard it.</font>
<font color="green"> 455.         while True:</font>
<font color="green"> 456.             line = self._fp.fp.readline()</font>
<font color="green"> 457.             if not line:</font>
<font color="black"> 458.                 # Some sites may not end with '\r\n'.</font>
<font color="red"> 459.                 break</font>
<font color="green"> 460.             if line == b'\r\n':</font>
<font color="green"> 461.                 break</font>
<font color="black"> 462. </font>
<font color="black"> 463.         # We read everything; close the &quot;file&quot;.</font>
<font color="green"> 464.         if self._original_response:</font>
<font color="green"> 465.             self._original_response.close()</font>
<font color="green"> 466.         self.release_conn()</font>
</pre>

