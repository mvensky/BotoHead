source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/jmespath/compat.py</b><br>


file stats: <b>37 lines, 21 executed: 56.8% covered</b>
<pre>
<font color="green">   1. import sys</font>
<font color="green">   2. import inspect</font>
<font color="black">   3. </font>
<font color="green">   4. PY2 = sys.version_info[0] == 2</font>
<font color="black">   5. </font>
<font color="green">   6. if PY2:</font>
<font color="green">   7.     text_type = unicode</font>
<font color="green">   8.     string_type = basestring</font>
<font color="green">   9.     from itertools import izip_longest as zip_longest</font>
<font color="black">  10. </font>
<font color="green">  11.     def with_str_method(cls):</font>
<font color="black">  12.         &quot;&quot;&quot;Class decorator that handles __str__ compat between py2 and py3.&quot;&quot;&quot;</font>
<font color="black">  13.         # In python2, the __str__ should be __unicode__</font>
<font color="black">  14.         # and __str__ should return bytes.</font>
<font color="green">  15.         cls.__unicode__ = cls.__str__</font>
<font color="green">  16.         def __str__(self):</font>
<font color="red">  17.             return self.__unicode__().encode('utf-8')</font>
<font color="green">  18.         cls.__str__ = __str__</font>
<font color="green">  19.         return cls</font>
<font color="black">  20. </font>
<font color="green">  21.     def with_repr_method(cls):</font>
<font color="black">  22.         &quot;&quot;&quot;Class decorator that handle __repr__ with py2 and py3.&quot;&quot;&quot;</font>
<font color="black">  23.         # This is almost the same thing as with_str_method *except*</font>
<font color="black">  24.         # it uses the unicode_escape encoding.  This also means we need to be</font>
<font color="black">  25.         # careful encoding the input multiple times, so we only encode</font>
<font color="black">  26.         # if we get a unicode type.</font>
<font color="green">  27.         original_repr_method = cls.__repr__</font>
<font color="green">  28.         def __repr__(self):</font>
<font color="red">  29.             original_repr = original_repr_method(self)</font>
<font color="red">  30.             if isinstance(original_repr, text_type):</font>
<font color="red">  31.                 original_repr = original_repr.encode('unicode_escape')</font>
<font color="red">  32.             return original_repr</font>
<font color="green">  33.         cls.__repr__ = __repr__</font>
<font color="green">  34.         return cls</font>
<font color="black">  35. </font>
<font color="green">  36.     def get_methods(cls):</font>
<font color="green">  37.         for name, method in inspect.getmembers(cls,</font>
<font color="green">  38.                                                predicate=inspect.ismethod):</font>
<font color="green">  39.             yield name, method</font>
<font color="black">  40. </font>
<font color="black">  41. else:</font>
<font color="red">  42.     text_type = str</font>
<font color="red">  43.     string_type = str</font>
<font color="red">  44.     from itertools import zip_longest</font>
<font color="black">  45. </font>
<font color="red">  46.     def with_str_method(cls):</font>
<font color="black">  47.         # In python3, we don't need to do anything, we return a str type.</font>
<font color="red">  48.         return cls</font>
<font color="black">  49. </font>
<font color="red">  50.     def with_repr_method(cls):</font>
<font color="red">  51.         return cls</font>
<font color="black">  52. </font>
<font color="red">  53.     def get_methods(cls):</font>
<font color="red">  54.         for name, method in inspect.getmembers(cls,</font>
<font color="red">  55.                                                predicate=inspect.isfunction):</font>
<font color="red">  56.             yield name, method</font>
</pre>

