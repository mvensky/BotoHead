source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/enum/__init__.py</b><br>


file stats: <b>461 lines, 252 executed: 54.7% covered</b>
<pre>
<font color="green">   1. &quot;&quot;&quot;Python Enumerations&quot;&quot;&quot;</font>
<font color="black">   2. </font>
<font color="green">   3. import sys as _sys</font>
<font color="black">   4. </font>
<font color="green">   5. __all__ = ['Enum', 'IntEnum', 'unique']</font>
<font color="black">   6. </font>
<font color="green">   7. version = 1, 1, 6</font>
<font color="black">   8. </font>
<font color="green">   9. pyver = float('%s.%s' % _sys.version_info[:2])</font>
<font color="black">  10. </font>
<font color="green">  11. try:</font>
<font color="green">  12.     any</font>
<font color="red">  13. except NameError:</font>
<font color="red">  14.     def any(iterable):</font>
<font color="red">  15.         for element in iterable:</font>
<font color="red">  16.             if element:</font>
<font color="red">  17.                 return True</font>
<font color="red">  18.         return False</font>
<font color="black">  19. </font>
<font color="green">  20. try:</font>
<font color="green">  21.     from collections import OrderedDict</font>
<font color="red">  22. except ImportError:</font>
<font color="red">  23.     OrderedDict = None</font>
<font color="black">  24. </font>
<font color="green">  25. try:</font>
<font color="green">  26.     basestring</font>
<font color="red">  27. except NameError:</font>
<font color="black">  28.     # In Python 2 basestring is the ancestor of both str and unicode</font>
<font color="black">  29.     # in Python 3 it's just str, but was missing in 3.1</font>
<font color="red">  30.     basestring = str</font>
<font color="black">  31. </font>
<font color="green">  32. try:</font>
<font color="green">  33.     unicode</font>
<font color="red">  34. except NameError:</font>
<font color="black">  35.     # In Python 3 unicode no longer exists (it's just str)</font>
<font color="red">  36.     unicode = str</font>
<font color="black">  37. </font>
<font color="green">  38. class _RouteClassAttributeToGetattr(object):</font>
<font color="black">  39.     &quot;&quot;&quot;Route attribute access on a class to __getattr__.</font>
<font color="black">  40. </font>
<font color="black">  41.     This is a descriptor, used to define attributes that act differently when</font>
<font color="black">  42.     accessed through an instance and through a class.  Instance access remains</font>
<font color="black">  43.     normal, but access to an attribute through a class will be routed to the</font>
<font color="black">  44.     class's __getattr__ method; this is done by raising AttributeError.</font>
<font color="black">  45. </font>
<font color="green">  46.     &quot;&quot;&quot;</font>
<font color="green">  47.     def __init__(self, fget=None):</font>
<font color="green">  48.         self.fget = fget</font>
<font color="black">  49. </font>
<font color="green">  50.     def __get__(self, instance, ownerclass=None):</font>
<font color="green">  51.         if instance is None:</font>
<font color="red">  52.             raise AttributeError()</font>
<font color="green">  53.         return self.fget(instance)</font>
<font color="black">  54. </font>
<font color="green">  55.     def __set__(self, instance, value):</font>
<font color="red">  56.         raise AttributeError(&quot;can't set attribute&quot;)</font>
<font color="black">  57. </font>
<font color="green">  58.     def __delete__(self, instance):</font>
<font color="red">  59.         raise AttributeError(&quot;can't delete attribute&quot;)</font>
<font color="black">  60. </font>
<font color="black">  61. </font>
<font color="green">  62. def _is_descriptor(obj):</font>
<font color="black">  63.     &quot;&quot;&quot;Returns True if obj is a descriptor, False otherwise.&quot;&quot;&quot;</font>
<font color="black">  64.     return (</font>
<font color="green">  65.             hasattr(obj, '__get__') or</font>
<font color="green">  66.             hasattr(obj, '__set__') or</font>
<font color="green">  67.             hasattr(obj, '__delete__'))</font>
<font color="black">  68. </font>
<font color="black">  69. </font>
<font color="green">  70. def _is_dunder(name):</font>
<font color="black">  71.     &quot;&quot;&quot;Returns True if a __dunder__ name, False otherwise.&quot;&quot;&quot;</font>
<font color="green">  72.     return (name[:2] == name[-2:] == '__' and</font>
<font color="green">  73.             name[2:3] != '_' and</font>
<font color="green">  74.             name[-3:-2] != '_' and</font>
<font color="green">  75.             len(name) &gt; 4)</font>
<font color="black">  76. </font>
<font color="black">  77. </font>
<font color="green">  78. def _is_sunder(name):</font>
<font color="black">  79.     &quot;&quot;&quot;Returns True if a _sunder_ name, False otherwise.&quot;&quot;&quot;</font>
<font color="green">  80.     return (name[0] == name[-1] == '_' and</font>
<font color="green">  81.             name[1:2] != '_' and</font>
<font color="red">  82.             name[-2:-1] != '_' and</font>
<font color="red">  83.             len(name) &gt; 2)</font>
<font color="black">  84. </font>
<font color="black">  85. </font>
<font color="green">  86. def _make_class_unpicklable(cls):</font>
<font color="black">  87.     &quot;&quot;&quot;Make the given class un-picklable.&quot;&quot;&quot;</font>
<font color="red">  88.     def _break_on_call_reduce(self, protocol=None):</font>
<font color="red">  89.         raise TypeError('%r cannot be pickled' % self)</font>
<font color="red">  90.     cls.__reduce_ex__ = _break_on_call_reduce</font>
<font color="red">  91.     cls.__module__ = '&lt;unknown&gt;'</font>
<font color="black">  92. </font>
<font color="black">  93. </font>
<font color="green">  94. class _EnumDict(dict):</font>
<font color="black">  95.     &quot;&quot;&quot;Track enum member order and ensure member names are not reused.</font>
<font color="black">  96. </font>
<font color="black">  97.     EnumMeta will use the names found in self._member_names as the</font>
<font color="black">  98.     enumeration member names.</font>
<font color="black">  99. </font>
<font color="green"> 100.     &quot;&quot;&quot;</font>
<font color="green"> 101.     def __init__(self):</font>
<font color="green"> 102.         super(_EnumDict, self).__init__()</font>
<font color="green"> 103.         self._member_names = []</font>
<font color="black"> 104. </font>
<font color="green"> 105.     def __setitem__(self, key, value):</font>
<font color="black"> 106.         &quot;&quot;&quot;Changes anything not dundered or not a descriptor.</font>
<font color="black"> 107. </font>
<font color="black"> 108.         If a descriptor is added with the same name as an enum member, the name</font>
<font color="black"> 109.         is removed from _member_names (this may leave a hole in the numerical</font>
<font color="black"> 110.         sequence of values).</font>
<font color="black"> 111. </font>
<font color="black"> 112.         If an enum member name is used twice, an error is raised; duplicate</font>
<font color="black"> 113.         values are not checked for.</font>
<font color="black"> 114. </font>
<font color="black"> 115.         Single underscore (sunder) names are reserved.</font>
<font color="black"> 116. </font>
<font color="black"> 117.         Note:   in 3.x __order__ is simply discarded as a not necessary piece</font>
<font color="black"> 118.                 leftover from 2.x</font>
<font color="black"> 119. </font>
<font color="black"> 120.         &quot;&quot;&quot;</font>
<font color="green"> 121.         if pyver &gt;= 3.0 and key in ('_order_', '__order__'):</font>
<font color="red"> 122.             return</font>
<font color="green"> 123.         elif key == '__order__':</font>
<font color="red"> 124.             key = '_order_'</font>
<font color="green"> 125.         if _is_sunder(key):</font>
<font color="red"> 126.             if key != '_order_':</font>
<font color="red"> 127.                 raise ValueError('_names_ are reserved for future Enum use')</font>
<font color="green"> 128.         elif _is_dunder(key):</font>
<font color="green"> 129.             pass</font>
<font color="green"> 130.         elif key in self._member_names:</font>
<font color="black"> 131.             # descriptor overwriting an enum?</font>
<font color="red"> 132.             raise TypeError('Attempted to reuse key: %r' % key)</font>
<font color="green"> 133.         elif not _is_descriptor(value):</font>
<font color="green"> 134.             if key in self:</font>
<font color="black"> 135.                 # enum overwriting a descriptor?</font>
<font color="red"> 136.                 raise TypeError('Key already defined as: %r' % self[key])</font>
<font color="green"> 137.             self._member_names.append(key)</font>
<font color="green"> 138.         super(_EnumDict, self).__setitem__(key, value)</font>
<font color="black"> 139. </font>
<font color="black"> 140. </font>
<font color="black"> 141. # Dummy value for Enum as EnumMeta explicity checks for it, but of course until</font>
<font color="black"> 142. # EnumMeta finishes running the first time the Enum class doesn't exist.  This</font>
<font color="black"> 143. # is also why there are checks in EnumMeta like `if Enum is not None`</font>
<font color="green"> 144. Enum = None</font>
<font color="black"> 145. </font>
<font color="black"> 146. </font>
<font color="green"> 147. class EnumMeta(type):</font>
<font color="green"> 148.     &quot;&quot;&quot;Metaclass for Enum&quot;&quot;&quot;</font>
<font color="green"> 149.     @classmethod</font>
<font color="black"> 150.     def __prepare__(metacls, cls, bases):</font>
<font color="red"> 151.         return _EnumDict()</font>
<font color="black"> 152. </font>
<font color="green"> 153.     def __new__(metacls, cls, bases, classdict):</font>
<font color="black"> 154.         # an Enum class is final once enumeration items have been defined; it</font>
<font color="black"> 155.         # cannot be mixed with other types (int, float, etc.) if it has an</font>
<font color="black"> 156.         # inherited __new__ unless a new __new__ is defined (or the resulting</font>
<font color="black"> 157.         # class will fail).</font>
<font color="green"> 158.         if type(classdict) is dict:</font>
<font color="green"> 159.             original_dict = classdict</font>
<font color="green"> 160.             classdict = _EnumDict()</font>
<font color="green"> 161.             for k, v in original_dict.items():</font>
<font color="green"> 162.                 classdict[k] = v</font>
<font color="black"> 163. </font>
<font color="green"> 164.         member_type, first_enum = metacls._get_mixins_(bases)</font>
<font color="green"> 165.         __new__, save_new, use_args = metacls._find_new_(classdict, member_type,</font>
<font color="green"> 166.                                                         first_enum)</font>
<font color="black"> 167.         # save enum items into separate mapping so they don't get baked into</font>
<font color="black"> 168.         # the new class</font>
<font color="green"> 169.         members = dict((k, classdict[k]) for k in classdict._member_names)</font>
<font color="green"> 170.         for name in classdict._member_names:</font>
<font color="green"> 171.             del classdict[name]</font>
<font color="black"> 172. </font>
<font color="black"> 173.         # py2 support for definition order</font>
<font color="green"> 174.         _order_ = classdict.get('_order_')</font>
<font color="green"> 175.         if _order_ is None:</font>
<font color="green"> 176.             if pyver &lt; 3.0:</font>
<font color="green"> 177.                 try:</font>
<font color="green"> 178.                     _order_ = [name for (name, value) in sorted(members.items(), key=lambda item: item[1])]</font>
<font color="red"> 179.                 except TypeError:</font>
<font color="red"> 180.                     _order_ = [name for name in sorted(members.keys())]</font>
<font color="black"> 181.             else:</font>
<font color="red"> 182.                 _order_ = classdict._member_names</font>
<font color="black"> 183.         else:</font>
<font color="red"> 184.             del classdict['_order_']</font>
<font color="red"> 185.             if pyver &lt; 3.0:</font>
<font color="red"> 186.                 _order_ = _order_.replace(',', ' ').split()</font>
<font color="red"> 187.                 aliases = [name for name in members if name not in _order_]</font>
<font color="red"> 188.                 _order_ += aliases</font>
<font color="black"> 189. </font>
<font color="black"> 190.         # check for illegal enum names (any others?)</font>
<font color="green"> 191.         invalid_names = set(members) &amp; set(['mro'])</font>
<font color="green"> 192.         if invalid_names:</font>
<font color="red"> 193.             raise ValueError('Invalid enum member name(s): %s' % (</font>
<font color="red"> 194.                 ', '.join(invalid_names), ))</font>
<font color="black"> 195. </font>
<font color="black"> 196.         # save attributes from super classes so we know if we can take</font>
<font color="black"> 197.         # the shortcut of storing members in the class dict</font>
<font color="green"> 198.         base_attributes = set([a for b in bases for a in b.__dict__])</font>
<font color="black"> 199.         # create our new Enum type</font>
<font color="green"> 200.         enum_class = super(EnumMeta, metacls).__new__(metacls, cls, bases, classdict)</font>
<font color="green"> 201.         enum_class._member_names_ = []               # names in random order</font>
<font color="green"> 202.         if OrderedDict is not None:</font>
<font color="green"> 203.             enum_class._member_map_ = OrderedDict()</font>
<font color="black"> 204.         else:</font>
<font color="red"> 205.             enum_class._member_map_ = {}             # name-&gt;value map</font>
<font color="green"> 206.         enum_class._member_type_ = member_type</font>
<font color="black"> 207. </font>
<font color="black"> 208.         # Reverse value-&gt;name map for hashable values.</font>
<font color="green"> 209.         enum_class._value2member_map_ = {}</font>
<font color="black"> 210. </font>
<font color="black"> 211.         # instantiate them, checking for duplicates as we go</font>
<font color="black"> 212.         # we instantiate first instead of checking for duplicates first in case</font>
<font color="black"> 213.         # a custom __new__ is doing something funky with the values -- such as</font>
<font color="black"> 214.         # auto-numbering ;)</font>
<font color="green"> 215.         if __new__ is None:</font>
<font color="green"> 216.             __new__ = enum_class.__new__</font>
<font color="green"> 217.         for member_name in _order_:</font>
<font color="green"> 218.             value = members[member_name]</font>
<font color="green"> 219.             if not isinstance(value, tuple):</font>
<font color="green"> 220.                 args = (value, )</font>
<font color="black"> 221.             else:</font>
<font color="red"> 222.                 args = value</font>
<font color="green"> 223.             if member_type is tuple:   # special case for tuple enums</font>
<font color="red"> 224.                 args = (args, )     # wrap it one more time</font>
<font color="green"> 225.             if not use_args or not args:</font>
<font color="green"> 226.                 enum_member = __new__(enum_class)</font>
<font color="green"> 227.                 if not hasattr(enum_member, '_value_'):</font>
<font color="green"> 228.                     enum_member._value_ = value</font>
<font color="black"> 229.             else:</font>
<font color="red"> 230.                 enum_member = __new__(enum_class, *args)</font>
<font color="red"> 231.                 if not hasattr(enum_member, '_value_'):</font>
<font color="red"> 232.                     enum_member._value_ = member_type(*args)</font>
<font color="green"> 233.             value = enum_member._value_</font>
<font color="green"> 234.             enum_member._name_ = member_name</font>
<font color="green"> 235.             enum_member.__objclass__ = enum_class</font>
<font color="green"> 236.             enum_member.__init__(*args)</font>
<font color="black"> 237.             # If another member with the same value was already defined, the</font>
<font color="black"> 238.             # new member becomes an alias to the existing one.</font>
<font color="green"> 239.             for name, canonical_member in enum_class._member_map_.items():</font>
<font color="green"> 240.                 if canonical_member.value == enum_member._value_:</font>
<font color="red"> 241.                     enum_member = canonical_member</font>
<font color="red"> 242.                     break</font>
<font color="black"> 243.             else:</font>
<font color="black"> 244.                 # Aliases don't appear in member names (only in __members__).</font>
<font color="green"> 245.                 enum_class._member_names_.append(member_name)</font>
<font color="black"> 246.             # performance boost for any member that would not shadow</font>
<font color="black"> 247.             # a DynamicClassAttribute (aka _RouteClassAttributeToGetattr)</font>
<font color="green"> 248.             if member_name not in base_attributes:</font>
<font color="green"> 249.                 setattr(enum_class, member_name, enum_member)</font>
<font color="black"> 250.             # now add to _member_map_</font>
<font color="green"> 251.             enum_class._member_map_[member_name] = enum_member</font>
<font color="green"> 252.             try:</font>
<font color="black"> 253.                 # This may fail if value is not hashable. We can't add the value</font>
<font color="black"> 254.                 # to the map, and by-value lookups for this value will be</font>
<font color="black"> 255.                 # linear.</font>
<font color="green"> 256.                 enum_class._value2member_map_[value] = enum_member</font>
<font color="red"> 257.             except TypeError:</font>
<font color="red"> 258.                 pass</font>
<font color="black"> 259. </font>
<font color="black"> 260. </font>
<font color="black"> 261.         # If a custom type is mixed into the Enum, and it does not know how</font>
<font color="black"> 262.         # to pickle itself, pickle.dumps will succeed but pickle.loads will</font>
<font color="black"> 263.         # fail.  Rather than have the error show up later and possibly far</font>
<font color="black"> 264.         # from the source, sabotage the pickle protocol for this class so</font>
<font color="black"> 265.         # that pickle.dumps also fails.</font>
<font color="black"> 266.         #</font>
<font color="black"> 267.         # However, if the new class implements its own __reduce_ex__, do not</font>
<font color="black"> 268.         # sabotage -- it's on them to make sure it works correctly.  We use</font>
<font color="black"> 269.         # __reduce_ex__ instead of any of the others as it is preferred by</font>
<font color="black"> 270.         # pickle over __reduce__, and it handles all pickle protocols.</font>
<font color="green"> 271.         unpicklable = False</font>
<font color="green"> 272.         if '__reduce_ex__' not in classdict:</font>
<font color="green"> 273.             if member_type is not object:</font>
<font color="black"> 274.                 methods = ('__getnewargs_ex__', '__getnewargs__',</font>
<font color="green"> 275.                         '__reduce_ex__', '__reduce__')</font>
<font color="green"> 276.                 if not any(m in member_type.__dict__ for m in methods):</font>
<font color="red"> 277.                     _make_class_unpicklable(enum_class)</font>
<font color="red"> 278.                     unpicklable = True</font>
<font color="black"> 279. </font>
<font color="black"> 280. </font>
<font color="black"> 281.         # double check that repr and friends are not the mixin's or various</font>
<font color="black"> 282.         # things break (such as pickle)</font>
<font color="green"> 283.         for name in ('__repr__', '__str__', '__format__', '__reduce_ex__'):</font>
<font color="green"> 284.             class_method = getattr(enum_class, name)</font>
<font color="green"> 285.             obj_method = getattr(member_type, name, None)</font>
<font color="green"> 286.             enum_method = getattr(first_enum, name, None)</font>
<font color="green"> 287.             if name not in classdict and class_method is not enum_method:</font>
<font color="green"> 288.                 if name == '__reduce_ex__' and unpicklable:</font>
<font color="red"> 289.                     continue</font>
<font color="green"> 290.                 setattr(enum_class, name, enum_method)</font>
<font color="black"> 291. </font>
<font color="black"> 292.         # method resolution and int's are not playing nice</font>
<font color="black"> 293.         # Python's less than 2.6 use __cmp__</font>
<font color="black"> 294. </font>
<font color="green"> 295.         if pyver &lt; 2.6:</font>
<font color="black"> 296. </font>
<font color="red"> 297.             if issubclass(enum_class, int):</font>
<font color="red"> 298.                 setattr(enum_class, '__cmp__', getattr(int, '__cmp__'))</font>
<font color="black"> 299. </font>
<font color="green"> 300.         elif pyver &lt; 3.0:</font>
<font color="black"> 301. </font>
<font color="green"> 302.             if issubclass(enum_class, int):</font>
<font color="green"> 303.                 for method in (</font>
<font color="black"> 304.                         '__le__',</font>
<font color="black"> 305.                         '__lt__',</font>
<font color="black"> 306.                         '__gt__',</font>
<font color="black"> 307.                         '__ge__',</font>
<font color="black"> 308.                         '__eq__',</font>
<font color="black"> 309.                         '__ne__',</font>
<font color="green"> 310.                         '__hash__',</font>
<font color="black"> 311.                         ):</font>
<font color="green"> 312.                     setattr(enum_class, method, getattr(int, method))</font>
<font color="black"> 313. </font>
<font color="black"> 314.         # replace any other __new__ with our own (as long as Enum is not None,</font>
<font color="black"> 315.         # anyway) -- again, this is to support pickle</font>
<font color="green"> 316.         if Enum is not None:</font>
<font color="black"> 317.             # if the user defined their own __new__, save it before it gets</font>
<font color="black"> 318.             # clobbered in case they subclass later</font>
<font color="green"> 319.             if save_new:</font>
<font color="red"> 320.                 setattr(enum_class, '__member_new__', enum_class.__dict__['__new__'])</font>
<font color="green"> 321.             setattr(enum_class, '__new__', Enum.__dict__['__new__'])</font>
<font color="green"> 322.         return enum_class</font>
<font color="black"> 323. </font>
<font color="green"> 324.     def __bool__(cls):</font>
<font color="black"> 325.         &quot;&quot;&quot;</font>
<font color="black"> 326.         classes/types should always be True.</font>
<font color="black"> 327.         &quot;&quot;&quot;</font>
<font color="red"> 328.         return True</font>
<font color="black"> 329. </font>
<font color="green"> 330.     def __call__(cls, value, names=None, module=None, type=None, start=1):</font>
<font color="black"> 331.         &quot;&quot;&quot;Either returns an existing member, or creates a new enum class.</font>
<font color="black"> 332. </font>
<font color="black"> 333.         This method is used both when an enum class is given a value to match</font>
<font color="black"> 334.         to an enumeration member (i.e. Color(3)) and for the functional API</font>
<font color="black"> 335.         (i.e. Color = Enum('Color', names='red green blue')).</font>
<font color="black"> 336. </font>
<font color="black"> 337.         When used for the functional API: `module`, if set, will be stored in</font>
<font color="black"> 338.         the new class' __module__ attribute; `type`, if set, will be mixed in</font>
<font color="black"> 339.         as the first base class.</font>
<font color="black"> 340. </font>
<font color="black"> 341.         Note: if `module` is not set this routine will attempt to discover the</font>
<font color="black"> 342.         calling module by walking the frame stack; if this is unsuccessful</font>
<font color="black"> 343.         the resulting class will not be pickleable.</font>
<font color="black"> 344. </font>
<font color="black"> 345.         &quot;&quot;&quot;</font>
<font color="red"> 346.         if names is None:  # simple value lookup</font>
<font color="red"> 347.             return cls.__new__(cls, value)</font>
<font color="black"> 348.         # otherwise, functional API: we're creating a new Enum type</font>
<font color="red"> 349.         return cls._create_(value, names, module=module, type=type, start=start)</font>
<font color="black"> 350. </font>
<font color="green"> 351.     def __contains__(cls, member):</font>
<font color="red"> 352.         return isinstance(member, cls) and member.name in cls._member_map_</font>
<font color="black"> 353. </font>
<font color="green"> 354.     def __delattr__(cls, attr):</font>
<font color="black"> 355.         # nicer error message when someone tries to delete an attribute</font>
<font color="black"> 356.         # (see issue19025).</font>
<font color="red"> 357.         if attr in cls._member_map_:</font>
<font color="red"> 358.             raise AttributeError(</font>
<font color="red"> 359.                     &quot;%s: cannot delete Enum member.&quot; % cls.__name__)</font>
<font color="red"> 360.         super(EnumMeta, cls).__delattr__(attr)</font>
<font color="black"> 361. </font>
<font color="green"> 362.     def __dir__(self):</font>
<font color="red"> 363.         return (['__class__', '__doc__', '__members__', '__module__'] +</font>
<font color="red"> 364.                 self._member_names_)</font>
<font color="black"> 365. </font>
<font color="green"> 366.     @property</font>
<font color="black"> 367.     def __members__(cls):</font>
<font color="black"> 368.         &quot;&quot;&quot;Returns a mapping of member name-&gt;value.</font>
<font color="black"> 369. </font>
<font color="black"> 370.         This mapping lists all enum members, including aliases. Note that this</font>
<font color="black"> 371.         is a copy of the internal mapping.</font>
<font color="black"> 372. </font>
<font color="black"> 373.         &quot;&quot;&quot;</font>
<font color="red"> 374.         return cls._member_map_.copy()</font>
<font color="black"> 375. </font>
<font color="green"> 376.     def __getattr__(cls, name):</font>
<font color="black"> 377.         &quot;&quot;&quot;Return the enum member matching `name`</font>
<font color="black"> 378. </font>
<font color="black"> 379.         We use __getattr__ instead of descriptors or inserting into the enum</font>
<font color="black"> 380.         class' __dict__ in order to support `name` and `value` being both</font>
<font color="black"> 381.         properties for enum members (which live in the class' __dict__) and</font>
<font color="black"> 382.         enum members themselves.</font>
<font color="black"> 383. </font>
<font color="black"> 384.         &quot;&quot;&quot;</font>
<font color="green"> 385.         if _is_dunder(name):</font>
<font color="green"> 386.             raise AttributeError(name)</font>
<font color="red"> 387.         try:</font>
<font color="red"> 388.             return cls._member_map_[name]</font>
<font color="red"> 389.         except KeyError:</font>
<font color="red"> 390.             raise AttributeError(name)</font>
<font color="black"> 391. </font>
<font color="green"> 392.     def __getitem__(cls, name):</font>
<font color="red"> 393.         return cls._member_map_[name]</font>
<font color="black"> 394. </font>
<font color="green"> 395.     def __iter__(cls):</font>
<font color="red"> 396.         return (cls._member_map_[name] for name in cls._member_names_)</font>
<font color="black"> 397. </font>
<font color="green"> 398.     def __reversed__(cls):</font>
<font color="red"> 399.         return (cls._member_map_[name] for name in reversed(cls._member_names_))</font>
<font color="black"> 400. </font>
<font color="green"> 401.     def __len__(cls):</font>
<font color="red"> 402.         return len(cls._member_names_)</font>
<font color="black"> 403. </font>
<font color="green"> 404.     __nonzero__ = __bool__</font>
<font color="black"> 405. </font>
<font color="green"> 406.     def __repr__(cls):</font>
<font color="red"> 407.         return &quot;&lt;enum %r&gt;&quot; % cls.__name__</font>
<font color="black"> 408. </font>
<font color="green"> 409.     def __setattr__(cls, name, value):</font>
<font color="black"> 410.         &quot;&quot;&quot;Block attempts to reassign Enum members.</font>
<font color="black"> 411. </font>
<font color="black"> 412.         A simple assignment to the class namespace only changes one of the</font>
<font color="black"> 413.         several possible ways to get an Enum member from the Enum class,</font>
<font color="black"> 414.         resulting in an inconsistent Enumeration.</font>
<font color="black"> 415. </font>
<font color="black"> 416.         &quot;&quot;&quot;</font>
<font color="green"> 417.         member_map = cls.__dict__.get('_member_map_', {})</font>
<font color="green"> 418.         if name in member_map:</font>
<font color="red"> 419.             raise AttributeError('Cannot reassign members.')</font>
<font color="green"> 420.         super(EnumMeta, cls).__setattr__(name, value)</font>
<font color="black"> 421. </font>
<font color="green"> 422.     def _create_(cls, class_name, names=None, module=None, type=None, start=1):</font>
<font color="black"> 423.         &quot;&quot;&quot;Convenience method to create a new Enum class.</font>
<font color="black"> 424. </font>
<font color="black"> 425.         `names` can be:</font>
<font color="black"> 426. </font>
<font color="black"> 427.         * A string containing member names, separated either with spaces or</font>
<font color="black"> 428.           commas.  Values are auto-numbered from 1.</font>
<font color="black"> 429.         * An iterable of member names.  Values are auto-numbered from 1.</font>
<font color="black"> 430.         * An iterable of (member name, value) pairs.</font>
<font color="black"> 431.         * A mapping of member name -&gt; value.</font>
<font color="black"> 432. </font>
<font color="black"> 433.         &quot;&quot;&quot;</font>
<font color="red"> 434.         if pyver &lt; 3.0:</font>
<font color="black"> 435.             # if class_name is unicode, attempt a conversion to ASCII</font>
<font color="red"> 436.             if isinstance(class_name, unicode):</font>
<font color="red"> 437.                 try:</font>
<font color="red"> 438.                     class_name = class_name.encode('ascii')</font>
<font color="red"> 439.                 except UnicodeEncodeError:</font>
<font color="red"> 440.                     raise TypeError('%r is not representable in ASCII' % class_name)</font>
<font color="red"> 441.         metacls = cls.__class__</font>
<font color="red"> 442.         if type is None:</font>
<font color="red"> 443.             bases = (cls, )</font>
<font color="black"> 444.         else:</font>
<font color="red"> 445.             bases = (type, cls)</font>
<font color="red"> 446.         classdict = metacls.__prepare__(class_name, bases)</font>
<font color="red"> 447.         _order_ = []</font>
<font color="black"> 448. </font>
<font color="black"> 449.         # special processing needed for names?</font>
<font color="red"> 450.         if isinstance(names, basestring):</font>
<font color="red"> 451.             names = names.replace(',', ' ').split()</font>
<font color="red"> 452.         if isinstance(names, (tuple, list)) and isinstance(names[0], basestring):</font>
<font color="red"> 453.             names = [(e, i+start) for (i, e) in enumerate(names)]</font>
<font color="black"> 454. </font>
<font color="black"> 455.         # Here, names is either an iterable of (name, value) or a mapping.</font>
<font color="red"> 456.         item = None  # in case names is empty</font>
<font color="red"> 457.         for item in names:</font>
<font color="red"> 458.             if isinstance(item, basestring):</font>
<font color="red"> 459.                 member_name, member_value = item, names[item]</font>
<font color="black"> 460.             else:</font>
<font color="red"> 461.                 member_name, member_value = item</font>
<font color="red"> 462.             classdict[member_name] = member_value</font>
<font color="red"> 463.             _order_.append(member_name)</font>
<font color="black"> 464.         # only set _order_ in classdict if name/value was not from a mapping</font>
<font color="red"> 465.         if not isinstance(item, basestring):</font>
<font color="red"> 466.             classdict['_order_'] = ' '.join(_order_)</font>
<font color="red"> 467.         enum_class = metacls.__new__(metacls, class_name, bases, classdict)</font>
<font color="black"> 468. </font>
<font color="black"> 469.         # TODO: replace the frame hack if a blessed way to know the calling</font>
<font color="black"> 470.         # module is ever developed</font>
<font color="red"> 471.         if module is None:</font>
<font color="red"> 472.             try:</font>
<font color="red"> 473.                 module = _sys._getframe(2).f_globals['__name__']</font>
<font color="red"> 474.             except (AttributeError, ValueError):</font>
<font color="red"> 475.                 pass</font>
<font color="red"> 476.         if module is None:</font>
<font color="red"> 477.             _make_class_unpicklable(enum_class)</font>
<font color="black"> 478.         else:</font>
<font color="red"> 479.             enum_class.__module__ = module</font>
<font color="black"> 480. </font>
<font color="red"> 481.         return enum_class</font>
<font color="black"> 482. </font>
<font color="green"> 483.     @staticmethod</font>
<font color="black"> 484.     def _get_mixins_(bases):</font>
<font color="black"> 485.         &quot;&quot;&quot;Returns the type for creating enum members, and the first inherited</font>
<font color="black"> 486.         enum class.</font>
<font color="black"> 487. </font>
<font color="black"> 488.         bases: the tuple of bases that was given to __new__</font>
<font color="black"> 489. </font>
<font color="black"> 490.         &quot;&quot;&quot;</font>
<font color="green"> 491.         if not bases or Enum is None:</font>
<font color="green"> 492.             return object, Enum</font>
<font color="black"> 493. </font>
<font color="black"> 494. </font>
<font color="black"> 495.         # double check that we are not subclassing a class with existing</font>
<font color="black"> 496.         # enumeration members; while we're at it, see if any other data</font>
<font color="black"> 497.         # type has been mixed in so we can use the correct __new__</font>
<font color="green"> 498.         member_type = first_enum = None</font>
<font color="green"> 499.         for base in bases:</font>
<font color="green"> 500.             if  (base is not Enum and</font>
<font color="green"> 501.                     issubclass(base, Enum) and</font>
<font color="red"> 502.                     base._member_names_):</font>
<font color="red"> 503.                 raise TypeError(&quot;Cannot extend enumerations&quot;)</font>
<font color="black"> 504.         # base is now the last base in bases</font>
<font color="green"> 505.         if not issubclass(base, Enum):</font>
<font color="red"> 506.             raise TypeError(&quot;new enumerations must be created as &quot;</font>
<font color="black"> 507.                     &quot;`ClassName([mixin_type,] enum_type)`&quot;)</font>
<font color="black"> 508. </font>
<font color="black"> 509.         # get correct mix-in type (either mix-in type of Enum subclass, or</font>
<font color="black"> 510.         # first base if last base is Enum)</font>
<font color="green"> 511.         if not issubclass(bases[0], Enum):</font>
<font color="green"> 512.             member_type = bases[0]     # first data type</font>
<font color="green"> 513.             first_enum = bases[-1]  # enum type</font>
<font color="black"> 514.         else:</font>
<font color="green"> 515.             for base in bases[0].__mro__:</font>
<font color="black"> 516.                 # most common: (IntEnum, int, Enum, object)</font>
<font color="black"> 517.                 # possible:    (&lt;Enum 'AutoIntEnum'&gt;, &lt;Enum 'IntEnum'&gt;,</font>
<font color="black"> 518.                 #               &lt;class 'int'&gt;, &lt;Enum 'Enum'&gt;,</font>
<font color="black"> 519.                 #               &lt;class 'object'&gt;)</font>
<font color="green"> 520.                 if issubclass(base, Enum):</font>
<font color="green"> 521.                     if first_enum is None:</font>
<font color="green"> 522.                         first_enum = base</font>
<font color="black"> 523.                 else:</font>
<font color="green"> 524.                     if member_type is None:</font>
<font color="green"> 525.                         member_type = base</font>
<font color="black"> 526. </font>
<font color="green"> 527.         return member_type, first_enum</font>
<font color="black"> 528. </font>
<font color="green"> 529.     if pyver &lt; 3.0:</font>
<font color="green"> 530.         @staticmethod</font>
<font color="black"> 531.         def _find_new_(classdict, member_type, first_enum):</font>
<font color="black"> 532.             &quot;&quot;&quot;Returns the __new__ to be used for creating the enum members.</font>
<font color="black"> 533. </font>
<font color="black"> 534.             classdict: the class dictionary given to __new__</font>
<font color="black"> 535.             member_type: the data type whose __new__ will be used by default</font>
<font color="black"> 536.             first_enum: enumeration to check for an overriding __new__</font>
<font color="black"> 537. </font>
<font color="black"> 538.             &quot;&quot;&quot;</font>
<font color="black"> 539.             # now find the correct __new__, checking to see of one was defined</font>
<font color="black"> 540.             # by the user; also check earlier enum classes in case a __new__ was</font>
<font color="black"> 541.             # saved as __member_new__</font>
<font color="green"> 542.             __new__ = classdict.get('__new__', None)</font>
<font color="green"> 543.             if __new__:</font>
<font color="green"> 544.                 return None, True, True      # __new__, save_new, use_args</font>
<font color="black"> 545. </font>
<font color="green"> 546.             N__new__ = getattr(None, '__new__')</font>
<font color="green"> 547.             O__new__ = getattr(object, '__new__')</font>
<font color="green"> 548.             if Enum is None:</font>
<font color="red"> 549.                 E__new__ = N__new__</font>
<font color="black"> 550.             else:</font>
<font color="green"> 551.                 E__new__ = Enum.__dict__['__new__']</font>
<font color="black"> 552.             # check all possibles for __member_new__ before falling back to</font>
<font color="black"> 553.             # __new__</font>
<font color="green"> 554.             for method in ('__member_new__', '__new__'):</font>
<font color="green"> 555.                 for possible in (member_type, first_enum):</font>
<font color="green"> 556.                     try:</font>
<font color="green"> 557.                         target = possible.__dict__[method]</font>
<font color="green"> 558.                     except (AttributeError, KeyError):</font>
<font color="green"> 559.                         target = getattr(possible, method, None)</font>
<font color="green"> 560.                     if target not in [</font>
<font color="green"> 561.                             None,</font>
<font color="green"> 562.                             N__new__,</font>
<font color="green"> 563.                             O__new__,</font>
<font color="green"> 564.                             E__new__,</font>
<font color="black"> 565.                             ]:</font>
<font color="green"> 566.                         if method == '__member_new__':</font>
<font color="red"> 567.                             classdict['__new__'] = target</font>
<font color="red"> 568.                             return None, False, True</font>
<font color="green"> 569.                         if isinstance(target, staticmethod):</font>
<font color="red"> 570.                             target = target.__get__(member_type)</font>
<font color="green"> 571.                         __new__ = target</font>
<font color="green"> 572.                         break</font>
<font color="green"> 573.                 if __new__ is not None:</font>
<font color="green"> 574.                     break</font>
<font color="black"> 575.             else:</font>
<font color="green"> 576.                 __new__ = object.__new__</font>
<font color="black"> 577. </font>
<font color="black"> 578.             # if a non-object.__new__ is used then whatever value/tuple was</font>
<font color="black"> 579.             # assigned to the enum member name will be passed to __new__ and to the</font>
<font color="black"> 580.             # new enum member's __init__</font>
<font color="green"> 581.             if __new__ is object.__new__:</font>
<font color="green"> 582.                 use_args = False</font>
<font color="black"> 583.             else:</font>
<font color="green"> 584.                 use_args = True</font>
<font color="black"> 585. </font>
<font color="green"> 586.             return __new__, False, use_args</font>
<font color="black"> 587.     else:</font>
<font color="red"> 588.         @staticmethod</font>
<font color="black"> 589.         def _find_new_(classdict, member_type, first_enum):</font>
<font color="black"> 590.             &quot;&quot;&quot;Returns the __new__ to be used for creating the enum members.</font>
<font color="black"> 591. </font>
<font color="black"> 592.             classdict: the class dictionary given to __new__</font>
<font color="black"> 593.             member_type: the data type whose __new__ will be used by default</font>
<font color="black"> 594.             first_enum: enumeration to check for an overriding __new__</font>
<font color="black"> 595. </font>
<font color="black"> 596.             &quot;&quot;&quot;</font>
<font color="black"> 597.             # now find the correct __new__, checking to see of one was defined</font>
<font color="black"> 598.             # by the user; also check earlier enum classes in case a __new__ was</font>
<font color="black"> 599.             # saved as __member_new__</font>
<font color="red"> 600.             __new__ = classdict.get('__new__', None)</font>
<font color="black"> 601. </font>
<font color="black"> 602.             # should __new__ be saved as __member_new__ later?</font>
<font color="red"> 603.             save_new = __new__ is not None</font>
<font color="black"> 604. </font>
<font color="red"> 605.             if __new__ is None:</font>
<font color="black"> 606.                 # check all possibles for __member_new__ before falling back to</font>
<font color="black"> 607.                 # __new__</font>
<font color="red"> 608.                 for method in ('__member_new__', '__new__'):</font>
<font color="red"> 609.                     for possible in (member_type, first_enum):</font>
<font color="red"> 610.                         target = getattr(possible, method, None)</font>
<font color="red"> 611.                         if target not in (</font>
<font color="red"> 612.                                 None,</font>
<font color="red"> 613.                                 None.__new__,</font>
<font color="red"> 614.                                 object.__new__,</font>
<font color="red"> 615.                                 Enum.__new__,</font>
<font color="black"> 616.                                 ):</font>
<font color="red"> 617.                             __new__ = target</font>
<font color="red"> 618.                             break</font>
<font color="red"> 619.                     if __new__ is not None:</font>
<font color="red"> 620.                         break</font>
<font color="black"> 621.                 else:</font>
<font color="red"> 622.                     __new__ = object.__new__</font>
<font color="black"> 623. </font>
<font color="black"> 624.             # if a non-object.__new__ is used then whatever value/tuple was</font>
<font color="black"> 625.             # assigned to the enum member name will be passed to __new__ and to the</font>
<font color="black"> 626.             # new enum member's __init__</font>
<font color="red"> 627.             if __new__ is object.__new__:</font>
<font color="red"> 628.                 use_args = False</font>
<font color="black"> 629.             else:</font>
<font color="red"> 630.                 use_args = True</font>
<font color="black"> 631. </font>
<font color="red"> 632.             return __new__, save_new, use_args</font>
<font color="black"> 633. </font>
<font color="black"> 634. </font>
<font color="black"> 635. ########################################################</font>
<font color="black"> 636. # In order to support Python 2 and 3 with a single</font>
<font color="black"> 637. # codebase we have to create the Enum methods separately</font>
<font color="black"> 638. # and then use the `type(name, bases, dict)` method to</font>
<font color="black"> 639. # create the class.</font>
<font color="black"> 640. ########################################################</font>
<font color="green"> 641. temp_enum_dict = {}</font>
<font color="green"> 642. temp_enum_dict['__doc__'] = &quot;Generic enumeration.\n\n    Derive from this class to define new enumerations.\n\n&quot;</font>
<font color="black"> 643. </font>
<font color="green"> 644. def __new__(cls, value):</font>
<font color="black"> 645.     # all enum instances are actually created during class construction</font>
<font color="black"> 646.     # without calling this method; this method is called by the metaclass'</font>
<font color="black"> 647.     # __call__ (i.e. Color(3) ), and by pickle</font>
<font color="red"> 648.     if type(value) is cls:</font>
<font color="black"> 649.         # For lookups like Color(Color.red)</font>
<font color="red"> 650.         value = value.value</font>
<font color="black"> 651.         #return value</font>
<font color="black"> 652.     # by-value search for a matching enum member</font>
<font color="black"> 653.     # see if it's in the reverse mapping (for hashable values)</font>
<font color="red"> 654.     try:</font>
<font color="red"> 655.         if value in cls._value2member_map_:</font>
<font color="red"> 656.             return cls._value2member_map_[value]</font>
<font color="red"> 657.     except TypeError:</font>
<font color="black"> 658.         # not there, now do long search -- O(n) behavior</font>
<font color="red"> 659.         for member in cls._member_map_.values():</font>
<font color="red"> 660.             if member.value == value:</font>
<font color="red"> 661.                 return member</font>
<font color="red"> 662.     raise ValueError(&quot;%s is not a valid %s&quot; % (value, cls.__name__))</font>
<font color="green"> 663. temp_enum_dict['__new__'] = __new__</font>
<font color="green"> 664. del __new__</font>
<font color="black"> 665. </font>
<font color="green"> 666. def __repr__(self):</font>
<font color="red"> 667.     return &quot;&lt;%s.%s: %r&gt;&quot; % (</font>
<font color="red"> 668.             self.__class__.__name__, self._name_, self._value_)</font>
<font color="green"> 669. temp_enum_dict['__repr__'] = __repr__</font>
<font color="green"> 670. del __repr__</font>
<font color="black"> 671. </font>
<font color="green"> 672. def __str__(self):</font>
<font color="red"> 673.     return &quot;%s.%s&quot; % (self.__class__.__name__, self._name_)</font>
<font color="green"> 674. temp_enum_dict['__str__'] = __str__</font>
<font color="green"> 675. del __str__</font>
<font color="black"> 676. </font>
<font color="green"> 677. if pyver &gt;= 3.0:</font>
<font color="red"> 678.     def __dir__(self):</font>
<font color="black"> 679.         added_behavior = [</font>
<font color="red"> 680.                 m</font>
<font color="red"> 681.                 for cls in self.__class__.mro()</font>
<font color="red"> 682.                 for m in cls.__dict__</font>
<font color="red"> 683.                 if m[0] != '_' and m not in self._member_map_</font>
<font color="black"> 684.                 ]</font>
<font color="red"> 685.         return (['__class__', '__doc__', '__module__', ] + added_behavior)</font>
<font color="red"> 686.     temp_enum_dict['__dir__'] = __dir__</font>
<font color="red"> 687.     del __dir__</font>
<font color="black"> 688. </font>
<font color="green"> 689. def __format__(self, format_spec):</font>
<font color="black"> 690.     # mixed-in Enums should use the mixed-in type's __format__, otherwise</font>
<font color="black"> 691.     # we can get strange results with the Enum name showing up instead of</font>
<font color="black"> 692.     # the value</font>
<font color="black"> 693. </font>
<font color="black"> 694.     # pure Enum branch</font>
<font color="red"> 695.     if self._member_type_ is object:</font>
<font color="red"> 696.         cls = str</font>
<font color="red"> 697.         val = str(self)</font>
<font color="black"> 698.     # mix-in branch</font>
<font color="black"> 699.     else:</font>
<font color="red"> 700.         cls = self._member_type_</font>
<font color="red"> 701.         val = self.value</font>
<font color="red"> 702.     return cls.__format__(val, format_spec)</font>
<font color="green"> 703. temp_enum_dict['__format__'] = __format__</font>
<font color="green"> 704. del __format__</font>
<font color="black"> 705. </font>
<font color="black"> 706. </font>
<font color="black"> 707. ####################################</font>
<font color="black"> 708. # Python's less than 2.6 use __cmp__</font>
<font color="black"> 709. </font>
<font color="green"> 710. if pyver &lt; 2.6:</font>
<font color="black"> 711. </font>
<font color="red"> 712.     def __cmp__(self, other):</font>
<font color="red"> 713.         if type(other) is self.__class__:</font>
<font color="red"> 714.             if self is other:</font>
<font color="red"> 715.                 return 0</font>
<font color="red"> 716.             return -1</font>
<font color="red"> 717.         return NotImplemented</font>
<font color="red"> 718.         raise TypeError(&quot;unorderable types: %s() and %s()&quot; % (self.__class__.__name__, other.__class__.__name__))</font>
<font color="red"> 719.     temp_enum_dict['__cmp__'] = __cmp__</font>
<font color="red"> 720.     del __cmp__</font>
<font color="black"> 721. </font>
<font color="black"> 722. else:</font>
<font color="black"> 723. </font>
<font color="green"> 724.     def __le__(self, other):</font>
<font color="red"> 725.         raise TypeError(&quot;unorderable types: %s() &lt;= %s()&quot; % (self.__class__.__name__, other.__class__.__name__))</font>
<font color="green"> 726.     temp_enum_dict['__le__'] = __le__</font>
<font color="green"> 727.     del __le__</font>
<font color="black"> 728. </font>
<font color="green"> 729.     def __lt__(self, other):</font>
<font color="red"> 730.         raise TypeError(&quot;unorderable types: %s() &lt; %s()&quot; % (self.__class__.__name__, other.__class__.__name__))</font>
<font color="green"> 731.     temp_enum_dict['__lt__'] = __lt__</font>
<font color="green"> 732.     del __lt__</font>
<font color="black"> 733. </font>
<font color="green"> 734.     def __ge__(self, other):</font>
<font color="red"> 735.         raise TypeError(&quot;unorderable types: %s() &gt;= %s()&quot; % (self.__class__.__name__, other.__class__.__name__))</font>
<font color="green"> 736.     temp_enum_dict['__ge__'] = __ge__</font>
<font color="green"> 737.     del __ge__</font>
<font color="black"> 738. </font>
<font color="green"> 739.     def __gt__(self, other):</font>
<font color="red"> 740.         raise TypeError(&quot;unorderable types: %s() &gt; %s()&quot; % (self.__class__.__name__, other.__class__.__name__))</font>
<font color="green"> 741.     temp_enum_dict['__gt__'] = __gt__</font>
<font color="green"> 742.     del __gt__</font>
<font color="black"> 743. </font>
<font color="black"> 744. </font>
<font color="green"> 745. def __eq__(self, other):</font>
<font color="red"> 746.     if type(other) is self.__class__:</font>
<font color="red"> 747.         return self is other</font>
<font color="red"> 748.     return NotImplemented</font>
<font color="green"> 749. temp_enum_dict['__eq__'] = __eq__</font>
<font color="green"> 750. del __eq__</font>
<font color="black"> 751. </font>
<font color="green"> 752. def __ne__(self, other):</font>
<font color="red"> 753.     if type(other) is self.__class__:</font>
<font color="red"> 754.         return self is not other</font>
<font color="red"> 755.     return NotImplemented</font>
<font color="green"> 756. temp_enum_dict['__ne__'] = __ne__</font>
<font color="green"> 757. del __ne__</font>
<font color="black"> 758. </font>
<font color="green"> 759. def __hash__(self):</font>
<font color="red"> 760.     return hash(self._name_)</font>
<font color="green"> 761. temp_enum_dict['__hash__'] = __hash__</font>
<font color="green"> 762. del __hash__</font>
<font color="black"> 763. </font>
<font color="green"> 764. def __reduce_ex__(self, proto):</font>
<font color="red"> 765.     return self.__class__, (self._value_, )</font>
<font color="green"> 766. temp_enum_dict['__reduce_ex__'] = __reduce_ex__</font>
<font color="green"> 767. del __reduce_ex__</font>
<font color="black"> 768. </font>
<font color="black"> 769. # _RouteClassAttributeToGetattr is used to provide access to the `name`</font>
<font color="black"> 770. # and `value` properties of enum members while keeping some measure of</font>
<font color="black"> 771. # protection from modification, while still allowing for an enumeration</font>
<font color="black"> 772. # to have members named `name` and `value`.  This works because enumeration</font>
<font color="black"> 773. # members are not set directly on the enum class -- __getattr__ is</font>
<font color="black"> 774. # used to look them up.</font>
<font color="black"> 775. </font>
<font color="green"> 776. @_RouteClassAttributeToGetattr</font>
<font color="black"> 777. def name(self):</font>
<font color="red"> 778.     return self._name_</font>
<font color="green"> 779. temp_enum_dict['name'] = name</font>
<font color="green"> 780. del name</font>
<font color="black"> 781. </font>
<font color="green"> 782. @_RouteClassAttributeToGetattr</font>
<font color="black"> 783. def value(self):</font>
<font color="green"> 784.     return self._value_</font>
<font color="green"> 785. temp_enum_dict['value'] = value</font>
<font color="green"> 786. del value</font>
<font color="black"> 787. </font>
<font color="green"> 788. @classmethod</font>
<font color="green"> 789. def _convert(cls, name, module, filter, source=None):</font>
<font color="black"> 790.     &quot;&quot;&quot;</font>
<font color="black"> 791.     Create a new Enum subclass that replaces a collection of global constants</font>
<font color="black"> 792.     &quot;&quot;&quot;</font>
<font color="black"> 793.     # convert all constants from source (or module) that pass filter() to</font>
<font color="black"> 794.     # a new Enum called name, and export the enum and its members back to</font>
<font color="black"> 795.     # module;</font>
<font color="black"> 796.     # also, replace the __reduce_ex__ method so unpickling works in</font>
<font color="black"> 797.     # previous Python versions</font>
<font color="red"> 798.     module_globals = vars(_sys.modules[module])</font>
<font color="red"> 799.     if source:</font>
<font color="red"> 800.         source = vars(source)</font>
<font color="black"> 801.     else:</font>
<font color="red"> 802.         source = module_globals</font>
<font color="red"> 803.     members = dict((name, value) for name, value in source.items() if filter(name))</font>
<font color="red"> 804.     cls = cls(name, members, module=module)</font>
<font color="red"> 805.     cls.__reduce_ex__ = _reduce_ex_by_name</font>
<font color="red"> 806.     module_globals.update(cls.__members__)</font>
<font color="red"> 807.     module_globals[name] = cls</font>
<font color="red"> 808.     return cls</font>
<font color="green"> 809. temp_enum_dict['_convert'] = _convert</font>
<font color="green"> 810. del _convert</font>
<font color="black"> 811. </font>
<font color="green"> 812. Enum = EnumMeta('Enum', (object, ), temp_enum_dict)</font>
<font color="green"> 813. del temp_enum_dict</font>
<font color="black"> 814. </font>
<font color="black"> 815. # Enum has now been created</font>
<font color="black"> 816. ###########################</font>
<font color="black"> 817. </font>
<font color="green"> 818. class IntEnum(int, Enum):</font>
<font color="green"> 819.     &quot;&quot;&quot;Enum where members are also (and must be) ints&quot;&quot;&quot;</font>
<font color="black"> 820. </font>
<font color="green"> 821. def _reduce_ex_by_name(self, proto):</font>
<font color="red"> 822.     return self.name</font>
<font color="black"> 823. </font>
<font color="green"> 824. def unique(enumeration):</font>
<font color="black"> 825.     &quot;&quot;&quot;Class decorator that ensures only unique members exist in an enumeration.&quot;&quot;&quot;</font>
<font color="red"> 826.     duplicates = []</font>
<font color="red"> 827.     for name, member in enumeration.__members__.items():</font>
<font color="red"> 828.         if name != member.name:</font>
<font color="red"> 829.             duplicates.append((name, member.name))</font>
<font color="red"> 830.     if duplicates:</font>
<font color="red"> 831.         duplicate_names = ', '.join(</font>
<font color="red"> 832.                 [&quot;%s -&gt; %s&quot; % (alias, name) for (alias, name) in duplicates]</font>
<font color="black"> 833.                 )</font>
<font color="red"> 834.         raise ValueError('duplicate names found in %r: %s' %</font>
<font color="red"> 835.                 (enumeration, duplicate_names)</font>
<font color="black"> 836.                 )</font>
<font color="red"> 837.     return enumeration</font>
</pre>

