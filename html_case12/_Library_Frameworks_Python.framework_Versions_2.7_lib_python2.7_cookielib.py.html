source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/cookielib.py</b><br>


file stats: <b>1025 lines, 223 executed: 21.8% covered</b>
<pre>
<font color="black">   1. r&quot;&quot;&quot;HTTP cookie handling for web clients.</font>
<font color="black">   2. </font>
<font color="black">   3. This module has (now fairly distant) origins in Gisle Aas' Perl module</font>
<font color="black">   4. HTTP::Cookies, from the libwww-perl library.</font>
<font color="black">   5. </font>
<font color="black">   6. Docstrings, comments and debug strings in this code refer to the</font>
<font color="black">   7. attributes of the HTTP cookie system as cookie-attributes, to distinguish</font>
<font color="black">   8. them clearly from Python attributes.</font>
<font color="black">   9. </font>
<font color="black">  10. Class diagram (note that BSDDBCookieJar and the MSIE* classes are not</font>
<font color="black">  11. distributed with the Python standard library, but are available from</font>
<font color="black">  12. http://wwwsearch.sf.net/):</font>
<font color="black">  13. </font>
<font color="black">  14.                         CookieJar____</font>
<font color="black">  15.                         /     \      \</font>
<font color="black">  16.             FileCookieJar      \      \</font>
<font color="black">  17.              /    |   \         \      \</font>
<font color="black">  18.  MozillaCookieJar | LWPCookieJar \      \</font>
<font color="black">  19.                   |               |      \</font>
<font color="black">  20.                   |   ---MSIEBase |       \</font>
<font color="black">  21.                   |  /      |     |        \</font>
<font color="black">  22.                   | /   MSIEDBCookieJar BSDDBCookieJar</font>
<font color="black">  23.                   |/</font>
<font color="black">  24.                MSIECookieJar</font>
<font color="black">  25. </font>
<font color="green">  26. &quot;&quot;&quot;</font>
<font color="black">  27. </font>
<font color="green">  28. __all__ = ['Cookie', 'CookieJar', 'CookiePolicy', 'DefaultCookiePolicy',</font>
<font color="green">  29.            'FileCookieJar', 'LWPCookieJar', 'lwp_cookie_str', 'LoadError',</font>
<font color="green">  30.            'MozillaCookieJar']</font>
<font color="black">  31. </font>
<font color="green">  32. import re, urlparse, copy, time, urllib</font>
<font color="green">  33. try:</font>
<font color="green">  34.     import threading as _threading</font>
<font color="red">  35. except ImportError:</font>
<font color="red">  36.     import dummy_threading as _threading</font>
<font color="green">  37. import httplib  # only for the default HTTP port</font>
<font color="green">  38. from calendar import timegm</font>
<font color="black">  39. </font>
<font color="green">  40. debug = False   # set to True to enable debugging via the logging module</font>
<font color="green">  41. logger = None</font>
<font color="black">  42. </font>
<font color="green">  43. def _debug(*args):</font>
<font color="green">  44.     if not debug:</font>
<font color="green">  45.         return</font>
<font color="black">  46.     global logger</font>
<font color="red">  47.     if not logger:</font>
<font color="red">  48.         import logging</font>
<font color="red">  49.         logger = logging.getLogger(&quot;cookielib&quot;)</font>
<font color="red">  50.     return logger.debug(*args)</font>
<font color="black">  51. </font>
<font color="black">  52. </font>
<font color="green">  53. DEFAULT_HTTP_PORT = str(httplib.HTTP_PORT)</font>
<font color="green">  54. MISSING_FILENAME_TEXT = (&quot;a filename was not supplied (nor was the CookieJar &quot;</font>
<font color="black">  55.                          &quot;instance initialised with one)&quot;)</font>
<font color="black">  56. </font>
<font color="green">  57. def _warn_unhandled_exception():</font>
<font color="black">  58.     # There are a few catch-all except: statements in this module, for</font>
<font color="black">  59.     # catching input that's bad in unexpected ways.  Warn if any</font>
<font color="black">  60.     # exceptions are caught there.</font>
<font color="red">  61.     import warnings, traceback, StringIO</font>
<font color="red">  62.     f = StringIO.StringIO()</font>
<font color="red">  63.     traceback.print_exc(None, f)</font>
<font color="red">  64.     msg = f.getvalue()</font>
<font color="red">  65.     warnings.warn(&quot;cookielib bug!\n%s&quot; % msg, stacklevel=2)</font>
<font color="black">  66. </font>
<font color="black">  67. </font>
<font color="black">  68. # Date/time conversion</font>
<font color="black">  69. # -----------------------------------------------------------------------------</font>
<font color="black">  70. </font>
<font color="green">  71. EPOCH_YEAR = 1970</font>
<font color="green">  72. def _timegm(tt):</font>
<font color="red">  73.     year, month, mday, hour, min, sec = tt[:6]</font>
<font color="red">  74.     if ((year &gt;= EPOCH_YEAR) and (1 &lt;= month &lt;= 12) and (1 &lt;= mday &lt;= 31) and</font>
<font color="red">  75.         (0 &lt;= hour &lt;= 24) and (0 &lt;= min &lt;= 59) and (0 &lt;= sec &lt;= 61)):</font>
<font color="red">  76.         return timegm(tt)</font>
<font color="black">  77.     else:</font>
<font color="red">  78.         return None</font>
<font color="black">  79. </font>
<font color="green">  80. DAYS = [&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;]</font>
<font color="green">  81. MONTHS = [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;,</font>
<font color="green">  82.           &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;]</font>
<font color="green">  83. MONTHS_LOWER = []</font>
<font color="green">  84. for month in MONTHS: MONTHS_LOWER.append(month.lower())</font>
<font color="black">  85. </font>
<font color="green">  86. def time2isoz(t=None):</font>
<font color="black">  87.     &quot;&quot;&quot;Return a string representing time in seconds since epoch, t.</font>
<font color="black">  88. </font>
<font color="black">  89.     If the function is called without an argument, it will use the current</font>
<font color="black">  90.     time.</font>
<font color="black">  91. </font>
<font color="black">  92.     The format of the returned string is like &quot;YYYY-MM-DD hh:mm:ssZ&quot;,</font>
<font color="black">  93.     representing Universal Time (UTC, aka GMT).  An example of this format is:</font>
<font color="black">  94. </font>
<font color="black">  95.     1994-11-24 08:49:37Z</font>
<font color="black">  96. </font>
<font color="black">  97.     &quot;&quot;&quot;</font>
<font color="red">  98.     if t is None: t = time.time()</font>
<font color="red">  99.     year, mon, mday, hour, min, sec = time.gmtime(t)[:6]</font>
<font color="red"> 100.     return &quot;%04d-%02d-%02d %02d:%02d:%02dZ&quot; % (</font>
<font color="red"> 101.         year, mon, mday, hour, min, sec)</font>
<font color="black"> 102. </font>
<font color="green"> 103. def time2netscape(t=None):</font>
<font color="black"> 104.     &quot;&quot;&quot;Return a string representing time in seconds since epoch, t.</font>
<font color="black"> 105. </font>
<font color="black"> 106.     If the function is called without an argument, it will use the current</font>
<font color="black"> 107.     time.</font>
<font color="black"> 108. </font>
<font color="black"> 109.     The format of the returned string is like this:</font>
<font color="black"> 110. </font>
<font color="black"> 111.     Wed, DD-Mon-YYYY HH:MM:SS GMT</font>
<font color="black"> 112. </font>
<font color="black"> 113.     &quot;&quot;&quot;</font>
<font color="red"> 114.     if t is None: t = time.time()</font>
<font color="red"> 115.     year, mon, mday, hour, min, sec, wday = time.gmtime(t)[:7]</font>
<font color="red"> 116.     return &quot;%s, %02d-%s-%04d %02d:%02d:%02d GMT&quot; % (</font>
<font color="red"> 117.         DAYS[wday], mday, MONTHS[mon-1], year, hour, min, sec)</font>
<font color="black"> 118. </font>
<font color="black"> 119. </font>
<font color="green"> 120. UTC_ZONES = {&quot;GMT&quot;: None, &quot;UTC&quot;: None, &quot;UT&quot;: None, &quot;Z&quot;: None}</font>
<font color="black"> 121. </font>
<font color="green"> 122. TIMEZONE_RE = re.compile(r&quot;^([-+])?(\d\d?):?(\d\d)?$&quot;)</font>
<font color="green"> 123. def offset_from_tz_string(tz):</font>
<font color="red"> 124.     offset = None</font>
<font color="red"> 125.     if tz in UTC_ZONES:</font>
<font color="red"> 126.         offset = 0</font>
<font color="black"> 127.     else:</font>
<font color="red"> 128.         m = TIMEZONE_RE.search(tz)</font>
<font color="red"> 129.         if m:</font>
<font color="red"> 130.             offset = 3600 * int(m.group(2))</font>
<font color="red"> 131.             if m.group(3):</font>
<font color="red"> 132.                 offset = offset + 60 * int(m.group(3))</font>
<font color="red"> 133.             if m.group(1) == '-':</font>
<font color="red"> 134.                 offset = -offset</font>
<font color="red"> 135.     return offset</font>
<font color="black"> 136. </font>
<font color="green"> 137. def _str2time(day, mon, yr, hr, min, sec, tz):</font>
<font color="black"> 138.     # translate month name to number</font>
<font color="black"> 139.     # month numbers start with 1 (January)</font>
<font color="red"> 140.     try:</font>
<font color="red"> 141.         mon = MONTHS_LOWER.index(mon.lower())+1</font>
<font color="red"> 142.     except ValueError:</font>
<font color="black"> 143.         # maybe it's already a number</font>
<font color="red"> 144.         try:</font>
<font color="red"> 145.             imon = int(mon)</font>
<font color="red"> 146.         except ValueError:</font>
<font color="red"> 147.             return None</font>
<font color="red"> 148.         if 1 &lt;= imon &lt;= 12:</font>
<font color="red"> 149.             mon = imon</font>
<font color="black"> 150.         else:</font>
<font color="red"> 151.             return None</font>
<font color="black"> 152. </font>
<font color="black"> 153.     # make sure clock elements are defined</font>
<font color="red"> 154.     if hr is None: hr = 0</font>
<font color="red"> 155.     if min is None: min = 0</font>
<font color="red"> 156.     if sec is None: sec = 0</font>
<font color="black"> 157. </font>
<font color="red"> 158.     yr = int(yr)</font>
<font color="red"> 159.     day = int(day)</font>
<font color="red"> 160.     hr = int(hr)</font>
<font color="red"> 161.     min = int(min)</font>
<font color="red"> 162.     sec = int(sec)</font>
<font color="black"> 163. </font>
<font color="red"> 164.     if yr &lt; 1000:</font>
<font color="black"> 165.         # find &quot;obvious&quot; year</font>
<font color="red"> 166.         cur_yr = time.localtime(time.time())[0]</font>
<font color="red"> 167.         m = cur_yr % 100</font>
<font color="red"> 168.         tmp = yr</font>
<font color="red"> 169.         yr = yr + cur_yr - m</font>
<font color="red"> 170.         m = m - tmp</font>
<font color="red"> 171.         if abs(m) &gt; 50:</font>
<font color="red"> 172.             if m &gt; 0: yr = yr + 100</font>
<font color="red"> 173.             else: yr = yr - 100</font>
<font color="black"> 174. </font>
<font color="black"> 175.     # convert UTC time tuple to seconds since epoch (not timezone-adjusted)</font>
<font color="red"> 176.     t = _timegm((yr, mon, day, hr, min, sec, tz))</font>
<font color="black"> 177. </font>
<font color="red"> 178.     if t is not None:</font>
<font color="black"> 179.         # adjust time using timezone string, to get absolute time since epoch</font>
<font color="red"> 180.         if tz is None:</font>
<font color="red"> 181.             tz = &quot;UTC&quot;</font>
<font color="red"> 182.         tz = tz.upper()</font>
<font color="red"> 183.         offset = offset_from_tz_string(tz)</font>
<font color="red"> 184.         if offset is None:</font>
<font color="red"> 185.             return None</font>
<font color="red"> 186.         t = t - offset</font>
<font color="black"> 187. </font>
<font color="red"> 188.     return t</font>
<font color="black"> 189. </font>
<font color="green"> 190. STRICT_DATE_RE = re.compile(</font>
<font color="green"> 191.     r&quot;^[SMTWF][a-z][a-z], (\d\d) ([JFMASOND][a-z][a-z]) &quot;</font>
<font color="black"> 192.     &quot;(\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$&quot;)</font>
<font color="green"> 193. WEEKDAY_RE = re.compile(</font>
<font color="green"> 194.     r&quot;^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*&quot;, re.I)</font>
<font color="green"> 195. LOOSE_HTTP_DATE_RE = re.compile(</font>
<font color="black"> 196.     r&quot;&quot;&quot;^</font>
<font color="black"> 197.     (\d\d?)            # day</font>
<font color="black"> 198.        (?:\s+|[-\/])</font>
<font color="black"> 199.     (\w+)              # month</font>
<font color="black"> 200.         (?:\s+|[-\/])</font>
<font color="black"> 201.     (\d+)              # year</font>
<font color="black"> 202.     (?:</font>
<font color="black"> 203.           (?:\s+|:)    # separator before clock</font>
<font color="black"> 204.        (\d\d?):(\d\d)  # hour:min</font>
<font color="black"> 205.        (?::(\d\d))?    # optional seconds</font>
<font color="black"> 206.     )?                 # optional clock</font>
<font color="black"> 207.        \s*</font>
<font color="black"> 208.     ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone</font>
<font color="black"> 209.        \s*</font>
<font color="black"> 210.     (?:\(\w+\))?       # ASCII representation of timezone in parens.</font>
<font color="green"> 211.        \s*$&quot;&quot;&quot;, re.X)</font>
<font color="green"> 212. def http2time(text):</font>
<font color="black"> 213.     &quot;&quot;&quot;Returns time in seconds since epoch of time represented by a string.</font>
<font color="black"> 214. </font>
<font color="black"> 215.     Return value is an integer.</font>
<font color="black"> 216. </font>
<font color="black"> 217.     None is returned if the format of str is unrecognized, the time is outside</font>
<font color="black"> 218.     the representable range, or the timezone string is not recognized.  If the</font>
<font color="black"> 219.     string contains no timezone, UTC is assumed.</font>
<font color="black"> 220. </font>
<font color="black"> 221.     The timezone in the string may be numerical (like &quot;-0800&quot; or &quot;+0100&quot;) or a</font>
<font color="black"> 222.     string timezone (like &quot;UTC&quot;, &quot;GMT&quot;, &quot;BST&quot; or &quot;EST&quot;).  Currently, only the</font>
<font color="black"> 223.     timezone strings equivalent to UTC (zero offset) are known to the function.</font>
<font color="black"> 224. </font>
<font color="black"> 225.     The function loosely parses the following formats:</font>
<font color="black"> 226. </font>
<font color="black"> 227.     Wed, 09 Feb 1994 22:23:32 GMT       -- HTTP format</font>
<font color="black"> 228.     Tuesday, 08-Feb-94 14:15:29 GMT     -- old rfc850 HTTP format</font>
<font color="black"> 229.     Tuesday, 08-Feb-1994 14:15:29 GMT   -- broken rfc850 HTTP format</font>
<font color="black"> 230.     09 Feb 1994 22:23:32 GMT            -- HTTP format (no weekday)</font>
<font color="black"> 231.     08-Feb-94 14:15:29 GMT              -- rfc850 format (no weekday)</font>
<font color="black"> 232.     08-Feb-1994 14:15:29 GMT            -- broken rfc850 format (no weekday)</font>
<font color="black"> 233. </font>
<font color="black"> 234.     The parser ignores leading and trailing whitespace.  The time may be</font>
<font color="black"> 235.     absent.</font>
<font color="black"> 236. </font>
<font color="black"> 237.     If the year is given with only 2 digits, the function will select the</font>
<font color="black"> 238.     century that makes the year closest to the current date.</font>
<font color="black"> 239. </font>
<font color="black"> 240.     &quot;&quot;&quot;</font>
<font color="black"> 241.     # fast exit for strictly conforming string</font>
<font color="red"> 242.     m = STRICT_DATE_RE.search(text)</font>
<font color="red"> 243.     if m:</font>
<font color="red"> 244.         g = m.groups()</font>
<font color="red"> 245.         mon = MONTHS_LOWER.index(g[1].lower()) + 1</font>
<font color="red"> 246.         tt = (int(g[2]), mon, int(g[0]),</font>
<font color="red"> 247.               int(g[3]), int(g[4]), float(g[5]))</font>
<font color="red"> 248.         return _timegm(tt)</font>
<font color="black"> 249. </font>
<font color="black"> 250.     # No, we need some messy parsing...</font>
<font color="black"> 251. </font>
<font color="black"> 252.     # clean up</font>
<font color="red"> 253.     text = text.lstrip()</font>
<font color="red"> 254.     text = WEEKDAY_RE.sub(&quot;&quot;, text, 1)  # Useless weekday</font>
<font color="black"> 255. </font>
<font color="black"> 256.     # tz is time zone specifier string</font>
<font color="red"> 257.     day, mon, yr, hr, min, sec, tz = [None]*7</font>
<font color="black"> 258. </font>
<font color="black"> 259.     # loose regexp parse</font>
<font color="red"> 260.     m = LOOSE_HTTP_DATE_RE.search(text)</font>
<font color="red"> 261.     if m is not None:</font>
<font color="red"> 262.         day, mon, yr, hr, min, sec, tz = m.groups()</font>
<font color="black"> 263.     else:</font>
<font color="red"> 264.         return None  # bad format</font>
<font color="black"> 265. </font>
<font color="red"> 266.     return _str2time(day, mon, yr, hr, min, sec, tz)</font>
<font color="black"> 267. </font>
<font color="green"> 268. ISO_DATE_RE = re.compile(</font>
<font color="black"> 269.     &quot;&quot;&quot;^</font>
<font color="black"> 270.     (\d{4})              # year</font>
<font color="black"> 271.        [-\/]?</font>
<font color="black"> 272.     (\d\d?)              # numerical month</font>
<font color="black"> 273.        [-\/]?</font>
<font color="black"> 274.     (\d\d?)              # day</font>
<font color="black"> 275.    (?:</font>
<font color="black"> 276.          (?:\s+|[-:Tt])  # separator before clock</font>
<font color="black"> 277.       (\d\d?):?(\d\d)    # hour:min</font>
<font color="black"> 278.       (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)</font>
<font color="black"> 279.    )?                    # optional clock</font>
<font color="black"> 280.       \s*</font>
<font color="black"> 281.    ([-+]?\d\d?:?(:?\d\d)?</font>
<font color="black"> 282.     |Z|z)?               # timezone  (Z is &quot;zero meridian&quot;, i.e. GMT)</font>
<font color="green"> 283.       \s*$&quot;&quot;&quot;, re.X)</font>
<font color="green"> 284. def iso2time(text):</font>
<font color="black"> 285.     &quot;&quot;&quot;</font>
<font color="black"> 286.     As for http2time, but parses the ISO 8601 formats:</font>
<font color="black"> 287. </font>
<font color="black"> 288.     1994-02-03 14:15:29 -0100    -- ISO 8601 format</font>
<font color="black"> 289.     1994-02-03 14:15:29          -- zone is optional</font>
<font color="black"> 290.     1994-02-03                   -- only date</font>
<font color="black"> 291.     1994-02-03T14:15:29          -- Use T as separator</font>
<font color="black"> 292.     19940203T141529Z             -- ISO 8601 compact format</font>
<font color="black"> 293.     19940203                     -- only date</font>
<font color="black"> 294. </font>
<font color="black"> 295.     &quot;&quot;&quot;</font>
<font color="black"> 296.     # clean up</font>
<font color="red"> 297.     text = text.lstrip()</font>
<font color="black"> 298. </font>
<font color="black"> 299.     # tz is time zone specifier string</font>
<font color="red"> 300.     day, mon, yr, hr, min, sec, tz = [None]*7</font>
<font color="black"> 301. </font>
<font color="black"> 302.     # loose regexp parse</font>
<font color="red"> 303.     m = ISO_DATE_RE.search(text)</font>
<font color="red"> 304.     if m is not None:</font>
<font color="black"> 305.         # XXX there's an extra bit of the timezone I'm ignoring here: is</font>
<font color="black"> 306.         #   this the right thing to do?</font>
<font color="red"> 307.         yr, mon, day, hr, min, sec, tz, _ = m.groups()</font>
<font color="black"> 308.     else:</font>
<font color="red"> 309.         return None  # bad format</font>
<font color="black"> 310. </font>
<font color="red"> 311.     return _str2time(day, mon, yr, hr, min, sec, tz)</font>
<font color="black"> 312. </font>
<font color="black"> 313. </font>
<font color="black"> 314. # Header parsing</font>
<font color="black"> 315. # -----------------------------------------------------------------------------</font>
<font color="black"> 316. </font>
<font color="green"> 317. def unmatched(match):</font>
<font color="black"> 318.     &quot;&quot;&quot;Return unmatched part of re.Match object.&quot;&quot;&quot;</font>
<font color="red"> 319.     start, end = match.span(0)</font>
<font color="red"> 320.     return match.string[:start]+match.string[end:]</font>
<font color="black"> 321. </font>
<font color="green"> 322. HEADER_TOKEN_RE =        re.compile(r&quot;^\s*([^=\s;,]+)&quot;)</font>
<font color="green"> 323. HEADER_QUOTED_VALUE_RE = re.compile(r&quot;^\s*=\s*\&quot;([^\&quot;\\]*(?:\\.[^\&quot;\\]*)*)\&quot;&quot;)</font>
<font color="green"> 324. HEADER_VALUE_RE =        re.compile(r&quot;^\s*=\s*([^\s;,]*)&quot;)</font>
<font color="green"> 325. HEADER_ESCAPE_RE = re.compile(r&quot;\\(.)&quot;)</font>
<font color="green"> 326. def split_header_words(header_values):</font>
<font color="black"> 327.     r&quot;&quot;&quot;Parse header values into a list of lists containing key,value pairs.</font>
<font color="black"> 328. </font>
<font color="black"> 329.     The function knows how to deal with &quot;,&quot;, &quot;;&quot; and &quot;=&quot; as well as quoted</font>
<font color="black"> 330.     values after &quot;=&quot;.  A list of space separated tokens are parsed as if they</font>
<font color="black"> 331.     were separated by &quot;;&quot;.</font>
<font color="black"> 332. </font>
<font color="black"> 333.     If the header_values passed as argument contains multiple values, then they</font>
<font color="black"> 334.     are treated as if they were a single value separated by comma &quot;,&quot;.</font>
<font color="black"> 335. </font>
<font color="black"> 336.     This means that this function is useful for parsing header fields that</font>
<font color="black"> 337.     follow this syntax (BNF as from the HTTP/1.1 specification, but we relax</font>
<font color="black"> 338.     the requirement for tokens).</font>
<font color="black"> 339. </font>
<font color="black"> 340.       headers           = #header</font>
<font color="black"> 341.       header            = (token | parameter) *( [&quot;;&quot;] (token | parameter))</font>
<font color="black"> 342. </font>
<font color="black"> 343.       token             = 1*&lt;any CHAR except CTLs or separators&gt;</font>
<font color="black"> 344.       separators        = &quot;(&quot; | &quot;)&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;@&quot;</font>
<font color="black"> 345.                         | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &lt;&quot;&gt;</font>
<font color="black"> 346.                         | &quot;/&quot; | &quot;[&quot; | &quot;]&quot; | &quot;?&quot; | &quot;=&quot;</font>
<font color="black"> 347.                         | &quot;{&quot; | &quot;}&quot; | SP | HT</font>
<font color="black"> 348. </font>
<font color="black"> 349.       quoted-string     = ( &lt;&quot;&gt; *(qdtext | quoted-pair ) &lt;&quot;&gt; )</font>
<font color="black"> 350.       qdtext            = &lt;any TEXT except &lt;&quot;&gt;&gt;</font>
<font color="black"> 351.       quoted-pair       = &quot;\&quot; CHAR</font>
<font color="black"> 352. </font>
<font color="black"> 353.       parameter         = attribute &quot;=&quot; value</font>
<font color="black"> 354.       attribute         = token</font>
<font color="black"> 355.       value             = token | quoted-string</font>
<font color="black"> 356. </font>
<font color="black"> 357.     Each header is represented by a list of key/value pairs.  The value for a</font>
<font color="black"> 358.     simple token (not part of a parameter) is None.  Syntactically incorrect</font>
<font color="black"> 359.     headers will not necessarily be parsed as you would want.</font>
<font color="black"> 360. </font>
<font color="black"> 361.     This is easier to describe with some examples:</font>
<font color="black"> 362. </font>
<font color="black"> 363.     &gt;&gt;&gt; split_header_words(['foo=&quot;bar&quot;; port=&quot;80,81&quot;; discard, bar=baz'])</font>
<font color="black"> 364.     [[('foo', 'bar'), ('port', '80,81'), ('discard', None)], [('bar', 'baz')]]</font>
<font color="black"> 365.     &gt;&gt;&gt; split_header_words(['text/html; charset=&quot;iso-8859-1&quot;'])</font>
<font color="black"> 366.     [[('text/html', None), ('charset', 'iso-8859-1')]]</font>
<font color="black"> 367.     &gt;&gt;&gt; split_header_words([r'Basic realm=&quot;\&quot;foo\bar\&quot;&quot;'])</font>
<font color="black"> 368.     [[('Basic', None), ('realm', '&quot;foobar&quot;')]]</font>
<font color="black"> 369. </font>
<font color="black"> 370.     &quot;&quot;&quot;</font>
<font color="red"> 371.     assert not isinstance(header_values, basestring)</font>
<font color="red"> 372.     result = []</font>
<font color="red"> 373.     for text in header_values:</font>
<font color="red"> 374.         orig_text = text</font>
<font color="red"> 375.         pairs = []</font>
<font color="red"> 376.         while text:</font>
<font color="red"> 377.             m = HEADER_TOKEN_RE.search(text)</font>
<font color="red"> 378.             if m:</font>
<font color="red"> 379.                 text = unmatched(m)</font>
<font color="red"> 380.                 name = m.group(1)</font>
<font color="red"> 381.                 m = HEADER_QUOTED_VALUE_RE.search(text)</font>
<font color="red"> 382.                 if m:  # quoted value</font>
<font color="red"> 383.                     text = unmatched(m)</font>
<font color="red"> 384.                     value = m.group(1)</font>
<font color="red"> 385.                     value = HEADER_ESCAPE_RE.sub(r&quot;\1&quot;, value)</font>
<font color="black"> 386.                 else:</font>
<font color="red"> 387.                     m = HEADER_VALUE_RE.search(text)</font>
<font color="red"> 388.                     if m:  # unquoted value</font>
<font color="red"> 389.                         text = unmatched(m)</font>
<font color="red"> 390.                         value = m.group(1)</font>
<font color="red"> 391.                         value = value.rstrip()</font>
<font color="black"> 392.                     else:</font>
<font color="black"> 393.                         # no value, a lone token</font>
<font color="red"> 394.                         value = None</font>
<font color="red"> 395.                 pairs.append((name, value))</font>
<font color="red"> 396.             elif text.lstrip().startswith(&quot;,&quot;):</font>
<font color="black"> 397.                 # concatenated headers, as per RFC 2616 section 4.2</font>
<font color="red"> 398.                 text = text.lstrip()[1:]</font>
<font color="red"> 399.                 if pairs: result.append(pairs)</font>
<font color="red"> 400.                 pairs = []</font>
<font color="black"> 401.             else:</font>
<font color="black"> 402.                 # skip junk</font>
<font color="red"> 403.                 non_junk, nr_junk_chars = re.subn(&quot;^[=\s;]*&quot;, &quot;&quot;, text)</font>
<font color="red"> 404.                 assert nr_junk_chars &gt; 0, (</font>
<font color="red"> 405.                     &quot;split_header_words bug: '%s', '%s', %s&quot; %</font>
<font color="red"> 406.                     (orig_text, text, pairs))</font>
<font color="red"> 407.                 text = non_junk</font>
<font color="red"> 408.         if pairs: result.append(pairs)</font>
<font color="red"> 409.     return result</font>
<font color="black"> 410. </font>
<font color="green"> 411. HEADER_JOIN_ESCAPE_RE = re.compile(r&quot;([\&quot;\\])&quot;)</font>
<font color="green"> 412. def join_header_words(lists):</font>
<font color="black"> 413.     &quot;&quot;&quot;Do the inverse (almost) of the conversion done by split_header_words.</font>
<font color="black"> 414. </font>
<font color="black"> 415.     Takes a list of lists of (key, value) pairs and produces a single header</font>
<font color="black"> 416.     value.  Attribute values are quoted if needed.</font>
<font color="black"> 417. </font>
<font color="black"> 418.     &gt;&gt;&gt; join_header_words([[(&quot;text/plain&quot;, None), (&quot;charset&quot;, &quot;iso-8859/1&quot;)]])</font>
<font color="black"> 419.     'text/plain; charset=&quot;iso-8859/1&quot;'</font>
<font color="black"> 420.     &gt;&gt;&gt; join_header_words([[(&quot;text/plain&quot;, None)], [(&quot;charset&quot;, &quot;iso-8859/1&quot;)]])</font>
<font color="black"> 421.     'text/plain, charset=&quot;iso-8859/1&quot;'</font>
<font color="black"> 422. </font>
<font color="black"> 423.     &quot;&quot;&quot;</font>
<font color="red"> 424.     headers = []</font>
<font color="red"> 425.     for pairs in lists:</font>
<font color="red"> 426.         attr = []</font>
<font color="red"> 427.         for k, v in pairs:</font>
<font color="red"> 428.             if v is not None:</font>
<font color="red"> 429.                 if not re.search(r&quot;^\w+$&quot;, v):</font>
<font color="red"> 430.                     v = HEADER_JOIN_ESCAPE_RE.sub(r&quot;\\\1&quot;, v)  # escape &quot; and \</font>
<font color="red"> 431.                     v = '&quot;%s&quot;' % v</font>
<font color="red"> 432.                 k = &quot;%s=%s&quot; % (k, v)</font>
<font color="red"> 433.             attr.append(k)</font>
<font color="red"> 434.         if attr: headers.append(&quot;; &quot;.join(attr))</font>
<font color="red"> 435.     return &quot;, &quot;.join(headers)</font>
<font color="black"> 436. </font>
<font color="green"> 437. def _strip_quotes(text):</font>
<font color="red"> 438.     if text.startswith('&quot;'):</font>
<font color="red"> 439.         text = text[1:]</font>
<font color="red"> 440.     if text.endswith('&quot;'):</font>
<font color="red"> 441.         text = text[:-1]</font>
<font color="red"> 442.     return text</font>
<font color="black"> 443. </font>
<font color="green"> 444. def parse_ns_headers(ns_headers):</font>
<font color="black"> 445.     &quot;&quot;&quot;Ad-hoc parser for Netscape protocol cookie-attributes.</font>
<font color="black"> 446. </font>
<font color="black"> 447.     The old Netscape cookie format for Set-Cookie can for instance contain</font>
<font color="black"> 448.     an unquoted &quot;,&quot; in the expires field, so we have to use this ad-hoc</font>
<font color="black"> 449.     parser instead of split_header_words.</font>
<font color="black"> 450. </font>
<font color="black"> 451.     XXX This may not make the best possible effort to parse all the crap</font>
<font color="black"> 452.     that Netscape Cookie headers contain.  Ronald Tschalar's HTTPClient</font>
<font color="black"> 453.     parser is probably better, so could do worse than following that if</font>
<font color="black"> 454.     this ever gives any trouble.</font>
<font color="black"> 455. </font>
<font color="black"> 456.     Currently, this is also used for parsing RFC 2109 cookies.</font>
<font color="black"> 457. </font>
<font color="black"> 458.     &quot;&quot;&quot;</font>
<font color="black"> 459.     known_attrs = (&quot;expires&quot;, &quot;domain&quot;, &quot;path&quot;, &quot;secure&quot;,</font>
<font color="black"> 460.                    # RFC 2109 attrs (may turn up in Netscape cookies, too)</font>
<font color="red"> 461.                    &quot;version&quot;, &quot;port&quot;, &quot;max-age&quot;)</font>
<font color="black"> 462. </font>
<font color="red"> 463.     result = []</font>
<font color="red"> 464.     for ns_header in ns_headers:</font>
<font color="red"> 465.         pairs = []</font>
<font color="red"> 466.         version_set = False</font>
<font color="black"> 467. </font>
<font color="black"> 468.         # XXX: The following does not strictly adhere to RFCs in that empty</font>
<font color="black"> 469.         # names and values are legal (the former will only appear once and will</font>
<font color="black"> 470.         # be overwritten if multiple occurrences are present). This is</font>
<font color="black"> 471.         # mostly to deal with backwards compatibility.</font>
<font color="red"> 472.         for ii, param in enumerate(ns_header.split(';')):</font>
<font color="red"> 473.             param = param.strip()</font>
<font color="black"> 474. </font>
<font color="red"> 475.             key, sep, val = param.partition('=')</font>
<font color="red"> 476.             key = key.strip()</font>
<font color="black"> 477. </font>
<font color="red"> 478.             if not key:</font>
<font color="red"> 479.                 if ii == 0:</font>
<font color="red"> 480.                     break</font>
<font color="black"> 481.                 else:</font>
<font color="red"> 482.                     continue</font>
<font color="black"> 483. </font>
<font color="black"> 484.             # allow for a distinction between present and empty and missing</font>
<font color="black"> 485.             # altogether</font>
<font color="red"> 486.             val = val.strip() if sep else None</font>
<font color="black"> 487. </font>
<font color="red"> 488.             if ii != 0:</font>
<font color="red"> 489.                 lc = key.lower()</font>
<font color="red"> 490.                 if lc in known_attrs:</font>
<font color="red"> 491.                     key = lc</font>
<font color="black"> 492. </font>
<font color="red"> 493.                 if key == &quot;version&quot;:</font>
<font color="black"> 494.                     # This is an RFC 2109 cookie.</font>
<font color="red"> 495.                     if val is not None:</font>
<font color="red"> 496.                         val = _strip_quotes(val)</font>
<font color="red"> 497.                     version_set = True</font>
<font color="red"> 498.                 elif key == &quot;expires&quot;:</font>
<font color="black"> 499.                     # convert expires date to seconds since epoch</font>
<font color="red"> 500.                     if val is not None:</font>
<font color="red"> 501.                         val = http2time(_strip_quotes(val))  # None if invalid</font>
<font color="red"> 502.             pairs.append((key, val))</font>
<font color="black"> 503. </font>
<font color="red"> 504.         if pairs:</font>
<font color="red"> 505.             if not version_set:</font>
<font color="red"> 506.                 pairs.append((&quot;version&quot;, &quot;0&quot;))</font>
<font color="red"> 507.             result.append(pairs)</font>
<font color="black"> 508. </font>
<font color="red"> 509.     return result</font>
<font color="black"> 510. </font>
<font color="black"> 511. </font>
<font color="green"> 512. IPV4_RE = re.compile(r&quot;\.\d+$&quot;)</font>
<font color="green"> 513. def is_HDN(text):</font>
<font color="black"> 514.     &quot;&quot;&quot;Return True if text is a host domain name.&quot;&quot;&quot;</font>
<font color="black"> 515.     # XXX</font>
<font color="black"> 516.     # This may well be wrong.  Which RFC is HDN defined in, if any (for</font>
<font color="black"> 517.     #  the purposes of RFC 2965)?</font>
<font color="black"> 518.     # For the current implementation, what about IPv6?  Remember to look</font>
<font color="black"> 519.     #  at other uses of IPV4_RE also, if change this.</font>
<font color="red"> 520.     if IPV4_RE.search(text):</font>
<font color="red"> 521.         return False</font>
<font color="red"> 522.     if text == &quot;&quot;:</font>
<font color="red"> 523.         return False</font>
<font color="red"> 524.     if text[0] == &quot;.&quot; or text[-1] == &quot;.&quot;:</font>
<font color="red"> 525.         return False</font>
<font color="red"> 526.     return True</font>
<font color="black"> 527. </font>
<font color="green"> 528. def domain_match(A, B):</font>
<font color="black"> 529.     &quot;&quot;&quot;Return True if domain A domain-matches domain B, according to RFC 2965.</font>
<font color="black"> 530. </font>
<font color="black"> 531.     A and B may be host domain names or IP addresses.</font>
<font color="black"> 532. </font>
<font color="black"> 533.     RFC 2965, section 1:</font>
<font color="black"> 534. </font>
<font color="black"> 535.     Host names can be specified either as an IP address or a HDN string.</font>
<font color="black"> 536.     Sometimes we compare one host name with another.  (Such comparisons SHALL</font>
<font color="black"> 537.     be case-insensitive.)  Host A's name domain-matches host B's if</font>
<font color="black"> 538. </font>
<font color="black"> 539.          *  their host name strings string-compare equal; or</font>
<font color="black"> 540. </font>
<font color="black"> 541.          * A is a HDN string and has the form NB, where N is a non-empty</font>
<font color="black"> 542.             name string, B has the form .B', and B' is a HDN string.  (So,</font>
<font color="black"> 543.             x.y.com domain-matches .Y.com but not Y.com.)</font>
<font color="black"> 544. </font>
<font color="black"> 545.     Note that domain-match is not a commutative operation: a.b.c.com</font>
<font color="black"> 546.     domain-matches .c.com, but not the reverse.</font>
<font color="black"> 547. </font>
<font color="black"> 548.     &quot;&quot;&quot;</font>
<font color="black"> 549.     # Note that, if A or B are IP addresses, the only relevant part of the</font>
<font color="black"> 550.     # definition of the domain-match algorithm is the direct string-compare.</font>
<font color="red"> 551.     A = A.lower()</font>
<font color="red"> 552.     B = B.lower()</font>
<font color="red"> 553.     if A == B:</font>
<font color="red"> 554.         return True</font>
<font color="red"> 555.     if not is_HDN(A):</font>
<font color="red"> 556.         return False</font>
<font color="red"> 557.     i = A.rfind(B)</font>
<font color="red"> 558.     if i == -1 or i == 0:</font>
<font color="black"> 559.         # A does not have form NB, or N is the empty string</font>
<font color="red"> 560.         return False</font>
<font color="red"> 561.     if not B.startswith(&quot;.&quot;):</font>
<font color="red"> 562.         return False</font>
<font color="red"> 563.     if not is_HDN(B[1:]):</font>
<font color="red"> 564.         return False</font>
<font color="red"> 565.     return True</font>
<font color="black"> 566. </font>
<font color="green"> 567. def liberal_is_HDN(text):</font>
<font color="black"> 568.     &quot;&quot;&quot;Return True if text is a sort-of-like a host domain name.</font>
<font color="black"> 569. </font>
<font color="black"> 570.     For accepting/blocking domains.</font>
<font color="black"> 571. </font>
<font color="black"> 572.     &quot;&quot;&quot;</font>
<font color="red"> 573.     if IPV4_RE.search(text):</font>
<font color="red"> 574.         return False</font>
<font color="red"> 575.     return True</font>
<font color="black"> 576. </font>
<font color="green"> 577. def user_domain_match(A, B):</font>
<font color="black"> 578.     &quot;&quot;&quot;For blocking/accepting domains.</font>
<font color="black"> 579. </font>
<font color="black"> 580.     A and B may be host domain names or IP addresses.</font>
<font color="black"> 581. </font>
<font color="black"> 582.     &quot;&quot;&quot;</font>
<font color="red"> 583.     A = A.lower()</font>
<font color="red"> 584.     B = B.lower()</font>
<font color="red"> 585.     if not (liberal_is_HDN(A) and liberal_is_HDN(B)):</font>
<font color="red"> 586.         if A == B:</font>
<font color="black"> 587.             # equal IP addresses</font>
<font color="red"> 588.             return True</font>
<font color="red"> 589.         return False</font>
<font color="red"> 590.     initial_dot = B.startswith(&quot;.&quot;)</font>
<font color="red"> 591.     if initial_dot and A.endswith(B):</font>
<font color="red"> 592.         return True</font>
<font color="red"> 593.     if not initial_dot and A == B:</font>
<font color="red"> 594.         return True</font>
<font color="red"> 595.     return False</font>
<font color="black"> 596. </font>
<font color="green"> 597. cut_port_re = re.compile(r&quot;:\d+$&quot;)</font>
<font color="green"> 598. def request_host(request):</font>
<font color="black"> 599.     &quot;&quot;&quot;Return request-host, as defined by RFC 2965.</font>
<font color="black"> 600. </font>
<font color="black"> 601.     Variation from RFC: returned value is lowercased, for convenient</font>
<font color="black"> 602.     comparison.</font>
<font color="black"> 603. </font>
<font color="black"> 604.     &quot;&quot;&quot;</font>
<font color="red"> 605.     url = request.get_full_url()</font>
<font color="red"> 606.     host = urlparse.urlparse(url)[1]</font>
<font color="red"> 607.     if host == &quot;&quot;:</font>
<font color="red"> 608.         host = request.get_header(&quot;Host&quot;, &quot;&quot;)</font>
<font color="black"> 609. </font>
<font color="black"> 610.     # remove port, if present</font>
<font color="red"> 611.     host = cut_port_re.sub(&quot;&quot;, host, 1)</font>
<font color="red"> 612.     return host.lower()</font>
<font color="black"> 613. </font>
<font color="green"> 614. def eff_request_host(request):</font>
<font color="black"> 615.     &quot;&quot;&quot;Return a tuple (request-host, effective request-host name).</font>
<font color="black"> 616. </font>
<font color="black"> 617.     As defined by RFC 2965, except both are lowercased.</font>
<font color="black"> 618. </font>
<font color="black"> 619.     &quot;&quot;&quot;</font>
<font color="red"> 620.     erhn = req_host = request_host(request)</font>
<font color="red"> 621.     if req_host.find(&quot;.&quot;) == -1 and not IPV4_RE.search(req_host):</font>
<font color="red"> 622.         erhn = req_host + &quot;.local&quot;</font>
<font color="red"> 623.     return req_host, erhn</font>
<font color="black"> 624. </font>
<font color="green"> 625. def request_path(request):</font>
<font color="black"> 626.     &quot;&quot;&quot;Path component of request-URI, as defined by RFC 2965.&quot;&quot;&quot;</font>
<font color="red"> 627.     url = request.get_full_url()</font>
<font color="red"> 628.     parts = urlparse.urlsplit(url)</font>
<font color="red"> 629.     path = escape_path(parts.path)</font>
<font color="red"> 630.     if not path.startswith(&quot;/&quot;):</font>
<font color="black"> 631.         # fix bad RFC 2396 absoluteURI</font>
<font color="red"> 632.         path = &quot;/&quot; + path</font>
<font color="red"> 633.     return path</font>
<font color="black"> 634. </font>
<font color="green"> 635. def request_port(request):</font>
<font color="red"> 636.     host = request.get_host()</font>
<font color="red"> 637.     i = host.find(':')</font>
<font color="red"> 638.     if i &gt;= 0:</font>
<font color="red"> 639.         port = host[i+1:]</font>
<font color="red"> 640.         try:</font>
<font color="red"> 641.             int(port)</font>
<font color="red"> 642.         except ValueError:</font>
<font color="red"> 643.             _debug(&quot;nonnumeric port: '%s'&quot;, port)</font>
<font color="red"> 644.             return None</font>
<font color="black"> 645.     else:</font>
<font color="red"> 646.         port = DEFAULT_HTTP_PORT</font>
<font color="red"> 647.     return port</font>
<font color="black"> 648. </font>
<font color="black"> 649. # Characters in addition to A-Z, a-z, 0-9, '_', '.', and '-' that don't</font>
<font color="black"> 650. # need to be escaped to form a valid HTTP URL (RFCs 2396 and 1738).</font>
<font color="green"> 651. HTTP_PATH_SAFE = &quot;%/;:@&amp;=+$,!~*'()&quot;</font>
<font color="green"> 652. ESCAPED_CHAR_RE = re.compile(r&quot;%([0-9a-fA-F][0-9a-fA-F])&quot;)</font>
<font color="green"> 653. def uppercase_escaped_char(match):</font>
<font color="red"> 654.     return &quot;%%%s&quot; % match.group(1).upper()</font>
<font color="green"> 655. def escape_path(path):</font>
<font color="black"> 656.     &quot;&quot;&quot;Escape any invalid characters in HTTP URL, and uppercase all escapes.&quot;&quot;&quot;</font>
<font color="black"> 657.     # There's no knowing what character encoding was used to create URLs</font>
<font color="black"> 658.     # containing %-escapes, but since we have to pick one to escape invalid</font>
<font color="black"> 659.     # path characters, we pick UTF-8, as recommended in the HTML 4.0</font>
<font color="black"> 660.     # specification:</font>
<font color="black"> 661.     # http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.2.1</font>
<font color="black"> 662.     # And here, kind of: draft-fielding-uri-rfc2396bis-03</font>
<font color="black"> 663.     # (And in draft IRI specification: draft-duerst-iri-05)</font>
<font color="black"> 664.     # (And here, for new URI schemes: RFC 2718)</font>
<font color="red"> 665.     if isinstance(path, unicode):</font>
<font color="red"> 666.         path = path.encode(&quot;utf-8&quot;)</font>
<font color="red"> 667.     path = urllib.quote(path, HTTP_PATH_SAFE)</font>
<font color="red"> 668.     path = ESCAPED_CHAR_RE.sub(uppercase_escaped_char, path)</font>
<font color="red"> 669.     return path</font>
<font color="black"> 670. </font>
<font color="green"> 671. def reach(h):</font>
<font color="black"> 672.     &quot;&quot;&quot;Return reach of host h, as defined by RFC 2965, section 1.</font>
<font color="black"> 673. </font>
<font color="black"> 674.     The reach R of a host name H is defined as follows:</font>
<font color="black"> 675. </font>
<font color="black"> 676.        *  If</font>
<font color="black"> 677. </font>
<font color="black"> 678.           -  H is the host domain name of a host; and,</font>
<font color="black"> 679. </font>
<font color="black"> 680.           -  H has the form A.B; and</font>
<font color="black"> 681. </font>
<font color="black"> 682.           -  A has no embedded (that is, interior) dots; and</font>
<font color="black"> 683. </font>
<font color="black"> 684.           -  B has at least one embedded dot, or B is the string &quot;local&quot;.</font>
<font color="black"> 685.              then the reach of H is .B.</font>
<font color="black"> 686. </font>
<font color="black"> 687.        *  Otherwise, the reach of H is H.</font>
<font color="black"> 688. </font>
<font color="black"> 689.     &gt;&gt;&gt; reach(&quot;www.acme.com&quot;)</font>
<font color="black"> 690.     '.acme.com'</font>
<font color="black"> 691.     &gt;&gt;&gt; reach(&quot;acme.com&quot;)</font>
<font color="black"> 692.     'acme.com'</font>
<font color="black"> 693.     &gt;&gt;&gt; reach(&quot;acme.local&quot;)</font>
<font color="black"> 694.     '.local'</font>
<font color="black"> 695. </font>
<font color="black"> 696.     &quot;&quot;&quot;</font>
<font color="red"> 697.     i = h.find(&quot;.&quot;)</font>
<font color="red"> 698.     if i &gt;= 0:</font>
<font color="black"> 699.         #a = h[:i]  # this line is only here to show what a is</font>
<font color="red"> 700.         b = h[i+1:]</font>
<font color="red"> 701.         i = b.find(&quot;.&quot;)</font>
<font color="red"> 702.         if is_HDN(h) and (i &gt;= 0 or b == &quot;local&quot;):</font>
<font color="red"> 703.             return &quot;.&quot;+b</font>
<font color="red"> 704.     return h</font>
<font color="black"> 705. </font>
<font color="green"> 706. def is_third_party(request):</font>
<font color="black"> 707.     &quot;&quot;&quot;</font>
<font color="black"> 708. </font>
<font color="black"> 709.     RFC 2965, section 3.3.6:</font>
<font color="black"> 710. </font>
<font color="black"> 711.         An unverifiable transaction is to a third-party host if its request-</font>
<font color="black"> 712.         host U does not domain-match the reach R of the request-host O in the</font>
<font color="black"> 713.         origin transaction.</font>
<font color="black"> 714. </font>
<font color="black"> 715.     &quot;&quot;&quot;</font>
<font color="red"> 716.     req_host = request_host(request)</font>
<font color="red"> 717.     if not domain_match(req_host, reach(request.get_origin_req_host())):</font>
<font color="red"> 718.         return True</font>
<font color="black"> 719.     else:</font>
<font color="red"> 720.         return False</font>
<font color="black"> 721. </font>
<font color="black"> 722. </font>
<font color="green"> 723. class Cookie:</font>
<font color="black"> 724.     &quot;&quot;&quot;HTTP Cookie.</font>
<font color="black"> 725. </font>
<font color="black"> 726.     This class represents both Netscape and RFC 2965 cookies.</font>
<font color="black"> 727. </font>
<font color="black"> 728.     This is deliberately a very simple class.  It just holds attributes.  It's</font>
<font color="black"> 729.     possible to construct Cookie instances that don't comply with the cookie</font>
<font color="black"> 730.     standards.  CookieJar.make_cookies is the factory function for Cookie</font>
<font color="black"> 731.     objects -- it deals with cookie parsing, supplying defaults, and</font>
<font color="black"> 732.     normalising to the representation used in this class.  CookiePolicy is</font>
<font color="black"> 733.     responsible for checking them to see whether they should be accepted from</font>
<font color="black"> 734.     and returned to the server.</font>
<font color="black"> 735. </font>
<font color="black"> 736.     Note that the port may be present in the headers, but unspecified (&quot;Port&quot;</font>
<font color="black"> 737.     rather than&quot;Port=80&quot;, for example); if this is the case, port is None.</font>
<font color="black"> 738. </font>
<font color="green"> 739.     &quot;&quot;&quot;</font>
<font color="black"> 740. </font>
<font color="black"> 741.     def __init__(self, version, name, value,</font>
<font color="black"> 742.                  port, port_specified,</font>
<font color="black"> 743.                  domain, domain_specified, domain_initial_dot,</font>
<font color="black"> 744.                  path, path_specified,</font>
<font color="black"> 745.                  secure,</font>
<font color="black"> 746.                  expires,</font>
<font color="black"> 747.                  discard,</font>
<font color="black"> 748.                  comment,</font>
<font color="black"> 749.                  comment_url,</font>
<font color="black"> 750.                  rest,</font>
<font color="green"> 751.                  rfc2109=False,</font>
<font color="black"> 752.                  ):</font>
<font color="black"> 753. </font>
<font color="red"> 754.         if version is not None: version = int(version)</font>
<font color="red"> 755.         if expires is not None: expires = int(expires)</font>
<font color="red"> 756.         if port is None and port_specified is True:</font>
<font color="red"> 757.             raise ValueError(&quot;if port is None, port_specified must be false&quot;)</font>
<font color="black"> 758. </font>
<font color="red"> 759.         self.version = version</font>
<font color="red"> 760.         self.name = name</font>
<font color="red"> 761.         self.value = value</font>
<font color="red"> 762.         self.port = port</font>
<font color="red"> 763.         self.port_specified = port_specified</font>
<font color="black"> 764.         # normalise case, as per RFC 2965 section 3.3.3</font>
<font color="red"> 765.         self.domain = domain.lower()</font>
<font color="red"> 766.         self.domain_specified = domain_specified</font>
<font color="black"> 767.         # Sigh.  We need to know whether the domain given in the</font>
<font color="black"> 768.         # cookie-attribute had an initial dot, in order to follow RFC 2965</font>
<font color="black"> 769.         # (as clarified in draft errata).  Needed for the returned $Domain</font>
<font color="black"> 770.         # value.</font>
<font color="red"> 771.         self.domain_initial_dot = domain_initial_dot</font>
<font color="red"> 772.         self.path = path</font>
<font color="red"> 773.         self.path_specified = path_specified</font>
<font color="red"> 774.         self.secure = secure</font>
<font color="red"> 775.         self.expires = expires</font>
<font color="red"> 776.         self.discard = discard</font>
<font color="red"> 777.         self.comment = comment</font>
<font color="red"> 778.         self.comment_url = comment_url</font>
<font color="red"> 779.         self.rfc2109 = rfc2109</font>
<font color="black"> 780. </font>
<font color="red"> 781.         self._rest = copy.copy(rest)</font>
<font color="black"> 782. </font>
<font color="green"> 783.     def has_nonstandard_attr(self, name):</font>
<font color="red"> 784.         return name in self._rest</font>
<font color="green"> 785.     def get_nonstandard_attr(self, name, default=None):</font>
<font color="red"> 786.         return self._rest.get(name, default)</font>
<font color="green"> 787.     def set_nonstandard_attr(self, name, value):</font>
<font color="red"> 788.         self._rest[name] = value</font>
<font color="black"> 789. </font>
<font color="green"> 790.     def is_expired(self, now=None):</font>
<font color="red"> 791.         if now is None: now = time.time()</font>
<font color="red"> 792.         if (self.expires is not None) and (self.expires &lt;= now):</font>
<font color="red"> 793.             return True</font>
<font color="red"> 794.         return False</font>
<font color="black"> 795. </font>
<font color="green"> 796.     def __str__(self):</font>
<font color="red"> 797.         if self.port is None: p = &quot;&quot;</font>
<font color="red"> 798.         else: p = &quot;:&quot;+self.port</font>
<font color="red"> 799.         limit = self.domain + p + self.path</font>
<font color="red"> 800.         if self.value is not None:</font>
<font color="red"> 801.             namevalue = &quot;%s=%s&quot; % (self.name, self.value)</font>
<font color="black"> 802.         else:</font>
<font color="red"> 803.             namevalue = self.name</font>
<font color="red"> 804.         return &quot;&lt;Cookie %s for %s&gt;&quot; % (namevalue, limit)</font>
<font color="black"> 805. </font>
<font color="green"> 806.     def __repr__(self):</font>
<font color="red"> 807.         args = []</font>
<font color="red"> 808.         for name in (&quot;version&quot;, &quot;name&quot;, &quot;value&quot;,</font>
<font color="black"> 809.                      &quot;port&quot;, &quot;port_specified&quot;,</font>
<font color="black"> 810.                      &quot;domain&quot;, &quot;domain_specified&quot;, &quot;domain_initial_dot&quot;,</font>
<font color="black"> 811.                      &quot;path&quot;, &quot;path_specified&quot;,</font>
<font color="red"> 812.                      &quot;secure&quot;, &quot;expires&quot;, &quot;discard&quot;, &quot;comment&quot;, &quot;comment_url&quot;,</font>
<font color="black"> 813.                      ):</font>
<font color="red"> 814.             attr = getattr(self, name)</font>
<font color="red"> 815.             args.append(&quot;%s=%s&quot; % (name, repr(attr)))</font>
<font color="red"> 816.         args.append(&quot;rest=%s&quot; % repr(self._rest))</font>
<font color="red"> 817.         args.append(&quot;rfc2109=%s&quot; % repr(self.rfc2109))</font>
<font color="red"> 818.         return &quot;Cookie(%s)&quot; % &quot;, &quot;.join(args)</font>
<font color="black"> 819. </font>
<font color="black"> 820. </font>
<font color="green"> 821. class CookiePolicy:</font>
<font color="black"> 822.     &quot;&quot;&quot;Defines which cookies get accepted from and returned to server.</font>
<font color="black"> 823. </font>
<font color="black"> 824.     May also modify cookies, though this is probably a bad idea.</font>
<font color="black"> 825. </font>
<font color="black"> 826.     The subclass DefaultCookiePolicy defines the standard rules for Netscape</font>
<font color="black"> 827.     and RFC 2965 cookies -- override that if you want a customised policy.</font>
<font color="black"> 828. </font>
<font color="green"> 829.     &quot;&quot;&quot;</font>
<font color="green"> 830.     def set_ok(self, cookie, request):</font>
<font color="black"> 831.         &quot;&quot;&quot;Return true if (and only if) cookie should be accepted from server.</font>
<font color="black"> 832. </font>
<font color="black"> 833.         Currently, pre-expired cookies never get this far -- the CookieJar</font>
<font color="black"> 834.         class deletes such cookies itself.</font>
<font color="black"> 835. </font>
<font color="black"> 836.         &quot;&quot;&quot;</font>
<font color="red"> 837.         raise NotImplementedError()</font>
<font color="black"> 838. </font>
<font color="green"> 839.     def return_ok(self, cookie, request):</font>
<font color="black"> 840.         &quot;&quot;&quot;Return true if (and only if) cookie should be returned to server.&quot;&quot;&quot;</font>
<font color="red"> 841.         raise NotImplementedError()</font>
<font color="black"> 842. </font>
<font color="green"> 843.     def domain_return_ok(self, domain, request):</font>
<font color="black"> 844.         &quot;&quot;&quot;Return false if cookies should not be returned, given cookie domain.</font>
<font color="black"> 845.         &quot;&quot;&quot;</font>
<font color="red"> 846.         return True</font>
<font color="black"> 847. </font>
<font color="green"> 848.     def path_return_ok(self, path, request):</font>
<font color="black"> 849.         &quot;&quot;&quot;Return false if cookies should not be returned, given cookie path.</font>
<font color="black"> 850.         &quot;&quot;&quot;</font>
<font color="red"> 851.         return True</font>
<font color="black"> 852. </font>
<font color="black"> 853. </font>
<font color="green"> 854. class DefaultCookiePolicy(CookiePolicy):</font>
<font color="green"> 855.     &quot;&quot;&quot;Implements the standard rules for accepting and returning cookies.&quot;&quot;&quot;</font>
<font color="black"> 856. </font>
<font color="green"> 857.     DomainStrictNoDots = 1</font>
<font color="green"> 858.     DomainStrictNonDomain = 2</font>
<font color="green"> 859.     DomainRFC2965Match = 4</font>
<font color="black"> 860. </font>
<font color="green"> 861.     DomainLiberal = 0</font>
<font color="green"> 862.     DomainStrict = DomainStrictNoDots|DomainStrictNonDomain</font>
<font color="black"> 863. </font>
<font color="black"> 864.     def __init__(self,</font>
<font color="green"> 865.                  blocked_domains=None, allowed_domains=None,</font>
<font color="green"> 866.                  netscape=True, rfc2965=False,</font>
<font color="green"> 867.                  rfc2109_as_netscape=None,</font>
<font color="green"> 868.                  hide_cookie2=False,</font>
<font color="green"> 869.                  strict_domain=False,</font>
<font color="green"> 870.                  strict_rfc2965_unverifiable=True,</font>
<font color="green"> 871.                  strict_ns_unverifiable=False,</font>
<font color="green"> 872.                  strict_ns_domain=DomainLiberal,</font>
<font color="green"> 873.                  strict_ns_set_initial_dollar=False,</font>
<font color="green"> 874.                  strict_ns_set_path=False,</font>
<font color="black"> 875.                  ):</font>
<font color="black"> 876.         &quot;&quot;&quot;Constructor arguments should be passed as keyword arguments only.&quot;&quot;&quot;</font>
<font color="green"> 877.         self.netscape = netscape</font>
<font color="green"> 878.         self.rfc2965 = rfc2965</font>
<font color="green"> 879.         self.rfc2109_as_netscape = rfc2109_as_netscape</font>
<font color="green"> 880.         self.hide_cookie2 = hide_cookie2</font>
<font color="green"> 881.         self.strict_domain = strict_domain</font>
<font color="green"> 882.         self.strict_rfc2965_unverifiable = strict_rfc2965_unverifiable</font>
<font color="green"> 883.         self.strict_ns_unverifiable = strict_ns_unverifiable</font>
<font color="green"> 884.         self.strict_ns_domain = strict_ns_domain</font>
<font color="green"> 885.         self.strict_ns_set_initial_dollar = strict_ns_set_initial_dollar</font>
<font color="green"> 886.         self.strict_ns_set_path = strict_ns_set_path</font>
<font color="black"> 887. </font>
<font color="green"> 888.         if blocked_domains is not None:</font>
<font color="red"> 889.             self._blocked_domains = tuple(blocked_domains)</font>
<font color="black"> 890.         else:</font>
<font color="green"> 891.             self._blocked_domains = ()</font>
<font color="black"> 892. </font>
<font color="green"> 893.         if allowed_domains is not None:</font>
<font color="red"> 894.             allowed_domains = tuple(allowed_domains)</font>
<font color="green"> 895.         self._allowed_domains = allowed_domains</font>
<font color="black"> 896. </font>
<font color="green"> 897.     def blocked_domains(self):</font>
<font color="black"> 898.         &quot;&quot;&quot;Return the sequence of blocked domains (as a tuple).&quot;&quot;&quot;</font>
<font color="red"> 899.         return self._blocked_domains</font>
<font color="green"> 900.     def set_blocked_domains(self, blocked_domains):</font>
<font color="black"> 901.         &quot;&quot;&quot;Set the sequence of blocked domains.&quot;&quot;&quot;</font>
<font color="red"> 902.         self._blocked_domains = tuple(blocked_domains)</font>
<font color="black"> 903. </font>
<font color="green"> 904.     def is_blocked(self, domain):</font>
<font color="red"> 905.         for blocked_domain in self._blocked_domains:</font>
<font color="red"> 906.             if user_domain_match(domain, blocked_domain):</font>
<font color="red"> 907.                 return True</font>
<font color="red"> 908.         return False</font>
<font color="black"> 909. </font>
<font color="green"> 910.     def allowed_domains(self):</font>
<font color="black"> 911.         &quot;&quot;&quot;Return None, or the sequence of allowed domains (as a tuple).&quot;&quot;&quot;</font>
<font color="red"> 912.         return self._allowed_domains</font>
<font color="green"> 913.     def set_allowed_domains(self, allowed_domains):</font>
<font color="black"> 914.         &quot;&quot;&quot;Set the sequence of allowed domains, or None.&quot;&quot;&quot;</font>
<font color="red"> 915.         if allowed_domains is not None:</font>
<font color="red"> 916.             allowed_domains = tuple(allowed_domains)</font>
<font color="red"> 917.         self._allowed_domains = allowed_domains</font>
<font color="black"> 918. </font>
<font color="green"> 919.     def is_not_allowed(self, domain):</font>
<font color="red"> 920.         if self._allowed_domains is None:</font>
<font color="red"> 921.             return False</font>
<font color="red"> 922.         for allowed_domain in self._allowed_domains:</font>
<font color="red"> 923.             if user_domain_match(domain, allowed_domain):</font>
<font color="red"> 924.                 return False</font>
<font color="red"> 925.         return True</font>
<font color="black"> 926. </font>
<font color="green"> 927.     def set_ok(self, cookie, request):</font>
<font color="black"> 928.         &quot;&quot;&quot;</font>
<font color="black"> 929.         If you override .set_ok(), be sure to call this method.  If it returns</font>
<font color="black"> 930.         false, so should your subclass (assuming your subclass wants to be more</font>
<font color="black"> 931.         strict about which cookies to accept).</font>
<font color="black"> 932. </font>
<font color="black"> 933.         &quot;&quot;&quot;</font>
<font color="red"> 934.         _debug(&quot; - checking cookie %s=%s&quot;, cookie.name, cookie.value)</font>
<font color="black"> 935. </font>
<font color="red"> 936.         assert cookie.name is not None</font>
<font color="black"> 937. </font>
<font color="red"> 938.         for n in &quot;version&quot;, &quot;verifiability&quot;, &quot;name&quot;, &quot;path&quot;, &quot;domain&quot;, &quot;port&quot;:</font>
<font color="red"> 939.             fn_name = &quot;set_ok_&quot;+n</font>
<font color="red"> 940.             fn = getattr(self, fn_name)</font>
<font color="red"> 941.             if not fn(cookie, request):</font>
<font color="red"> 942.                 return False</font>
<font color="black"> 943. </font>
<font color="red"> 944.         return True</font>
<font color="black"> 945. </font>
<font color="green"> 946.     def set_ok_version(self, cookie, request):</font>
<font color="red"> 947.         if cookie.version is None:</font>
<font color="black"> 948.             # Version is always set to 0 by parse_ns_headers if it's a Netscape</font>
<font color="black"> 949.             # cookie, so this must be an invalid RFC 2965 cookie.</font>
<font color="red"> 950.             _debug(&quot;   Set-Cookie2 without version attribute (%s=%s)&quot;,</font>
<font color="red"> 951.                    cookie.name, cookie.value)</font>
<font color="red"> 952.             return False</font>
<font color="red"> 953.         if cookie.version &gt; 0 and not self.rfc2965:</font>
<font color="red"> 954.             _debug(&quot;   RFC 2965 cookies are switched off&quot;)</font>
<font color="red"> 955.             return False</font>
<font color="red"> 956.         elif cookie.version == 0 and not self.netscape:</font>
<font color="red"> 957.             _debug(&quot;   Netscape cookies are switched off&quot;)</font>
<font color="red"> 958.             return False</font>
<font color="red"> 959.         return True</font>
<font color="black"> 960. </font>
<font color="green"> 961.     def set_ok_verifiability(self, cookie, request):</font>
<font color="red"> 962.         if request.is_unverifiable() and is_third_party(request):</font>
<font color="red"> 963.             if cookie.version &gt; 0 and self.strict_rfc2965_unverifiable:</font>
<font color="red"> 964.                 _debug(&quot;   third-party RFC 2965 cookie during &quot;</font>
<font color="black"> 965.                              &quot;unverifiable transaction&quot;)</font>
<font color="red"> 966.                 return False</font>
<font color="red"> 967.             elif cookie.version == 0 and self.strict_ns_unverifiable:</font>
<font color="red"> 968.                 _debug(&quot;   third-party Netscape cookie during &quot;</font>
<font color="black"> 969.                              &quot;unverifiable transaction&quot;)</font>
<font color="red"> 970.                 return False</font>
<font color="red"> 971.         return True</font>
<font color="black"> 972. </font>
<font color="green"> 973.     def set_ok_name(self, cookie, request):</font>
<font color="black"> 974.         # Try and stop servers setting V0 cookies designed to hack other</font>
<font color="black"> 975.         # servers that know both V0 and V1 protocols.</font>
<font color="red"> 976.         if (cookie.version == 0 and self.strict_ns_set_initial_dollar and</font>
<font color="red"> 977.             cookie.name.startswith(&quot;$&quot;)):</font>
<font color="red"> 978.             _debug(&quot;   illegal name (starts with '$'): '%s'&quot;, cookie.name)</font>
<font color="red"> 979.             return False</font>
<font color="red"> 980.         return True</font>
<font color="black"> 981. </font>
<font color="green"> 982.     def set_ok_path(self, cookie, request):</font>
<font color="red"> 983.         if cookie.path_specified:</font>
<font color="red"> 984.             req_path = request_path(request)</font>
<font color="red"> 985.             if ((cookie.version &gt; 0 or</font>
<font color="red"> 986.                  (cookie.version == 0 and self.strict_ns_set_path)) and</font>
<font color="red"> 987.                 not req_path.startswith(cookie.path)):</font>
<font color="red"> 988.                 _debug(&quot;   path attribute %s is not a prefix of request &quot;</font>
<font color="red"> 989.                        &quot;path %s&quot;, cookie.path, req_path)</font>
<font color="red"> 990.                 return False</font>
<font color="red"> 991.         return True</font>
<font color="black"> 992. </font>
<font color="green"> 993.     def set_ok_domain(self, cookie, request):</font>
<font color="red"> 994.         if self.is_blocked(cookie.domain):</font>
<font color="red"> 995.             _debug(&quot;   domain %s is in user block-list&quot;, cookie.domain)</font>
<font color="red"> 996.             return False</font>
<font color="red"> 997.         if self.is_not_allowed(cookie.domain):</font>
<font color="red"> 998.             _debug(&quot;   domain %s is not in user allow-list&quot;, cookie.domain)</font>
<font color="red"> 999.             return False</font>
<font color="red">1000.         if cookie.domain_specified:</font>
<font color="red">1001.             req_host, erhn = eff_request_host(request)</font>
<font color="red">1002.             domain = cookie.domain</font>
<font color="red">1003.             if self.strict_domain and (domain.count(&quot;.&quot;) &gt;= 2):</font>
<font color="black">1004.                 # XXX This should probably be compared with the Konqueror</font>
<font color="black">1005.                 # (kcookiejar.cpp) and Mozilla implementations, but it's a</font>
<font color="black">1006.                 # losing battle.</font>
<font color="red">1007.                 i = domain.rfind(&quot;.&quot;)</font>
<font color="red">1008.                 j = domain.rfind(&quot;.&quot;, 0, i)</font>
<font color="red">1009.                 if j == 0:  # domain like .foo.bar</font>
<font color="red">1010.                     tld = domain[i+1:]</font>
<font color="red">1011.                     sld = domain[j+1:i]</font>
<font color="red">1012.                     if sld.lower() in (&quot;co&quot;, &quot;ac&quot;, &quot;com&quot;, &quot;edu&quot;, &quot;org&quot;, &quot;net&quot;,</font>
<font color="black">1013.                        &quot;gov&quot;, &quot;mil&quot;, &quot;int&quot;, &quot;aero&quot;, &quot;biz&quot;, &quot;cat&quot;, &quot;coop&quot;,</font>
<font color="black">1014.                        &quot;info&quot;, &quot;jobs&quot;, &quot;mobi&quot;, &quot;museum&quot;, &quot;name&quot;, &quot;pro&quot;,</font>
<font color="red">1015.                        &quot;travel&quot;, &quot;eu&quot;) and len(tld) == 2:</font>
<font color="black">1016.                         # domain like .co.uk</font>
<font color="red">1017.                         _debug(&quot;   country-code second level domain %s&quot;, domain)</font>
<font color="red">1018.                         return False</font>
<font color="red">1019.             if domain.startswith(&quot;.&quot;):</font>
<font color="red">1020.                 undotted_domain = domain[1:]</font>
<font color="black">1021.             else:</font>
<font color="red">1022.                 undotted_domain = domain</font>
<font color="red">1023.             embedded_dots = (undotted_domain.find(&quot;.&quot;) &gt;= 0)</font>
<font color="red">1024.             if not embedded_dots and domain != &quot;.local&quot;:</font>
<font color="red">1025.                 _debug(&quot;   non-local domain %s contains no embedded dot&quot;,</font>
<font color="red">1026.                        domain)</font>
<font color="red">1027.                 return False</font>
<font color="red">1028.             if cookie.version == 0:</font>
<font color="red">1029.                 if (not erhn.endswith(domain) and</font>
<font color="red">1030.                     (not erhn.startswith(&quot;.&quot;) and</font>
<font color="red">1031.                      not (&quot;.&quot;+erhn).endswith(domain))):</font>
<font color="red">1032.                     _debug(&quot;   effective request-host %s (even with added &quot;</font>
<font color="black">1033.                            &quot;initial dot) does not end with %s&quot;,</font>
<font color="red">1034.                            erhn, domain)</font>
<font color="red">1035.                     return False</font>
<font color="red">1036.             if (cookie.version &gt; 0 or</font>
<font color="red">1037.                 (self.strict_ns_domain &amp; self.DomainRFC2965Match)):</font>
<font color="red">1038.                 if not domain_match(erhn, domain):</font>
<font color="red">1039.                     _debug(&quot;   effective request-host %s does not domain-match &quot;</font>
<font color="red">1040.                            &quot;%s&quot;, erhn, domain)</font>
<font color="red">1041.                     return False</font>
<font color="red">1042.             if (cookie.version &gt; 0 or</font>
<font color="red">1043.                 (self.strict_ns_domain &amp; self.DomainStrictNoDots)):</font>
<font color="red">1044.                 host_prefix = req_host[:-len(domain)]</font>
<font color="red">1045.                 if (host_prefix.find(&quot;.&quot;) &gt;= 0 and</font>
<font color="red">1046.                     not IPV4_RE.search(req_host)):</font>
<font color="red">1047.                     _debug(&quot;   host prefix %s for domain %s contains a dot&quot;,</font>
<font color="red">1048.                            host_prefix, domain)</font>
<font color="red">1049.                     return False</font>
<font color="red">1050.         return True</font>
<font color="black">1051. </font>
<font color="green">1052.     def set_ok_port(self, cookie, request):</font>
<font color="red">1053.         if cookie.port_specified:</font>
<font color="red">1054.             req_port = request_port(request)</font>
<font color="red">1055.             if req_port is None:</font>
<font color="red">1056.                 req_port = &quot;80&quot;</font>
<font color="black">1057.             else:</font>
<font color="red">1058.                 req_port = str(req_port)</font>
<font color="red">1059.             for p in cookie.port.split(&quot;,&quot;):</font>
<font color="red">1060.                 try:</font>
<font color="red">1061.                     int(p)</font>
<font color="red">1062.                 except ValueError:</font>
<font color="red">1063.                     _debug(&quot;   bad port %s (not numeric)&quot;, p)</font>
<font color="red">1064.                     return False</font>
<font color="red">1065.                 if p == req_port:</font>
<font color="red">1066.                     break</font>
<font color="black">1067.             else:</font>
<font color="red">1068.                 _debug(&quot;   request port (%s) not found in %s&quot;,</font>
<font color="red">1069.                        req_port, cookie.port)</font>
<font color="red">1070.                 return False</font>
<font color="red">1071.         return True</font>
<font color="black">1072. </font>
<font color="green">1073.     def return_ok(self, cookie, request):</font>
<font color="black">1074.         &quot;&quot;&quot;</font>
<font color="black">1075.         If you override .return_ok(), be sure to call this method.  If it</font>
<font color="black">1076.         returns false, so should your subclass (assuming your subclass wants to</font>
<font color="black">1077.         be more strict about which cookies to return).</font>
<font color="black">1078. </font>
<font color="black">1079.         &quot;&quot;&quot;</font>
<font color="black">1080.         # Path has already been checked by .path_return_ok(), and domain</font>
<font color="black">1081.         # blocking done by .domain_return_ok().</font>
<font color="red">1082.         _debug(&quot; - checking cookie %s=%s&quot;, cookie.name, cookie.value)</font>
<font color="black">1083. </font>
<font color="red">1084.         for n in &quot;version&quot;, &quot;verifiability&quot;, &quot;secure&quot;, &quot;expires&quot;, &quot;port&quot;, &quot;domain&quot;:</font>
<font color="red">1085.             fn_name = &quot;return_ok_&quot;+n</font>
<font color="red">1086.             fn = getattr(self, fn_name)</font>
<font color="red">1087.             if not fn(cookie, request):</font>
<font color="red">1088.                 return False</font>
<font color="red">1089.         return True</font>
<font color="black">1090. </font>
<font color="green">1091.     def return_ok_version(self, cookie, request):</font>
<font color="red">1092.         if cookie.version &gt; 0 and not self.rfc2965:</font>
<font color="red">1093.             _debug(&quot;   RFC 2965 cookies are switched off&quot;)</font>
<font color="red">1094.             return False</font>
<font color="red">1095.         elif cookie.version == 0 and not self.netscape:</font>
<font color="red">1096.             _debug(&quot;   Netscape cookies are switched off&quot;)</font>
<font color="red">1097.             return False</font>
<font color="red">1098.         return True</font>
<font color="black">1099. </font>
<font color="green">1100.     def return_ok_verifiability(self, cookie, request):</font>
<font color="red">1101.         if request.is_unverifiable() and is_third_party(request):</font>
<font color="red">1102.             if cookie.version &gt; 0 and self.strict_rfc2965_unverifiable:</font>
<font color="red">1103.                 _debug(&quot;   third-party RFC 2965 cookie during unverifiable &quot;</font>
<font color="black">1104.                        &quot;transaction&quot;)</font>
<font color="red">1105.                 return False</font>
<font color="red">1106.             elif cookie.version == 0 and self.strict_ns_unverifiable:</font>
<font color="red">1107.                 _debug(&quot;   third-party Netscape cookie during unverifiable &quot;</font>
<font color="black">1108.                        &quot;transaction&quot;)</font>
<font color="red">1109.                 return False</font>
<font color="red">1110.         return True</font>
<font color="black">1111. </font>
<font color="green">1112.     def return_ok_secure(self, cookie, request):</font>
<font color="red">1113.         if cookie.secure and request.get_type() != &quot;https&quot;:</font>
<font color="red">1114.             _debug(&quot;   secure cookie with non-secure request&quot;)</font>
<font color="red">1115.             return False</font>
<font color="red">1116.         return True</font>
<font color="black">1117. </font>
<font color="green">1118.     def return_ok_expires(self, cookie, request):</font>
<font color="red">1119.         if cookie.is_expired(self._now):</font>
<font color="red">1120.             _debug(&quot;   cookie expired&quot;)</font>
<font color="red">1121.             return False</font>
<font color="red">1122.         return True</font>
<font color="black">1123. </font>
<font color="green">1124.     def return_ok_port(self, cookie, request):</font>
<font color="red">1125.         if cookie.port:</font>
<font color="red">1126.             req_port = request_port(request)</font>
<font color="red">1127.             if req_port is None:</font>
<font color="red">1128.                 req_port = &quot;80&quot;</font>
<font color="red">1129.             for p in cookie.port.split(&quot;,&quot;):</font>
<font color="red">1130.                 if p == req_port:</font>
<font color="red">1131.                     break</font>
<font color="black">1132.             else:</font>
<font color="red">1133.                 _debug(&quot;   request port %s does not match cookie port %s&quot;,</font>
<font color="red">1134.                        req_port, cookie.port)</font>
<font color="red">1135.                 return False</font>
<font color="red">1136.         return True</font>
<font color="black">1137. </font>
<font color="green">1138.     def return_ok_domain(self, cookie, request):</font>
<font color="red">1139.         req_host, erhn = eff_request_host(request)</font>
<font color="red">1140.         domain = cookie.domain</font>
<font color="black">1141. </font>
<font color="black">1142.         # strict check of non-domain cookies: Mozilla does this, MSIE5 doesn't</font>
<font color="red">1143.         if (cookie.version == 0 and</font>
<font color="red">1144.             (self.strict_ns_domain &amp; self.DomainStrictNonDomain) and</font>
<font color="red">1145.             not cookie.domain_specified and domain != erhn):</font>
<font color="red">1146.             _debug(&quot;   cookie with unspecified domain does not string-compare &quot;</font>
<font color="black">1147.                    &quot;equal to request domain&quot;)</font>
<font color="red">1148.             return False</font>
<font color="black">1149. </font>
<font color="red">1150.         if cookie.version &gt; 0 and not domain_match(erhn, domain):</font>
<font color="red">1151.             _debug(&quot;   effective request-host name %s does not domain-match &quot;</font>
<font color="red">1152.                    &quot;RFC 2965 cookie domain %s&quot;, erhn, domain)</font>
<font color="red">1153.             return False</font>
<font color="red">1154.         if cookie.version == 0 and not (&quot;.&quot;+erhn).endswith(domain):</font>
<font color="red">1155.             _debug(&quot;   request-host %s does not match Netscape cookie domain &quot;</font>
<font color="red">1156.                    &quot;%s&quot;, req_host, domain)</font>
<font color="red">1157.             return False</font>
<font color="red">1158.         return True</font>
<font color="black">1159. </font>
<font color="green">1160.     def domain_return_ok(self, domain, request):</font>
<font color="black">1161.         # Liberal check of.  This is here as an optimization to avoid</font>
<font color="black">1162.         # having to load lots of MSIE cookie files unless necessary.</font>
<font color="red">1163.         req_host, erhn = eff_request_host(request)</font>
<font color="red">1164.         if not req_host.startswith(&quot;.&quot;):</font>
<font color="red">1165.             req_host = &quot;.&quot;+req_host</font>
<font color="red">1166.         if not erhn.startswith(&quot;.&quot;):</font>
<font color="red">1167.             erhn = &quot;.&quot;+erhn</font>
<font color="red">1168.         if not (req_host.endswith(domain) or erhn.endswith(domain)):</font>
<font color="black">1169.             #_debug(&quot;   request domain %s does not match cookie domain %s&quot;,</font>
<font color="black">1170.             #       req_host, domain)</font>
<font color="red">1171.             return False</font>
<font color="black">1172. </font>
<font color="red">1173.         if self.is_blocked(domain):</font>
<font color="red">1174.             _debug(&quot;   domain %s is in user block-list&quot;, domain)</font>
<font color="red">1175.             return False</font>
<font color="red">1176.         if self.is_not_allowed(domain):</font>
<font color="red">1177.             _debug(&quot;   domain %s is not in user allow-list&quot;, domain)</font>
<font color="red">1178.             return False</font>
<font color="black">1179. </font>
<font color="red">1180.         return True</font>
<font color="black">1181. </font>
<font color="green">1182.     def path_return_ok(self, path, request):</font>
<font color="red">1183.         _debug(&quot;- checking cookie path=%s&quot;, path)</font>
<font color="red">1184.         req_path = request_path(request)</font>
<font color="red">1185.         if not req_path.startswith(path):</font>
<font color="red">1186.             _debug(&quot;  %s does not path-match %s&quot;, req_path, path)</font>
<font color="red">1187.             return False</font>
<font color="red">1188.         return True</font>
<font color="black">1189. </font>
<font color="black">1190. </font>
<font color="green">1191. def vals_sorted_by_key(adict):</font>
<font color="green">1192.     keys = adict.keys()</font>
<font color="green">1193.     keys.sort()</font>
<font color="green">1194.     return map(adict.get, keys)</font>
<font color="black">1195. </font>
<font color="green">1196. def deepvalues(mapping):</font>
<font color="black">1197.     &quot;&quot;&quot;Iterates over nested mapping, depth-first, in sorted order by key.&quot;&quot;&quot;</font>
<font color="green">1198.     values = vals_sorted_by_key(mapping)</font>
<font color="green">1199.     for obj in values:</font>
<font color="red">1200.         mapping = False</font>
<font color="red">1201.         try:</font>
<font color="red">1202.             obj.items</font>
<font color="red">1203.         except AttributeError:</font>
<font color="red">1204.             pass</font>
<font color="black">1205.         else:</font>
<font color="red">1206.             mapping = True</font>
<font color="red">1207.             for subobj in deepvalues(obj):</font>
<font color="red">1208.                 yield subobj</font>
<font color="red">1209.         if not mapping:</font>
<font color="red">1210.             yield obj</font>
<font color="black">1211. </font>
<font color="black">1212. </font>
<font color="black">1213. # Used as second parameter to dict.get() method, to distinguish absent</font>
<font color="black">1214. # dict key from one with a None value.</font>
<font color="green">1215. class Absent: pass</font>
<font color="black">1216. </font>
<font color="green">1217. class CookieJar:</font>
<font color="black">1218.     &quot;&quot;&quot;Collection of HTTP cookies.</font>
<font color="black">1219. </font>
<font color="black">1220.     You may not need to know about this class: try</font>
<font color="black">1221.     urllib2.build_opener(HTTPCookieProcessor).open(url).</font>
<font color="black">1222. </font>
<font color="green">1223.     &quot;&quot;&quot;</font>
<font color="black">1224. </font>
<font color="green">1225.     non_word_re = re.compile(r&quot;\W&quot;)</font>
<font color="green">1226.     quote_re = re.compile(r&quot;([\&quot;\\])&quot;)</font>
<font color="green">1227.     strict_domain_re = re.compile(r&quot;\.?[^.]*&quot;)</font>
<font color="green">1228.     domain_re = re.compile(r&quot;[^.]*&quot;)</font>
<font color="green">1229.     dots_re = re.compile(r&quot;^\.+&quot;)</font>
<font color="black">1230. </font>
<font color="green">1231.     magic_re = r&quot;^\#LWP-Cookies-(\d+\.\d+)&quot;</font>
<font color="black">1232. </font>
<font color="green">1233.     def __init__(self, policy=None):</font>
<font color="green">1234.         if policy is None:</font>
<font color="green">1235.             policy = DefaultCookiePolicy()</font>
<font color="green">1236.         self._policy = policy</font>
<font color="black">1237. </font>
<font color="green">1238.         self._cookies_lock = _threading.RLock()</font>
<font color="green">1239.         self._cookies = {}</font>
<font color="black">1240. </font>
<font color="green">1241.     def set_policy(self, policy):</font>
<font color="red">1242.         self._policy = policy</font>
<font color="black">1243. </font>
<font color="green">1244.     def _cookies_for_domain(self, domain, request):</font>
<font color="red">1245.         cookies = []</font>
<font color="red">1246.         if not self._policy.domain_return_ok(domain, request):</font>
<font color="red">1247.             return []</font>
<font color="red">1248.         _debug(&quot;Checking %s for cookies to return&quot;, domain)</font>
<font color="red">1249.         cookies_by_path = self._cookies[domain]</font>
<font color="red">1250.         for path in cookies_by_path.keys():</font>
<font color="red">1251.             if not self._policy.path_return_ok(path, request):</font>
<font color="red">1252.                 continue</font>
<font color="red">1253.             cookies_by_name = cookies_by_path[path]</font>
<font color="red">1254.             for cookie in cookies_by_name.values():</font>
<font color="red">1255.                 if not self._policy.return_ok(cookie, request):</font>
<font color="red">1256.                     _debug(&quot;   not returning cookie&quot;)</font>
<font color="red">1257.                     continue</font>
<font color="red">1258.                 _debug(&quot;   it's a match&quot;)</font>
<font color="red">1259.                 cookies.append(cookie)</font>
<font color="red">1260.         return cookies</font>
<font color="black">1261. </font>
<font color="green">1262.     def _cookies_for_request(self, request):</font>
<font color="black">1263.         &quot;&quot;&quot;Return a list of cookies to be returned to server.&quot;&quot;&quot;</font>
<font color="green">1264.         cookies = []</font>
<font color="green">1265.         for domain in self._cookies.keys():</font>
<font color="red">1266.             cookies.extend(self._cookies_for_domain(domain, request))</font>
<font color="green">1267.         return cookies</font>
<font color="black">1268. </font>
<font color="green">1269.     def _cookie_attrs(self, cookies):</font>
<font color="black">1270.         &quot;&quot;&quot;Return a list of cookie-attributes to be returned to server.</font>
<font color="black">1271. </font>
<font color="black">1272.         like ['foo=&quot;bar&quot;; $Path=&quot;/&quot;', ...]</font>
<font color="black">1273. </font>
<font color="black">1274.         The $Version attribute is also added when appropriate (currently only</font>
<font color="black">1275.         once per request).</font>
<font color="black">1276. </font>
<font color="black">1277.         &quot;&quot;&quot;</font>
<font color="black">1278.         # add cookies in order of most specific (ie. longest) path first</font>
<font color="green">1279.         cookies.sort(key=lambda arg: len(arg.path), reverse=True)</font>
<font color="black">1280. </font>
<font color="green">1281.         version_set = False</font>
<font color="black">1282. </font>
<font color="green">1283.         attrs = []</font>
<font color="green">1284.         for cookie in cookies:</font>
<font color="black">1285.             # set version of Cookie header</font>
<font color="black">1286.             # XXX</font>
<font color="black">1287.             # What should it be if multiple matching Set-Cookie headers have</font>
<font color="black">1288.             #  different versions themselves?</font>
<font color="black">1289.             # Answer: there is no answer; was supposed to be settled by</font>
<font color="black">1290.             #  RFC 2965 errata, but that may never appear...</font>
<font color="red">1291.             version = cookie.version</font>
<font color="red">1292.             if not version_set:</font>
<font color="red">1293.                 version_set = True</font>
<font color="red">1294.                 if version &gt; 0:</font>
<font color="red">1295.                     attrs.append(&quot;$Version=%s&quot; % version)</font>
<font color="black">1296. </font>
<font color="black">1297.             # quote cookie value if necessary</font>
<font color="black">1298.             # (not for Netscape protocol, which already has any quotes</font>
<font color="black">1299.             #  intact, due to the poorly-specified Netscape Cookie: syntax)</font>
<font color="red">1300.             if ((cookie.value is not None) and</font>
<font color="red">1301.                 self.non_word_re.search(cookie.value) and version &gt; 0):</font>
<font color="red">1302.                 value = self.quote_re.sub(r&quot;\\\1&quot;, cookie.value)</font>
<font color="black">1303.             else:</font>
<font color="red">1304.                 value = cookie.value</font>
<font color="black">1305. </font>
<font color="black">1306.             # add cookie-attributes to be returned in Cookie header</font>
<font color="red">1307.             if cookie.value is None:</font>
<font color="red">1308.                 attrs.append(cookie.name)</font>
<font color="black">1309.             else:</font>
<font color="red">1310.                 attrs.append(&quot;%s=%s&quot; % (cookie.name, value))</font>
<font color="red">1311.             if version &gt; 0:</font>
<font color="red">1312.                 if cookie.path_specified:</font>
<font color="red">1313.                     attrs.append('$Path=&quot;%s&quot;' % cookie.path)</font>
<font color="red">1314.                 if cookie.domain.startswith(&quot;.&quot;):</font>
<font color="red">1315.                     domain = cookie.domain</font>
<font color="red">1316.                     if (not cookie.domain_initial_dot and</font>
<font color="red">1317.                         domain.startswith(&quot;.&quot;)):</font>
<font color="red">1318.                         domain = domain[1:]</font>
<font color="red">1319.                     attrs.append('$Domain=&quot;%s&quot;' % domain)</font>
<font color="red">1320.                 if cookie.port is not None:</font>
<font color="red">1321.                     p = &quot;$Port&quot;</font>
<font color="red">1322.                     if cookie.port_specified:</font>
<font color="red">1323.                         p = p + ('=&quot;%s&quot;' % cookie.port)</font>
<font color="red">1324.                     attrs.append(p)</font>
<font color="black">1325. </font>
<font color="green">1326.         return attrs</font>
<font color="black">1327. </font>
<font color="green">1328.     def add_cookie_header(self, request):</font>
<font color="black">1329.         &quot;&quot;&quot;Add correct Cookie: header to request (urllib2.Request object).</font>
<font color="black">1330. </font>
<font color="black">1331.         The Cookie2 header is also added unless policy.hide_cookie2 is true.</font>
<font color="black">1332. </font>
<font color="black">1333.         &quot;&quot;&quot;</font>
<font color="green">1334.         _debug(&quot;add_cookie_header&quot;)</font>
<font color="green">1335.         self._cookies_lock.acquire()</font>
<font color="green">1336.         try:</font>
<font color="black">1337. </font>
<font color="green">1338.             self._policy._now = self._now = int(time.time())</font>
<font color="black">1339. </font>
<font color="green">1340.             cookies = self._cookies_for_request(request)</font>
<font color="black">1341. </font>
<font color="green">1342.             attrs = self._cookie_attrs(cookies)</font>
<font color="green">1343.             if attrs:</font>
<font color="red">1344.                 if not request.has_header(&quot;Cookie&quot;):</font>
<font color="red">1345.                     request.add_unredirected_header(</font>
<font color="red">1346.                         &quot;Cookie&quot;, &quot;; &quot;.join(attrs))</font>
<font color="black">1347. </font>
<font color="black">1348.             # if necessary, advertise that we know RFC 2965</font>
<font color="green">1349.             if (self._policy.rfc2965 and not self._policy.hide_cookie2 and</font>
<font color="red">1350.                 not request.has_header(&quot;Cookie2&quot;)):</font>
<font color="red">1351.                 for cookie in cookies:</font>
<font color="red">1352.                     if cookie.version != 1:</font>
<font color="red">1353.                         request.add_unredirected_header(&quot;Cookie2&quot;, '$Version=&quot;1&quot;')</font>
<font color="red">1354.                         break</font>
<font color="black">1355. </font>
<font color="black">1356.         finally:</font>
<font color="green">1357.             self._cookies_lock.release()</font>
<font color="black">1358. </font>
<font color="green">1359.         self.clear_expired_cookies()</font>
<font color="black">1360. </font>
<font color="green">1361.     def _normalized_cookie_tuples(self, attrs_set):</font>
<font color="black">1362.         &quot;&quot;&quot;Return list of tuples containing normalised cookie information.</font>
<font color="black">1363. </font>
<font color="black">1364.         attrs_set is the list of lists of key,value pairs extracted from</font>
<font color="black">1365.         the Set-Cookie or Set-Cookie2 headers.</font>
<font color="black">1366. </font>
<font color="black">1367.         Tuples are name, value, standard, rest, where name and value are the</font>
<font color="black">1368.         cookie name and value, standard is a dictionary containing the standard</font>
<font color="black">1369.         cookie-attributes (discard, secure, version, expires or max-age,</font>
<font color="black">1370.         domain, path and port) and rest is a dictionary containing the rest of</font>
<font color="black">1371.         the cookie-attributes.</font>
<font color="black">1372. </font>
<font color="black">1373.         &quot;&quot;&quot;</font>
<font color="red">1374.         cookie_tuples = []</font>
<font color="black">1375. </font>
<font color="red">1376.         boolean_attrs = &quot;discard&quot;, &quot;secure&quot;</font>
<font color="black">1377.         value_attrs = (&quot;version&quot;,</font>
<font color="black">1378.                        &quot;expires&quot;, &quot;max-age&quot;,</font>
<font color="black">1379.                        &quot;domain&quot;, &quot;path&quot;, &quot;port&quot;,</font>
<font color="red">1380.                        &quot;comment&quot;, &quot;commenturl&quot;)</font>
<font color="black">1381. </font>
<font color="red">1382.         for cookie_attrs in attrs_set:</font>
<font color="red">1383.             name, value = cookie_attrs[0]</font>
<font color="black">1384. </font>
<font color="black">1385.             # Build dictionary of standard cookie-attributes (standard) and</font>
<font color="black">1386.             # dictionary of other cookie-attributes (rest).</font>
<font color="black">1387. </font>
<font color="black">1388.             # Note: expiry time is normalised to seconds since epoch.  V0</font>
<font color="black">1389.             # cookies should have the Expires cookie-attribute, and V1 cookies</font>
<font color="black">1390.             # should have Max-Age, but since V1 includes RFC 2109 cookies (and</font>
<font color="black">1391.             # since V0 cookies may be a mish-mash of Netscape and RFC 2109), we</font>
<font color="black">1392.             # accept either (but prefer Max-Age).</font>
<font color="red">1393.             max_age_set = False</font>
<font color="black">1394. </font>
<font color="red">1395.             bad_cookie = False</font>
<font color="black">1396. </font>
<font color="red">1397.             standard = {}</font>
<font color="red">1398.             rest = {}</font>
<font color="red">1399.             for k, v in cookie_attrs[1:]:</font>
<font color="red">1400.                 lc = k.lower()</font>
<font color="black">1401.                 # don't lose case distinction for unknown fields</font>
<font color="red">1402.                 if lc in value_attrs or lc in boolean_attrs:</font>
<font color="red">1403.                     k = lc</font>
<font color="red">1404.                 if k in boolean_attrs and v is None:</font>
<font color="black">1405.                     # boolean cookie-attribute is present, but has no value</font>
<font color="black">1406.                     # (like &quot;discard&quot;, rather than &quot;port=80&quot;)</font>
<font color="red">1407.                     v = True</font>
<font color="red">1408.                 if k in standard:</font>
<font color="black">1409.                     # only first value is significant</font>
<font color="red">1410.                     continue</font>
<font color="red">1411.                 if k == &quot;domain&quot;:</font>
<font color="red">1412.                     if v is None:</font>
<font color="red">1413.                         _debug(&quot;   missing value for domain attribute&quot;)</font>
<font color="red">1414.                         bad_cookie = True</font>
<font color="red">1415.                         break</font>
<font color="black">1416.                     # RFC 2965 section 3.3.3</font>
<font color="red">1417.                     v = v.lower()</font>
<font color="red">1418.                 if k == &quot;expires&quot;:</font>
<font color="red">1419.                     if max_age_set:</font>
<font color="black">1420.                         # Prefer max-age to expires (like Mozilla)</font>
<font color="red">1421.                         continue</font>
<font color="red">1422.                     if v is None:</font>
<font color="red">1423.                         _debug(&quot;   missing or invalid value for expires &quot;</font>
<font color="black">1424.                               &quot;attribute: treating as session cookie&quot;)</font>
<font color="red">1425.                         continue</font>
<font color="red">1426.                 if k == &quot;max-age&quot;:</font>
<font color="red">1427.                     max_age_set = True</font>
<font color="red">1428.                     try:</font>
<font color="red">1429.                         v = int(v)</font>
<font color="red">1430.                     except ValueError:</font>
<font color="red">1431.                         _debug(&quot;   missing or invalid (non-numeric) value for &quot;</font>
<font color="black">1432.                               &quot;max-age attribute&quot;)</font>
<font color="red">1433.                         bad_cookie = True</font>
<font color="red">1434.                         break</font>
<font color="black">1435.                     # convert RFC 2965 Max-Age to seconds since epoch</font>
<font color="black">1436.                     # XXX Strictly you're supposed to follow RFC 2616</font>
<font color="black">1437.                     #   age-calculation rules.  Remember that zero Max-Age</font>
<font color="black">1438.                     #   is a request to discard (old and new) cookie, though.</font>
<font color="red">1439.                     k = &quot;expires&quot;</font>
<font color="red">1440.                     v = self._now + v</font>
<font color="red">1441.                 if (k in value_attrs) or (k in boolean_attrs):</font>
<font color="red">1442.                     if (v is None and</font>
<font color="red">1443.                         k not in (&quot;port&quot;, &quot;comment&quot;, &quot;commenturl&quot;)):</font>
<font color="red">1444.                         _debug(&quot;   missing value for %s attribute&quot; % k)</font>
<font color="red">1445.                         bad_cookie = True</font>
<font color="red">1446.                         break</font>
<font color="red">1447.                     standard[k] = v</font>
<font color="black">1448.                 else:</font>
<font color="red">1449.                     rest[k] = v</font>
<font color="black">1450. </font>
<font color="red">1451.             if bad_cookie:</font>
<font color="red">1452.                 continue</font>
<font color="black">1453. </font>
<font color="red">1454.             cookie_tuples.append((name, value, standard, rest))</font>
<font color="black">1455. </font>
<font color="red">1456.         return cookie_tuples</font>
<font color="black">1457. </font>
<font color="green">1458.     def _cookie_from_cookie_tuple(self, tup, request):</font>
<font color="black">1459.         # standard is dict of standard cookie-attributes, rest is dict of the</font>
<font color="black">1460.         # rest of them</font>
<font color="red">1461.         name, value, standard, rest = tup</font>
<font color="black">1462. </font>
<font color="red">1463.         domain = standard.get(&quot;domain&quot;, Absent)</font>
<font color="red">1464.         path = standard.get(&quot;path&quot;, Absent)</font>
<font color="red">1465.         port = standard.get(&quot;port&quot;, Absent)</font>
<font color="red">1466.         expires = standard.get(&quot;expires&quot;, Absent)</font>
<font color="black">1467. </font>
<font color="black">1468.         # set the easy defaults</font>
<font color="red">1469.         version = standard.get(&quot;version&quot;, None)</font>
<font color="red">1470.         if version is not None:</font>
<font color="red">1471.             try:</font>
<font color="red">1472.                 version = int(version)</font>
<font color="red">1473.             except ValueError:</font>
<font color="red">1474.                 return None  # invalid version, ignore cookie</font>
<font color="red">1475.         secure = standard.get(&quot;secure&quot;, False)</font>
<font color="black">1476.         # (discard is also set if expires is Absent)</font>
<font color="red">1477.         discard = standard.get(&quot;discard&quot;, False)</font>
<font color="red">1478.         comment = standard.get(&quot;comment&quot;, None)</font>
<font color="red">1479.         comment_url = standard.get(&quot;commenturl&quot;, None)</font>
<font color="black">1480. </font>
<font color="black">1481.         # set default path</font>
<font color="red">1482.         if path is not Absent and path != &quot;&quot;:</font>
<font color="red">1483.             path_specified = True</font>
<font color="red">1484.             path = escape_path(path)</font>
<font color="black">1485.         else:</font>
<font color="red">1486.             path_specified = False</font>
<font color="red">1487.             path = request_path(request)</font>
<font color="red">1488.             i = path.rfind(&quot;/&quot;)</font>
<font color="red">1489.             if i != -1:</font>
<font color="red">1490.                 if version == 0:</font>
<font color="black">1491.                     # Netscape spec parts company from reality here</font>
<font color="red">1492.                     path = path[:i]</font>
<font color="black">1493.                 else:</font>
<font color="red">1494.                     path = path[:i+1]</font>
<font color="red">1495.             if len(path) == 0: path = &quot;/&quot;</font>
<font color="black">1496. </font>
<font color="black">1497.         # set default domain</font>
<font color="red">1498.         domain_specified = domain is not Absent</font>
<font color="black">1499.         # but first we have to remember whether it starts with a dot</font>
<font color="red">1500.         domain_initial_dot = False</font>
<font color="red">1501.         if domain_specified:</font>
<font color="red">1502.             domain_initial_dot = bool(domain.startswith(&quot;.&quot;))</font>
<font color="red">1503.         if domain is Absent:</font>
<font color="red">1504.             req_host, erhn = eff_request_host(request)</font>
<font color="red">1505.             domain = erhn</font>
<font color="red">1506.         elif not domain.startswith(&quot;.&quot;):</font>
<font color="red">1507.             domain = &quot;.&quot;+domain</font>
<font color="black">1508. </font>
<font color="black">1509.         # set default port</font>
<font color="red">1510.         port_specified = False</font>
<font color="red">1511.         if port is not Absent:</font>
<font color="red">1512.             if port is None:</font>
<font color="black">1513.                 # Port attr present, but has no value: default to request port.</font>
<font color="black">1514.                 # Cookie should then only be sent back on that port.</font>
<font color="red">1515.                 port = request_port(request)</font>
<font color="black">1516.             else:</font>
<font color="red">1517.                 port_specified = True</font>
<font color="red">1518.                 port = re.sub(r&quot;\s+&quot;, &quot;&quot;, port)</font>
<font color="black">1519.         else:</font>
<font color="black">1520.             # No port attr present.  Cookie can be sent back on any port.</font>
<font color="red">1521.             port = None</font>
<font color="black">1522. </font>
<font color="black">1523.         # set default expires and discard</font>
<font color="red">1524.         if expires is Absent:</font>
<font color="red">1525.             expires = None</font>
<font color="red">1526.             discard = True</font>
<font color="red">1527.         elif expires &lt;= self._now:</font>
<font color="black">1528.             # Expiry date in past is request to delete cookie.  This can't be</font>
<font color="black">1529.             # in DefaultCookiePolicy, because can't delete cookies there.</font>
<font color="red">1530.             try:</font>
<font color="red">1531.                 self.clear(domain, path, name)</font>
<font color="red">1532.             except KeyError:</font>
<font color="red">1533.                 pass</font>
<font color="red">1534.             _debug(&quot;Expiring cookie, domain='%s', path='%s', name='%s'&quot;,</font>
<font color="red">1535.                    domain, path, name)</font>
<font color="red">1536.             return None</font>
<font color="black">1537. </font>
<font color="red">1538.         return Cookie(version,</font>
<font color="red">1539.                       name, value,</font>
<font color="red">1540.                       port, port_specified,</font>
<font color="red">1541.                       domain, domain_specified, domain_initial_dot,</font>
<font color="red">1542.                       path, path_specified,</font>
<font color="red">1543.                       secure,</font>
<font color="red">1544.                       expires,</font>
<font color="red">1545.                       discard,</font>
<font color="red">1546.                       comment,</font>
<font color="red">1547.                       comment_url,</font>
<font color="red">1548.                       rest)</font>
<font color="black">1549. </font>
<font color="green">1550.     def _cookies_from_attrs_set(self, attrs_set, request):</font>
<font color="red">1551.         cookie_tuples = self._normalized_cookie_tuples(attrs_set)</font>
<font color="black">1552. </font>
<font color="red">1553.         cookies = []</font>
<font color="red">1554.         for tup in cookie_tuples:</font>
<font color="red">1555.             cookie = self._cookie_from_cookie_tuple(tup, request)</font>
<font color="red">1556.             if cookie: cookies.append(cookie)</font>
<font color="red">1557.         return cookies</font>
<font color="black">1558. </font>
<font color="green">1559.     def _process_rfc2109_cookies(self, cookies):</font>
<font color="red">1560.         rfc2109_as_ns = getattr(self._policy, 'rfc2109_as_netscape', None)</font>
<font color="red">1561.         if rfc2109_as_ns is None:</font>
<font color="red">1562.             rfc2109_as_ns = not self._policy.rfc2965</font>
<font color="red">1563.         for cookie in cookies:</font>
<font color="red">1564.             if cookie.version == 1:</font>
<font color="red">1565.                 cookie.rfc2109 = True</font>
<font color="red">1566.                 if rfc2109_as_ns:</font>
<font color="black">1567.                     # treat 2109 cookies as Netscape cookies rather than</font>
<font color="black">1568.                     # as RFC2965 cookies</font>
<font color="red">1569.                     cookie.version = 0</font>
<font color="black">1570. </font>
<font color="green">1571.     def make_cookies(self, response, request):</font>
<font color="black">1572.         &quot;&quot;&quot;Return sequence of Cookie objects extracted from response object.&quot;&quot;&quot;</font>
<font color="black">1573.         # get cookie-attributes for RFC 2965 and Netscape protocols</font>
<font color="green">1574.         headers = response.info()</font>
<font color="green">1575.         rfc2965_hdrs = headers.getheaders(&quot;Set-Cookie2&quot;)</font>
<font color="green">1576.         ns_hdrs = headers.getheaders(&quot;Set-Cookie&quot;)</font>
<font color="black">1577. </font>
<font color="green">1578.         rfc2965 = self._policy.rfc2965</font>
<font color="green">1579.         netscape = self._policy.netscape</font>
<font color="black">1580. </font>
<font color="green">1581.         if ((not rfc2965_hdrs and not ns_hdrs) or</font>
<font color="red">1582.             (not ns_hdrs and not rfc2965) or</font>
<font color="red">1583.             (not rfc2965_hdrs and not netscape) or</font>
<font color="red">1584.             (not netscape and not rfc2965)):</font>
<font color="green">1585.             return []  # no relevant cookie headers: quick exit</font>
<font color="black">1586. </font>
<font color="red">1587.         try:</font>
<font color="red">1588.             cookies = self._cookies_from_attrs_set(</font>
<font color="red">1589.                 split_header_words(rfc2965_hdrs), request)</font>
<font color="red">1590.         except Exception:</font>
<font color="red">1591.             _warn_unhandled_exception()</font>
<font color="red">1592.             cookies = []</font>
<font color="black">1593. </font>
<font color="red">1594.         if ns_hdrs and netscape:</font>
<font color="red">1595.             try:</font>
<font color="black">1596.                 # RFC 2109 and Netscape cookies</font>
<font color="red">1597.                 ns_cookies = self._cookies_from_attrs_set(</font>
<font color="red">1598.                     parse_ns_headers(ns_hdrs), request)</font>
<font color="red">1599.             except Exception:</font>
<font color="red">1600.                 _warn_unhandled_exception()</font>
<font color="red">1601.                 ns_cookies = []</font>
<font color="red">1602.             self._process_rfc2109_cookies(ns_cookies)</font>
<font color="black">1603. </font>
<font color="black">1604.             # Look for Netscape cookies (from Set-Cookie headers) that match</font>
<font color="black">1605.             # corresponding RFC 2965 cookies (from Set-Cookie2 headers).</font>
<font color="black">1606.             # For each match, keep the RFC 2965 cookie and ignore the Netscape</font>
<font color="black">1607.             # cookie (RFC 2965 section 9.1).  Actually, RFC 2109 cookies are</font>
<font color="black">1608.             # bundled in with the Netscape cookies for this purpose, which is</font>
<font color="black">1609.             # reasonable behaviour.</font>
<font color="red">1610.             if rfc2965:</font>
<font color="red">1611.                 lookup = {}</font>
<font color="red">1612.                 for cookie in cookies:</font>
<font color="red">1613.                     lookup[(cookie.domain, cookie.path, cookie.name)] = None</font>
<font color="black">1614. </font>
<font color="red">1615.                 def no_matching_rfc2965(ns_cookie, lookup=lookup):</font>
<font color="red">1616.                     key = ns_cookie.domain, ns_cookie.path, ns_cookie.name</font>
<font color="red">1617.                     return key not in lookup</font>
<font color="red">1618.                 ns_cookies = filter(no_matching_rfc2965, ns_cookies)</font>
<font color="black">1619. </font>
<font color="red">1620.             if ns_cookies:</font>
<font color="red">1621.                 cookies.extend(ns_cookies)</font>
<font color="black">1622. </font>
<font color="red">1623.         return cookies</font>
<font color="black">1624. </font>
<font color="green">1625.     def set_cookie_if_ok(self, cookie, request):</font>
<font color="black">1626.         &quot;&quot;&quot;Set a cookie if policy says it's OK to do so.&quot;&quot;&quot;</font>
<font color="red">1627.         self._cookies_lock.acquire()</font>
<font color="red">1628.         try:</font>
<font color="red">1629.             self._policy._now = self._now = int(time.time())</font>
<font color="black">1630. </font>
<font color="red">1631.             if self._policy.set_ok(cookie, request):</font>
<font color="red">1632.                 self.set_cookie(cookie)</font>
<font color="black">1633. </font>
<font color="black">1634. </font>
<font color="black">1635.         finally:</font>
<font color="red">1636.             self._cookies_lock.release()</font>
<font color="black">1637. </font>
<font color="green">1638.     def set_cookie(self, cookie):</font>
<font color="black">1639.         &quot;&quot;&quot;Set a cookie, without checking whether or not it should be set.&quot;&quot;&quot;</font>
<font color="red">1640.         c = self._cookies</font>
<font color="red">1641.         self._cookies_lock.acquire()</font>
<font color="red">1642.         try:</font>
<font color="red">1643.             if cookie.domain not in c: c[cookie.domain] = {}</font>
<font color="red">1644.             c2 = c[cookie.domain]</font>
<font color="red">1645.             if cookie.path not in c2: c2[cookie.path] = {}</font>
<font color="red">1646.             c3 = c2[cookie.path]</font>
<font color="red">1647.             c3[cookie.name] = cookie</font>
<font color="black">1648.         finally:</font>
<font color="red">1649.             self._cookies_lock.release()</font>
<font color="black">1650. </font>
<font color="green">1651.     def extract_cookies(self, response, request):</font>
<font color="black">1652.         &quot;&quot;&quot;Extract cookies from response, where allowable given the request.&quot;&quot;&quot;</font>
<font color="green">1653.         _debug(&quot;extract_cookies: %s&quot;, response.info())</font>
<font color="green">1654.         self._cookies_lock.acquire()</font>
<font color="green">1655.         try:</font>
<font color="green">1656.             self._policy._now = self._now = int(time.time())</font>
<font color="black">1657. </font>
<font color="green">1658.             for cookie in self.make_cookies(response, request):</font>
<font color="red">1659.                 if self._policy.set_ok(cookie, request):</font>
<font color="red">1660.                     _debug(&quot; setting cookie: %s&quot;, cookie)</font>
<font color="red">1661.                     self.set_cookie(cookie)</font>
<font color="black">1662.         finally:</font>
<font color="green">1663.             self._cookies_lock.release()</font>
<font color="black">1664. </font>
<font color="green">1665.     def clear(self, domain=None, path=None, name=None):</font>
<font color="black">1666.         &quot;&quot;&quot;Clear some cookies.</font>
<font color="black">1667. </font>
<font color="black">1668.         Invoking this method without arguments will clear all cookies.  If</font>
<font color="black">1669.         given a single argument, only cookies belonging to that domain will be</font>
<font color="black">1670.         removed.  If given two arguments, cookies belonging to the specified</font>
<font color="black">1671.         path within that domain are removed.  If given three arguments, then</font>
<font color="black">1672.         the cookie with the specified name, path and domain is removed.</font>
<font color="black">1673. </font>
<font color="black">1674.         Raises KeyError if no matching cookie exists.</font>
<font color="black">1675. </font>
<font color="black">1676.         &quot;&quot;&quot;</font>
<font color="red">1677.         if name is not None:</font>
<font color="red">1678.             if (domain is None) or (path is None):</font>
<font color="red">1679.                 raise ValueError(</font>
<font color="red">1680.                     &quot;domain and path must be given to remove a cookie by name&quot;)</font>
<font color="red">1681.             del self._cookies[domain][path][name]</font>
<font color="red">1682.         elif path is not None:</font>
<font color="red">1683.             if domain is None:</font>
<font color="red">1684.                 raise ValueError(</font>
<font color="red">1685.                     &quot;domain must be given to remove cookies by path&quot;)</font>
<font color="red">1686.             del self._cookies[domain][path]</font>
<font color="red">1687.         elif domain is not None:</font>
<font color="red">1688.             del self._cookies[domain]</font>
<font color="black">1689.         else:</font>
<font color="red">1690.             self._cookies = {}</font>
<font color="black">1691. </font>
<font color="green">1692.     def clear_session_cookies(self):</font>
<font color="black">1693.         &quot;&quot;&quot;Discard all session cookies.</font>
<font color="black">1694. </font>
<font color="black">1695.         Note that the .save() method won't save session cookies anyway, unless</font>
<font color="black">1696.         you ask otherwise by passing a true ignore_discard argument.</font>
<font color="black">1697. </font>
<font color="black">1698.         &quot;&quot;&quot;</font>
<font color="red">1699.         self._cookies_lock.acquire()</font>
<font color="red">1700.         try:</font>
<font color="red">1701.             for cookie in self:</font>
<font color="red">1702.                 if cookie.discard:</font>
<font color="red">1703.                     self.clear(cookie.domain, cookie.path, cookie.name)</font>
<font color="black">1704.         finally:</font>
<font color="red">1705.             self._cookies_lock.release()</font>
<font color="black">1706. </font>
<font color="green">1707.     def clear_expired_cookies(self):</font>
<font color="black">1708.         &quot;&quot;&quot;Discard all expired cookies.</font>
<font color="black">1709. </font>
<font color="black">1710.         You probably don't need to call this method: expired cookies are never</font>
<font color="black">1711.         sent back to the server (provided you're using DefaultCookiePolicy),</font>
<font color="black">1712.         this method is called by CookieJar itself every so often, and the</font>
<font color="black">1713.         .save() method won't save expired cookies anyway (unless you ask</font>
<font color="black">1714.         otherwise by passing a true ignore_expires argument).</font>
<font color="black">1715. </font>
<font color="black">1716.         &quot;&quot;&quot;</font>
<font color="green">1717.         self._cookies_lock.acquire()</font>
<font color="green">1718.         try:</font>
<font color="green">1719.             now = time.time()</font>
<font color="green">1720.             for cookie in self:</font>
<font color="red">1721.                 if cookie.is_expired(now):</font>
<font color="red">1722.                     self.clear(cookie.domain, cookie.path, cookie.name)</font>
<font color="black">1723.         finally:</font>
<font color="green">1724.             self._cookies_lock.release()</font>
<font color="black">1725. </font>
<font color="green">1726.     def __iter__(self):</font>
<font color="green">1727.         return deepvalues(self._cookies)</font>
<font color="black">1728. </font>
<font color="green">1729.     def __len__(self):</font>
<font color="black">1730.         &quot;&quot;&quot;Return number of contained cookies.&quot;&quot;&quot;</font>
<font color="red">1731.         i = 0</font>
<font color="red">1732.         for cookie in self: i = i + 1</font>
<font color="red">1733.         return i</font>
<font color="black">1734. </font>
<font color="green">1735.     def __repr__(self):</font>
<font color="red">1736.         r = []</font>
<font color="red">1737.         for cookie in self: r.append(repr(cookie))</font>
<font color="red">1738.         return &quot;&lt;%s[%s]&gt;&quot; % (self.__class__.__name__, &quot;, &quot;.join(r))</font>
<font color="black">1739. </font>
<font color="green">1740.     def __str__(self):</font>
<font color="red">1741.         r = []</font>
<font color="red">1742.         for cookie in self: r.append(str(cookie))</font>
<font color="red">1743.         return &quot;&lt;%s[%s]&gt;&quot; % (self.__class__.__name__, &quot;, &quot;.join(r))</font>
<font color="black">1744. </font>
<font color="black">1745. </font>
<font color="black">1746. # derives from IOError for backwards-compatibility with Python 2.4.0</font>
<font color="green">1747. class LoadError(IOError): pass</font>
<font color="black">1748. </font>
<font color="green">1749. class FileCookieJar(CookieJar):</font>
<font color="green">1750.     &quot;&quot;&quot;CookieJar that can be loaded from and saved to a file.&quot;&quot;&quot;</font>
<font color="black">1751. </font>
<font color="green">1752.     def __init__(self, filename=None, delayload=False, policy=None):</font>
<font color="black">1753.         &quot;&quot;&quot;</font>
<font color="black">1754.         Cookies are NOT loaded from the named file until either the .load() or</font>
<font color="black">1755.         .revert() method is called.</font>
<font color="black">1756. </font>
<font color="black">1757.         &quot;&quot;&quot;</font>
<font color="red">1758.         CookieJar.__init__(self, policy)</font>
<font color="red">1759.         if filename is not None:</font>
<font color="red">1760.             try:</font>
<font color="red">1761.                 filename+&quot;&quot;</font>
<font color="red">1762.             except:</font>
<font color="red">1763.                 raise ValueError(&quot;filename must be string-like&quot;)</font>
<font color="red">1764.         self.filename = filename</font>
<font color="red">1765.         self.delayload = bool(delayload)</font>
<font color="black">1766. </font>
<font color="green">1767.     def save(self, filename=None, ignore_discard=False, ignore_expires=False):</font>
<font color="black">1768.         &quot;&quot;&quot;Save cookies to a file.&quot;&quot;&quot;</font>
<font color="red">1769.         raise NotImplementedError()</font>
<font color="black">1770. </font>
<font color="green">1771.     def load(self, filename=None, ignore_discard=False, ignore_expires=False):</font>
<font color="black">1772.         &quot;&quot;&quot;Load cookies from a file.&quot;&quot;&quot;</font>
<font color="red">1773.         if filename is None:</font>
<font color="red">1774.             if self.filename is not None: filename = self.filename</font>
<font color="red">1775.             else: raise ValueError(MISSING_FILENAME_TEXT)</font>
<font color="black">1776. </font>
<font color="red">1777.         f = open(filename)</font>
<font color="red">1778.         try:</font>
<font color="red">1779.             self._really_load(f, filename, ignore_discard, ignore_expires)</font>
<font color="black">1780.         finally:</font>
<font color="red">1781.             f.close()</font>
<font color="black">1782. </font>
<font color="green">1783.     def revert(self, filename=None,</font>
<font color="green">1784.                ignore_discard=False, ignore_expires=False):</font>
<font color="black">1785.         &quot;&quot;&quot;Clear all cookies and reload cookies from a saved file.</font>
<font color="black">1786. </font>
<font color="black">1787.         Raises LoadError (or IOError) if reversion is not successful; the</font>
<font color="black">1788.         object's state will not be altered if this happens.</font>
<font color="black">1789. </font>
<font color="black">1790.         &quot;&quot;&quot;</font>
<font color="red">1791.         if filename is None:</font>
<font color="red">1792.             if self.filename is not None: filename = self.filename</font>
<font color="red">1793.             else: raise ValueError(MISSING_FILENAME_TEXT)</font>
<font color="black">1794. </font>
<font color="red">1795.         self._cookies_lock.acquire()</font>
<font color="red">1796.         try:</font>
<font color="black">1797. </font>
<font color="red">1798.             old_state = copy.deepcopy(self._cookies)</font>
<font color="red">1799.             self._cookies = {}</font>
<font color="red">1800.             try:</font>
<font color="red">1801.                 self.load(filename, ignore_discard, ignore_expires)</font>
<font color="red">1802.             except (LoadError, IOError):</font>
<font color="red">1803.                 self._cookies = old_state</font>
<font color="red">1804.                 raise</font>
<font color="black">1805. </font>
<font color="black">1806.         finally:</font>
<font color="red">1807.             self._cookies_lock.release()</font>
<font color="black">1808. </font>
<font color="green">1809. from _LWPCookieJar import LWPCookieJar, lwp_cookie_str</font>
<font color="green">1810. from _MozillaCookieJar import MozillaCookieJar</font>
</pre>

