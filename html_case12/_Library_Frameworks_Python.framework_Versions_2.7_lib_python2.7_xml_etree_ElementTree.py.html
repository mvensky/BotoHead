source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/xml/etree/ElementTree.py</b><br>


file stats: <b>820 lines, 258 executed: 31.5% covered</b>
<pre>
<font color="black">   1. #</font>
<font color="black">   2. # ElementTree</font>
<font color="black">   3. # $Id: ElementTree.py 3440 2008-07-18 14:45:01Z fredrik $</font>
<font color="black">   4. #</font>
<font color="black">   5. # light-weight XML support for Python 2.3 and later.</font>
<font color="black">   6. #</font>
<font color="black">   7. # history (since 1.2.6):</font>
<font color="black">   8. # 2005-11-12 fl   added tostringlist/fromstringlist helpers</font>
<font color="black">   9. # 2006-07-05 fl   merged in selected changes from the 1.3 sandbox</font>
<font color="black">  10. # 2006-07-05 fl   removed support for 2.1 and earlier</font>
<font color="black">  11. # 2007-06-21 fl   added deprecation/future warnings</font>
<font color="black">  12. # 2007-08-25 fl   added doctype hook, added parser version attribute etc</font>
<font color="black">  13. # 2007-08-26 fl   added new serializer code (better namespace handling, etc)</font>
<font color="black">  14. # 2007-08-27 fl   warn for broken /tag searches on tree level</font>
<font color="black">  15. # 2007-09-02 fl   added html/text methods to serializer (experimental)</font>
<font color="black">  16. # 2007-09-05 fl   added method argument to tostring/tostringlist</font>
<font color="black">  17. # 2007-09-06 fl   improved error handling</font>
<font color="black">  18. # 2007-09-13 fl   added itertext, iterfind; assorted cleanups</font>
<font color="black">  19. # 2007-12-15 fl   added C14N hooks, copy method (experimental)</font>
<font color="black">  20. #</font>
<font color="black">  21. # Copyright (c) 1999-2008 by Fredrik Lundh.  All rights reserved.</font>
<font color="black">  22. #</font>
<font color="black">  23. # fredrik@pythonware.com</font>
<font color="black">  24. # http://www.pythonware.com</font>
<font color="black">  25. #</font>
<font color="black">  26. # --------------------------------------------------------------------</font>
<font color="black">  27. # The ElementTree toolkit is</font>
<font color="black">  28. #</font>
<font color="black">  29. # Copyright (c) 1999-2008 by Fredrik Lundh</font>
<font color="black">  30. #</font>
<font color="black">  31. # By obtaining, using, and/or copying this software and/or its</font>
<font color="black">  32. # associated documentation, you agree that you have read, understood,</font>
<font color="black">  33. # and will comply with the following terms and conditions:</font>
<font color="black">  34. #</font>
<font color="black">  35. # Permission to use, copy, modify, and distribute this software and</font>
<font color="black">  36. # its associated documentation for any purpose and without fee is</font>
<font color="black">  37. # hereby granted, provided that the above copyright notice appears in</font>
<font color="black">  38. # all copies, and that both that copyright notice and this permission</font>
<font color="black">  39. # notice appear in supporting documentation, and that the name of</font>
<font color="black">  40. # Secret Labs AB or the author not be used in advertising or publicity</font>
<font color="black">  41. # pertaining to distribution of the software without specific, written</font>
<font color="black">  42. # prior permission.</font>
<font color="black">  43. #</font>
<font color="black">  44. # SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD</font>
<font color="black">  45. # TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-</font>
<font color="black">  46. # ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR</font>
<font color="black">  47. # BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY</font>
<font color="black">  48. # DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,</font>
<font color="black">  49. # WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS</font>
<font color="black">  50. # ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE</font>
<font color="black">  51. # OF THIS SOFTWARE.</font>
<font color="black">  52. # --------------------------------------------------------------------</font>
<font color="black">  53. </font>
<font color="black">  54. # Licensed to PSF under a Contributor Agreement.</font>
<font color="black">  55. # See http://www.python.org/psf/license for licensing details.</font>
<font color="black">  56. </font>
<font color="black">  57. __all__ = [</font>
<font color="black">  58.     # public symbols</font>
<font color="green">  59.     &quot;Comment&quot;,</font>
<font color="green">  60.     &quot;dump&quot;,</font>
<font color="green">  61.     &quot;Element&quot;, &quot;ElementTree&quot;,</font>
<font color="green">  62.     &quot;fromstring&quot;, &quot;fromstringlist&quot;,</font>
<font color="green">  63.     &quot;iselement&quot;, &quot;iterparse&quot;,</font>
<font color="green">  64.     &quot;parse&quot;, &quot;ParseError&quot;,</font>
<font color="green">  65.     &quot;PI&quot;, &quot;ProcessingInstruction&quot;,</font>
<font color="green">  66.     &quot;QName&quot;,</font>
<font color="green">  67.     &quot;SubElement&quot;,</font>
<font color="green">  68.     &quot;tostring&quot;, &quot;tostringlist&quot;,</font>
<font color="green">  69.     &quot;TreeBuilder&quot;,</font>
<font color="green">  70.     &quot;VERSION&quot;,</font>
<font color="green">  71.     &quot;XML&quot;,</font>
<font color="green">  72.     &quot;XMLParser&quot;, &quot;XMLTreeBuilder&quot;,</font>
<font color="black">  73.     ]</font>
<font color="black">  74. </font>
<font color="green">  75. VERSION = &quot;1.3.0&quot;</font>
<font color="black">  76. </font>
<font color="black">  77. ##</font>
<font color="black">  78. # The &lt;b&gt;Element&lt;/b&gt; type is a flexible container object, designed to</font>
<font color="black">  79. # store hierarchical data structures in memory. The type can be</font>
<font color="black">  80. # described as a cross between a list and a dictionary.</font>
<font color="black">  81. # &lt;p&gt;</font>
<font color="black">  82. # Each element has a number of properties associated with it:</font>
<font color="black">  83. # &lt;ul&gt;</font>
<font color="black">  84. # &lt;li&gt;a &lt;i&gt;tag&lt;/i&gt;. This is a string identifying what kind of data</font>
<font color="black">  85. # this element represents (the element type, in other words).&lt;/li&gt;</font>
<font color="black">  86. # &lt;li&gt;a number of &lt;i&gt;attributes&lt;/i&gt;, stored in a Python dictionary.&lt;/li&gt;</font>
<font color="black">  87. # &lt;li&gt;a &lt;i&gt;text&lt;/i&gt; string.&lt;/li&gt;</font>
<font color="black">  88. # &lt;li&gt;an optional &lt;i&gt;tail&lt;/i&gt; string.&lt;/li&gt;</font>
<font color="black">  89. # &lt;li&gt;a number of &lt;i&gt;child elements&lt;/i&gt;, stored in a Python sequence&lt;/li&gt;</font>
<font color="black">  90. # &lt;/ul&gt;</font>
<font color="black">  91. #</font>
<font color="black">  92. # To create an element instance, use the {@link #Element} constructor</font>
<font color="black">  93. # or the {@link #SubElement} factory function.</font>
<font color="black">  94. # &lt;p&gt;</font>
<font color="black">  95. # The {@link #ElementTree} class can be used to wrap an element</font>
<font color="black">  96. # structure, and convert it from and to XML.</font>
<font color="black">  97. ##</font>
<font color="black">  98. </font>
<font color="green">  99. import sys</font>
<font color="green"> 100. import re</font>
<font color="green"> 101. import warnings</font>
<font color="black"> 102. </font>
<font color="black"> 103. </font>
<font color="green"> 104. class _SimpleElementPath(object):</font>
<font color="black"> 105.     # emulate pre-1.2 find/findtext/findall behaviour</font>
<font color="green"> 106.     def find(self, element, tag, namespaces=None):</font>
<font color="red"> 107.         for elem in element:</font>
<font color="red"> 108.             if elem.tag == tag:</font>
<font color="red"> 109.                 return elem</font>
<font color="red"> 110.         return None</font>
<font color="green"> 111.     def findtext(self, element, tag, default=None, namespaces=None):</font>
<font color="red"> 112.         elem = self.find(element, tag)</font>
<font color="red"> 113.         if elem is None:</font>
<font color="red"> 114.             return default</font>
<font color="red"> 115.         return elem.text or &quot;&quot;</font>
<font color="green"> 116.     def iterfind(self, element, tag, namespaces=None):</font>
<font color="red"> 117.         if tag[:3] == &quot;.//&quot;:</font>
<font color="red"> 118.             for elem in element.iter(tag[3:]):</font>
<font color="red"> 119.                 yield elem</font>
<font color="red"> 120.         for elem in element:</font>
<font color="red"> 121.             if elem.tag == tag:</font>
<font color="red"> 122.                 yield elem</font>
<font color="green"> 123.     def findall(self, element, tag, namespaces=None):</font>
<font color="red"> 124.         return list(self.iterfind(element, tag, namespaces))</font>
<font color="black"> 125. </font>
<font color="green"> 126. try:</font>
<font color="green"> 127.     from . import ElementPath</font>
<font color="red"> 128. except ImportError:</font>
<font color="red"> 129.     ElementPath = _SimpleElementPath()</font>
<font color="black"> 130. </font>
<font color="black"> 131. ##</font>
<font color="black"> 132. # Parser error.  This is a subclass of &lt;b&gt;SyntaxError&lt;/b&gt;.</font>
<font color="black"> 133. # &lt;p&gt;</font>
<font color="black"> 134. # In addition to the exception value, an exception instance contains a</font>
<font color="black"> 135. # specific exception code in the &lt;b&gt;code&lt;/b&gt; attribute, and the line and</font>
<font color="black"> 136. # column of the error in the &lt;b&gt;position&lt;/b&gt; attribute.</font>
<font color="black"> 137. </font>
<font color="green"> 138. class ParseError(SyntaxError):</font>
<font color="green"> 139.     pass</font>
<font color="black"> 140. </font>
<font color="black"> 141. # --------------------------------------------------------------------</font>
<font color="black"> 142. </font>
<font color="black"> 143. ##</font>
<font color="black"> 144. # Checks if an object appears to be a valid element object.</font>
<font color="black"> 145. #</font>
<font color="black"> 146. # @param An element instance.</font>
<font color="black"> 147. # @return A true value if this is an element object.</font>
<font color="black"> 148. # @defreturn flag</font>
<font color="black"> 149. </font>
<font color="green"> 150. def iselement(element):</font>
<font color="black"> 151.     # FIXME: not sure about this; might be a better idea to look</font>
<font color="black"> 152.     # for tag/attrib/text attributes</font>
<font color="red"> 153.     return isinstance(element, Element) or hasattr(element, &quot;tag&quot;)</font>
<font color="black"> 154. </font>
<font color="black"> 155. ##</font>
<font color="black"> 156. # Element class.  This class defines the Element interface, and</font>
<font color="black"> 157. # provides a reference implementation of this interface.</font>
<font color="black"> 158. # &lt;p&gt;</font>
<font color="black"> 159. # The element name, attribute names, and attribute values can be</font>
<font color="black"> 160. # either ASCII strings (ordinary Python strings containing only 7-bit</font>
<font color="black"> 161. # ASCII characters) or Unicode strings.</font>
<font color="black"> 162. #</font>
<font color="black"> 163. # @param tag The element name.</font>
<font color="black"> 164. # @param attrib An optional dictionary, containing element attributes.</font>
<font color="black"> 165. # @param **extra Additional attributes, given as keyword arguments.</font>
<font color="black"> 166. # @see Element</font>
<font color="black"> 167. # @see SubElement</font>
<font color="black"> 168. # @see Comment</font>
<font color="black"> 169. # @see ProcessingInstruction</font>
<font color="black"> 170. </font>
<font color="green"> 171. class Element(object):</font>
<font color="black"> 172.     # &lt;tag attrib&gt;text&lt;child/&gt;...&lt;/tag&gt;tail</font>
<font color="black"> 173. </font>
<font color="black"> 174.     ##</font>
<font color="black"> 175.     # (Attribute) Element tag.</font>
<font color="black"> 176. </font>
<font color="green"> 177.     tag = None</font>
<font color="black"> 178. </font>
<font color="black"> 179.     ##</font>
<font color="black"> 180.     # (Attribute) Element attribute dictionary.  Where possible, use</font>
<font color="black"> 181.     # {@link #Element.get},</font>
<font color="black"> 182.     # {@link #Element.set},</font>
<font color="black"> 183.     # {@link #Element.keys}, and</font>
<font color="black"> 184.     # {@link #Element.items} to access</font>
<font color="black"> 185.     # element attributes.</font>
<font color="black"> 186. </font>
<font color="green"> 187.     attrib = None</font>
<font color="black"> 188. </font>
<font color="black"> 189.     ##</font>
<font color="black"> 190.     # (Attribute) Text before first subelement.  This is either a</font>
<font color="black"> 191.     # string or the value None.  Note that if there was no text, this</font>
<font color="black"> 192.     # attribute may be either None or an empty string, depending on</font>
<font color="black"> 193.     # the parser.</font>
<font color="black"> 194. </font>
<font color="green"> 195.     text = None</font>
<font color="black"> 196. </font>
<font color="black"> 197.     ##</font>
<font color="black"> 198.     # (Attribute) Text after this element's end tag, but before the</font>
<font color="black"> 199.     # next sibling element's start tag.  This is either a string or</font>
<font color="black"> 200.     # the value None.  Note that if there was no text, this attribute</font>
<font color="black"> 201.     # may be either None or an empty string, depending on the parser.</font>
<font color="black"> 202. </font>
<font color="green"> 203.     tail = None # text after end tag, if any</font>
<font color="black"> 204. </font>
<font color="black"> 205.     # constructor</font>
<font color="black"> 206. </font>
<font color="green"> 207.     def __init__(self, tag, attrib={}, **extra):</font>
<font color="green"> 208.         attrib = attrib.copy()</font>
<font color="green"> 209.         attrib.update(extra)</font>
<font color="green"> 210.         self.tag = tag</font>
<font color="green"> 211.         self.attrib = attrib</font>
<font color="green"> 212.         self._children = []</font>
<font color="black"> 213. </font>
<font color="green"> 214.     def __repr__(self):</font>
<font color="red"> 215.         return &quot;&lt;Element %s at 0x%x&gt;&quot; % (repr(self.tag), id(self))</font>
<font color="black"> 216. </font>
<font color="black"> 217.     ##</font>
<font color="black"> 218.     # Creates a new element object of the same type as this element.</font>
<font color="black"> 219.     #</font>
<font color="black"> 220.     # @param tag Element tag.</font>
<font color="black"> 221.     # @param attrib Element attributes, given as a dictionary.</font>
<font color="black"> 222.     # @return A new element instance.</font>
<font color="black"> 223. </font>
<font color="green"> 224.     def makeelement(self, tag, attrib):</font>
<font color="green"> 225.         return self.__class__(tag, attrib)</font>
<font color="black"> 226. </font>
<font color="black"> 227.     ##</font>
<font color="black"> 228.     # (Experimental) Copies the current element.  This creates a</font>
<font color="black"> 229.     # shallow copy; subelements will be shared with the original tree.</font>
<font color="black"> 230.     #</font>
<font color="black"> 231.     # @return A new element instance.</font>
<font color="black"> 232. </font>
<font color="green"> 233.     def copy(self):</font>
<font color="red"> 234.         elem = self.makeelement(self.tag, self.attrib)</font>
<font color="red"> 235.         elem.text = self.text</font>
<font color="red"> 236.         elem.tail = self.tail</font>
<font color="red"> 237.         elem[:] = self</font>
<font color="red"> 238.         return elem</font>
<font color="black"> 239. </font>
<font color="black"> 240.     ##</font>
<font color="black"> 241.     # Returns the number of subelements.  Note that this only counts</font>
<font color="black"> 242.     # full elements; to check if there's any content in an element, you</font>
<font color="black"> 243.     # have to check both the length and the &lt;b&gt;text&lt;/b&gt; attribute.</font>
<font color="black"> 244.     #</font>
<font color="black"> 245.     # @return The number of subelements.</font>
<font color="black"> 246. </font>
<font color="green"> 247.     def __len__(self):</font>
<font color="green"> 248.         return len(self._children)</font>
<font color="black"> 249. </font>
<font color="green"> 250.     def __nonzero__(self):</font>
<font color="red"> 251.         warnings.warn(</font>
<font color="red"> 252.             &quot;The behavior of this method will change in future versions.  &quot;</font>
<font color="black"> 253.             &quot;Use specific 'len(elem)' or 'elem is not None' test instead.&quot;,</font>
<font color="red"> 254.             FutureWarning, stacklevel=2</font>
<font color="black"> 255.             )</font>
<font color="red"> 256.         return len(self._children) != 0 # emulate old behaviour, for now</font>
<font color="black"> 257. </font>
<font color="black"> 258.     ##</font>
<font color="black"> 259.     # Returns the given subelement, by index.</font>
<font color="black"> 260.     #</font>
<font color="black"> 261.     # @param index What subelement to return.</font>
<font color="black"> 262.     # @return The given subelement.</font>
<font color="black"> 263.     # @exception IndexError If the given element does not exist.</font>
<font color="black"> 264. </font>
<font color="green"> 265.     def __getitem__(self, index):</font>
<font color="green"> 266.         return self._children[index]</font>
<font color="black"> 267. </font>
<font color="black"> 268.     ##</font>
<font color="black"> 269.     # Replaces the given subelement, by index.</font>
<font color="black"> 270.     #</font>
<font color="black"> 271.     # @param index What subelement to replace.</font>
<font color="black"> 272.     # @param element The new element value.</font>
<font color="black"> 273.     # @exception IndexError If the given element does not exist.</font>
<font color="black"> 274. </font>
<font color="green"> 275.     def __setitem__(self, index, element):</font>
<font color="black"> 276.         # if isinstance(index, slice):</font>
<font color="black"> 277.         #     for elt in element:</font>
<font color="black"> 278.         #         assert iselement(elt)</font>
<font color="black"> 279.         # else:</font>
<font color="black"> 280.         #     assert iselement(element)</font>
<font color="red"> 281.         self._children[index] = element</font>
<font color="black"> 282. </font>
<font color="black"> 283.     ##</font>
<font color="black"> 284.     # Deletes the given subelement, by index.</font>
<font color="black"> 285.     #</font>
<font color="black"> 286.     # @param index What subelement to delete.</font>
<font color="black"> 287.     # @exception IndexError If the given element does not exist.</font>
<font color="black"> 288. </font>
<font color="green"> 289.     def __delitem__(self, index):</font>
<font color="red"> 290.         del self._children[index]</font>
<font color="black"> 291. </font>
<font color="black"> 292.     ##</font>
<font color="black"> 293.     # Adds a subelement to the end of this element.  In document order,</font>
<font color="black"> 294.     # the new element will appear after the last existing subelement (or</font>
<font color="black"> 295.     # directly after the text, if it's the first subelement), but before</font>
<font color="black"> 296.     # the end tag for this element.</font>
<font color="black"> 297.     #</font>
<font color="black"> 298.     # @param element The element to add.</font>
<font color="black"> 299. </font>
<font color="green"> 300.     def append(self, element):</font>
<font color="black"> 301.         # assert iselement(element)</font>
<font color="green"> 302.         self._children.append(element)</font>
<font color="black"> 303. </font>
<font color="black"> 304.     ##</font>
<font color="black"> 305.     # Appends subelements from a sequence.</font>
<font color="black"> 306.     #</font>
<font color="black"> 307.     # @param elements A sequence object with zero or more elements.</font>
<font color="black"> 308.     # @since 1.3</font>
<font color="black"> 309. </font>
<font color="green"> 310.     def extend(self, elements):</font>
<font color="black"> 311.         # for element in elements:</font>
<font color="black"> 312.         #     assert iselement(element)</font>
<font color="red"> 313.         self._children.extend(elements)</font>
<font color="black"> 314. </font>
<font color="black"> 315.     ##</font>
<font color="black"> 316.     # Inserts a subelement at the given position in this element.</font>
<font color="black"> 317.     #</font>
<font color="black"> 318.     # @param index Where to insert the new subelement.</font>
<font color="black"> 319. </font>
<font color="green"> 320.     def insert(self, index, element):</font>
<font color="black"> 321.         # assert iselement(element)</font>
<font color="red"> 322.         self._children.insert(index, element)</font>
<font color="black"> 323. </font>
<font color="black"> 324.     ##</font>
<font color="black"> 325.     # Removes a matching subelement.  Unlike the &lt;b&gt;find&lt;/b&gt; methods,</font>
<font color="black"> 326.     # this method compares elements based on identity, not on tag</font>
<font color="black"> 327.     # value or contents.  To remove subelements by other means, the</font>
<font color="black"> 328.     # easiest way is often to use a list comprehension to select what</font>
<font color="black"> 329.     # elements to keep, and use slice assignment to update the parent</font>
<font color="black"> 330.     # element.</font>
<font color="black"> 331.     #</font>
<font color="black"> 332.     # @param element What element to remove.</font>
<font color="black"> 333.     # @exception ValueError If a matching element could not be found.</font>
<font color="black"> 334. </font>
<font color="green"> 335.     def remove(self, element):</font>
<font color="black"> 336.         # assert iselement(element)</font>
<font color="red"> 337.         self._children.remove(element)</font>
<font color="black"> 338. </font>
<font color="black"> 339.     ##</font>
<font color="black"> 340.     # (Deprecated) Returns all subelements.  The elements are returned</font>
<font color="black"> 341.     # in document order.</font>
<font color="black"> 342.     #</font>
<font color="black"> 343.     # @return A list of subelements.</font>
<font color="black"> 344.     # @defreturn list of Element instances</font>
<font color="black"> 345. </font>
<font color="green"> 346.     def getchildren(self):</font>
<font color="red"> 347.         warnings.warn(</font>
<font color="red"> 348.             &quot;This method will be removed in future versions.  &quot;</font>
<font color="black"> 349.             &quot;Use 'list(elem)' or iteration over elem instead.&quot;,</font>
<font color="red"> 350.             DeprecationWarning, stacklevel=2</font>
<font color="black"> 351.             )</font>
<font color="red"> 352.         return self._children</font>
<font color="black"> 353. </font>
<font color="black"> 354.     ##</font>
<font color="black"> 355.     # Finds the first matching subelement, by tag name or path.</font>
<font color="black"> 356.     #</font>
<font color="black"> 357.     # @param path What element to look for.</font>
<font color="black"> 358.     # @keyparam namespaces Optional namespace prefix map.</font>
<font color="black"> 359.     # @return The first matching element, or None if no element was found.</font>
<font color="black"> 360.     # @defreturn Element or None</font>
<font color="black"> 361. </font>
<font color="green"> 362.     def find(self, path, namespaces=None):</font>
<font color="red"> 363.         return ElementPath.find(self, path, namespaces)</font>
<font color="black"> 364. </font>
<font color="black"> 365.     ##</font>
<font color="black"> 366.     # Finds text for the first matching subelement, by tag name or path.</font>
<font color="black"> 367.     #</font>
<font color="black"> 368.     # @param path What element to look for.</font>
<font color="black"> 369.     # @param default What to return if the element was not found.</font>
<font color="black"> 370.     # @keyparam namespaces Optional namespace prefix map.</font>
<font color="black"> 371.     # @return The text content of the first matching element, or the</font>
<font color="black"> 372.     #     default value no element was found.  Note that if the element</font>
<font color="black"> 373.     #     is found, but has no text content, this method returns an</font>
<font color="black"> 374.     #     empty string.</font>
<font color="black"> 375.     # @defreturn string</font>
<font color="black"> 376. </font>
<font color="green"> 377.     def findtext(self, path, default=None, namespaces=None):</font>
<font color="red"> 378.         return ElementPath.findtext(self, path, default, namespaces)</font>
<font color="black"> 379. </font>
<font color="black"> 380.     ##</font>
<font color="black"> 381.     # Finds all matching subelements, by tag name or path.</font>
<font color="black"> 382.     #</font>
<font color="black"> 383.     # @param path What element to look for.</font>
<font color="black"> 384.     # @keyparam namespaces Optional namespace prefix map.</font>
<font color="black"> 385.     # @return A list or other sequence containing all matching elements,</font>
<font color="black"> 386.     #    in document order.</font>
<font color="black"> 387.     # @defreturn list of Element instances</font>
<font color="black"> 388. </font>
<font color="green"> 389.     def findall(self, path, namespaces=None):</font>
<font color="red"> 390.         return ElementPath.findall(self, path, namespaces)</font>
<font color="black"> 391. </font>
<font color="black"> 392.     ##</font>
<font color="black"> 393.     # Finds all matching subelements, by tag name or path.</font>
<font color="black"> 394.     #</font>
<font color="black"> 395.     # @param path What element to look for.</font>
<font color="black"> 396.     # @keyparam namespaces Optional namespace prefix map.</font>
<font color="black"> 397.     # @return An iterator or sequence containing all matching elements,</font>
<font color="black"> 398.     #    in document order.</font>
<font color="black"> 399.     # @defreturn a generated sequence of Element instances</font>
<font color="black"> 400. </font>
<font color="green"> 401.     def iterfind(self, path, namespaces=None):</font>
<font color="red"> 402.         return ElementPath.iterfind(self, path, namespaces)</font>
<font color="black"> 403. </font>
<font color="black"> 404.     ##</font>
<font color="black"> 405.     # Resets an element.  This function removes all subelements, clears</font>
<font color="black"> 406.     # all attributes, and sets the &lt;b&gt;text&lt;/b&gt; and &lt;b&gt;tail&lt;/b&gt; attributes</font>
<font color="black"> 407.     # to None.</font>
<font color="black"> 408. </font>
<font color="green"> 409.     def clear(self):</font>
<font color="red"> 410.         self.attrib.clear()</font>
<font color="red"> 411.         self._children = []</font>
<font color="red"> 412.         self.text = self.tail = None</font>
<font color="black"> 413. </font>
<font color="black"> 414.     ##</font>
<font color="black"> 415.     # Gets an element attribute.  Equivalent to &lt;b&gt;attrib.get&lt;/b&gt;, but</font>
<font color="black"> 416.     # some implementations may handle this a bit more efficiently.</font>
<font color="black"> 417.     #</font>
<font color="black"> 418.     # @param key What attribute to look for.</font>
<font color="black"> 419.     # @param default What to return if the attribute was not found.</font>
<font color="black"> 420.     # @return The attribute value, or the default value, if the</font>
<font color="black"> 421.     #     attribute was not found.</font>
<font color="black"> 422.     # @defreturn string or None</font>
<font color="black"> 423. </font>
<font color="green"> 424.     def get(self, key, default=None):</font>
<font color="red"> 425.         return self.attrib.get(key, default)</font>
<font color="black"> 426. </font>
<font color="black"> 427.     ##</font>
<font color="black"> 428.     # Sets an element attribute.  Equivalent to &lt;b&gt;attrib[key] = value&lt;/b&gt;,</font>
<font color="black"> 429.     # but some implementations may handle this a bit more efficiently.</font>
<font color="black"> 430.     #</font>
<font color="black"> 431.     # @param key What attribute to set.</font>
<font color="black"> 432.     # @param value The attribute value.</font>
<font color="black"> 433. </font>
<font color="green"> 434.     def set(self, key, value):</font>
<font color="red"> 435.         self.attrib[key] = value</font>
<font color="black"> 436. </font>
<font color="black"> 437.     ##</font>
<font color="black"> 438.     # Gets a list of attribute names.  The names are returned in an</font>
<font color="black"> 439.     # arbitrary order (just like for an ordinary Python dictionary).</font>
<font color="black"> 440.     # Equivalent to &lt;b&gt;attrib.keys()&lt;/b&gt;.</font>
<font color="black"> 441.     #</font>
<font color="black"> 442.     # @return A list of element attribute names.</font>
<font color="black"> 443.     # @defreturn list of strings</font>
<font color="black"> 444. </font>
<font color="green"> 445.     def keys(self):</font>
<font color="red"> 446.         return self.attrib.keys()</font>
<font color="black"> 447. </font>
<font color="black"> 448.     ##</font>
<font color="black"> 449.     # Gets element attributes, as a sequence.  The attributes are</font>
<font color="black"> 450.     # returned in an arbitrary order.  Equivalent to &lt;b&gt;attrib.items()&lt;/b&gt;.</font>
<font color="black"> 451.     #</font>
<font color="black"> 452.     # @return A list of (name, value) tuples for all attributes.</font>
<font color="black"> 453.     # @defreturn list of (string, string) tuples</font>
<font color="black"> 454. </font>
<font color="green"> 455.     def items(self):</font>
<font color="green"> 456.         return self.attrib.items()</font>
<font color="black"> 457. </font>
<font color="black"> 458.     ##</font>
<font color="black"> 459.     # Creates a tree iterator.  The iterator loops over this element</font>
<font color="black"> 460.     # and all subelements, in document order, and returns all elements</font>
<font color="black"> 461.     # with a matching tag.</font>
<font color="black"> 462.     # &lt;p&gt;</font>
<font color="black"> 463.     # If the tree structure is modified during iteration, new or removed</font>
<font color="black"> 464.     # elements may or may not be included.  To get a stable set, use the</font>
<font color="black"> 465.     # list() function on the iterator, and loop over the resulting list.</font>
<font color="black"> 466.     #</font>
<font color="black"> 467.     # @param tag What tags to look for (default is to return all elements).</font>
<font color="black"> 468.     # @return An iterator containing all the matching elements.</font>
<font color="black"> 469.     # @defreturn iterator</font>
<font color="black"> 470. </font>
<font color="green"> 471.     def iter(self, tag=None):</font>
<font color="green"> 472.         if tag == &quot;*&quot;:</font>
<font color="red"> 473.             tag = None</font>
<font color="green"> 474.         if tag is None or self.tag == tag:</font>
<font color="green"> 475.             yield self</font>
<font color="green"> 476.         for e in self._children:</font>
<font color="green"> 477.             for e in e.iter(tag):</font>
<font color="green"> 478.                 yield e</font>
<font color="black"> 479. </font>
<font color="black"> 480.     # compatibility</font>
<font color="green"> 481.     def getiterator(self, tag=None):</font>
<font color="black"> 482.         # Change for a DeprecationWarning in 1.4</font>
<font color="red"> 483.         warnings.warn(</font>
<font color="red"> 484.             &quot;This method will be removed in future versions.  &quot;</font>
<font color="black"> 485.             &quot;Use 'elem.iter()' or 'list(elem.iter())' instead.&quot;,</font>
<font color="red"> 486.             PendingDeprecationWarning, stacklevel=2</font>
<font color="black"> 487.         )</font>
<font color="red"> 488.         return list(self.iter(tag))</font>
<font color="black"> 489. </font>
<font color="black"> 490.     ##</font>
<font color="black"> 491.     # Creates a text iterator.  The iterator loops over this element</font>
<font color="black"> 492.     # and all subelements, in document order, and returns all inner</font>
<font color="black"> 493.     # text.</font>
<font color="black"> 494.     #</font>
<font color="black"> 495.     # @return An iterator containing all inner text.</font>
<font color="black"> 496.     # @defreturn iterator</font>
<font color="black"> 497. </font>
<font color="green"> 498.     def itertext(self):</font>
<font color="red"> 499.         tag = self.tag</font>
<font color="red"> 500.         if not isinstance(tag, basestring) and tag is not None:</font>
<font color="red"> 501.             return</font>
<font color="red"> 502.         if self.text:</font>
<font color="red"> 503.             yield self.text</font>
<font color="red"> 504.         for e in self:</font>
<font color="red"> 505.             for s in e.itertext():</font>
<font color="red"> 506.                 yield s</font>
<font color="red"> 507.             if e.tail:</font>
<font color="red"> 508.                 yield e.tail</font>
<font color="black"> 509. </font>
<font color="black"> 510. # compatibility</font>
<font color="green"> 511. _Element = _ElementInterface = Element</font>
<font color="black"> 512. </font>
<font color="black"> 513. ##</font>
<font color="black"> 514. # Subelement factory.  This function creates an element instance, and</font>
<font color="black"> 515. # appends it to an existing element.</font>
<font color="black"> 516. # &lt;p&gt;</font>
<font color="black"> 517. # The element name, attribute names, and attribute values can be</font>
<font color="black"> 518. # either 8-bit ASCII strings or Unicode strings.</font>
<font color="black"> 519. #</font>
<font color="black"> 520. # @param parent The parent element.</font>
<font color="black"> 521. # @param tag The subelement name.</font>
<font color="black"> 522. # @param attrib An optional dictionary, containing element attributes.</font>
<font color="black"> 523. # @param **extra Additional attributes, given as keyword arguments.</font>
<font color="black"> 524. # @return An element instance.</font>
<font color="black"> 525. # @defreturn Element</font>
<font color="black"> 526. </font>
<font color="green"> 527. def SubElement(parent, tag, attrib={}, **extra):</font>
<font color="green"> 528.     attrib = attrib.copy()</font>
<font color="green"> 529.     attrib.update(extra)</font>
<font color="green"> 530.     element = parent.makeelement(tag, attrib)</font>
<font color="green"> 531.     parent.append(element)</font>
<font color="green"> 532.     return element</font>
<font color="black"> 533. </font>
<font color="black"> 534. ##</font>
<font color="black"> 535. # Comment element factory.  This factory function creates a special</font>
<font color="black"> 536. # element that will be serialized as an XML comment by the standard</font>
<font color="black"> 537. # serializer.</font>
<font color="black"> 538. # &lt;p&gt;</font>
<font color="black"> 539. # The comment string can be either an 8-bit ASCII string or a Unicode</font>
<font color="black"> 540. # string.</font>
<font color="black"> 541. #</font>
<font color="black"> 542. # @param text A string containing the comment string.</font>
<font color="black"> 543. # @return An element instance, representing a comment.</font>
<font color="black"> 544. # @defreturn Element</font>
<font color="black"> 545. </font>
<font color="green"> 546. def Comment(text=None):</font>
<font color="red"> 547.     element = Element(Comment)</font>
<font color="red"> 548.     element.text = text</font>
<font color="red"> 549.     return element</font>
<font color="black"> 550. </font>
<font color="black"> 551. ##</font>
<font color="black"> 552. # PI element factory.  This factory function creates a special element</font>
<font color="black"> 553. # that will be serialized as an XML processing instruction by the standard</font>
<font color="black"> 554. # serializer.</font>
<font color="black"> 555. #</font>
<font color="black"> 556. # @param target A string containing the PI target.</font>
<font color="black"> 557. # @param text A string containing the PI contents, if any.</font>
<font color="black"> 558. # @return An element instance, representing a PI.</font>
<font color="black"> 559. # @defreturn Element</font>
<font color="black"> 560. </font>
<font color="green"> 561. def ProcessingInstruction(target, text=None):</font>
<font color="red"> 562.     element = Element(ProcessingInstruction)</font>
<font color="red"> 563.     element.text = target</font>
<font color="red"> 564.     if text:</font>
<font color="red"> 565.         element.text = element.text + &quot; &quot; + text</font>
<font color="red"> 566.     return element</font>
<font color="black"> 567. </font>
<font color="green"> 568. PI = ProcessingInstruction</font>
<font color="black"> 569. </font>
<font color="black"> 570. ##</font>
<font color="black"> 571. # QName wrapper.  This can be used to wrap a QName attribute value, in</font>
<font color="black"> 572. # order to get proper namespace handling on output.</font>
<font color="black"> 573. #</font>
<font color="black"> 574. # @param text A string containing the QName value, in the form {uri}local,</font>
<font color="black"> 575. #     or, if the tag argument is given, the URI part of a QName.</font>
<font color="black"> 576. # @param tag Optional tag.  If given, the first argument is interpreted as</font>
<font color="black"> 577. #     a URI, and this argument is interpreted as a local name.</font>
<font color="black"> 578. # @return An opaque object, representing the QName.</font>
<font color="black"> 579. </font>
<font color="green"> 580. class QName(object):</font>
<font color="green"> 581.     def __init__(self, text_or_uri, tag=None):</font>
<font color="red"> 582.         if tag:</font>
<font color="red"> 583.             text_or_uri = &quot;{%s}%s&quot; % (text_or_uri, tag)</font>
<font color="red"> 584.         self.text = text_or_uri</font>
<font color="green"> 585.     def __str__(self):</font>
<font color="red"> 586.         return self.text</font>
<font color="green"> 587.     def __hash__(self):</font>
<font color="red"> 588.         return hash(self.text)</font>
<font color="green"> 589.     def __cmp__(self, other):</font>
<font color="red"> 590.         if isinstance(other, QName):</font>
<font color="red"> 591.             return cmp(self.text, other.text)</font>
<font color="red"> 592.         return cmp(self.text, other)</font>
<font color="black"> 593. </font>
<font color="black"> 594. # --------------------------------------------------------------------</font>
<font color="black"> 595. </font>
<font color="black"> 596. ##</font>
<font color="black"> 597. # ElementTree wrapper class.  This class represents an entire element</font>
<font color="black"> 598. # hierarchy, and adds some extra support for serialization to and from</font>
<font color="black"> 599. # standard XML.</font>
<font color="black"> 600. #</font>
<font color="black"> 601. # @param element Optional root element.</font>
<font color="black"> 602. # @keyparam file Optional file handle or file name.  If given, the</font>
<font color="black"> 603. #     tree is initialized with the contents of this XML file.</font>
<font color="black"> 604. </font>
<font color="green"> 605. class ElementTree(object):</font>
<font color="black"> 606. </font>
<font color="green"> 607.     def __init__(self, element=None, file=None):</font>
<font color="black"> 608.         # assert element is None or iselement(element)</font>
<font color="green"> 609.         self._root = element # first node</font>
<font color="green"> 610.         if file:</font>
<font color="red"> 611.             self.parse(file)</font>
<font color="black"> 612. </font>
<font color="black"> 613.     ##</font>
<font color="black"> 614.     # Gets the root element for this tree.</font>
<font color="black"> 615.     #</font>
<font color="black"> 616.     # @return An element instance.</font>
<font color="black"> 617.     # @defreturn Element</font>
<font color="black"> 618. </font>
<font color="green"> 619.     def getroot(self):</font>
<font color="red"> 620.         return self._root</font>
<font color="black"> 621. </font>
<font color="black"> 622.     ##</font>
<font color="black"> 623.     # Replaces the root element for this tree.  This discards the</font>
<font color="black"> 624.     # current contents of the tree, and replaces it with the given</font>
<font color="black"> 625.     # element.  Use with care.</font>
<font color="black"> 626.     #</font>
<font color="black"> 627.     # @param element An element instance.</font>
<font color="black"> 628. </font>
<font color="green"> 629.     def _setroot(self, element):</font>
<font color="black"> 630.         # assert iselement(element)</font>
<font color="red"> 631.         self._root = element</font>
<font color="black"> 632. </font>
<font color="black"> 633.     ##</font>
<font color="black"> 634.     # Loads an external XML document into this element tree.</font>
<font color="black"> 635.     #</font>
<font color="black"> 636.     # @param source A file name or file object.  If a file object is</font>
<font color="black"> 637.     #     given, it only has to implement a &lt;b&gt;read(n)&lt;/b&gt; method.</font>
<font color="black"> 638.     # @keyparam parser An optional parser instance.  If not given, the</font>
<font color="black"> 639.     #     standard {@link XMLParser} parser is used.</font>
<font color="black"> 640.     # @return The document root element.</font>
<font color="black"> 641.     # @defreturn Element</font>
<font color="black"> 642.     # @exception ParseError If the parser fails to parse the document.</font>
<font color="black"> 643. </font>
<font color="green"> 644.     def parse(self, source, parser=None):</font>
<font color="red"> 645.         close_source = False</font>
<font color="red"> 646.         if not hasattr(source, &quot;read&quot;):</font>
<font color="red"> 647.             source = open(source, &quot;rb&quot;)</font>
<font color="red"> 648.             close_source = True</font>
<font color="red"> 649.         try:</font>
<font color="red"> 650.             if not parser:</font>
<font color="red"> 651.                 parser = XMLParser(target=TreeBuilder())</font>
<font color="red"> 652.             while 1:</font>
<font color="red"> 653.                 data = source.read(65536)</font>
<font color="red"> 654.                 if not data:</font>
<font color="red"> 655.                     break</font>
<font color="red"> 656.                 parser.feed(data)</font>
<font color="red"> 657.             self._root = parser.close()</font>
<font color="red"> 658.             return self._root</font>
<font color="black"> 659.         finally:</font>
<font color="red"> 660.             if close_source:</font>
<font color="red"> 661.                 source.close()</font>
<font color="black"> 662. </font>
<font color="black"> 663.     ##</font>
<font color="black"> 664.     # Creates a tree iterator for the root element.  The iterator loops</font>
<font color="black"> 665.     # over all elements in this tree, in document order.</font>
<font color="black"> 666.     #</font>
<font color="black"> 667.     # @param tag What tags to look for (default is to return all elements)</font>
<font color="black"> 668.     # @return An iterator.</font>
<font color="black"> 669.     # @defreturn iterator</font>
<font color="black"> 670. </font>
<font color="green"> 671.     def iter(self, tag=None):</font>
<font color="black"> 672.         # assert self._root is not None</font>
<font color="red"> 673.         return self._root.iter(tag)</font>
<font color="black"> 674. </font>
<font color="black"> 675.     # compatibility</font>
<font color="green"> 676.     def getiterator(self, tag=None):</font>
<font color="black"> 677.         # Change for a DeprecationWarning in 1.4</font>
<font color="red"> 678.         warnings.warn(</font>
<font color="red"> 679.             &quot;This method will be removed in future versions.  &quot;</font>
<font color="black"> 680.             &quot;Use 'tree.iter()' or 'list(tree.iter())' instead.&quot;,</font>
<font color="red"> 681.             PendingDeprecationWarning, stacklevel=2</font>
<font color="black"> 682.         )</font>
<font color="red"> 683.         return list(self.iter(tag))</font>
<font color="black"> 684. </font>
<font color="black"> 685.     ##</font>
<font color="black"> 686.     # Same as getroot().find(path), starting at the root of the</font>
<font color="black"> 687.     # tree.</font>
<font color="black"> 688.     #</font>
<font color="black"> 689.     # @param path What element to look for.</font>
<font color="black"> 690.     # @keyparam namespaces Optional namespace prefix map.</font>
<font color="black"> 691.     # @return The first matching element, or None if no element was found.</font>
<font color="black"> 692.     # @defreturn Element or None</font>
<font color="black"> 693. </font>
<font color="green"> 694.     def find(self, path, namespaces=None):</font>
<font color="black"> 695.         # assert self._root is not None</font>
<font color="red"> 696.         if path[:1] == &quot;/&quot;:</font>
<font color="red"> 697.             path = &quot;.&quot; + path</font>
<font color="red"> 698.             warnings.warn(</font>
<font color="red"> 699.                 &quot;This search is broken in 1.3 and earlier, and will be &quot;</font>
<font color="black"> 700.                 &quot;fixed in a future version.  If you rely on the current &quot;</font>
<font color="red"> 701.                 &quot;behaviour, change it to %r&quot; % path,</font>
<font color="red"> 702.                 FutureWarning, stacklevel=2</font>
<font color="black"> 703.                 )</font>
<font color="red"> 704.         return self._root.find(path, namespaces)</font>
<font color="black"> 705. </font>
<font color="black"> 706.     ##</font>
<font color="black"> 707.     # Same as getroot().findtext(path), starting at the root of the tree.</font>
<font color="black"> 708.     #</font>
<font color="black"> 709.     # @param path What element to look for.</font>
<font color="black"> 710.     # @param default What to return if the element was not found.</font>
<font color="black"> 711.     # @keyparam namespaces Optional namespace prefix map.</font>
<font color="black"> 712.     # @return The text content of the first matching element, or the</font>
<font color="black"> 713.     #     default value no element was found.  Note that if the element</font>
<font color="black"> 714.     #     is found, but has no text content, this method returns an</font>
<font color="black"> 715.     #     empty string.</font>
<font color="black"> 716.     # @defreturn string</font>
<font color="black"> 717. </font>
<font color="green"> 718.     def findtext(self, path, default=None, namespaces=None):</font>
<font color="black"> 719.         # assert self._root is not None</font>
<font color="red"> 720.         if path[:1] == &quot;/&quot;:</font>
<font color="red"> 721.             path = &quot;.&quot; + path</font>
<font color="red"> 722.             warnings.warn(</font>
<font color="red"> 723.                 &quot;This search is broken in 1.3 and earlier, and will be &quot;</font>
<font color="black"> 724.                 &quot;fixed in a future version.  If you rely on the current &quot;</font>
<font color="red"> 725.                 &quot;behaviour, change it to %r&quot; % path,</font>
<font color="red"> 726.                 FutureWarning, stacklevel=2</font>
<font color="black"> 727.                 )</font>
<font color="red"> 728.         return self._root.findtext(path, default, namespaces)</font>
<font color="black"> 729. </font>
<font color="black"> 730.     ##</font>
<font color="black"> 731.     # Same as getroot().findall(path), starting at the root of the tree.</font>
<font color="black"> 732.     #</font>
<font color="black"> 733.     # @param path What element to look for.</font>
<font color="black"> 734.     # @keyparam namespaces Optional namespace prefix map.</font>
<font color="black"> 735.     # @return A list or iterator containing all matching elements,</font>
<font color="black"> 736.     #    in document order.</font>
<font color="black"> 737.     # @defreturn list of Element instances</font>
<font color="black"> 738. </font>
<font color="green"> 739.     def findall(self, path, namespaces=None):</font>
<font color="black"> 740.         # assert self._root is not None</font>
<font color="red"> 741.         if path[:1] == &quot;/&quot;:</font>
<font color="red"> 742.             path = &quot;.&quot; + path</font>
<font color="red"> 743.             warnings.warn(</font>
<font color="red"> 744.                 &quot;This search is broken in 1.3 and earlier, and will be &quot;</font>
<font color="black"> 745.                 &quot;fixed in a future version.  If you rely on the current &quot;</font>
<font color="red"> 746.                 &quot;behaviour, change it to %r&quot; % path,</font>
<font color="red"> 747.                 FutureWarning, stacklevel=2</font>
<font color="black"> 748.                 )</font>
<font color="red"> 749.         return self._root.findall(path, namespaces)</font>
<font color="black"> 750. </font>
<font color="black"> 751.     ##</font>
<font color="black"> 752.     # Finds all matching subelements, by tag name or path.</font>
<font color="black"> 753.     # Same as getroot().iterfind(path).</font>
<font color="black"> 754.     #</font>
<font color="black"> 755.     # @param path What element to look for.</font>
<font color="black"> 756.     # @keyparam namespaces Optional namespace prefix map.</font>
<font color="black"> 757.     # @return An iterator or sequence containing all matching elements,</font>
<font color="black"> 758.     #    in document order.</font>
<font color="black"> 759.     # @defreturn a generated sequence of Element instances</font>
<font color="black"> 760. </font>
<font color="green"> 761.     def iterfind(self, path, namespaces=None):</font>
<font color="black"> 762.         # assert self._root is not None</font>
<font color="red"> 763.         if path[:1] == &quot;/&quot;:</font>
<font color="red"> 764.             path = &quot;.&quot; + path</font>
<font color="red"> 765.             warnings.warn(</font>
<font color="red"> 766.                 &quot;This search is broken in 1.3 and earlier, and will be &quot;</font>
<font color="black"> 767.                 &quot;fixed in a future version.  If you rely on the current &quot;</font>
<font color="red"> 768.                 &quot;behaviour, change it to %r&quot; % path,</font>
<font color="red"> 769.                 FutureWarning, stacklevel=2</font>
<font color="black"> 770.                 )</font>
<font color="red"> 771.         return self._root.iterfind(path, namespaces)</font>
<font color="black"> 772. </font>
<font color="black"> 773.     ##</font>
<font color="black"> 774.     # Writes the element tree to a file, as XML.</font>
<font color="black"> 775.     #</font>
<font color="black"> 776.     # @def write(file, **options)</font>
<font color="black"> 777.     # @param file A file name, or a file object opened for writing.</font>
<font color="black"> 778.     # @param **options Options, given as keyword arguments.</font>
<font color="black"> 779.     # @keyparam encoding Optional output encoding (default is US-ASCII).</font>
<font color="black"> 780.     # @keyparam xml_declaration Controls if an XML declaration should</font>
<font color="black"> 781.     #     be added to the file.  Use False for never, True for always,</font>
<font color="black"> 782.     #     None for only if not US-ASCII or UTF-8.  None is default.</font>
<font color="black"> 783.     # @keyparam default_namespace Sets the default XML namespace (for &quot;xmlns&quot;).</font>
<font color="black"> 784.     # @keyparam method Optional output method (&quot;xml&quot;, &quot;html&quot;, &quot;text&quot; or</font>
<font color="black"> 785.     #     &quot;c14n&quot;; default is &quot;xml&quot;).</font>
<font color="black"> 786. </font>
<font color="black"> 787.     def write(self, file_or_filename,</font>
<font color="black"> 788.               # keyword arguments</font>
<font color="green"> 789.               encoding=None,</font>
<font color="green"> 790.               xml_declaration=None,</font>
<font color="green"> 791.               default_namespace=None,</font>
<font color="green"> 792.               method=None):</font>
<font color="black"> 793.         # assert self._root is not None</font>
<font color="green"> 794.         if not method:</font>
<font color="green"> 795.             method = &quot;xml&quot;</font>
<font color="red"> 796.         elif method not in _serialize:</font>
<font color="black"> 797.             # FIXME: raise an ImportError for c14n if ElementC14N is missing?</font>
<font color="red"> 798.             raise ValueError(&quot;unknown method %r&quot; % method)</font>
<font color="green"> 799.         if hasattr(file_or_filename, &quot;write&quot;):</font>
<font color="green"> 800.             file = file_or_filename</font>
<font color="black"> 801.         else:</font>
<font color="red"> 802.             file = open(file_or_filename, &quot;wb&quot;)</font>
<font color="green"> 803.         write = file.write</font>
<font color="green"> 804.         if not encoding:</font>
<font color="red"> 805.             if method == &quot;c14n&quot;:</font>
<font color="red"> 806.                 encoding = &quot;utf-8&quot;</font>
<font color="black"> 807.             else:</font>
<font color="red"> 808.                 encoding = &quot;us-ascii&quot;</font>
<font color="green"> 809.         elif xml_declaration or (xml_declaration is None and</font>
<font color="green"> 810.                                  encoding not in (&quot;utf-8&quot;, &quot;us-ascii&quot;)):</font>
<font color="red"> 811.             if method == &quot;xml&quot;:</font>
<font color="red"> 812.                 write(&quot;&lt;?xml version='1.0' encoding='%s'?&gt;\n&quot; % encoding)</font>
<font color="green"> 813.         if method == &quot;text&quot;:</font>
<font color="red"> 814.             _serialize_text(write, self._root, encoding)</font>
<font color="black"> 815.         else:</font>
<font color="green"> 816.             qnames, namespaces = _namespaces(</font>
<font color="green"> 817.                 self._root, encoding, default_namespace</font>
<font color="black"> 818.                 )</font>
<font color="green"> 819.             serialize = _serialize[method]</font>
<font color="green"> 820.             serialize(write, self._root, encoding, qnames, namespaces)</font>
<font color="green"> 821.         if file_or_filename is not file:</font>
<font color="red"> 822.             file.close()</font>
<font color="black"> 823. </font>
<font color="green"> 824.     def write_c14n(self, file):</font>
<font color="black"> 825.         # lxml.etree compatibility.  use output method instead</font>
<font color="red"> 826.         return self.write(file, method=&quot;c14n&quot;)</font>
<font color="black"> 827. </font>
<font color="black"> 828. # --------------------------------------------------------------------</font>
<font color="black"> 829. # serialization support</font>
<font color="black"> 830. </font>
<font color="green"> 831. def _namespaces(elem, encoding, default_namespace=None):</font>
<font color="black"> 832.     # identify namespaces used in this tree</font>
<font color="black"> 833. </font>
<font color="black"> 834.     # maps qnames to *encoded* prefix:local names</font>
<font color="green"> 835.     qnames = {None: None}</font>
<font color="black"> 836. </font>
<font color="black"> 837.     # maps uri:s to prefixes</font>
<font color="green"> 838.     namespaces = {}</font>
<font color="green"> 839.     if default_namespace:</font>
<font color="red"> 840.         namespaces[default_namespace] = &quot;&quot;</font>
<font color="black"> 841. </font>
<font color="green"> 842.     def encode(text):</font>
<font color="green"> 843.         return text.encode(encoding)</font>
<font color="black"> 844. </font>
<font color="green"> 845.     def add_qname(qname):</font>
<font color="black"> 846.         # calculate serialized qname representation</font>
<font color="green"> 847.         try:</font>
<font color="green"> 848.             if qname[:1] == &quot;{&quot;:</font>
<font color="red"> 849.                 uri, tag = qname[1:].rsplit(&quot;}&quot;, 1)</font>
<font color="red"> 850.                 prefix = namespaces.get(uri)</font>
<font color="red"> 851.                 if prefix is None:</font>
<font color="red"> 852.                     prefix = _namespace_map.get(uri)</font>
<font color="red"> 853.                     if prefix is None:</font>
<font color="red"> 854.                         prefix = &quot;ns%d&quot; % len(namespaces)</font>
<font color="red"> 855.                     if prefix != &quot;xml&quot;:</font>
<font color="red"> 856.                         namespaces[uri] = prefix</font>
<font color="red"> 857.                 if prefix:</font>
<font color="red"> 858.                     qnames[qname] = encode(&quot;%s:%s&quot; % (prefix, tag))</font>
<font color="black"> 859.                 else:</font>
<font color="red"> 860.                     qnames[qname] = encode(tag) # default element</font>
<font color="black"> 861.             else:</font>
<font color="green"> 862.                 if default_namespace:</font>
<font color="black"> 863.                     # FIXME: can this be handled in XML 1.0?</font>
<font color="red"> 864.                     raise ValueError(</font>
<font color="red"> 865.                         &quot;cannot use non-qualified names with &quot;</font>
<font color="black"> 866.                         &quot;default_namespace option&quot;</font>
<font color="black"> 867.                         )</font>
<font color="green"> 868.                 qnames[qname] = encode(qname)</font>
<font color="red"> 869.         except TypeError:</font>
<font color="red"> 870.             _raise_serialization_error(qname)</font>
<font color="black"> 871. </font>
<font color="black"> 872.     # populate qname and namespaces table</font>
<font color="green"> 873.     try:</font>
<font color="green"> 874.         iterate = elem.iter</font>
<font color="red"> 875.     except AttributeError:</font>
<font color="red"> 876.         iterate = elem.getiterator # cET compatibility</font>
<font color="green"> 877.     for elem in iterate():</font>
<font color="green"> 878.         tag = elem.tag</font>
<font color="green"> 879.         if isinstance(tag, QName):</font>
<font color="red"> 880.             if tag.text not in qnames:</font>
<font color="red"> 881.                 add_qname(tag.text)</font>
<font color="green"> 882.         elif isinstance(tag, basestring):</font>
<font color="green"> 883.             if tag not in qnames:</font>
<font color="green"> 884.                 add_qname(tag)</font>
<font color="red"> 885.         elif tag is not None and tag is not Comment and tag is not PI:</font>
<font color="red"> 886.             _raise_serialization_error(tag)</font>
<font color="green"> 887.         for key, value in elem.items():</font>
<font color="green"> 888.             if isinstance(key, QName):</font>
<font color="red"> 889.                 key = key.text</font>
<font color="green"> 890.             if key not in qnames:</font>
<font color="green"> 891.                 add_qname(key)</font>
<font color="green"> 892.             if isinstance(value, QName) and value.text not in qnames:</font>
<font color="red"> 893.                 add_qname(value.text)</font>
<font color="green"> 894.         text = elem.text</font>
<font color="green"> 895.         if isinstance(text, QName) and text.text not in qnames:</font>
<font color="red"> 896.             add_qname(text.text)</font>
<font color="green"> 897.     return qnames, namespaces</font>
<font color="black"> 898. </font>
<font color="green"> 899. def _serialize_xml(write, elem, encoding, qnames, namespaces):</font>
<font color="green"> 900.     tag = elem.tag</font>
<font color="green"> 901.     text = elem.text</font>
<font color="green"> 902.     if tag is Comment:</font>
<font color="red"> 903.         write(&quot;&lt;!--%s--&gt;&quot; % _encode(text, encoding))</font>
<font color="green"> 904.     elif tag is ProcessingInstruction:</font>
<font color="red"> 905.         write(&quot;&lt;?%s?&gt;&quot; % _encode(text, encoding))</font>
<font color="black"> 906.     else:</font>
<font color="green"> 907.         tag = qnames[tag]</font>
<font color="green"> 908.         if tag is None:</font>
<font color="red"> 909.             if text:</font>
<font color="red"> 910.                 write(_escape_cdata(text, encoding))</font>
<font color="red"> 911.             for e in elem:</font>
<font color="red"> 912.                 _serialize_xml(write, e, encoding, qnames, None)</font>
<font color="black"> 913.         else:</font>
<font color="green"> 914.             write(&quot;&lt;&quot; + tag)</font>
<font color="green"> 915.             items = elem.items()</font>
<font color="green"> 916.             if items or namespaces:</font>
<font color="green"> 917.                 if namespaces:</font>
<font color="red"> 918.                     for v, k in sorted(namespaces.items(),</font>
<font color="red"> 919.                                        key=lambda x: x[1]):  # sort on prefix</font>
<font color="red"> 920.                         if k:</font>
<font color="red"> 921.                             k = &quot;:&quot; + k</font>
<font color="red"> 922.                         write(&quot; xmlns%s=\&quot;%s\&quot;&quot; % (</font>
<font color="red"> 923.                             k.encode(encoding),</font>
<font color="red"> 924.                             _escape_attrib(v, encoding)</font>
<font color="black"> 925.                             ))</font>
<font color="green"> 926.                 for k, v in sorted(items):  # lexical order</font>
<font color="green"> 927.                     if isinstance(k, QName):</font>
<font color="red"> 928.                         k = k.text</font>
<font color="green"> 929.                     if isinstance(v, QName):</font>
<font color="red"> 930.                         v = qnames[v.text]</font>
<font color="black"> 931.                     else:</font>
<font color="green"> 932.                         v = _escape_attrib(v, encoding)</font>
<font color="green"> 933.                     write(&quot; %s=\&quot;%s\&quot;&quot; % (qnames[k], v))</font>
<font color="green"> 934.             if text or len(elem):</font>
<font color="green"> 935.                 write(&quot;&gt;&quot;)</font>
<font color="green"> 936.                 if text:</font>
<font color="green"> 937.                     write(_escape_cdata(text, encoding))</font>
<font color="green"> 938.                 for e in elem:</font>
<font color="green"> 939.                     _serialize_xml(write, e, encoding, qnames, None)</font>
<font color="green"> 940.                 write(&quot;&lt;/&quot; + tag + &quot;&gt;&quot;)</font>
<font color="black"> 941.             else:</font>
<font color="red"> 942.                 write(&quot; /&gt;&quot;)</font>
<font color="green"> 943.     if elem.tail:</font>
<font color="red"> 944.         write(_escape_cdata(elem.tail, encoding))</font>
<font color="black"> 945. </font>
<font color="green"> 946. HTML_EMPTY = (&quot;area&quot;, &quot;base&quot;, &quot;basefont&quot;, &quot;br&quot;, &quot;col&quot;, &quot;frame&quot;, &quot;hr&quot;,</font>
<font color="green"> 947.               &quot;img&quot;, &quot;input&quot;, &quot;isindex&quot;, &quot;link&quot;, &quot;meta&quot;, &quot;param&quot;)</font>
<font color="black"> 948. </font>
<font color="green"> 949. try:</font>
<font color="green"> 950.     HTML_EMPTY = set(HTML_EMPTY)</font>
<font color="red"> 951. except NameError:</font>
<font color="red"> 952.     pass</font>
<font color="black"> 953. </font>
<font color="green"> 954. def _serialize_html(write, elem, encoding, qnames, namespaces):</font>
<font color="red"> 955.     tag = elem.tag</font>
<font color="red"> 956.     text = elem.text</font>
<font color="red"> 957.     if tag is Comment:</font>
<font color="red"> 958.         write(&quot;&lt;!--%s--&gt;&quot; % _escape_cdata(text, encoding))</font>
<font color="red"> 959.     elif tag is ProcessingInstruction:</font>
<font color="red"> 960.         write(&quot;&lt;?%s?&gt;&quot; % _escape_cdata(text, encoding))</font>
<font color="black"> 961.     else:</font>
<font color="red"> 962.         tag = qnames[tag]</font>
<font color="red"> 963.         if tag is None:</font>
<font color="red"> 964.             if text:</font>
<font color="red"> 965.                 write(_escape_cdata(text, encoding))</font>
<font color="red"> 966.             for e in elem:</font>
<font color="red"> 967.                 _serialize_html(write, e, encoding, qnames, None)</font>
<font color="black"> 968.         else:</font>
<font color="red"> 969.             write(&quot;&lt;&quot; + tag)</font>
<font color="red"> 970.             items = elem.items()</font>
<font color="red"> 971.             if items or namespaces:</font>
<font color="red"> 972.                 if namespaces:</font>
<font color="red"> 973.                     for v, k in sorted(namespaces.items(),</font>
<font color="red"> 974.                                        key=lambda x: x[1]):  # sort on prefix</font>
<font color="red"> 975.                         if k:</font>
<font color="red"> 976.                             k = &quot;:&quot; + k</font>
<font color="red"> 977.                         write(&quot; xmlns%s=\&quot;%s\&quot;&quot; % (</font>
<font color="red"> 978.                             k.encode(encoding),</font>
<font color="red"> 979.                             _escape_attrib(v, encoding)</font>
<font color="black"> 980.                             ))</font>
<font color="red"> 981.                 for k, v in sorted(items):  # lexical order</font>
<font color="red"> 982.                     if isinstance(k, QName):</font>
<font color="red"> 983.                         k = k.text</font>
<font color="red"> 984.                     if isinstance(v, QName):</font>
<font color="red"> 985.                         v = qnames[v.text]</font>
<font color="black"> 986.                     else:</font>
<font color="red"> 987.                         v = _escape_attrib_html(v, encoding)</font>
<font color="black"> 988.                     # FIXME: handle boolean attributes</font>
<font color="red"> 989.                     write(&quot; %s=\&quot;%s\&quot;&quot; % (qnames[k], v))</font>
<font color="red"> 990.             write(&quot;&gt;&quot;)</font>
<font color="red"> 991.             ltag = tag.lower()</font>
<font color="red"> 992.             if text:</font>
<font color="red"> 993.                 if ltag == &quot;script&quot; or ltag == &quot;style&quot;:</font>
<font color="red"> 994.                     write(_encode(text, encoding))</font>
<font color="black"> 995.                 else:</font>
<font color="red"> 996.                     write(_escape_cdata(text, encoding))</font>
<font color="red"> 997.             for e in elem:</font>
<font color="red"> 998.                 _serialize_html(write, e, encoding, qnames, None)</font>
<font color="red"> 999.             if ltag not in HTML_EMPTY:</font>
<font color="red">1000.                 write(&quot;&lt;/&quot; + tag + &quot;&gt;&quot;)</font>
<font color="red">1001.     if elem.tail:</font>
<font color="red">1002.         write(_escape_cdata(elem.tail, encoding))</font>
<font color="black">1003. </font>
<font color="green">1004. def _serialize_text(write, elem, encoding):</font>
<font color="red">1005.     for part in elem.itertext():</font>
<font color="red">1006.         write(part.encode(encoding))</font>
<font color="red">1007.     if elem.tail:</font>
<font color="red">1008.         write(elem.tail.encode(encoding))</font>
<font color="black">1009. </font>
<font color="green">1010. _serialize = {</font>
<font color="green">1011.     &quot;xml&quot;: _serialize_xml,</font>
<font color="green">1012.     &quot;html&quot;: _serialize_html,</font>
<font color="green">1013.     &quot;text&quot;: _serialize_text,</font>
<font color="black">1014. # this optional method is imported at the end of the module</font>
<font color="black">1015. #   &quot;c14n&quot;: _serialize_c14n,</font>
<font color="black">1016. }</font>
<font color="black">1017. </font>
<font color="black">1018. ##</font>
<font color="black">1019. # Registers a namespace prefix.  The registry is global, and any</font>
<font color="black">1020. # existing mapping for either the given prefix or the namespace URI</font>
<font color="black">1021. # will be removed.</font>
<font color="black">1022. #</font>
<font color="black">1023. # @param prefix Namespace prefix.</font>
<font color="black">1024. # @param uri Namespace uri.  Tags and attributes in this namespace</font>
<font color="black">1025. #     will be serialized with the given prefix, if at all possible.</font>
<font color="black">1026. # @exception ValueError If the prefix is reserved, or is otherwise</font>
<font color="black">1027. #     invalid.</font>
<font color="black">1028. </font>
<font color="green">1029. def register_namespace(prefix, uri):</font>
<font color="red">1030.     if re.match(&quot;ns\d+$&quot;, prefix):</font>
<font color="red">1031.         raise ValueError(&quot;Prefix format reserved for internal use&quot;)</font>
<font color="red">1032.     for k, v in _namespace_map.items():</font>
<font color="red">1033.         if k == uri or v == prefix:</font>
<font color="red">1034.             del _namespace_map[k]</font>
<font color="red">1035.     _namespace_map[uri] = prefix</font>
<font color="black">1036. </font>
<font color="green">1037. _namespace_map = {</font>
<font color="black">1038.     # &quot;well-known&quot; namespace prefixes</font>
<font color="green">1039.     &quot;http://www.w3.org/XML/1998/namespace&quot;: &quot;xml&quot;,</font>
<font color="green">1040.     &quot;http://www.w3.org/1999/xhtml&quot;: &quot;html&quot;,</font>
<font color="green">1041.     &quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;: &quot;rdf&quot;,</font>
<font color="green">1042.     &quot;http://schemas.xmlsoap.org/wsdl/&quot;: &quot;wsdl&quot;,</font>
<font color="black">1043.     # xml schema</font>
<font color="green">1044.     &quot;http://www.w3.org/2001/XMLSchema&quot;: &quot;xs&quot;,</font>
<font color="green">1045.     &quot;http://www.w3.org/2001/XMLSchema-instance&quot;: &quot;xsi&quot;,</font>
<font color="black">1046.     # dublin core</font>
<font color="green">1047.     &quot;http://purl.org/dc/elements/1.1/&quot;: &quot;dc&quot;,</font>
<font color="black">1048. }</font>
<font color="black">1049. </font>
<font color="green">1050. def _raise_serialization_error(text):</font>
<font color="red">1051.     raise TypeError(</font>
<font color="red">1052.         &quot;cannot serialize %r (type %s)&quot; % (text, type(text).__name__)</font>
<font color="black">1053.         )</font>
<font color="black">1054. </font>
<font color="green">1055. def _encode(text, encoding):</font>
<font color="red">1056.     try:</font>
<font color="red">1057.         return text.encode(encoding, &quot;xmlcharrefreplace&quot;)</font>
<font color="red">1058.     except (TypeError, AttributeError):</font>
<font color="red">1059.         _raise_serialization_error(text)</font>
<font color="black">1060. </font>
<font color="green">1061. def _escape_cdata(text, encoding):</font>
<font color="black">1062.     # escape character data</font>
<font color="green">1063.     try:</font>
<font color="black">1064.         # it's worth avoiding do-nothing calls for strings that are</font>
<font color="black">1065.         # shorter than 500 character, or so.  assume that's, by far,</font>
<font color="black">1066.         # the most common case in most applications.</font>
<font color="green">1067.         if &quot;&amp;&quot; in text:</font>
<font color="red">1068.             text = text.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)</font>
<font color="green">1069.         if &quot;&lt;&quot; in text:</font>
<font color="red">1070.             text = text.replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)</font>
<font color="green">1071.         if &quot;&gt;&quot; in text:</font>
<font color="red">1072.             text = text.replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)</font>
<font color="green">1073.         return text.encode(encoding, &quot;xmlcharrefreplace&quot;)</font>
<font color="red">1074.     except (TypeError, AttributeError):</font>
<font color="red">1075.         _raise_serialization_error(text)</font>
<font color="black">1076. </font>
<font color="green">1077. def _escape_attrib(text, encoding):</font>
<font color="black">1078.     # escape attribute value</font>
<font color="green">1079.     try:</font>
<font color="green">1080.         if &quot;&amp;&quot; in text:</font>
<font color="red">1081.             text = text.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)</font>
<font color="green">1082.         if &quot;&lt;&quot; in text:</font>
<font color="red">1083.             text = text.replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)</font>
<font color="green">1084.         if &quot;&gt;&quot; in text:</font>
<font color="red">1085.             text = text.replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)</font>
<font color="green">1086.         if &quot;\&quot;&quot; in text:</font>
<font color="red">1087.             text = text.replace(&quot;\&quot;&quot;, &quot;&amp;quot;&quot;)</font>
<font color="green">1088.         if &quot;\n&quot; in text:</font>
<font color="red">1089.             text = text.replace(&quot;\n&quot;, &quot;&amp;#10;&quot;)</font>
<font color="green">1090.         return text.encode(encoding, &quot;xmlcharrefreplace&quot;)</font>
<font color="red">1091.     except (TypeError, AttributeError):</font>
<font color="red">1092.         _raise_serialization_error(text)</font>
<font color="black">1093. </font>
<font color="green">1094. def _escape_attrib_html(text, encoding):</font>
<font color="black">1095.     # escape attribute value</font>
<font color="red">1096.     try:</font>
<font color="red">1097.         if &quot;&amp;&quot; in text:</font>
<font color="red">1098.             text = text.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)</font>
<font color="red">1099.         if &quot;&gt;&quot; in text:</font>
<font color="red">1100.             text = text.replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)</font>
<font color="red">1101.         if &quot;\&quot;&quot; in text:</font>
<font color="red">1102.             text = text.replace(&quot;\&quot;&quot;, &quot;&amp;quot;&quot;)</font>
<font color="red">1103.         return text.encode(encoding, &quot;xmlcharrefreplace&quot;)</font>
<font color="red">1104.     except (TypeError, AttributeError):</font>
<font color="red">1105.         _raise_serialization_error(text)</font>
<font color="black">1106. </font>
<font color="black">1107. # --------------------------------------------------------------------</font>
<font color="black">1108. </font>
<font color="black">1109. ##</font>
<font color="black">1110. # Generates a string representation of an XML element, including all</font>
<font color="black">1111. # subelements.</font>
<font color="black">1112. #</font>
<font color="black">1113. # @param element An Element instance.</font>
<font color="black">1114. # @keyparam encoding Optional output encoding (default is US-ASCII).</font>
<font color="black">1115. # @keyparam method Optional output method (&quot;xml&quot;, &quot;html&quot;, &quot;text&quot; or</font>
<font color="black">1116. #     &quot;c14n&quot;; default is &quot;xml&quot;).</font>
<font color="black">1117. # @return An encoded string containing the XML data.</font>
<font color="black">1118. # @defreturn string</font>
<font color="black">1119. </font>
<font color="green">1120. def tostring(element, encoding=None, method=None):</font>
<font color="green">1121.     class dummy:</font>
<font color="green">1122.         pass</font>
<font color="green">1123.     data = []</font>
<font color="green">1124.     file = dummy()</font>
<font color="green">1125.     file.write = data.append</font>
<font color="green">1126.     ElementTree(element).write(file, encoding, method=method)</font>
<font color="green">1127.     return &quot;&quot;.join(data)</font>
<font color="black">1128. </font>
<font color="black">1129. ##</font>
<font color="black">1130. # Generates a string representation of an XML element, including all</font>
<font color="black">1131. # subelements.  The string is returned as a sequence of string fragments.</font>
<font color="black">1132. #</font>
<font color="black">1133. # @param element An Element instance.</font>
<font color="black">1134. # @keyparam encoding Optional output encoding (default is US-ASCII).</font>
<font color="black">1135. # @keyparam method Optional output method (&quot;xml&quot;, &quot;html&quot;, &quot;text&quot; or</font>
<font color="black">1136. #     &quot;c14n&quot;; default is &quot;xml&quot;).</font>
<font color="black">1137. # @return A sequence object containing the XML data.</font>
<font color="black">1138. # @defreturn sequence</font>
<font color="black">1139. # @since 1.3</font>
<font color="black">1140. </font>
<font color="green">1141. def tostringlist(element, encoding=None, method=None):</font>
<font color="red">1142.     class dummy:</font>
<font color="red">1143.         pass</font>
<font color="red">1144.     data = []</font>
<font color="red">1145.     file = dummy()</font>
<font color="red">1146.     file.write = data.append</font>
<font color="red">1147.     ElementTree(element).write(file, encoding, method=method)</font>
<font color="black">1148.     # FIXME: merge small fragments into larger parts</font>
<font color="red">1149.     return data</font>
<font color="black">1150. </font>
<font color="black">1151. ##</font>
<font color="black">1152. # Writes an element tree or element structure to sys.stdout.  This</font>
<font color="black">1153. # function should be used for debugging only.</font>
<font color="black">1154. # &lt;p&gt;</font>
<font color="black">1155. # The exact output format is implementation dependent.  In this</font>
<font color="black">1156. # version, it's written as an ordinary XML file.</font>
<font color="black">1157. #</font>
<font color="black">1158. # @param elem An element tree or an individual element.</font>
<font color="black">1159. </font>
<font color="green">1160. def dump(elem):</font>
<font color="black">1161.     # debugging</font>
<font color="red">1162.     if not isinstance(elem, ElementTree):</font>
<font color="red">1163.         elem = ElementTree(elem)</font>
<font color="red">1164.     elem.write(sys.stdout)</font>
<font color="red">1165.     tail = elem.getroot().tail</font>
<font color="red">1166.     if not tail or tail[-1] != &quot;\n&quot;:</font>
<font color="red">1167.         sys.stdout.write(&quot;\n&quot;)</font>
<font color="black">1168. </font>
<font color="black">1169. # --------------------------------------------------------------------</font>
<font color="black">1170. # parsing</font>
<font color="black">1171. </font>
<font color="black">1172. ##</font>
<font color="black">1173. # Parses an XML document into an element tree.</font>
<font color="black">1174. #</font>
<font color="black">1175. # @param source A filename or file object containing XML data.</font>
<font color="black">1176. # @param parser An optional parser instance.  If not given, the</font>
<font color="black">1177. #     standard {@link XMLParser} parser is used.</font>
<font color="black">1178. # @return An ElementTree instance</font>
<font color="black">1179. </font>
<font color="green">1180. def parse(source, parser=None):</font>
<font color="red">1181.     tree = ElementTree()</font>
<font color="red">1182.     tree.parse(source, parser)</font>
<font color="red">1183.     return tree</font>
<font color="black">1184. </font>
<font color="black">1185. ##</font>
<font color="black">1186. # Parses an XML document into an element tree incrementally, and reports</font>
<font color="black">1187. # what's going on to the user.</font>
<font color="black">1188. #</font>
<font color="black">1189. # @param source A filename or file object containing XML data.</font>
<font color="black">1190. # @param events A list of events to report back.  If omitted, only &quot;end&quot;</font>
<font color="black">1191. #     events are reported.</font>
<font color="black">1192. # @param parser An optional parser instance.  If not given, the</font>
<font color="black">1193. #     standard {@link XMLParser} parser is used.</font>
<font color="black">1194. # @return A (event, elem) iterator.</font>
<font color="black">1195. </font>
<font color="green">1196. def iterparse(source, events=None, parser=None):</font>
<font color="red">1197.     close_source = False</font>
<font color="red">1198.     if not hasattr(source, &quot;read&quot;):</font>
<font color="red">1199.         source = open(source, &quot;rb&quot;)</font>
<font color="red">1200.         close_source = True</font>
<font color="red">1201.     try:</font>
<font color="red">1202.         if not parser:</font>
<font color="red">1203.             parser = XMLParser(target=TreeBuilder())</font>
<font color="red">1204.         return _IterParseIterator(source, events, parser, close_source)</font>
<font color="red">1205.     except:</font>
<font color="red">1206.         if close_source:</font>
<font color="red">1207.             source.close()</font>
<font color="red">1208.         raise</font>
<font color="black">1209. </font>
<font color="green">1210. class _IterParseIterator(object):</font>
<font color="black">1211. </font>
<font color="green">1212.     def __init__(self, source, events, parser, close_source=False):</font>
<font color="red">1213.         self._file = source</font>
<font color="red">1214.         self._close_file = close_source</font>
<font color="red">1215.         self._events = []</font>
<font color="red">1216.         self._index = 0</font>
<font color="red">1217.         self._error = None</font>
<font color="red">1218.         self.root = self._root = None</font>
<font color="red">1219.         self._parser = parser</font>
<font color="black">1220.         # wire up the parser for event reporting</font>
<font color="red">1221.         parser = self._parser._parser</font>
<font color="red">1222.         append = self._events.append</font>
<font color="red">1223.         if events is None:</font>
<font color="red">1224.             events = [&quot;end&quot;]</font>
<font color="red">1225.         for event in events:</font>
<font color="red">1226.             if event == &quot;start&quot;:</font>
<font color="red">1227.                 try:</font>
<font color="red">1228.                     parser.ordered_attributes = 1</font>
<font color="red">1229.                     parser.specified_attributes = 1</font>
<font color="red">1230.                     def handler(tag, attrib_in, event=event, append=append,</font>
<font color="red">1231.                                 start=self._parser._start_list):</font>
<font color="red">1232.                         append((event, start(tag, attrib_in)))</font>
<font color="red">1233.                     parser.StartElementHandler = handler</font>
<font color="red">1234.                 except AttributeError:</font>
<font color="red">1235.                     def handler(tag, attrib_in, event=event, append=append,</font>
<font color="red">1236.                                 start=self._parser._start):</font>
<font color="red">1237.                         append((event, start(tag, attrib_in)))</font>
<font color="red">1238.                     parser.StartElementHandler = handler</font>
<font color="red">1239.             elif event == &quot;end&quot;:</font>
<font color="red">1240.                 def handler(tag, event=event, append=append,</font>
<font color="red">1241.                             end=self._parser._end):</font>
<font color="red">1242.                     append((event, end(tag)))</font>
<font color="red">1243.                 parser.EndElementHandler = handler</font>
<font color="red">1244.             elif event == &quot;start-ns&quot;:</font>
<font color="red">1245.                 def handler(prefix, uri, event=event, append=append):</font>
<font color="red">1246.                     try:</font>
<font color="red">1247.                         uri = (uri or &quot;&quot;).encode(&quot;ascii&quot;)</font>
<font color="red">1248.                     except UnicodeError:</font>
<font color="red">1249.                         pass</font>
<font color="red">1250.                     append((event, (prefix or &quot;&quot;, uri or &quot;&quot;)))</font>
<font color="red">1251.                 parser.StartNamespaceDeclHandler = handler</font>
<font color="red">1252.             elif event == &quot;end-ns&quot;:</font>
<font color="red">1253.                 def handler(prefix, event=event, append=append):</font>
<font color="red">1254.                     append((event, None))</font>
<font color="red">1255.                 parser.EndNamespaceDeclHandler = handler</font>
<font color="black">1256.             else:</font>
<font color="red">1257.                 raise ValueError(&quot;unknown event %r&quot; % event)</font>
<font color="black">1258. </font>
<font color="green">1259.     def next(self):</font>
<font color="red">1260.         try:</font>
<font color="red">1261.             while 1:</font>
<font color="red">1262.                 try:</font>
<font color="red">1263.                     item = self._events[self._index]</font>
<font color="red">1264.                     self._index += 1</font>
<font color="red">1265.                     return item</font>
<font color="red">1266.                 except IndexError:</font>
<font color="red">1267.                     pass</font>
<font color="red">1268.                 if self._error:</font>
<font color="red">1269.                     e = self._error</font>
<font color="red">1270.                     self._error = None</font>
<font color="red">1271.                     raise e</font>
<font color="red">1272.                 if self._parser is None:</font>
<font color="red">1273.                     self.root = self._root</font>
<font color="red">1274.                     break</font>
<font color="black">1275.                 # load event buffer</font>
<font color="red">1276.                 del self._events[:]</font>
<font color="red">1277.                 self._index = 0</font>
<font color="red">1278.                 data = self._file.read(16384)</font>
<font color="red">1279.                 if data:</font>
<font color="red">1280.                     try:</font>
<font color="red">1281.                         self._parser.feed(data)</font>
<font color="red">1282.                     except SyntaxError as exc:</font>
<font color="red">1283.                         self._error = exc</font>
<font color="black">1284.                 else:</font>
<font color="red">1285.                     self._root = self._parser.close()</font>
<font color="red">1286.                     self._parser = None</font>
<font color="red">1287.         except:</font>
<font color="red">1288.             if self._close_file:</font>
<font color="red">1289.                 self._file.close()</font>
<font color="red">1290.             raise</font>
<font color="red">1291.         if self._close_file:</font>
<font color="red">1292.             self._file.close()</font>
<font color="red">1293.         raise StopIteration</font>
<font color="black">1294. </font>
<font color="green">1295.     def __iter__(self):</font>
<font color="red">1296.         return self</font>
<font color="black">1297. </font>
<font color="black">1298. ##</font>
<font color="black">1299. # Parses an XML document from a string constant.  This function can</font>
<font color="black">1300. # be used to embed &quot;XML literals&quot; in Python code.</font>
<font color="black">1301. #</font>
<font color="black">1302. # @param source A string containing XML data.</font>
<font color="black">1303. # @param parser An optional parser instance.  If not given, the</font>
<font color="black">1304. #     standard {@link XMLParser} parser is used.</font>
<font color="black">1305. # @return An Element instance.</font>
<font color="black">1306. # @defreturn Element</font>
<font color="black">1307. </font>
<font color="green">1308. def XML(text, parser=None):</font>
<font color="red">1309.     if not parser:</font>
<font color="red">1310.         parser = XMLParser(target=TreeBuilder())</font>
<font color="red">1311.     parser.feed(text)</font>
<font color="red">1312.     return parser.close()</font>
<font color="black">1313. </font>
<font color="black">1314. ##</font>
<font color="black">1315. # Parses an XML document from a string constant, and also returns</font>
<font color="black">1316. # a dictionary which maps from element id:s to elements.</font>
<font color="black">1317. #</font>
<font color="black">1318. # @param source A string containing XML data.</font>
<font color="black">1319. # @param parser An optional parser instance.  If not given, the</font>
<font color="black">1320. #     standard {@link XMLParser} parser is used.</font>
<font color="black">1321. # @return A tuple containing an Element instance and a dictionary.</font>
<font color="black">1322. # @defreturn (Element, dictionary)</font>
<font color="black">1323. </font>
<font color="green">1324. def XMLID(text, parser=None):</font>
<font color="red">1325.     if not parser:</font>
<font color="red">1326.         parser = XMLParser(target=TreeBuilder())</font>
<font color="red">1327.     parser.feed(text)</font>
<font color="red">1328.     tree = parser.close()</font>
<font color="red">1329.     ids = {}</font>
<font color="red">1330.     for elem in tree.iter():</font>
<font color="red">1331.         id = elem.get(&quot;id&quot;)</font>
<font color="red">1332.         if id:</font>
<font color="red">1333.             ids[id] = elem</font>
<font color="red">1334.     return tree, ids</font>
<font color="black">1335. </font>
<font color="black">1336. ##</font>
<font color="black">1337. # Parses an XML document from a string constant.  Same as {@link #XML}.</font>
<font color="black">1338. #</font>
<font color="black">1339. # @def fromstring(text)</font>
<font color="black">1340. # @param source A string containing XML data.</font>
<font color="black">1341. # @return An Element instance.</font>
<font color="black">1342. # @defreturn Element</font>
<font color="black">1343. </font>
<font color="green">1344. fromstring = XML</font>
<font color="black">1345. </font>
<font color="black">1346. ##</font>
<font color="black">1347. # Parses an XML document from a sequence of string fragments.</font>
<font color="black">1348. #</font>
<font color="black">1349. # @param sequence A list or other sequence containing XML data fragments.</font>
<font color="black">1350. # @param parser An optional parser instance.  If not given, the</font>
<font color="black">1351. #     standard {@link XMLParser} parser is used.</font>
<font color="black">1352. # @return An Element instance.</font>
<font color="black">1353. # @defreturn Element</font>
<font color="black">1354. # @since 1.3</font>
<font color="black">1355. </font>
<font color="green">1356. def fromstringlist(sequence, parser=None):</font>
<font color="red">1357.     if not parser:</font>
<font color="red">1358.         parser = XMLParser(target=TreeBuilder())</font>
<font color="red">1359.     for text in sequence:</font>
<font color="red">1360.         parser.feed(text)</font>
<font color="red">1361.     return parser.close()</font>
<font color="black">1362. </font>
<font color="black">1363. # --------------------------------------------------------------------</font>
<font color="black">1364. </font>
<font color="black">1365. ##</font>
<font color="black">1366. # Generic element structure builder.  This builder converts a sequence</font>
<font color="black">1367. # of {@link #TreeBuilder.start}, {@link #TreeBuilder.data}, and {@link</font>
<font color="black">1368. # #TreeBuilder.end} method calls to a well-formed element structure.</font>
<font color="black">1369. # &lt;p&gt;</font>
<font color="black">1370. # You can use this class to build an element structure using a custom XML</font>
<font color="black">1371. # parser, or a parser for some other XML-like format.</font>
<font color="black">1372. #</font>
<font color="black">1373. # @param element_factory Optional element factory.  This factory</font>
<font color="black">1374. #    is called to create new Element instances, as necessary.</font>
<font color="black">1375. </font>
<font color="green">1376. class TreeBuilder(object):</font>
<font color="black">1377. </font>
<font color="green">1378.     def __init__(self, element_factory=None):</font>
<font color="red">1379.         self._data = [] # data collector</font>
<font color="red">1380.         self._elem = [] # element stack</font>
<font color="red">1381.         self._last = None # last element</font>
<font color="red">1382.         self._tail = None # true if we're after an end tag</font>
<font color="red">1383.         if element_factory is None:</font>
<font color="red">1384.             element_factory = Element</font>
<font color="red">1385.         self._factory = element_factory</font>
<font color="black">1386. </font>
<font color="black">1387.     ##</font>
<font color="black">1388.     # Flushes the builder buffers, and returns the toplevel document</font>
<font color="black">1389.     # element.</font>
<font color="black">1390.     #</font>
<font color="black">1391.     # @return An Element instance.</font>
<font color="black">1392.     # @defreturn Element</font>
<font color="black">1393. </font>
<font color="green">1394.     def close(self):</font>
<font color="red">1395.         assert len(self._elem) == 0, &quot;missing end tags&quot;</font>
<font color="red">1396.         assert self._last is not None, &quot;missing toplevel element&quot;</font>
<font color="red">1397.         return self._last</font>
<font color="black">1398. </font>
<font color="green">1399.     def _flush(self):</font>
<font color="red">1400.         if self._data:</font>
<font color="red">1401.             if self._last is not None:</font>
<font color="red">1402.                 text = &quot;&quot;.join(self._data)</font>
<font color="red">1403.                 if self._tail:</font>
<font color="red">1404.                     assert self._last.tail is None, &quot;internal error (tail)&quot;</font>
<font color="red">1405.                     self._last.tail = text</font>
<font color="black">1406.                 else:</font>
<font color="red">1407.                     assert self._last.text is None, &quot;internal error (text)&quot;</font>
<font color="red">1408.                     self._last.text = text</font>
<font color="red">1409.             self._data = []</font>
<font color="black">1410. </font>
<font color="black">1411.     ##</font>
<font color="black">1412.     # Adds text to the current element.</font>
<font color="black">1413.     #</font>
<font color="black">1414.     # @param data A string.  This should be either an 8-bit string</font>
<font color="black">1415.     #    containing ASCII text, or a Unicode string.</font>
<font color="black">1416. </font>
<font color="green">1417.     def data(self, data):</font>
<font color="red">1418.         self._data.append(data)</font>
<font color="black">1419. </font>
<font color="black">1420.     ##</font>
<font color="black">1421.     # Opens a new element.</font>
<font color="black">1422.     #</font>
<font color="black">1423.     # @param tag The element name.</font>
<font color="black">1424.     # @param attrib A dictionary containing element attributes.</font>
<font color="black">1425.     # @return The opened element.</font>
<font color="black">1426.     # @defreturn Element</font>
<font color="black">1427. </font>
<font color="green">1428.     def start(self, tag, attrs):</font>
<font color="red">1429.         self._flush()</font>
<font color="red">1430.         self._last = elem = self._factory(tag, attrs)</font>
<font color="red">1431.         if self._elem:</font>
<font color="red">1432.             self._elem[-1].append(elem)</font>
<font color="red">1433.         self._elem.append(elem)</font>
<font color="red">1434.         self._tail = 0</font>
<font color="red">1435.         return elem</font>
<font color="black">1436. </font>
<font color="black">1437.     ##</font>
<font color="black">1438.     # Closes the current element.</font>
<font color="black">1439.     #</font>
<font color="black">1440.     # @param tag The element name.</font>
<font color="black">1441.     # @return The closed element.</font>
<font color="black">1442.     # @defreturn Element</font>
<font color="black">1443. </font>
<font color="green">1444.     def end(self, tag):</font>
<font color="red">1445.         self._flush()</font>
<font color="red">1446.         self._last = self._elem.pop()</font>
<font color="red">1447.         assert self._last.tag == tag,\</font>
<font color="red">1448.                &quot;end tag mismatch (expected %s, got %s)&quot; % (</font>
<font color="red">1449.                    self._last.tag, tag)</font>
<font color="red">1450.         self._tail = 1</font>
<font color="red">1451.         return self._last</font>
<font color="black">1452. </font>
<font color="green">1453. _sentinel = ['sentinel']</font>
<font color="black">1454. </font>
<font color="black">1455. ##</font>
<font color="black">1456. # Element structure builder for XML source data, based on the</font>
<font color="black">1457. # &lt;b&gt;expat&lt;/b&gt; parser.</font>
<font color="black">1458. #</font>
<font color="black">1459. # @keyparam target Target object.  If omitted, the builder uses an</font>
<font color="black">1460. #     instance of the standard {@link #TreeBuilder} class.</font>
<font color="black">1461. # @keyparam html Predefine HTML entities.  This flag is not supported</font>
<font color="black">1462. #     by the current implementation.</font>
<font color="black">1463. # @keyparam encoding Optional encoding.  If given, the value overrides</font>
<font color="black">1464. #     the encoding specified in the XML file.</font>
<font color="black">1465. # @see #ElementTree</font>
<font color="black">1466. # @see #TreeBuilder</font>
<font color="black">1467. </font>
<font color="green">1468. class XMLParser(object):</font>
<font color="black">1469. </font>
<font color="green">1470.     def __init__(self, html=_sentinel, target=None, encoding=None):</font>
<font color="red">1471.         if html is not _sentinel:</font>
<font color="red">1472.             warnings.warnpy3k(</font>
<font color="red">1473.                 &quot;The html argument of XMLParser() is deprecated&quot;,</font>
<font color="red">1474.                 DeprecationWarning, stacklevel=2)</font>
<font color="red">1475.         try:</font>
<font color="red">1476.             from xml.parsers import expat</font>
<font color="red">1477.         except ImportError:</font>
<font color="red">1478.             try:</font>
<font color="red">1479.                 import pyexpat as expat</font>
<font color="red">1480.             except ImportError:</font>
<font color="red">1481.                 raise ImportError(</font>
<font color="red">1482.                     &quot;No module named expat; use SimpleXMLTreeBuilder instead&quot;</font>
<font color="black">1483.                     )</font>
<font color="red">1484.         parser = expat.ParserCreate(encoding, &quot;}&quot;)</font>
<font color="red">1485.         if target is None:</font>
<font color="red">1486.             target = TreeBuilder()</font>
<font color="black">1487.         # underscored names are provided for compatibility only</font>
<font color="red">1488.         self.parser = self._parser = parser</font>
<font color="red">1489.         self.target = self._target = target</font>
<font color="red">1490.         self._error = expat.error</font>
<font color="red">1491.         self._names = {} # name memo cache</font>
<font color="black">1492.         # callbacks</font>
<font color="red">1493.         parser.DefaultHandlerExpand = self._default</font>
<font color="red">1494.         parser.StartElementHandler = self._start</font>
<font color="red">1495.         parser.EndElementHandler = self._end</font>
<font color="red">1496.         parser.CharacterDataHandler = self._data</font>
<font color="black">1497.         # optional callbacks</font>
<font color="red">1498.         parser.CommentHandler = self._comment</font>
<font color="red">1499.         parser.ProcessingInstructionHandler = self._pi</font>
<font color="black">1500.         # let expat do the buffering, if supported</font>
<font color="red">1501.         try:</font>
<font color="red">1502.             self._parser.buffer_text = 1</font>
<font color="red">1503.         except AttributeError:</font>
<font color="red">1504.             pass</font>
<font color="black">1505.         # use new-style attribute handling, if supported</font>
<font color="red">1506.         try:</font>
<font color="red">1507.             self._parser.ordered_attributes = 1</font>
<font color="red">1508.             self._parser.specified_attributes = 1</font>
<font color="red">1509.             parser.StartElementHandler = self._start_list</font>
<font color="red">1510.         except AttributeError:</font>
<font color="red">1511.             pass</font>
<font color="red">1512.         self._doctype = None</font>
<font color="red">1513.         self.entity = {}</font>
<font color="red">1514.         try:</font>
<font color="red">1515.             self.version = &quot;Expat %d.%d.%d&quot; % expat.version_info</font>
<font color="red">1516.         except AttributeError:</font>
<font color="red">1517.             pass # unknown</font>
<font color="black">1518. </font>
<font color="green">1519.     def _raiseerror(self, value):</font>
<font color="red">1520.         err = ParseError(value)</font>
<font color="red">1521.         err.code = value.code</font>
<font color="red">1522.         err.position = value.lineno, value.offset</font>
<font color="red">1523.         raise err</font>
<font color="black">1524. </font>
<font color="green">1525.     def _fixtext(self, text):</font>
<font color="black">1526.         # convert text string to ascii, if possible</font>
<font color="red">1527.         try:</font>
<font color="red">1528.             return text.encode(&quot;ascii&quot;)</font>
<font color="red">1529.         except UnicodeError:</font>
<font color="red">1530.             return text</font>
<font color="black">1531. </font>
<font color="green">1532.     def _fixname(self, key):</font>
<font color="black">1533.         # expand qname, and convert name string to ascii, if possible</font>
<font color="red">1534.         try:</font>
<font color="red">1535.             name = self._names[key]</font>
<font color="red">1536.         except KeyError:</font>
<font color="red">1537.             name = key</font>
<font color="red">1538.             if &quot;}&quot; in name:</font>
<font color="red">1539.                 name = &quot;{&quot; + name</font>
<font color="red">1540.             self._names[key] = name = self._fixtext(name)</font>
<font color="red">1541.         return name</font>
<font color="black">1542. </font>
<font color="green">1543.     def _start(self, tag, attrib_in):</font>
<font color="red">1544.         fixname = self._fixname</font>
<font color="red">1545.         fixtext = self._fixtext</font>
<font color="red">1546.         tag = fixname(tag)</font>
<font color="red">1547.         attrib = {}</font>
<font color="red">1548.         for key, value in attrib_in.items():</font>
<font color="red">1549.             attrib[fixname(key)] = fixtext(value)</font>
<font color="red">1550.         return self.target.start(tag, attrib)</font>
<font color="black">1551. </font>
<font color="green">1552.     def _start_list(self, tag, attrib_in):</font>
<font color="red">1553.         fixname = self._fixname</font>
<font color="red">1554.         fixtext = self._fixtext</font>
<font color="red">1555.         tag = fixname(tag)</font>
<font color="red">1556.         attrib = {}</font>
<font color="red">1557.         if attrib_in:</font>
<font color="red">1558.             for i in range(0, len(attrib_in), 2):</font>
<font color="red">1559.                 attrib[fixname(attrib_in[i])] = fixtext(attrib_in[i+1])</font>
<font color="red">1560.         return self.target.start(tag, attrib)</font>
<font color="black">1561. </font>
<font color="green">1562.     def _data(self, text):</font>
<font color="red">1563.         return self.target.data(self._fixtext(text))</font>
<font color="black">1564. </font>
<font color="green">1565.     def _end(self, tag):</font>
<font color="red">1566.         return self.target.end(self._fixname(tag))</font>
<font color="black">1567. </font>
<font color="green">1568.     def _comment(self, data):</font>
<font color="red">1569.         try:</font>
<font color="red">1570.             comment = self.target.comment</font>
<font color="red">1571.         except AttributeError:</font>
<font color="red">1572.             pass</font>
<font color="black">1573.         else:</font>
<font color="red">1574.             return comment(self._fixtext(data))</font>
<font color="black">1575. </font>
<font color="green">1576.     def _pi(self, target, data):</font>
<font color="red">1577.         try:</font>
<font color="red">1578.             pi = self.target.pi</font>
<font color="red">1579.         except AttributeError:</font>
<font color="red">1580.             pass</font>
<font color="black">1581.         else:</font>
<font color="red">1582.             return pi(self._fixtext(target), self._fixtext(data))</font>
<font color="black">1583. </font>
<font color="green">1584.     def _default(self, text):</font>
<font color="red">1585.         prefix = text[:1]</font>
<font color="red">1586.         if prefix == &quot;&amp;&quot;:</font>
<font color="black">1587.             # deal with undefined entities</font>
<font color="red">1588.             try:</font>
<font color="red">1589.                 self.target.data(self.entity[text[1:-1]])</font>
<font color="red">1590.             except KeyError:</font>
<font color="red">1591.                 from xml.parsers import expat</font>
<font color="red">1592.                 err = expat.error(</font>
<font color="red">1593.                     &quot;undefined entity %s: line %d, column %d&quot; %</font>
<font color="red">1594.                     (text, self._parser.ErrorLineNumber,</font>
<font color="red">1595.                     self._parser.ErrorColumnNumber)</font>
<font color="black">1596.                     )</font>
<font color="red">1597.                 err.code = 11 # XML_ERROR_UNDEFINED_ENTITY</font>
<font color="red">1598.                 err.lineno = self._parser.ErrorLineNumber</font>
<font color="red">1599.                 err.offset = self._parser.ErrorColumnNumber</font>
<font color="red">1600.                 raise err</font>
<font color="red">1601.         elif prefix == &quot;&lt;&quot; and text[:9] == &quot;&lt;!DOCTYPE&quot;:</font>
<font color="red">1602.             self._doctype = [] # inside a doctype declaration</font>
<font color="red">1603.         elif self._doctype is not None:</font>
<font color="black">1604.             # parse doctype contents</font>
<font color="red">1605.             if prefix == &quot;&gt;&quot;:</font>
<font color="red">1606.                 self._doctype = None</font>
<font color="red">1607.                 return</font>
<font color="red">1608.             text = text.strip()</font>
<font color="red">1609.             if not text:</font>
<font color="red">1610.                 return</font>
<font color="red">1611.             self._doctype.append(text)</font>
<font color="red">1612.             n = len(self._doctype)</font>
<font color="red">1613.             if n &gt; 2:</font>
<font color="red">1614.                 type = self._doctype[1]</font>
<font color="red">1615.                 if type == &quot;PUBLIC&quot; and n == 4:</font>
<font color="red">1616.                     name, type, pubid, system = self._doctype</font>
<font color="red">1617.                 elif type == &quot;SYSTEM&quot; and n == 3:</font>
<font color="red">1618.                     name, type, system = self._doctype</font>
<font color="red">1619.                     pubid = None</font>
<font color="black">1620.                 else:</font>
<font color="red">1621.                     return</font>
<font color="red">1622.                 if pubid:</font>
<font color="red">1623.                     pubid = pubid[1:-1]</font>
<font color="red">1624.                 if hasattr(self.target, &quot;doctype&quot;):</font>
<font color="red">1625.                     self.target.doctype(name, pubid, system[1:-1])</font>
<font color="red">1626.                 elif self.doctype != self._XMLParser__doctype:</font>
<font color="black">1627.                     # warn about deprecated call</font>
<font color="red">1628.                     self._XMLParser__doctype(name, pubid, system[1:-1])</font>
<font color="red">1629.                     self.doctype(name, pubid, system[1:-1])</font>
<font color="red">1630.                 self._doctype = None</font>
<font color="black">1631. </font>
<font color="black">1632.     ##</font>
<font color="black">1633.     # (Deprecated) Handles a doctype declaration.</font>
<font color="black">1634.     #</font>
<font color="black">1635.     # @param name Doctype name.</font>
<font color="black">1636.     # @param pubid Public identifier.</font>
<font color="black">1637.     # @param system System identifier.</font>
<font color="black">1638. </font>
<font color="green">1639.     def doctype(self, name, pubid, system):</font>
<font color="black">1640.         &quot;&quot;&quot;This method of XMLParser is deprecated.&quot;&quot;&quot;</font>
<font color="red">1641.         warnings.warn(</font>
<font color="red">1642.             &quot;This method of XMLParser is deprecated.  Define doctype() &quot;</font>
<font color="black">1643.             &quot;method on the TreeBuilder target.&quot;,</font>
<font color="red">1644.             DeprecationWarning,</font>
<font color="black">1645.             )</font>
<font color="black">1646. </font>
<font color="black">1647.     # sentinel, if doctype is redefined in a subclass</font>
<font color="green">1648.     __doctype = doctype</font>
<font color="black">1649. </font>
<font color="black">1650.     ##</font>
<font color="black">1651.     # Feeds data to the parser.</font>
<font color="black">1652.     #</font>
<font color="black">1653.     # @param data Encoded data.</font>
<font color="black">1654. </font>
<font color="green">1655.     def feed(self, data):</font>
<font color="red">1656.         try:</font>
<font color="red">1657.             self._parser.Parse(data, 0)</font>
<font color="red">1658.         except self._error, v:</font>
<font color="red">1659.             self._raiseerror(v)</font>
<font color="black">1660. </font>
<font color="black">1661.     ##</font>
<font color="black">1662.     # Finishes feeding data to the parser.</font>
<font color="black">1663.     #</font>
<font color="black">1664.     # @return An element structure.</font>
<font color="black">1665.     # @defreturn Element</font>
<font color="black">1666. </font>
<font color="green">1667.     def close(self):</font>
<font color="red">1668.         try:</font>
<font color="red">1669.             self._parser.Parse(&quot;&quot;, 1) # end of data</font>
<font color="red">1670.         except self._error, v:</font>
<font color="red">1671.             self._raiseerror(v)</font>
<font color="red">1672.         tree = self.target.close()</font>
<font color="red">1673.         del self.target, self._parser # get rid of circular references</font>
<font color="red">1674.         return tree</font>
<font color="black">1675. </font>
<font color="black">1676. # compatibility</font>
<font color="green">1677. XMLTreeBuilder = XMLParser</font>
<font color="black">1678. </font>
<font color="black">1679. # workaround circular import.</font>
<font color="green">1680. try:</font>
<font color="green">1681.     from ElementC14N import _serialize_c14n</font>
<font color="red">1682.     _serialize[&quot;c14n&quot;] = _serialize_c14n</font>
<font color="green">1683. except ImportError:</font>
<font color="green">1684.     pass</font>
</pre>

