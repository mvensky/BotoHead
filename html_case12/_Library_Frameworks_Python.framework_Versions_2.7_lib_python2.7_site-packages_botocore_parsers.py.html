source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/parsers.py</b><br>


file stats: <b>507 lines, 225 executed: 44.4% covered</b>
<pre>
<font color="black">   1. # Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="black">  13. &quot;&quot;&quot;Response parsers for the various protocol types.</font>
<font color="black">  14. </font>
<font color="black">  15. The module contains classes that can take an HTTP response, and given</font>
<font color="black">  16. an output shape, parse the response into a dict according to the</font>
<font color="black">  17. rules in the output shape.</font>
<font color="black">  18. </font>
<font color="black">  19. There are many similarities amongst the different protocols with regard</font>
<font color="black">  20. to response parsing, and the code is structured in a way to avoid</font>
<font color="black">  21. code duplication when possible.  The diagram below is a diagram</font>
<font color="black">  22. showing the inheritance hierarchy of the response classes.</font>
<font color="black">  23. </font>
<font color="black">  24. ::</font>
<font color="black">  25. </font>
<font color="black">  26. </font>
<font color="black">  27. </font>
<font color="black">  28.                                  +--------------+</font>
<font color="black">  29.                                  |ResponseParser|</font>
<font color="black">  30.                                  +--------------+</font>
<font color="black">  31.                                     ^    ^    ^</font>
<font color="black">  32.                +--------------------+    |    +-------------------+</font>
<font color="black">  33.                |                         |                        |</font>
<font color="black">  34.     +----------+----------+       +------+-------+        +-------+------+</font>
<font color="black">  35.     |BaseXMLResponseParser|       |BaseRestParser|        |BaseJSONParser|</font>
<font color="black">  36.     +---------------------+       +--------------+        +--------------+</font>
<font color="black">  37.               ^         ^          ^           ^           ^        ^</font>
<font color="black">  38.               |         |          |           |           |        |</font>
<font color="black">  39.               |         |          |           |           |        |</font>
<font color="black">  40.               |        ++----------+-+       +-+-----------++       |</font>
<font color="black">  41.               |        |RestXMLParser|       |RestJSONParser|       |</font>
<font color="black">  42.         +-----+-----+  +-------------+       +--------------+  +----+-----+</font>
<font color="black">  43.         |QueryParser|                                          |JSONParser|</font>
<font color="black">  44.         +-----------+                                          +----------+</font>
<font color="black">  45. </font>
<font color="black">  46. </font>
<font color="black">  47. The diagram above shows that there is a base class, ``ResponseParser`` that</font>
<font color="black">  48. contains logic that is similar amongst all the different protocols (``query``,</font>
<font color="black">  49. ``json``, ``rest-json``, ``rest-xml``).  Amongst the various services there</font>
<font color="black">  50. is shared logic that can be grouped several ways:</font>
<font color="black">  51. </font>
<font color="black">  52. * The ``query`` and ``rest-xml`` both have XML bodies that are parsed in the</font>
<font color="black">  53.   same way.</font>
<font color="black">  54. * The ``json`` and ``rest-json`` protocols both have JSON bodies that are</font>
<font color="black">  55.   parsed in the same way.</font>
<font color="black">  56. * The ``rest-json`` and ``rest-xml`` protocols have additional attributes</font>
<font color="black">  57.   besides body parameters that are parsed the same (headers, query string,</font>
<font color="black">  58.   status code).</font>
<font color="black">  59. </font>
<font color="black">  60. This is reflected in the class diagram above.  The ``BaseXMLResponseParser``</font>
<font color="black">  61. and the BaseJSONParser contain logic for parsing the XML/JSON body,</font>
<font color="black">  62. and the BaseRestParser contains logic for parsing out attributes that</font>
<font color="black">  63. come from other parts of the HTTP response.  Classes like the</font>
<font color="black">  64. ``RestXMLParser`` inherit from the ``BaseXMLResponseParser`` to get the</font>
<font color="black">  65. XML body parsing logic and the ``BaseRestParser`` to get the HTTP</font>
<font color="black">  66. header/status code/query string parsing.</font>
<font color="black">  67. </font>
<font color="black">  68. Additionally, there are event stream parsers that are used by the other parsers</font>
<font color="black">  69. to wrap streaming bodies that represent a stream of events. The</font>
<font color="black">  70. BaseEventStreamParser extends from ResponseParser and defines the logic for</font>
<font color="black">  71. parsing values from the headers and payload of a message from the underlying</font>
<font color="black">  72. binary encoding protocol. Currently, event streams support parsing bodies</font>
<font color="black">  73. encoded as JSON and XML through the following hierarchy.</font>
<font color="black">  74. </font>
<font color="black">  75. </font>
<font color="black">  76.                                   +--------------+</font>
<font color="black">  77.                                   |ResponseParser|</font>
<font color="black">  78.                                   +--------------+</font>
<font color="black">  79.                                     ^    ^    ^</font>
<font color="black">  80.                +--------------------+    |    +------------------+</font>
<font color="black">  81.                |                         |                       |</font>
<font color="black">  82.     +----------+----------+   +----------+----------+    +-------+------+</font>
<font color="black">  83.     |BaseXMLResponseParser|   |BaseEventStreamParser|    |BaseJSONParser|</font>
<font color="black">  84.     +---------------------+   +---------------------+    +--------------+</font>
<font color="black">  85.                      ^                ^        ^                 ^</font>
<font color="black">  86.                      |                |        |                 |</font>
<font color="black">  87.                      |                |        |                 |</font>
<font color="black">  88.                    +-+----------------+-+    +-+-----------------+-+</font>
<font color="black">  89.                    |EventStreamXMLParser|    |EventStreamJSONParser|</font>
<font color="black">  90.                    +--------------------+    +---------------------+</font>
<font color="black">  91. </font>
<font color="black">  92. Return Values</font>
<font color="black">  93. =============</font>
<font color="black">  94. </font>
<font color="black">  95. Each call to ``parse()`` returns a dict has this form::</font>
<font color="black">  96. </font>
<font color="black">  97.     Standard Response</font>
<font color="black">  98. </font>
<font color="black">  99.     {</font>
<font color="black"> 100.       &quot;ResponseMetadata&quot;: {&quot;RequestId&quot;: &lt;requestid&gt;}</font>
<font color="black"> 101.       &lt;response keys&gt;</font>
<font color="black"> 102.     }</font>
<font color="black"> 103. </font>
<font color="black"> 104.     Error response</font>
<font color="black"> 105. </font>
<font color="black"> 106.     {</font>
<font color="black"> 107.       &quot;ResponseMetadata&quot;: {&quot;RequestId&quot;: &lt;requestid&gt;}</font>
<font color="black"> 108.       &quot;Error&quot;: {</font>
<font color="black"> 109.         &quot;Code&quot;: &lt;string&gt;,</font>
<font color="black"> 110.         &quot;Message&quot;: &lt;string&gt;,</font>
<font color="black"> 111.         &quot;Type&quot;: &lt;string&gt;,</font>
<font color="black"> 112.         &lt;additional keys&gt;</font>
<font color="black"> 113.       }</font>
<font color="black"> 114.     }</font>
<font color="black"> 115. </font>
<font color="green"> 116. &quot;&quot;&quot;</font>
<font color="green"> 117. import re</font>
<font color="green"> 118. import base64</font>
<font color="green"> 119. import json</font>
<font color="green"> 120. import xml.etree.cElementTree</font>
<font color="green"> 121. import logging</font>
<font color="black"> 122. </font>
<font color="green"> 123. from botocore.compat import six, XMLParseError</font>
<font color="green"> 124. from botocore.eventstream import EventStream</font>
<font color="black"> 125. </font>
<font color="green"> 126. from botocore.utils import parse_timestamp, merge_dicts, \</font>
<font color="black"> 127.     is_json_value_header</font>
<font color="black"> 128. </font>
<font color="green"> 129. LOG = logging.getLogger(__name__)</font>
<font color="black"> 130. </font>
<font color="green"> 131. DEFAULT_TIMESTAMP_PARSER = parse_timestamp</font>
<font color="black"> 132. </font>
<font color="black"> 133. </font>
<font color="green"> 134. class ResponseParserFactory(object):</font>
<font color="green"> 135.     def __init__(self):</font>
<font color="green"> 136.         self._defaults = {}</font>
<font color="black"> 137. </font>
<font color="green"> 138.     def set_parser_defaults(self, **kwargs):</font>
<font color="black"> 139.         &quot;&quot;&quot;Set default arguments when a parser instance is created.</font>
<font color="black"> 140. </font>
<font color="black"> 141.         You can specify any kwargs that are allowed by a ResponseParser</font>
<font color="black"> 142.         class.  There are currently two arguments:</font>
<font color="black"> 143. </font>
<font color="black"> 144.             * timestamp_parser - A callable that can parse a timetsamp string</font>
<font color="black"> 145.             * blob_parser - A callable that can parse a blob type</font>
<font color="black"> 146. </font>
<font color="black"> 147.         &quot;&quot;&quot;</font>
<font color="red"> 148.         self._defaults.update(kwargs)</font>
<font color="black"> 149. </font>
<font color="green"> 150.     def create_parser(self, protocol_name):</font>
<font color="green"> 151.         parser_cls = PROTOCOL_PARSERS[protocol_name]</font>
<font color="green"> 152.         return parser_cls(**self._defaults)</font>
<font color="black"> 153. </font>
<font color="black"> 154. </font>
<font color="green"> 155. def create_parser(protocol):</font>
<font color="green"> 156.     return ResponseParserFactory().create_parser(protocol)</font>
<font color="black"> 157. </font>
<font color="black"> 158. </font>
<font color="green"> 159. def _text_content(func):</font>
<font color="black"> 160.     # This decorator hides the difference between</font>
<font color="black"> 161.     # an XML node with text or a plain string.  It's used</font>
<font color="black"> 162.     # to ensure that scalar processing operates only on text</font>
<font color="black"> 163.     # strings, which allows the same scalar handlers to be used</font>
<font color="black"> 164.     # for XML nodes from the body and HTTP headers.</font>
<font color="green"> 165.     def _get_text_content(self, shape, node_or_string):</font>
<font color="green"> 166.         if hasattr(node_or_string, 'text'):</font>
<font color="green"> 167.             text = node_or_string.text</font>
<font color="green"> 168.             if text is None:</font>
<font color="black"> 169.                 # If an XML node is empty &lt;foo&gt;&lt;/foo&gt;,</font>
<font color="black"> 170.                 # we want to parse that as an empty string,</font>
<font color="black"> 171.                 # not as a null/None value.</font>
<font color="red"> 172.                 text = ''</font>
<font color="black"> 173.         else:</font>
<font color="red"> 174.             text = node_or_string</font>
<font color="green"> 175.         return func(self, shape, text)</font>
<font color="green"> 176.     return _get_text_content</font>
<font color="black"> 177. </font>
<font color="black"> 178. </font>
<font color="green"> 179. class ResponseParserError(Exception):</font>
<font color="green"> 180.     pass</font>
<font color="black"> 181. </font>
<font color="black"> 182. </font>
<font color="green"> 183. class ResponseParser(object):</font>
<font color="black"> 184.     &quot;&quot;&quot;Base class for response parsing.</font>
<font color="black"> 185. </font>
<font color="black"> 186.     This class represents the interface that all ResponseParsers for the</font>
<font color="black"> 187.     various protocols must implement.</font>
<font color="black"> 188. </font>
<font color="black"> 189.     This class will take an HTTP response and a model shape and parse the</font>
<font color="black"> 190.     HTTP response into a dictionary.</font>
<font color="black"> 191. </font>
<font color="black"> 192.     There is a single public method exposed: ``parse``.  See the ``parse``</font>
<font color="black"> 193.     docstring for more info.</font>
<font color="black"> 194. </font>
<font color="green"> 195.     &quot;&quot;&quot;</font>
<font color="green"> 196.     DEFAULT_ENCODING = 'utf-8'</font>
<font color="green"> 197.     EVENT_STREAM_PARSER_CLS = None</font>
<font color="black"> 198. </font>
<font color="green"> 199.     def __init__(self, timestamp_parser=None, blob_parser=None):</font>
<font color="green"> 200.         if timestamp_parser is None:</font>
<font color="green"> 201.             timestamp_parser = DEFAULT_TIMESTAMP_PARSER</font>
<font color="green"> 202.         self._timestamp_parser = timestamp_parser</font>
<font color="green"> 203.         if blob_parser is None:</font>
<font color="green"> 204.             blob_parser = self._default_blob_parser</font>
<font color="green"> 205.         self._blob_parser = blob_parser</font>
<font color="green"> 206.         self._event_stream_parser = None</font>
<font color="green"> 207.         if self.EVENT_STREAM_PARSER_CLS is not None:</font>
<font color="green"> 208.             self._event_stream_parser = self.EVENT_STREAM_PARSER_CLS(</font>
<font color="green"> 209.                 timestamp_parser, blob_parser)</font>
<font color="black"> 210. </font>
<font color="green"> 211.     def _default_blob_parser(self, value):</font>
<font color="black"> 212.         # Blobs are always returned as bytes type (this matters on python3).</font>
<font color="black"> 213.         # We don't decode this to a str because it's entirely possible that the</font>
<font color="black"> 214.         # blob contains binary data that actually can't be decoded.</font>
<font color="red"> 215.         return base64.b64decode(value)</font>
<font color="black"> 216. </font>
<font color="green"> 217.     def parse(self, response, shape):</font>
<font color="black"> 218.         &quot;&quot;&quot;Parse the HTTP response given a shape.</font>
<font color="black"> 219. </font>
<font color="black"> 220.         :param response: The HTTP response dictionary.  This is a dictionary</font>
<font color="black"> 221.             that represents the HTTP request.  The dictionary must have the</font>
<font color="black"> 222.             following keys, ``body``, ``headers``, and ``status_code``.</font>
<font color="black"> 223. </font>
<font color="black"> 224.         :param shape: The model shape describing the expected output.</font>
<font color="black"> 225.         :return: Returns a dictionary representing the parsed response</font>
<font color="black"> 226.             described by the model.  In addition to the shape described from</font>
<font color="black"> 227.             the model, each response will also have a ``ResponseMetadata``</font>
<font color="black"> 228.             which contains metadata about the response, which contains at least</font>
<font color="black"> 229.             two keys containing ``RequestId`` and ``HTTPStatusCode``.  Some</font>
<font color="black"> 230.             responses may populate additional keys, but ``RequestId`` will</font>
<font color="black"> 231.             always be present.</font>
<font color="black"> 232. </font>
<font color="black"> 233.         &quot;&quot;&quot;</font>
<font color="green"> 234.         LOG.debug('Response headers: %s', response['headers'])</font>
<font color="green"> 235.         LOG.debug('Response body:\n%s', response['body'])</font>
<font color="green"> 236.         if response['status_code'] &gt;= 301:</font>
<font color="red"> 237.             if self._is_generic_error_response(response):</font>
<font color="red"> 238.                 parsed = self._do_generic_error_parse(response)</font>
<font color="black"> 239.             else:</font>
<font color="red"> 240.                 parsed = self._do_error_parse(response, shape)</font>
<font color="black"> 241.         else:</font>
<font color="green"> 242.             parsed = self._do_parse(response, shape)</font>
<font color="black"> 243. </font>
<font color="black"> 244.         # We don't want to decorate event stream responses with metadata</font>
<font color="green"> 245.         if shape and shape.serialization.get('eventstream'):</font>
<font color="red"> 246.             return parsed</font>
<font color="black"> 247. </font>
<font color="black"> 248.         # Add ResponseMetadata if it doesn't exist and inject the HTTP</font>
<font color="black"> 249.         # status code and headers from the response.</font>
<font color="green"> 250.         if isinstance(parsed, dict):</font>
<font color="green"> 251.             response_metadata = parsed.get('ResponseMetadata', {})</font>
<font color="green"> 252.             response_metadata['HTTPStatusCode'] = response['status_code']</font>
<font color="green"> 253.             response_metadata['HTTPHeaders'] = dict(response['headers'])</font>
<font color="green"> 254.             parsed['ResponseMetadata'] = response_metadata</font>
<font color="green"> 255.         return parsed</font>
<font color="black"> 256. </font>
<font color="green"> 257.     def _is_generic_error_response(self, response):</font>
<font color="black"> 258.         # There are times when a service will respond with a generic</font>
<font color="black"> 259.         # error response such as:</font>
<font color="black"> 260.         # '&lt;html&gt;&lt;body&gt;&lt;b&gt;Http/1.1 Service Unavailable&lt;/b&gt;&lt;/body&gt;&lt;/html&gt;'</font>
<font color="black"> 261.         #</font>
<font color="black"> 262.         # This can also happen if you're going through a proxy.</font>
<font color="black"> 263.         # In this case the protocol specific _do_error_parse will either</font>
<font color="black"> 264.         # fail to parse the response (in the best case) or silently succeed</font>
<font color="black"> 265.         # and treat the HTML above as an XML response and return</font>
<font color="black"> 266.         # non sensical parsed data.</font>
<font color="black"> 267.         # To prevent this case from happening we first need to check</font>
<font color="black"> 268.         # whether or not this response looks like the generic response.</font>
<font color="red"> 269.         if response['status_code'] &gt;= 500:</font>
<font color="red"> 270.             body = response['body'].strip()</font>
<font color="red"> 271.             return body.startswith(b'&lt;html&gt;') or not body</font>
<font color="black"> 272. </font>
<font color="green"> 273.     def _do_generic_error_parse(self, response):</font>
<font color="black"> 274.         # There's not really much we can do when we get a generic</font>
<font color="black"> 275.         # html response.</font>
<font color="red"> 276.         LOG.debug(&quot;Received a non protocol specific error response from the &quot;</font>
<font color="black"> 277.                   &quot;service, unable to populate error code and message.&quot;)</font>
<font color="red"> 278.         return {</font>
<font color="red"> 279.             'Error': {'Code': str(response['status_code']),</font>
<font color="red"> 280.                       'Message': six.moves.http_client.responses.get(</font>
<font color="red"> 281.                           response['status_code'], '')},</font>
<font color="red"> 282.             'ResponseMetadata': {},</font>
<font color="black"> 283.         }</font>
<font color="black"> 284. </font>
<font color="green"> 285.     def _do_parse(self, response, shape):</font>
<font color="red"> 286.         raise NotImplementedError(&quot;%s._do_parse&quot; % self.__class__.__name__)</font>
<font color="black"> 287. </font>
<font color="green"> 288.     def _do_error_parse(self, response, shape):</font>
<font color="red"> 289.         raise NotImplementedError(</font>
<font color="red"> 290.             &quot;%s._do_error_parse&quot; % self.__class__.__name__)</font>
<font color="black"> 291. </font>
<font color="green"> 292.     def _parse_shape(self, shape, node):</font>
<font color="green"> 293.         handler = getattr(self, '_handle_%s' % shape.type_name,</font>
<font color="green"> 294.                           self._default_handle)</font>
<font color="green"> 295.         return handler(shape, node)</font>
<font color="black"> 296. </font>
<font color="green"> 297.     def _handle_list(self, shape, node):</font>
<font color="black"> 298.         # Enough implementations share list serialization that it's moved</font>
<font color="black"> 299.         # up here in the base class.</font>
<font color="green"> 300.         parsed = []</font>
<font color="green"> 301.         member_shape = shape.member</font>
<font color="green"> 302.         for item in node:</font>
<font color="green"> 303.             parsed.append(self._parse_shape(member_shape, item))</font>
<font color="green"> 304.         return parsed</font>
<font color="black"> 305. </font>
<font color="green"> 306.     def _default_handle(self, shape, value):</font>
<font color="red"> 307.         return value</font>
<font color="black"> 308. </font>
<font color="black"> 309. </font>
<font color="green"> 310. class BaseXMLResponseParser(ResponseParser):</font>
<font color="green"> 311.     def __init__(self, timestamp_parser=None, blob_parser=None):</font>
<font color="green"> 312.         super(BaseXMLResponseParser, self).__init__(timestamp_parser,</font>
<font color="green"> 313.                                                     blob_parser)</font>
<font color="green"> 314.         self._namespace_re = re.compile('{.*}')</font>
<font color="black"> 315. </font>
<font color="green"> 316.     def _handle_map(self, shape, node):</font>
<font color="red"> 317.         parsed = {}</font>
<font color="red"> 318.         key_shape = shape.key</font>
<font color="red"> 319.         value_shape = shape.value</font>
<font color="red"> 320.         key_location_name = key_shape.serialization.get('name') or 'key'</font>
<font color="red"> 321.         value_location_name = value_shape.serialization.get('name') or 'value'</font>
<font color="red"> 322.         if shape.serialization.get('flattened') and not isinstance(node, list):</font>
<font color="red"> 323.             node = [node]</font>
<font color="red"> 324.         for keyval_node in node:</font>
<font color="red"> 325.             for single_pair in keyval_node:</font>
<font color="black"> 326.                 # Within each &lt;entry&gt; there's a &lt;key&gt; and a &lt;value&gt;</font>
<font color="red"> 327.                 tag_name = self._node_tag(single_pair)</font>
<font color="red"> 328.                 if tag_name == key_location_name:</font>
<font color="red"> 329.                     key_name = self._parse_shape(key_shape, single_pair)</font>
<font color="red"> 330.                 elif tag_name == value_location_name:</font>
<font color="red"> 331.                     val_name = self._parse_shape(value_shape, single_pair)</font>
<font color="black"> 332.                 else:</font>
<font color="red"> 333.                     raise ResponseParserError(&quot;Unknown tag: %s&quot; % tag_name)</font>
<font color="red"> 334.             parsed[key_name] = val_name</font>
<font color="red"> 335.         return parsed</font>
<font color="black"> 336. </font>
<font color="green"> 337.     def _node_tag(self, node):</font>
<font color="green"> 338.         return self._namespace_re.sub('', node.tag)</font>
<font color="black"> 339. </font>
<font color="green"> 340.     def _handle_list(self, shape, node):</font>
<font color="black"> 341.         # When we use _build_name_to_xml_node, repeated elements are aggregated</font>
<font color="black"> 342.         # into a list.  However, we can't tell the difference between a scalar</font>
<font color="black"> 343.         # value and a single element flattened list.  So before calling the</font>
<font color="black"> 344.         # real _handle_list, we know that &quot;node&quot; should actually be a list if</font>
<font color="black"> 345.         # it's flattened, and if it's not, then we make it a one element list.</font>
<font color="green"> 346.         if shape.serialization.get('flattened') and not isinstance(node, list):</font>
<font color="green"> 347.             node = [node]</font>
<font color="green"> 348.         return super(BaseXMLResponseParser, self)._handle_list(shape, node)</font>
<font color="black"> 349. </font>
<font color="green"> 350.     def _handle_structure(self, shape, node):</font>
<font color="green"> 351.         parsed = {}</font>
<font color="green"> 352.         members = shape.members</font>
<font color="green"> 353.         xml_dict = self._build_name_to_xml_node(node)</font>
<font color="green"> 354.         for member_name in members:</font>
<font color="green"> 355.             member_shape = members[member_name]</font>
<font color="green"> 356.             if 'location' in member_shape.serialization or \</font>
<font color="green"> 357.                member_shape.serialization.get('eventheader'):</font>
<font color="black"> 358.                 # All members with locations have already been handled,</font>
<font color="black"> 359.                 # so we don't need to parse these members.</font>
<font color="red"> 360.                 continue</font>
<font color="green"> 361.             xml_name = self._member_key_name(member_shape, member_name)</font>
<font color="green"> 362.             member_node = xml_dict.get(xml_name)</font>
<font color="green"> 363.             if member_node is not None:</font>
<font color="green"> 364.                 parsed[member_name] = self._parse_shape(</font>
<font color="green"> 365.                     member_shape, member_node)</font>
<font color="green"> 366.             elif member_shape.serialization.get('xmlAttribute'):</font>
<font color="red"> 367.                 attribs = {}</font>
<font color="red"> 368.                 location_name = member_shape.serialization['name']</font>
<font color="red"> 369.                 for key, value in node.attrib.items():</font>
<font color="red"> 370.                     new_key = self._namespace_re.sub(</font>
<font color="red"> 371.                         location_name.split(':')[0] + ':', key)</font>
<font color="red"> 372.                     attribs[new_key] = value</font>
<font color="red"> 373.                 if location_name in attribs:</font>
<font color="red"> 374.                     parsed[member_name] = attribs[location_name]</font>
<font color="green"> 375.         return parsed</font>
<font color="black"> 376. </font>
<font color="green"> 377.     def _member_key_name(self, shape, member_name):</font>
<font color="black"> 378.         # This method is needed because we have to special case flattened list</font>
<font color="black"> 379.         # with a serialization name.  If this is the case we use the</font>
<font color="black"> 380.         # locationName from the list's member shape as the key name for the</font>
<font color="black"> 381.         # surrounding structure.</font>
<font color="green"> 382.         if shape.type_name == 'list' and shape.serialization.get('flattened'):</font>
<font color="green"> 383.             list_member_serialized_name = shape.member.serialization.get(</font>
<font color="green"> 384.                 'name')</font>
<font color="green"> 385.             if list_member_serialized_name is not None:</font>
<font color="red"> 386.                 return list_member_serialized_name</font>
<font color="green"> 387.         serialized_name = shape.serialization.get('name')</font>
<font color="green"> 388.         if serialized_name is not None:</font>
<font color="green"> 389.             return serialized_name</font>
<font color="green"> 390.         return member_name</font>
<font color="black"> 391. </font>
<font color="green"> 392.     def _build_name_to_xml_node(self, parent_node):</font>
<font color="black"> 393.         # If the parent node is actually a list. We should not be trying</font>
<font color="black"> 394.         # to serialize it to a dictionary. Instead, return the first element</font>
<font color="black"> 395.         # in the list.</font>
<font color="green"> 396.         if isinstance(parent_node, list):</font>
<font color="red"> 397.             return self._build_name_to_xml_node(parent_node[0])</font>
<font color="green"> 398.         xml_dict = {}</font>
<font color="green"> 399.         for item in parent_node:</font>
<font color="green"> 400.             key = self._node_tag(item)</font>
<font color="green"> 401.             if key in xml_dict:</font>
<font color="black"> 402.                 # If the key already exists, the most natural</font>
<font color="black"> 403.                 # way to handle this is to aggregate repeated</font>
<font color="black"> 404.                 # keys into a single list.</font>
<font color="black"> 405.                 # &lt;foo&gt;1&lt;/foo&gt;&lt;foo&gt;2&lt;/foo&gt; -&gt; {'foo': [Node(1), Node(2)]}</font>
<font color="red"> 406.                 if isinstance(xml_dict[key], list):</font>
<font color="red"> 407.                     xml_dict[key].append(item)</font>
<font color="black"> 408.                 else:</font>
<font color="black"> 409.                     # Convert from a scalar to a list.</font>
<font color="red"> 410.                     xml_dict[key] = [xml_dict[key], item]</font>
<font color="black"> 411.             else:</font>
<font color="green"> 412.                 xml_dict[key] = item</font>
<font color="green"> 413.         return xml_dict</font>
<font color="black"> 414. </font>
<font color="green"> 415.     def _parse_xml_string_to_dom(self, xml_string):</font>
<font color="green"> 416.         try:</font>
<font color="green"> 417.             parser = xml.etree.cElementTree.XMLParser(</font>
<font color="green"> 418.                 target=xml.etree.cElementTree.TreeBuilder(),</font>
<font color="green"> 419.                 encoding=self.DEFAULT_ENCODING)</font>
<font color="green"> 420.             parser.feed(xml_string)</font>
<font color="green"> 421.             root = parser.close()</font>
<font color="red"> 422.         except XMLParseError as e:</font>
<font color="red"> 423.             raise ResponseParserError(</font>
<font color="red"> 424.                 &quot;Unable to parse response (%s), &quot;</font>
<font color="red"> 425.                 &quot;invalid XML received:\n%s&quot; % (e, xml_string))</font>
<font color="green"> 426.         return root</font>
<font color="black"> 427. </font>
<font color="green"> 428.     def _replace_nodes(self, parsed):</font>
<font color="red"> 429.         for key, value in parsed.items():</font>
<font color="red"> 430.             if value.getchildren():</font>
<font color="red"> 431.                 sub_dict = self._build_name_to_xml_node(value)</font>
<font color="red"> 432.                 parsed[key] = self._replace_nodes(sub_dict)</font>
<font color="black"> 433.             else:</font>
<font color="red"> 434.                 parsed[key] = value.text</font>
<font color="red"> 435.         return parsed</font>
<font color="black"> 436. </font>
<font color="green"> 437.     @_text_content</font>
<font color="black"> 438.     def _handle_boolean(self, shape, text):</font>
<font color="red"> 439.         if text == 'true':</font>
<font color="red"> 440.             return True</font>
<font color="black"> 441.         else:</font>
<font color="red"> 442.             return False</font>
<font color="black"> 443. </font>
<font color="green"> 444.     @_text_content</font>
<font color="black"> 445.     def _handle_float(self, shape, text):</font>
<font color="red"> 446.         return float(text)</font>
<font color="black"> 447. </font>
<font color="green"> 448.     @_text_content</font>
<font color="black"> 449.     def _handle_timestamp(self, shape, text):</font>
<font color="green"> 450.         return self._timestamp_parser(text)</font>
<font color="black"> 451. </font>
<font color="green"> 452.     @_text_content</font>
<font color="black"> 453.     def _handle_integer(self, shape, text):</font>
<font color="green"> 454.         return int(text)</font>
<font color="black"> 455. </font>
<font color="green"> 456.     @_text_content</font>
<font color="black"> 457.     def _handle_string(self, shape, text):</font>
<font color="red"> 458.         return text</font>
<font color="black"> 459. </font>
<font color="green"> 460.     @_text_content</font>
<font color="black"> 461.     def _handle_blob(self, shape, text):</font>
<font color="red"> 462.         return self._blob_parser(text)</font>
<font color="black"> 463. </font>
<font color="green"> 464.     _handle_character = _handle_string</font>
<font color="green"> 465.     _handle_double = _handle_float</font>
<font color="green"> 466.     _handle_long = _handle_integer</font>
<font color="black"> 467. </font>
<font color="black"> 468. </font>
<font color="green"> 469. class QueryParser(BaseXMLResponseParser):</font>
<font color="black"> 470. </font>
<font color="green"> 471.     def _do_error_parse(self, response, shape):</font>
<font color="red"> 472.         xml_contents = response['body']</font>
<font color="red"> 473.         root = self._parse_xml_string_to_dom(xml_contents)</font>
<font color="red"> 474.         parsed = self._build_name_to_xml_node(root)</font>
<font color="red"> 475.         self._replace_nodes(parsed)</font>
<font color="black"> 476.         # Once we've converted xml-&gt;dict, we need to make one or two</font>
<font color="black"> 477.         # more adjustments to extract nested errors and to be consistent</font>
<font color="black"> 478.         # with ResponseMetadata for non-error responses:</font>
<font color="black"> 479.         # 1. {&quot;Errors&quot;: {&quot;Error&quot;: {...}}} -&gt; {&quot;Error&quot;: {...}}</font>
<font color="black"> 480.         # 2. {&quot;RequestId&quot;: &quot;id&quot;} -&gt; {&quot;ResponseMetadata&quot;: {&quot;RequestId&quot;: &quot;id&quot;}}</font>
<font color="red"> 481.         if 'Errors' in parsed:</font>
<font color="red"> 482.             parsed.update(parsed.pop('Errors'))</font>
<font color="red"> 483.         if 'RequestId' in parsed:</font>
<font color="red"> 484.             parsed['ResponseMetadata'] = {'RequestId': parsed.pop('RequestId')}</font>
<font color="red"> 485.         return parsed</font>
<font color="black"> 486. </font>
<font color="green"> 487.     def _do_parse(self, response, shape):</font>
<font color="red"> 488.         xml_contents = response['body']</font>
<font color="red"> 489.         root = self._parse_xml_string_to_dom(xml_contents)</font>
<font color="red"> 490.         parsed = {}</font>
<font color="red"> 491.         if shape is not None:</font>
<font color="red"> 492.             start = root</font>
<font color="red"> 493.             if 'resultWrapper' in shape.serialization:</font>
<font color="red"> 494.                 start = self._find_result_wrapped_shape(</font>
<font color="red"> 495.                     shape.serialization['resultWrapper'],</font>
<font color="red"> 496.                     root)</font>
<font color="red"> 497.             parsed = self._parse_shape(shape, start)</font>
<font color="red"> 498.         self._inject_response_metadata(root, parsed)</font>
<font color="red"> 499.         return parsed</font>
<font color="black"> 500. </font>
<font color="green"> 501.     def _find_result_wrapped_shape(self, element_name, xml_root_node):</font>
<font color="red"> 502.         mapping = self._build_name_to_xml_node(xml_root_node)</font>
<font color="red"> 503.         return mapping[element_name]</font>
<font color="black"> 504. </font>
<font color="green"> 505.     def _inject_response_metadata(self, node, inject_into):</font>
<font color="red"> 506.         mapping = self._build_name_to_xml_node(node)</font>
<font color="red"> 507.         child_node = mapping.get('ResponseMetadata')</font>
<font color="red"> 508.         if child_node is not None:</font>
<font color="red"> 509.             sub_mapping = self._build_name_to_xml_node(child_node)</font>
<font color="red"> 510.             for key, value in sub_mapping.items():</font>
<font color="red"> 511.                 sub_mapping[key] = value.text</font>
<font color="red"> 512.             inject_into['ResponseMetadata'] = sub_mapping</font>
<font color="black"> 513. </font>
<font color="black"> 514. </font>
<font color="green"> 515. class EC2QueryParser(QueryParser):</font>
<font color="black"> 516. </font>
<font color="green"> 517.     def _inject_response_metadata(self, node, inject_into):</font>
<font color="red"> 518.         mapping = self._build_name_to_xml_node(node)</font>
<font color="red"> 519.         child_node = mapping.get('requestId')</font>
<font color="red"> 520.         if child_node is not None:</font>
<font color="red"> 521.             inject_into['ResponseMetadata'] = {'RequestId': child_node.text}</font>
<font color="black"> 522. </font>
<font color="green"> 523.     def _do_error_parse(self, response, shape):</font>
<font color="black"> 524.         # EC2 errors look like:</font>
<font color="black"> 525.         # &lt;Response&gt;</font>
<font color="black"> 526.         #   &lt;Errors&gt;</font>
<font color="black"> 527.         #     &lt;Error&gt;</font>
<font color="black"> 528.         #       &lt;Code&gt;InvalidInstanceID.Malformed&lt;/Code&gt;</font>
<font color="black"> 529.         #       &lt;Message&gt;Invalid id: &quot;1343124&quot;&lt;/Message&gt;</font>
<font color="black"> 530.         #     &lt;/Error&gt;</font>
<font color="black"> 531.         #   &lt;/Errors&gt;</font>
<font color="black"> 532.         #   &lt;RequestID&gt;12345&lt;/RequestID&gt;</font>
<font color="black"> 533.         # &lt;/Response&gt;</font>
<font color="black"> 534.         # This is different from QueryParser in that it's RequestID,</font>
<font color="black"> 535.         # not RequestId</font>
<font color="red"> 536.         original = super(EC2QueryParser, self)._do_error_parse(response, shape)</font>
<font color="red"> 537.         original['ResponseMetadata'] = {</font>
<font color="red"> 538.             'RequestId': original.pop('RequestID')</font>
<font color="black"> 539.         }</font>
<font color="red"> 540.         return original</font>
<font color="black"> 541. </font>
<font color="black"> 542. </font>
<font color="green"> 543. class BaseJSONParser(ResponseParser):</font>
<font color="black"> 544. </font>
<font color="green"> 545.     def _handle_structure(self, shape, value):</font>
<font color="red"> 546.         member_shapes = shape.members</font>
<font color="red"> 547.         if value is None:</font>
<font color="black"> 548.             # If the comes across the wire as &quot;null&quot; (None in python),</font>
<font color="black"> 549.             # we should be returning this unchanged, instead of as an</font>
<font color="black"> 550.             # empty dict.</font>
<font color="red"> 551.             return None</font>
<font color="red"> 552.         final_parsed = {}</font>
<font color="red"> 553.         for member_name in member_shapes:</font>
<font color="red"> 554.             member_shape = member_shapes[member_name]</font>
<font color="red"> 555.             json_name = member_shape.serialization.get('name', member_name)</font>
<font color="red"> 556.             raw_value = value.get(json_name)</font>
<font color="red"> 557.             if raw_value is not None:</font>
<font color="red"> 558.                 final_parsed[member_name] = self._parse_shape(</font>
<font color="red"> 559.                     member_shapes[member_name],</font>
<font color="red"> 560.                     raw_value)</font>
<font color="red"> 561.         return final_parsed</font>
<font color="black"> 562. </font>
<font color="green"> 563.     def _handle_map(self, shape, value):</font>
<font color="red"> 564.         parsed = {}</font>
<font color="red"> 565.         key_shape = shape.key</font>
<font color="red"> 566.         value_shape = shape.value</font>
<font color="red"> 567.         for key, value in value.items():</font>
<font color="red"> 568.             actual_key = self._parse_shape(key_shape, key)</font>
<font color="red"> 569.             actual_value = self._parse_shape(value_shape, value)</font>
<font color="red"> 570.             parsed[actual_key] = actual_value</font>
<font color="red"> 571.         return parsed</font>
<font color="black"> 572. </font>
<font color="green"> 573.     def _handle_blob(self, shape, value):</font>
<font color="red"> 574.         return self._blob_parser(value)</font>
<font color="black"> 575. </font>
<font color="green"> 576.     def _handle_timestamp(self, shape, value):</font>
<font color="red"> 577.         return self._timestamp_parser(value)</font>
<font color="black"> 578. </font>
<font color="green"> 579.     def _do_error_parse(self, response, shape):</font>
<font color="red"> 580.         body = self._parse_body_as_json(response['body'])</font>
<font color="red"> 581.         error = {&quot;Error&quot;: {&quot;Message&quot;: '', &quot;Code&quot;: ''}, &quot;ResponseMetadata&quot;: {}}</font>
<font color="black"> 582.         # Error responses can have slightly different structures for json.</font>
<font color="black"> 583.         # The basic structure is:</font>
<font color="black"> 584.         #</font>
<font color="black"> 585.         # {&quot;__type&quot;:&quot;ConnectClientException&quot;,</font>
<font color="black"> 586.         #  &quot;message&quot;:&quot;The error message.&quot;}</font>
<font color="black"> 587. </font>
<font color="black"> 588.         # The error message can either come in the 'message' or 'Message' key</font>
<font color="black"> 589.         # so we need to check for both.</font>
<font color="red"> 590.         error['Error']['Message'] = body.get('message',</font>
<font color="red"> 591.                                              body.get('Message', ''))</font>
<font color="black"> 592.         # if the message did not contain an error code</font>
<font color="black"> 593.         # include the response status code</font>
<font color="red"> 594.         response_code = response.get('status_code')</font>
<font color="red"> 595.         code = body.get('__type', response_code and str(response_code))</font>
<font color="red"> 596.         if code is not None:</font>
<font color="black"> 597.             # code has a couple forms as well:</font>
<font color="black"> 598.             # * &quot;com.aws.dynamodb.vAPI#ProvisionedThroughputExceededException&quot;</font>
<font color="black"> 599.             # * &quot;ResourceNotFoundException&quot;</font>
<font color="red"> 600.             if '#' in code:</font>
<font color="red"> 601.                 code = code.rsplit('#', 1)[1]</font>
<font color="red"> 602.             error['Error']['Code'] = code</font>
<font color="red"> 603.         self._inject_response_metadata(error, response['headers'])</font>
<font color="red"> 604.         return error</font>
<font color="black"> 605. </font>
<font color="green"> 606.     def _inject_response_metadata(self, parsed, headers):</font>
<font color="red"> 607.         if 'x-amzn-requestid' in headers:</font>
<font color="black"> 608.             parsed.setdefault('ResponseMetadata', {})['RequestId'] = (</font>
<font color="red"> 609.                 headers['x-amzn-requestid'])</font>
<font color="black"> 610. </font>
<font color="green"> 611.     def _parse_body_as_json(self, body_contents):</font>
<font color="red"> 612.         if not body_contents:</font>
<font color="red"> 613.             return {}</font>
<font color="red"> 614.         body = body_contents.decode(self.DEFAULT_ENCODING)</font>
<font color="red"> 615.         try:</font>
<font color="red"> 616.             original_parsed = json.loads(body)</font>
<font color="red"> 617.             return original_parsed</font>
<font color="red"> 618.         except ValueError:</font>
<font color="black"> 619.             # if the body cannot be parsed, include</font>
<font color="black"> 620.             # the literal string as the message</font>
<font color="red"> 621.             return { 'message': body }</font>
<font color="black"> 622. </font>
<font color="black"> 623. </font>
<font color="green"> 624. class JSONParser(BaseJSONParser):</font>
<font color="green"> 625.     &quot;&quot;&quot;Response parse for the &quot;json&quot; protocol.&quot;&quot;&quot;</font>
<font color="green"> 626.     def _do_parse(self, response, shape):</font>
<font color="black"> 627.         # The json.loads() gives us the primitive JSON types,</font>
<font color="black"> 628.         # but we need to traverse the parsed JSON data to convert</font>
<font color="black"> 629.         # to richer types (blobs, timestamps, etc.</font>
<font color="red"> 630.         parsed = {}</font>
<font color="red"> 631.         if shape is not None:</font>
<font color="red"> 632.             original_parsed = self._parse_body_as_json(response['body'])</font>
<font color="red"> 633.             parsed = self._parse_shape(shape, original_parsed)</font>
<font color="red"> 634.         self._inject_response_metadata(parsed, response['headers'])</font>
<font color="red"> 635.         return parsed</font>
<font color="black"> 636. </font>
<font color="black"> 637. </font>
<font color="green"> 638. class BaseEventStreamParser(ResponseParser):</font>
<font color="black"> 639. </font>
<font color="green"> 640.     def _do_parse(self, response, shape):</font>
<font color="red"> 641.         final_parsed = {}</font>
<font color="red"> 642.         if shape.serialization.get('eventstream'):</font>
<font color="red"> 643.             event_type = response['headers'].get(':event-type')</font>
<font color="red"> 644.             event_shape = shape.members.get(event_type)</font>
<font color="red"> 645.             if event_shape:</font>
<font color="red"> 646.                 final_parsed[event_type] = self._do_parse(response, event_shape)</font>
<font color="black"> 647.         else:</font>
<font color="red"> 648.             self._parse_non_payload_attrs(response, shape,</font>
<font color="red"> 649.                                           shape.members, final_parsed)</font>
<font color="red"> 650.             self._parse_payload(response, shape, shape.members, final_parsed)</font>
<font color="red"> 651.         return final_parsed</font>
<font color="black"> 652. </font>
<font color="green"> 653.     def _do_error_parse(self, response, shape):</font>
<font color="red"> 654.         error = {</font>
<font color="red"> 655.             'Error': {</font>
<font color="red"> 656.                 'Code': response['headers'].get(':error-code', ''),</font>
<font color="red"> 657.                 'Message': response['headers'].get(':error-message', ''),</font>
<font color="black"> 658.             }</font>
<font color="black"> 659.         }</font>
<font color="red"> 660.         return error</font>
<font color="black"> 661. </font>
<font color="green"> 662.     def _parse_payload(self, response, shape, member_shapes, final_parsed):</font>
<font color="red"> 663.         if shape.serialization.get('event'):</font>
<font color="red"> 664.             for name in member_shapes:</font>
<font color="red"> 665.                 member_shape = member_shapes[name]</font>
<font color="red"> 666.                 if member_shape.serialization.get('eventpayload'):</font>
<font color="red"> 667.                     body = response['body']</font>
<font color="red"> 668.                     if member_shape.type_name == 'blob':</font>
<font color="red"> 669.                         parsed_body = body</font>
<font color="red"> 670.                     elif member_shape.type_name == 'string':</font>
<font color="red"> 671.                         parsed_body = body.decode(self.DEFAULT_ENCODING)</font>
<font color="black"> 672.                     else:</font>
<font color="red"> 673.                         raw_parse = self._initial_body_parse(body)</font>
<font color="red"> 674.                         parsed_body = self._parse_shape(member_shape, raw_parse)</font>
<font color="red"> 675.                     final_parsed[name] = parsed_body</font>
<font color="red"> 676.                     return</font>
<font color="black"> 677.             # If we didn't find an explicit payload, use the current shape</font>
<font color="red"> 678.             original_parsed = self._initial_body_parse(response['body'])</font>
<font color="red"> 679.             body_parsed = self._parse_shape(shape, original_parsed)</font>
<font color="red"> 680.             final_parsed.update(body_parsed)</font>
<font color="black"> 681. </font>
<font color="green"> 682.     def _parse_non_payload_attrs(self, response, shape,</font>
<font color="black"> 683.                                  member_shapes, final_parsed):</font>
<font color="red"> 684.         headers = response['headers']</font>
<font color="red"> 685.         for name in member_shapes:</font>
<font color="red"> 686.             member_shape = member_shapes[name]</font>
<font color="red"> 687.             if member_shape.serialization.get('eventheader'):</font>
<font color="red"> 688.                 if name in headers:</font>
<font color="red"> 689.                     value = headers[name]</font>
<font color="red"> 690.                     if member_shape.type_name == 'timestamp':</font>
<font color="black"> 691.                         # Event stream timestamps are an in milleseconds so we</font>
<font color="black"> 692.                         # divide by 1000 to convert to seconds.</font>
<font color="red"> 693.                         value = self._timestamp_parser(value / 1000.0)</font>
<font color="red"> 694.                     final_parsed[name] = value</font>
<font color="black"> 695. </font>
<font color="green"> 696.     def _initial_body_parse(self, body_contents):</font>
<font color="black"> 697.         # This method should do the initial xml/json parsing of the</font>
<font color="black"> 698.         # body.  We we still need to walk the parsed body in order</font>
<font color="black"> 699.         # to convert types, but this method will do the first round</font>
<font color="black"> 700.         # of parsing.</font>
<font color="red"> 701.         raise NotImplementedError(&quot;_initial_body_parse&quot;)</font>
<font color="black"> 702. </font>
<font color="black"> 703. </font>
<font color="green"> 704. class EventStreamJSONParser(BaseEventStreamParser, BaseJSONParser):</font>
<font color="black"> 705. </font>
<font color="green"> 706.     def _initial_body_parse(self, body_contents):</font>
<font color="red"> 707.         return self._parse_body_as_json(body_contents)</font>
<font color="black"> 708. </font>
<font color="black"> 709. </font>
<font color="green"> 710. class EventStreamXMLParser(BaseEventStreamParser, BaseXMLResponseParser):</font>
<font color="black"> 711. </font>
<font color="green"> 712.     def _initial_body_parse(self, xml_string):</font>
<font color="red"> 713.         if not xml_string:</font>
<font color="red"> 714.             return xml.etree.cElementTree.Element('')</font>
<font color="red"> 715.         return self._parse_xml_string_to_dom(xml_string)</font>
<font color="black"> 716. </font>
<font color="black"> 717. </font>
<font color="green"> 718. class BaseRestParser(ResponseParser):</font>
<font color="black"> 719. </font>
<font color="green"> 720.     def _do_parse(self, response, shape):</font>
<font color="green"> 721.         final_parsed = {}</font>
<font color="green"> 722.         final_parsed['ResponseMetadata'] = self._populate_response_metadata(</font>
<font color="green"> 723.             response)</font>
<font color="green"> 724.         if shape is None:</font>
<font color="green"> 725.             return final_parsed</font>
<font color="green"> 726.         member_shapes = shape.members</font>
<font color="green"> 727.         self._parse_non_payload_attrs(response, shape,</font>
<font color="green"> 728.                                       member_shapes, final_parsed)</font>
<font color="green"> 729.         self._parse_payload(response, shape, member_shapes, final_parsed)</font>
<font color="green"> 730.         return final_parsed</font>
<font color="black"> 731. </font>
<font color="green"> 732.     def _populate_response_metadata(self, response):</font>
<font color="green"> 733.         metadata = {}</font>
<font color="green"> 734.         headers = response['headers']</font>
<font color="green"> 735.         if 'x-amzn-requestid' in headers:</font>
<font color="red"> 736.             metadata['RequestId'] = headers['x-amzn-requestid']</font>
<font color="green"> 737.         elif 'x-amz-request-id' in headers:</font>
<font color="green"> 738.             metadata['RequestId'] = headers['x-amz-request-id']</font>
<font color="black"> 739.             # HostId is what it's called whenver this value is returned</font>
<font color="black"> 740.             # in an XML response body, so to be consistent, we'll always</font>
<font color="black"> 741.             # call is HostId.</font>
<font color="green"> 742.             metadata['HostId'] = headers.get('x-amz-id-2', '')</font>
<font color="green"> 743.         return metadata</font>
<font color="black"> 744. </font>
<font color="green"> 745.     def _parse_payload(self, response, shape, member_shapes, final_parsed):</font>
<font color="green"> 746.         if 'payload' in shape.serialization:</font>
<font color="black"> 747.             # If a payload is specified in the output shape, then only that</font>
<font color="black"> 748.             # shape is used for the body payload.</font>
<font color="red"> 749.             payload_member_name = shape.serialization['payload']</font>
<font color="red"> 750.             body_shape = member_shapes[payload_member_name]</font>
<font color="red"> 751.             if body_shape.serialization.get('eventstream'):</font>
<font color="red"> 752.                 parser = self._event_stream_parser</font>
<font color="red"> 753.                 name = response['context'].get('operation_name')</font>
<font color="red"> 754.                 body = EventStream(response['body'], body_shape, parser, name)</font>
<font color="red"> 755.                 final_parsed[payload_member_name] = body</font>
<font color="red"> 756.             elif body_shape.type_name in ['string', 'blob']:</font>
<font color="black"> 757.                 # This is a stream</font>
<font color="red"> 758.                 body = response['body']</font>
<font color="red"> 759.                 if isinstance(body, bytes):</font>
<font color="red"> 760.                     body = body.decode(self.DEFAULT_ENCODING)</font>
<font color="red"> 761.                 final_parsed[payload_member_name] = body</font>
<font color="black"> 762.             else:</font>
<font color="red"> 763.                 original_parsed = self._initial_body_parse(response['body'])</font>
<font color="red"> 764.                 final_parsed[payload_member_name] = self._parse_shape(</font>
<font color="red"> 765.                     body_shape, original_parsed)</font>
<font color="black"> 766.         else:</font>
<font color="green"> 767.             original_parsed = self._initial_body_parse(response['body'])</font>
<font color="green"> 768.             body_parsed = self._parse_shape(shape, original_parsed)</font>
<font color="green"> 769.             final_parsed.update(body_parsed)</font>
<font color="black"> 770. </font>
<font color="green"> 771.     def _parse_non_payload_attrs(self, response, shape,</font>
<font color="black"> 772.                                  member_shapes, final_parsed):</font>
<font color="green"> 773.         headers = response['headers']</font>
<font color="green"> 774.         for name in member_shapes:</font>
<font color="green"> 775.             member_shape = member_shapes[name]</font>
<font color="green"> 776.             location = member_shape.serialization.get('location')</font>
<font color="green"> 777.             if location is None:</font>
<font color="green"> 778.                 continue</font>
<font color="red"> 779.             elif location == 'statusCode':</font>
<font color="red"> 780.                 final_parsed[name] = self._parse_shape(</font>
<font color="red"> 781.                     member_shape, response['status_code'])</font>
<font color="red"> 782.             elif location == 'headers':</font>
<font color="red"> 783.                 final_parsed[name] = self._parse_header_map(member_shape,</font>
<font color="red"> 784.                                                             headers)</font>
<font color="red"> 785.             elif location == 'header':</font>
<font color="red"> 786.                 header_name = member_shape.serialization.get('name', name)</font>
<font color="red"> 787.                 if header_name in headers:</font>
<font color="red"> 788.                     final_parsed[name] = self._parse_shape(</font>
<font color="red"> 789.                         member_shape, headers[header_name])</font>
<font color="black"> 790. </font>
<font color="green"> 791.     def _parse_header_map(self, shape, headers):</font>
<font color="black"> 792.         # Note that headers are case insensitive, so we .lower()</font>
<font color="black"> 793.         # all header names and header prefixes.</font>
<font color="red"> 794.         parsed = {}</font>
<font color="red"> 795.         prefix = shape.serialization.get('name', '').lower()</font>
<font color="red"> 796.         for header_name in headers:</font>
<font color="red"> 797.             if header_name.lower().startswith(prefix):</font>
<font color="black"> 798.                 # The key name inserted into the parsed hash</font>
<font color="black"> 799.                 # strips off the prefix.</font>
<font color="red"> 800.                 name = header_name[len(prefix):]</font>
<font color="red"> 801.                 parsed[name] = headers[header_name]</font>
<font color="red"> 802.         return parsed</font>
<font color="black"> 803. </font>
<font color="green"> 804.     def _initial_body_parse(self, body_contents):</font>
<font color="black"> 805.         # This method should do the initial xml/json parsing of the</font>
<font color="black"> 806.         # body.  We we still need to walk the parsed body in order</font>
<font color="black"> 807.         # to convert types, but this method will do the first round</font>
<font color="black"> 808.         # of parsing.</font>
<font color="red"> 809.         raise NotImplementedError(&quot;_initial_body_parse&quot;)</font>
<font color="black"> 810. </font>
<font color="green"> 811.     def _handle_string(self, shape, value):</font>
<font color="green"> 812.         parsed = value</font>
<font color="green"> 813.         if is_json_value_header(shape):</font>
<font color="red"> 814.             decoded = base64.b64decode(value).decode(self.DEFAULT_ENCODING)</font>
<font color="red"> 815.             parsed = json.loads(decoded)</font>
<font color="green"> 816.         return parsed</font>
<font color="black"> 817. </font>
<font color="black"> 818. </font>
<font color="green"> 819. class RestJSONParser(BaseRestParser, BaseJSONParser):</font>
<font color="black"> 820. </font>
<font color="green"> 821.     EVENT_STREAM_PARSER_CLS = EventStreamJSONParser</font>
<font color="black"> 822. </font>
<font color="green"> 823.     def _initial_body_parse(self, body_contents):</font>
<font color="red"> 824.         return self._parse_body_as_json(body_contents)</font>
<font color="black"> 825. </font>
<font color="green"> 826.     def _do_error_parse(self, response, shape):</font>
<font color="red"> 827.         error = super(RestJSONParser, self)._do_error_parse(response, shape)</font>
<font color="red"> 828.         self._inject_error_code(error, response)</font>
<font color="red"> 829.         return error</font>
<font color="black"> 830. </font>
<font color="green"> 831.     def _inject_error_code(self, error, response):</font>
<font color="black"> 832.         # The &quot;Code&quot; value can come from either a response</font>
<font color="black"> 833.         # header or a value in the JSON body.</font>
<font color="red"> 834.         body = self._initial_body_parse(response['body'])</font>
<font color="red"> 835.         if 'x-amzn-errortype' in response['headers']:</font>
<font color="red"> 836.             code = response['headers']['x-amzn-errortype']</font>
<font color="black"> 837.             # Could be:</font>
<font color="black"> 838.             # x-amzn-errortype: ValidationException:</font>
<font color="red"> 839.             code = code.split(':')[0]</font>
<font color="red"> 840.             error['Error']['Code'] = code</font>
<font color="red"> 841.         elif 'code' in body or 'Code' in body:</font>
<font color="red"> 842.             error['Error']['Code'] = body.get(</font>
<font color="red"> 843.                 'code', body.get('Code', ''))</font>
<font color="black"> 844. </font>
<font color="black"> 845. </font>
<font color="green"> 846. class RestXMLParser(BaseRestParser, BaseXMLResponseParser):</font>
<font color="black"> 847. </font>
<font color="green"> 848.     EVENT_STREAM_PARSER_CLS = EventStreamXMLParser</font>
<font color="black"> 849. </font>
<font color="green"> 850.     def _initial_body_parse(self, xml_string):</font>
<font color="green"> 851.         if not xml_string:</font>
<font color="red"> 852.             return xml.etree.cElementTree.Element('')</font>
<font color="green"> 853.         return self._parse_xml_string_to_dom(xml_string)</font>
<font color="black"> 854. </font>
<font color="green"> 855.     def _do_error_parse(self, response, shape):</font>
<font color="black"> 856.         # We're trying to be service agnostic here, but S3 does have a slightly</font>
<font color="black"> 857.         # different response structure for its errors compared to other</font>
<font color="black"> 858.         # rest-xml serivces (route53/cloudfront).  We handle this by just</font>
<font color="black"> 859.         # trying to parse both forms.</font>
<font color="black"> 860.         # First:</font>
<font color="black"> 861.         # &lt;ErrorResponse xmlns=&quot;...&quot;&gt;</font>
<font color="black"> 862.         #   &lt;Error&gt;</font>
<font color="black"> 863.         #     &lt;Type&gt;Sender&lt;/Type&gt;</font>
<font color="black"> 864.         #     &lt;Code&gt;InvalidInput&lt;/Code&gt;</font>
<font color="black"> 865.         #     &lt;Message&gt;Invalid resource type: foo&lt;/Message&gt;</font>
<font color="black"> 866.         #   &lt;/Error&gt;</font>
<font color="black"> 867.         #   &lt;RequestId&gt;request-id&lt;/RequestId&gt;</font>
<font color="black"> 868.         # &lt;/ErrorResponse&gt;</font>
<font color="red"> 869.         if response['body']:</font>
<font color="black"> 870.             # If the body ends up being invalid xml, the xml parser should not</font>
<font color="black"> 871.             # blow up. It should at least try to pull information about the</font>
<font color="black"> 872.             # the error response from other sources like the HTTP status code.</font>
<font color="red"> 873.             try:</font>
<font color="red"> 874.                 return self._parse_error_from_body(response)</font>
<font color="red"> 875.             except ResponseParserError as e:</font>
<font color="red"> 876.                 LOG.debug(</font>
<font color="red"> 877.                     'Exception caught when parsing error response body:',</font>
<font color="red"> 878.                     exc_info=True)</font>
<font color="red"> 879.         return self._parse_error_from_http_status(response)</font>
<font color="black"> 880. </font>
<font color="green"> 881.     def _parse_error_from_http_status(self, response):</font>
<font color="red"> 882.         return {</font>
<font color="red"> 883.             'Error': {</font>
<font color="red"> 884.                 'Code': str(response['status_code']),</font>
<font color="red"> 885.                 'Message': six.moves.http_client.responses.get(</font>
<font color="red"> 886.                     response['status_code'], ''),</font>
<font color="black"> 887.             },</font>
<font color="red"> 888.             'ResponseMetadata': {</font>
<font color="red"> 889.                 'RequestId': response['headers'].get('x-amz-request-id', ''),</font>
<font color="red"> 890.                 'HostId': response['headers'].get('x-amz-id-2', ''),</font>
<font color="black"> 891.             }</font>
<font color="black"> 892.         }</font>
<font color="black"> 893. </font>
<font color="green"> 894.     def _parse_error_from_body(self, response):</font>
<font color="red"> 895.         xml_contents = response['body']</font>
<font color="red"> 896.         root = self._parse_xml_string_to_dom(xml_contents)</font>
<font color="red"> 897.         parsed = self._build_name_to_xml_node(root)</font>
<font color="red"> 898.         self._replace_nodes(parsed)</font>
<font color="red"> 899.         if root.tag == 'Error':</font>
<font color="black"> 900.             # This is an S3 error response.  First we'll populate the</font>
<font color="black"> 901.             # response metadata.</font>
<font color="red"> 902.             metadata = self._populate_response_metadata(response)</font>
<font color="black"> 903.             # The RequestId and the HostId are already in the</font>
<font color="black"> 904.             # ResponseMetadata, but are also duplicated in the XML</font>
<font color="black"> 905.             # body.  We don't need these values in both places,</font>
<font color="black"> 906.             # we'll just remove them from the parsed XML body.</font>
<font color="red"> 907.             parsed.pop('RequestId', '')</font>
<font color="red"> 908.             parsed.pop('HostId', '')</font>
<font color="red"> 909.             return {'Error': parsed, 'ResponseMetadata': metadata}</font>
<font color="red"> 910.         elif 'RequestId' in parsed:</font>
<font color="black"> 911.             # Other rest-xml serivces:</font>
<font color="red"> 912.             parsed['ResponseMetadata'] = {'RequestId': parsed.pop('RequestId')}</font>
<font color="red"> 913.         default = {'Error': {'Message': '', 'Code': ''}}</font>
<font color="red"> 914.         merge_dicts(default, parsed)</font>
<font color="red"> 915.         return default</font>
<font color="black"> 916. </font>
<font color="green"> 917.     @_text_content</font>
<font color="black"> 918.     def _handle_string(self, shape, text):</font>
<font color="green"> 919.         text = super(RestXMLParser, self)._handle_string(shape, text)</font>
<font color="green"> 920.         return text</font>
<font color="black"> 921. </font>
<font color="black"> 922. </font>
<font color="green"> 923. PROTOCOL_PARSERS = {</font>
<font color="green"> 924.     'ec2': EC2QueryParser,</font>
<font color="green"> 925.     'query': QueryParser,</font>
<font color="green"> 926.     'json': JSONParser,</font>
<font color="green"> 927.     'rest-json': RestJSONParser,</font>
<font color="green"> 928.     'rest-xml': RestXMLParser,</font>
<font color="black"> 929. }</font>
</pre>

