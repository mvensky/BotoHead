source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/s3transfer/bandwidth.py</b><br>


file stats: <b>166 lines, 46 executed: 27.7% covered</b>
<pre>
<font color="black">   1. # Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="green">  13. import time</font>
<font color="green">  14. import threading</font>
<font color="black">  15. </font>
<font color="black">  16. </font>
<font color="green">  17. class RequestExceededException(Exception):</font>
<font color="green">  18.     def __init__(self, requested_amt, retry_time):</font>
<font color="black">  19.         &quot;&quot;&quot;Error when requested amount exceeds what is allowed</font>
<font color="black">  20. </font>
<font color="black">  21.         The request that raised this error should be retried after waiting</font>
<font color="black">  22.         the time specified by ``retry_time``.</font>
<font color="black">  23. </font>
<font color="black">  24.         :type requested_amt: int</font>
<font color="black">  25.         :param requested_amt: The originally requested byte amount</font>
<font color="black">  26. </font>
<font color="black">  27.         :type retry_time: float</font>
<font color="black">  28.         :param retry_time: The length in time to wait to retry for the</font>
<font color="black">  29.             requested amount</font>
<font color="black">  30.         &quot;&quot;&quot;</font>
<font color="red">  31.         self.requested_amt = requested_amt</font>
<font color="red">  32.         self.retry_time = retry_time</font>
<font color="black">  33.         msg = (</font>
<font color="red">  34.             'Request amount %s exceeded the amount available. Retry in %s' % (</font>
<font color="red">  35.                 requested_amt, retry_time)</font>
<font color="black">  36.         )</font>
<font color="red">  37.         super(RequestExceededException, self).__init__(msg)</font>
<font color="black">  38. </font>
<font color="black">  39. </font>
<font color="green">  40. class RequestToken(object):</font>
<font color="green">  41.     &quot;&quot;&quot;A token to pass as an identifier when consuming from the LeakyBucket&quot;&quot;&quot;</font>
<font color="green">  42.     pass</font>
<font color="black">  43. </font>
<font color="black">  44. </font>
<font color="green">  45. class TimeUtils(object):</font>
<font color="green">  46.     def time(self):</font>
<font color="black">  47.         &quot;&quot;&quot;Get the current time back</font>
<font color="black">  48. </font>
<font color="black">  49.         :rtype: float</font>
<font color="black">  50.         :returns: The current time in seconds</font>
<font color="black">  51.         &quot;&quot;&quot;</font>
<font color="red">  52.         return time.time()</font>
<font color="black">  53. </font>
<font color="green">  54.     def sleep(self, value):</font>
<font color="black">  55.         &quot;&quot;&quot;Sleep for a designated time</font>
<font color="black">  56. </font>
<font color="black">  57.         :type value: float</font>
<font color="black">  58.         :param value: The time to sleep for in seconds</font>
<font color="black">  59.         &quot;&quot;&quot;</font>
<font color="red">  60.         return time.sleep(value)</font>
<font color="black">  61. </font>
<font color="black">  62. </font>
<font color="green">  63. class BandwidthLimiter(object):</font>
<font color="green">  64.     def __init__(self, leaky_bucket, time_utils=None):</font>
<font color="black">  65.         &quot;&quot;&quot;Limits bandwidth for shared S3 transfers</font>
<font color="black">  66. </font>
<font color="black">  67.         :type leaky_bucket: LeakyBucket</font>
<font color="black">  68.         :param leaky_bucket: The leaky bucket to use limit bandwidth</font>
<font color="black">  69. </font>
<font color="black">  70.         :type time_utils: TimeUtils</font>
<font color="black">  71.         :param time_utils: Time utility to use for interacting with time.</font>
<font color="black">  72.         &quot;&quot;&quot;</font>
<font color="red">  73.         self._leaky_bucket = leaky_bucket</font>
<font color="red">  74.         self._time_utils = time_utils</font>
<font color="red">  75.         if time_utils is None:</font>
<font color="red">  76.             self._time_utils = TimeUtils()</font>
<font color="black">  77. </font>
<font color="black">  78.     def get_bandwith_limited_stream(self, fileobj, transfer_coordinator,</font>
<font color="green">  79.                                     enabled=True):</font>
<font color="black">  80.         &quot;&quot;&quot;Wraps a fileobj in a bandwidth limited stream wrapper</font>
<font color="black">  81. </font>
<font color="black">  82.         :type fileobj: file-like obj</font>
<font color="black">  83.         :param fileobj: The file-like obj to wrap</font>
<font color="black">  84. </font>
<font color="black">  85.         :type transfer_coordinator: s3transfer.futures.TransferCoordinator</font>
<font color="black">  86.         param transfer_coordinator: The coordinator for the general transfer</font>
<font color="black">  87.             that the wrapped stream is a part of</font>
<font color="black">  88. </font>
<font color="black">  89.         :type enabled: boolean</font>
<font color="black">  90.         :param enabled: Whether bandwidth limiting should be enabled to start</font>
<font color="black">  91.         &quot;&quot;&quot;</font>
<font color="red">  92.         stream = BandwidthLimitedStream(</font>
<font color="red">  93.             fileobj, self._leaky_bucket, transfer_coordinator,</font>
<font color="red">  94.             self._time_utils)</font>
<font color="red">  95.         if not enabled:</font>
<font color="red">  96.             stream.disable_bandwidth_limiting()</font>
<font color="red">  97.         return stream</font>
<font color="black">  98. </font>
<font color="black">  99. </font>
<font color="green"> 100. class BandwidthLimitedStream(object):</font>
<font color="black"> 101.     def __init__(self, fileobj, leaky_bucket, transfer_coordinator,</font>
<font color="green"> 102.                  time_utils=None, bytes_threshold=256 * 1024):</font>
<font color="black"> 103.         &quot;&quot;&quot;Limits bandwidth for reads on a wrapped stream</font>
<font color="black"> 104. </font>
<font color="black"> 105.         :type fileobj: file-like object</font>
<font color="black"> 106.         :param fileobj: The file like object to wrap</font>
<font color="black"> 107. </font>
<font color="black"> 108.         :type leaky_bucket: LeakyBucket</font>
<font color="black"> 109.         :param leaky_bucket: The leaky bucket to use to throttle reads on</font>
<font color="black"> 110.             the stream</font>
<font color="black"> 111. </font>
<font color="black"> 112.         :type transfer_coordinator: s3transfer.futures.TransferCoordinator</font>
<font color="black"> 113.         param transfer_coordinator: The coordinator for the general transfer</font>
<font color="black"> 114.             that the wrapped stream is a part of</font>
<font color="black"> 115. </font>
<font color="black"> 116.         :type time_utils: TimeUtils</font>
<font color="black"> 117.         :param time_utils: The time utility to use for interacting with time</font>
<font color="black"> 118.         &quot;&quot;&quot;</font>
<font color="red"> 119.         self._fileobj = fileobj</font>
<font color="red"> 120.         self._leaky_bucket = leaky_bucket</font>
<font color="red"> 121.         self._transfer_coordinator = transfer_coordinator</font>
<font color="red"> 122.         self._time_utils = time_utils</font>
<font color="red"> 123.         if time_utils is None:</font>
<font color="red"> 124.             self._time_utils = TimeUtils()</font>
<font color="red"> 125.         self._bandwidth_limiting_enabled = True</font>
<font color="red"> 126.         self._request_token = RequestToken()</font>
<font color="red"> 127.         self._bytes_seen = 0</font>
<font color="red"> 128.         self._bytes_threshold = bytes_threshold</font>
<font color="black"> 129. </font>
<font color="green"> 130.     def enable_bandwidth_limiting(self):</font>
<font color="black"> 131.         &quot;&quot;&quot;Enable bandwidth limiting on reads to the stream&quot;&quot;&quot;</font>
<font color="red"> 132.         self._bandwidth_limiting_enabled = True</font>
<font color="black"> 133. </font>
<font color="green"> 134.     def disable_bandwidth_limiting(self):</font>
<font color="black"> 135.         &quot;&quot;&quot;Disable bandwidth limiting on reads to the stream&quot;&quot;&quot;</font>
<font color="red"> 136.         self._bandwidth_limiting_enabled = False</font>
<font color="black"> 137. </font>
<font color="green"> 138.     def read(self, amount):</font>
<font color="black"> 139.         &quot;&quot;&quot;Read a specified amount</font>
<font color="black"> 140. </font>
<font color="black"> 141.         Reads will only be throttled if bandwidth limiting is enabled.</font>
<font color="black"> 142.         &quot;&quot;&quot;</font>
<font color="red"> 143.         if not self._bandwidth_limiting_enabled:</font>
<font color="red"> 144.             return self._fileobj.read(amount)</font>
<font color="black"> 145. </font>
<font color="black"> 146.         # We do not want to be calling consume on every read as the read</font>
<font color="black"> 147.         # amounts can be small causing the lock of the leaky bucket to</font>
<font color="black"> 148.         # introduce noticeable overhead. So instead we keep track of</font>
<font color="black"> 149.         # how many bytes we have seen and only call consume once we pass a</font>
<font color="black"> 150.         # certain threshold.</font>
<font color="red"> 151.         self._bytes_seen += amount</font>
<font color="red"> 152.         if self._bytes_seen &lt; self._bytes_threshold:</font>
<font color="red"> 153.             return self._fileobj.read(amount)</font>
<font color="black"> 154. </font>
<font color="red"> 155.         self._consume_through_leaky_bucket()</font>
<font color="red"> 156.         return self._fileobj.read(amount)</font>
<font color="black"> 157. </font>
<font color="green"> 158.     def _consume_through_leaky_bucket(self):</font>
<font color="black"> 159.         # NOTE: If the read amonut on the stream are high, it will result</font>
<font color="black"> 160.         # in large bursty behavior as there is not an interface for partial</font>
<font color="black"> 161.         # reads. However given the read's on this abstraction are at most 256KB</font>
<font color="black"> 162.         # (via downloads), it reduces the burstiness to be small KB bursts at</font>
<font color="black"> 163.         # worst.</font>
<font color="red"> 164.         while not self._transfer_coordinator.exception:</font>
<font color="red"> 165.             try:</font>
<font color="red"> 166.                 self._leaky_bucket.consume(</font>
<font color="red"> 167.                     self._bytes_seen, self._request_token)</font>
<font color="red"> 168.                 self._bytes_seen = 0</font>
<font color="red"> 169.                 return</font>
<font color="red"> 170.             except RequestExceededException as e:</font>
<font color="red"> 171.                 self._time_utils.sleep(e.retry_time)</font>
<font color="black"> 172.         else:</font>
<font color="red"> 173.             raise self._transfer_coordinator.exception</font>
<font color="black"> 174. </font>
<font color="green"> 175.     def signal_transferring(self):</font>
<font color="black"> 176.         &quot;&quot;&quot;Signal that data being read is being transferred to S3&quot;&quot;&quot;</font>
<font color="red"> 177.         self.enable_bandwidth_limiting()</font>
<font color="black"> 178. </font>
<font color="green"> 179.     def signal_not_transferring(self):</font>
<font color="black"> 180.         &quot;&quot;&quot;Signal that data being read is not being transferred to S3&quot;&quot;&quot;</font>
<font color="red"> 181.         self.disable_bandwidth_limiting()</font>
<font color="black"> 182. </font>
<font color="green"> 183.     def seek(self, where):</font>
<font color="red"> 184.         self._fileobj.seek(where)</font>
<font color="black"> 185. </font>
<font color="green"> 186.     def tell(self):</font>
<font color="red"> 187.         return self._fileobj.tell()</font>
<font color="black"> 188. </font>
<font color="green"> 189.     def close(self):</font>
<font color="red"> 190.         if self._bandwidth_limiting_enabled and self._bytes_seen:</font>
<font color="black"> 191.             # This handles the case where the file is small enough to never</font>
<font color="black"> 192.             # trigger the threshold and thus is never subjugated to the</font>
<font color="black"> 193.             # leaky bucket on read(). This specifically happens for small</font>
<font color="black"> 194.             # uploads. So instead to account for those bytes, have</font>
<font color="black"> 195.             # it go through the leaky bucket when the file gets closed.</font>
<font color="red"> 196.             self._consume_through_leaky_bucket()</font>
<font color="red"> 197.         self._fileobj.close()</font>
<font color="black"> 198. </font>
<font color="green"> 199.     def __enter__(self):</font>
<font color="red"> 200.         return self</font>
<font color="black"> 201. </font>
<font color="green"> 202.     def __exit__(self, *args, **kwargs):</font>
<font color="red"> 203.         self.close()</font>
<font color="black"> 204. </font>
<font color="black"> 205. </font>
<font color="green"> 206. class LeakyBucket(object):</font>
<font color="green"> 207.     def __init__(self, max_rate, time_utils=None, rate_tracker=None,</font>
<font color="green"> 208.                  consumption_scheduler=None):</font>
<font color="black"> 209.         &quot;&quot;&quot;A leaky bucket abstraction to limit bandwidth consumption</font>
<font color="black"> 210. </font>
<font color="black"> 211.         :type rate: int</font>
<font color="black"> 212.         :type rate: The maximum rate to allow. This rate is in terms of</font>
<font color="black"> 213.             bytes per second.</font>
<font color="black"> 214. </font>
<font color="black"> 215.         :type time_utils: TimeUtils</font>
<font color="black"> 216.         :param time_utils: The time utility to use for interacting with time</font>
<font color="black"> 217. </font>
<font color="black"> 218.         :type rate_tracker: BandwidthRateTracker</font>
<font color="black"> 219.         :param rate_tracker: Tracks bandwidth consumption</font>
<font color="black"> 220. </font>
<font color="black"> 221.         :type consumption_scheduler: ConsumptionScheduler</font>
<font color="black"> 222.         :param consumption_scheduler: Schedules consumption retries when</font>
<font color="black"> 223.             necessary</font>
<font color="black"> 224.         &quot;&quot;&quot;</font>
<font color="red"> 225.         self._max_rate = float(max_rate)</font>
<font color="red"> 226.         self._time_utils = time_utils</font>
<font color="red"> 227.         if time_utils is None:</font>
<font color="red"> 228.             self._time_utils = TimeUtils()</font>
<font color="red"> 229.         self._lock = threading.Lock()</font>
<font color="red"> 230.         self._rate_tracker = rate_tracker</font>
<font color="red"> 231.         if rate_tracker is None:</font>
<font color="red"> 232.             self._rate_tracker = BandwidthRateTracker()</font>
<font color="red"> 233.         self._consumption_scheduler = consumption_scheduler</font>
<font color="red"> 234.         if consumption_scheduler is None:</font>
<font color="red"> 235.             self._consumption_scheduler = ConsumptionScheduler()</font>
<font color="black"> 236. </font>
<font color="green"> 237.     def consume(self, amt, request_token):</font>
<font color="black"> 238.         &quot;&quot;&quot;Consume an a requested amount</font>
<font color="black"> 239. </font>
<font color="black"> 240.         :type amt: int</font>
<font color="black"> 241.         :param amt: The amount of bytes to request to consume</font>
<font color="black"> 242. </font>
<font color="black"> 243.         :type request_token: RequestToken</font>
<font color="black"> 244.         :param request_token: The token associated to the consumption</font>
<font color="black"> 245.             request that is used to identify the request. So if a</font>
<font color="black"> 246.             RequestExceededException is raised the token should be used</font>
<font color="black"> 247.             in subsequent retry consume() request.</font>
<font color="black"> 248. </font>
<font color="black"> 249.         :raises RequestExceededException: If the consumption amount would</font>
<font color="black"> 250.             exceed the maximum allocated bandwidth</font>
<font color="black"> 251. </font>
<font color="black"> 252.         :rtype: int</font>
<font color="black"> 253.         :returns: The amount consumed</font>
<font color="black"> 254.         &quot;&quot;&quot;</font>
<font color="red"> 255.         with self._lock:</font>
<font color="red"> 256.             time_now = self._time_utils.time()</font>
<font color="red"> 257.             if self._consumption_scheduler.is_scheduled(request_token):</font>
<font color="red"> 258.                 return self._release_requested_amt_for_scheduled_request(</font>
<font color="red"> 259.                     amt, request_token, time_now)</font>
<font color="red"> 260.             elif self._projected_to_exceed_max_rate(amt, time_now):</font>
<font color="red"> 261.                 self._raise_request_exceeded_exception(</font>
<font color="red"> 262.                     amt, request_token, time_now)</font>
<font color="black"> 263.             else:</font>
<font color="red"> 264.                 return self._release_requested_amt(amt, time_now)</font>
<font color="black"> 265. </font>
<font color="green"> 266.     def _projected_to_exceed_max_rate(self, amt, time_now):</font>
<font color="red"> 267.         projected_rate = self._rate_tracker.get_projected_rate(amt, time_now)</font>
<font color="red"> 268.         return projected_rate &gt; self._max_rate</font>
<font color="black"> 269. </font>
<font color="green"> 270.     def _release_requested_amt_for_scheduled_request(self, amt, request_token,</font>
<font color="black"> 271.                                                      time_now):</font>
<font color="red"> 272.         self._consumption_scheduler.process_scheduled_consumption(</font>
<font color="red"> 273.             request_token)</font>
<font color="red"> 274.         return self._release_requested_amt(amt, time_now)</font>
<font color="black"> 275. </font>
<font color="green"> 276.     def _raise_request_exceeded_exception(self, amt, request_token, time_now):</font>
<font color="red"> 277.         allocated_time = amt/float(self._max_rate)</font>
<font color="red"> 278.         retry_time = self._consumption_scheduler.schedule_consumption(</font>
<font color="red"> 279.             amt, request_token, allocated_time)</font>
<font color="red"> 280.         raise RequestExceededException(</font>
<font color="red"> 281.             requested_amt=amt, retry_time=retry_time)</font>
<font color="black"> 282. </font>
<font color="green"> 283.     def _release_requested_amt(self, amt, time_now):</font>
<font color="red"> 284.         self._rate_tracker.record_consumption_rate(amt, time_now)</font>
<font color="red"> 285.         return amt</font>
<font color="black"> 286. </font>
<font color="black"> 287. </font>
<font color="green"> 288. class ConsumptionScheduler(object):</font>
<font color="green"> 289.     def __init__(self):</font>
<font color="black"> 290.         &quot;&quot;&quot;Schedules when to consume a desired amount&quot;&quot;&quot;</font>
<font color="red"> 291.         self._tokens_to_scheduled_consumption = {}</font>
<font color="red"> 292.         self._total_wait = 0</font>
<font color="black"> 293. </font>
<font color="green"> 294.     def is_scheduled(self, token):</font>
<font color="black"> 295.         &quot;&quot;&quot;Indicates if a consumption request has been scheduled</font>
<font color="black"> 296. </font>
<font color="black"> 297.         :type token: RequestToken</font>
<font color="black"> 298.         :param token: The token associated to the consumption</font>
<font color="black"> 299.             request that is used to identify the request.</font>
<font color="black"> 300.         &quot;&quot;&quot;</font>
<font color="red"> 301.         return token in self._tokens_to_scheduled_consumption</font>
<font color="black"> 302. </font>
<font color="green"> 303.     def schedule_consumption(self, amt, token, time_to_consume):</font>
<font color="black"> 304.         &quot;&quot;&quot;Schedules a wait time to be able to consume an amount</font>
<font color="black"> 305. </font>
<font color="black"> 306.         :type amt: int</font>
<font color="black"> 307.         :param amt: The amount of bytes scheduled to be consumed</font>
<font color="black"> 308. </font>
<font color="black"> 309.         :type token: RequestToken</font>
<font color="black"> 310.         :param token: The token associated to the consumption</font>
<font color="black"> 311.             request that is used to identify the request.</font>
<font color="black"> 312. </font>
<font color="black"> 313.         :type time_to_consume: float</font>
<font color="black"> 314.         :param time_to_consume: The desired time it should take for that</font>
<font color="black"> 315.             specific request amount to be consumed in regardless of previously</font>
<font color="black"> 316.             scheduled consumption requests</font>
<font color="black"> 317. </font>
<font color="black"> 318.         :rtype: float</font>
<font color="black"> 319.         :returns: The amount of time to wait for the specific request before</font>
<font color="black"> 320.             actually consuming the specified amount.</font>
<font color="black"> 321.         &quot;&quot;&quot;</font>
<font color="red"> 322.         self._total_wait += time_to_consume</font>
<font color="red"> 323.         self._tokens_to_scheduled_consumption[token] = {</font>
<font color="red"> 324.             'wait_duration': self._total_wait,</font>
<font color="red"> 325.             'time_to_consume': time_to_consume,</font>
<font color="black"> 326.         }</font>
<font color="red"> 327.         return self._total_wait</font>
<font color="black"> 328. </font>
<font color="green"> 329.     def process_scheduled_consumption(self, token):</font>
<font color="black"> 330.         &quot;&quot;&quot;Processes a scheduled consumption request that has completed</font>
<font color="black"> 331. </font>
<font color="black"> 332.         :type token: RequestToken</font>
<font color="black"> 333.         :param token: The token associated to the consumption</font>
<font color="black"> 334.             request that is used to identify the request.</font>
<font color="black"> 335.         &quot;&quot;&quot;</font>
<font color="red"> 336.         scheduled_retry = self._tokens_to_scheduled_consumption.pop(token)</font>
<font color="red"> 337.         self._total_wait = max(</font>
<font color="red"> 338.             self._total_wait - scheduled_retry['time_to_consume'], 0)</font>
<font color="black"> 339. </font>
<font color="black"> 340. </font>
<font color="green"> 341. class BandwidthRateTracker(object):</font>
<font color="green"> 342.     def __init__(self, alpha=0.8):</font>
<font color="black"> 343.         &quot;&quot;&quot;Tracks the rate of bandwidth consumption</font>
<font color="black"> 344. </font>
<font color="black"> 345.         :type a: float</font>
<font color="black"> 346.         :param a: The constant to use in calculating the exponentional moving</font>
<font color="black"> 347.             average of the bandwidth rate. Specifically it is used in the</font>
<font color="black"> 348.             following calculation:</font>
<font color="black"> 349. </font>
<font color="black"> 350.             current_rate = alpha * new_rate + (1 - alpha) * current_rate</font>
<font color="black"> 351. </font>
<font color="black"> 352.             This value of this constant should be between 0 and 1.</font>
<font color="black"> 353.         &quot;&quot;&quot;</font>
<font color="red"> 354.         self._alpha = alpha</font>
<font color="red"> 355.         self._last_time = None</font>
<font color="red"> 356.         self._current_rate = None</font>
<font color="black"> 357. </font>
<font color="green"> 358.     @property</font>
<font color="black"> 359.     def current_rate(self):</font>
<font color="black"> 360.         &quot;&quot;&quot;The current transfer rate</font>
<font color="black"> 361. </font>
<font color="black"> 362.         :rtype: float</font>
<font color="black"> 363.         :returns: The current tracked transfer rate</font>
<font color="black"> 364.         &quot;&quot;&quot;</font>
<font color="red"> 365.         if self._last_time is None:</font>
<font color="red"> 366.             return 0.0</font>
<font color="red"> 367.         return self._current_rate</font>
<font color="black"> 368. </font>
<font color="green"> 369.     def get_projected_rate(self, amt, time_at_consumption):</font>
<font color="black"> 370.         &quot;&quot;&quot;Get the projected rate using a provided amount and time</font>
<font color="black"> 371. </font>
<font color="black"> 372.         :type amt: int</font>
<font color="black"> 373.         :param amt: The proposed amount to consume</font>
<font color="black"> 374. </font>
<font color="black"> 375.         :type time_at_consumption: float</font>
<font color="black"> 376.         :param time_at_consumption: The proposed time to consume at</font>
<font color="black"> 377. </font>
<font color="black"> 378.         :rtype: float</font>
<font color="black"> 379.         :returns: The consumption rate if that amt and time were consumed</font>
<font color="black"> 380.         &quot;&quot;&quot;</font>
<font color="red"> 381.         if self._last_time is None:</font>
<font color="red"> 382.             return 0.0</font>
<font color="red"> 383.         return self._calculate_exponential_moving_average_rate(</font>
<font color="red"> 384.             amt, time_at_consumption)</font>
<font color="black"> 385. </font>
<font color="green"> 386.     def record_consumption_rate(self, amt, time_at_consumption):</font>
<font color="black"> 387.         &quot;&quot;&quot;Record the consumption rate based off amount and time point</font>
<font color="black"> 388. </font>
<font color="black"> 389.         :type amt: int</font>
<font color="black"> 390.         :param amt: The amount that got consumed</font>
<font color="black"> 391. </font>
<font color="black"> 392.         :type time_at_consumption: float</font>
<font color="black"> 393.         :param time_at_consumption: The time at which the amount was consumed</font>
<font color="black"> 394.         &quot;&quot;&quot;</font>
<font color="red"> 395.         if self._last_time is None:</font>
<font color="red"> 396.             self._last_time = time_at_consumption</font>
<font color="red"> 397.             self._current_rate = 0.0</font>
<font color="red"> 398.             return</font>
<font color="red"> 399.         self._current_rate = self._calculate_exponential_moving_average_rate(</font>
<font color="red"> 400.             amt, time_at_consumption)</font>
<font color="red"> 401.         self._last_time = time_at_consumption</font>
<font color="black"> 402. </font>
<font color="green"> 403.     def _calculate_rate(self, amt, time_at_consumption):</font>
<font color="red"> 404.         time_delta = time_at_consumption - self._last_time</font>
<font color="red"> 405.         if time_delta &lt;= 0:</font>
<font color="black"> 406.             # While it is really unlikley to see this in an actual transfer,</font>
<font color="black"> 407.             # we do not want to be returning back a negative rate or try to</font>
<font color="black"> 408.             # divide the amount by zero. So instead return back an infinite</font>
<font color="black"> 409.             # rate as the time delta is infinitesimally small.</font>
<font color="red"> 410.             return float('inf')</font>
<font color="red"> 411.         return amt / (time_delta)</font>
<font color="black"> 412. </font>
<font color="green"> 413.     def _calculate_exponential_moving_average_rate(self, amt,</font>
<font color="black"> 414.                                                    time_at_consumption):</font>
<font color="red"> 415.         new_rate = self._calculate_rate(amt, time_at_consumption)</font>
<font color="red"> 416.         return self._alpha * new_rate + (1 - self._alpha) * self._current_rate</font>
</pre>

