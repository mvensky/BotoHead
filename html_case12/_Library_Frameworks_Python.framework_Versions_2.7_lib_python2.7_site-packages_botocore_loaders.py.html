source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/loaders.py</b><br>


file stats: <b>149 lines, 132 executed: 88.6% covered</b>
<pre>
<font color="black">   1. # Copyright 2012-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="black">  13. &quot;&quot;&quot;Module for loading various model files.</font>
<font color="black">  14. </font>
<font color="black">  15. This module provides the classes that are used to load models used</font>
<font color="black">  16. by botocore.  This can include:</font>
<font color="black">  17. </font>
<font color="black">  18.     * Service models (e.g. the model for EC2, S3, DynamoDB, etc.)</font>
<font color="black">  19.     * Service model extras which customize the service models</font>
<font color="black">  20.     * Other models associated with a service (pagination, waiters)</font>
<font color="black">  21.     * Non service-specific config (Endpoint data, retry config)</font>
<font color="black">  22. </font>
<font color="black">  23. Loading a module is broken down into several steps:</font>
<font color="black">  24. </font>
<font color="black">  25.     * Determining the path to load</font>
<font color="black">  26.     * Search the data_path for files to load</font>
<font color="black">  27.     * The mechanics of loading the file</font>
<font color="black">  28.     * Searching for extras and applying them to the loaded file</font>
<font color="black">  29. </font>
<font color="black">  30. The last item is used so that other faster loading mechanism</font>
<font color="black">  31. besides the default JSON loader can be used.</font>
<font color="black">  32. </font>
<font color="black">  33. The Search Path</font>
<font color="black">  34. ===============</font>
<font color="black">  35. </font>
<font color="black">  36. Similar to how the PATH environment variable is to finding executables</font>
<font color="black">  37. and the PYTHONPATH environment variable is to finding python modules</font>
<font color="black">  38. to import, the botocore loaders have the concept of a data path exposed</font>
<font color="black">  39. through AWS_DATA_PATH.</font>
<font color="black">  40. </font>
<font color="black">  41. This enables end users to provide additional search paths where we</font>
<font color="black">  42. will attempt to load models outside of the models we ship with</font>
<font color="black">  43. botocore.  When you create a ``Loader``, there are two paths</font>
<font color="black">  44. automatically added to the model search path:</font>
<font color="black">  45. </font>
<font color="black">  46.     * &lt;botocore root&gt;/data/</font>
<font color="black">  47.     * ~/.aws/models</font>
<font color="black">  48. </font>
<font color="black">  49. The first value is the path where all the model files shipped with</font>
<font color="black">  50. botocore are located.</font>
<font color="black">  51. </font>
<font color="black">  52. The second path is so that users can just drop new model files in</font>
<font color="black">  53. ``~/.aws/models`` without having to mess around with the AWS_DATA_PATH.</font>
<font color="black">  54. </font>
<font color="black">  55. The AWS_DATA_PATH using the platform specific path separator to</font>
<font color="black">  56. separate entries (typically ``:`` on linux and ``;`` on windows).</font>
<font color="black">  57. </font>
<font color="black">  58. </font>
<font color="black">  59. Directory Layout</font>
<font color="black">  60. ================</font>
<font color="black">  61. </font>
<font color="black">  62. The Loader expects a particular directory layout.  In order for any</font>
<font color="black">  63. directory specified in AWS_DATA_PATH to be considered, it must have</font>
<font color="black">  64. this structure for service models::</font>
<font color="black">  65. </font>
<font color="black">  66.     &lt;root&gt;</font>
<font color="black">  67.       |</font>
<font color="black">  68.       |-- servicename1</font>
<font color="black">  69.       |   |-- 2012-10-25</font>
<font color="black">  70.       |       |-- service-2.json</font>
<font color="black">  71.       |-- ec2</font>
<font color="black">  72.       |   |-- 2014-01-01</font>
<font color="black">  73.       |   |   |-- paginators-1.json</font>
<font color="black">  74.       |   |   |-- service-2.json</font>
<font color="black">  75.       |   |   |-- waiters-2.json</font>
<font color="black">  76.       |   |-- 2015-03-01</font>
<font color="black">  77.       |       |-- paginators-1.json</font>
<font color="black">  78.       |       |-- service-2.json</font>
<font color="black">  79.       |       |-- waiters-2.json</font>
<font color="black">  80.       |       |-- service-2.sdk-extras.json</font>
<font color="black">  81. </font>
<font color="black">  82. </font>
<font color="black">  83. That is:</font>
<font color="black">  84. </font>
<font color="black">  85.     * The root directory contains sub directories that are the name</font>
<font color="black">  86.       of the services.</font>
<font color="black">  87.     * Within each service directory, there's a sub directory for each</font>
<font color="black">  88.       available API version.</font>
<font color="black">  89.     * Within each API version, there are model specific files, including</font>
<font color="black">  90.       (but not limited to): service-2.json, waiters-2.json, paginators-1.json</font>
<font color="black">  91. </font>
<font color="black">  92. The ``-1`` and ``-2`` suffix at the end of the model files denote which version</font>
<font color="black">  93. schema is used within the model.  Even though this information is available in</font>
<font color="black">  94. the ``version`` key within the model, this version is also part of the filename</font>
<font color="black">  95. so that code does not need to load the JSON model in order to determine which</font>
<font color="black">  96. version to use.</font>
<font color="black">  97. </font>
<font color="black">  98. The ``sdk-extras`` and similar files represent extra data that needs to be</font>
<font color="black">  99. applied to the model after it is loaded. Data in these files might represent</font>
<font color="black"> 100. information that doesn't quite fit in the original models, but is still needed</font>
<font color="black"> 101. for the sdk. For instance, additional operation parameters might be added here</font>
<font color="black"> 102. which don't represent the actual service api.</font>
<font color="green"> 103. &quot;&quot;&quot;</font>
<font color="green"> 104. import os</font>
<font color="green"> 105. import logging</font>
<font color="black"> 106. </font>
<font color="green"> 107. from botocore import BOTOCORE_ROOT</font>
<font color="green"> 108. from botocore.compat import json</font>
<font color="green"> 109. from botocore.compat import OrderedDict</font>
<font color="green"> 110. from botocore.exceptions import DataNotFoundError, UnknownServiceError</font>
<font color="green"> 111. from botocore.utils import deep_merge</font>
<font color="black"> 112. </font>
<font color="black"> 113. </font>
<font color="green"> 114. logger = logging.getLogger(__name__)</font>
<font color="black"> 115. </font>
<font color="black"> 116. </font>
<font color="green"> 117. def instance_cache(func):</font>
<font color="black"> 118.     &quot;&quot;&quot;Cache the result of a method on a per instance basis.</font>
<font color="black"> 119. </font>
<font color="black"> 120.     This is not a general purpose caching decorator.  In order</font>
<font color="black"> 121.     for this to be used, it must be used on methods on an</font>
<font color="black"> 122.     instance, and that instance *must* provide a</font>
<font color="black"> 123.     ``self._cache`` dictionary.</font>
<font color="black"> 124. </font>
<font color="black"> 125.     &quot;&quot;&quot;</font>
<font color="green"> 126.     def _wrapper(self, *args, **kwargs):</font>
<font color="green"> 127.         key = (func.__name__,) + args</font>
<font color="green"> 128.         for pair in sorted(kwargs.items()):</font>
<font color="green"> 129.             key += pair</font>
<font color="green"> 130.         if key in self._cache:</font>
<font color="red"> 131.             return self._cache[key]</font>
<font color="green"> 132.         data = func(self, *args, **kwargs)</font>
<font color="green"> 133.         self._cache[key] = data</font>
<font color="green"> 134.         return data</font>
<font color="green"> 135.     return _wrapper</font>
<font color="black"> 136. </font>
<font color="black"> 137. </font>
<font color="green"> 138. class JSONFileLoader(object):</font>
<font color="black"> 139.     &quot;&quot;&quot;Loader JSON files.</font>
<font color="black"> 140. </font>
<font color="black"> 141.     This class can load the default format of models, which is a JSON file.</font>
<font color="black"> 142. </font>
<font color="green"> 143.     &quot;&quot;&quot;</font>
<font color="green"> 144.     def exists(self, file_path):</font>
<font color="black"> 145.         &quot;&quot;&quot;Checks if the file exists.</font>
<font color="black"> 146. </font>
<font color="black"> 147.         :type file_path: str</font>
<font color="black"> 148.         :param file_path: The full path to the file to load without</font>
<font color="black"> 149.             the '.json' extension.</font>
<font color="black"> 150. </font>
<font color="black"> 151.         :return: True if file path exists, False otherwise.</font>
<font color="black"> 152. </font>
<font color="black"> 153.         &quot;&quot;&quot;</font>
<font color="green"> 154.         return os.path.isfile(file_path + '.json')</font>
<font color="black"> 155. </font>
<font color="green"> 156.     def load_file(self, file_path):</font>
<font color="black"> 157.         &quot;&quot;&quot;Attempt to load the file path.</font>
<font color="black"> 158. </font>
<font color="black"> 159.         :type file_path: str</font>
<font color="black"> 160.         :param file_path: The full path to the file to load without</font>
<font color="black"> 161.             the '.json' extension.</font>
<font color="black"> 162. </font>
<font color="black"> 163.         :return: The loaded data if it exists, otherwise None.</font>
<font color="black"> 164. </font>
<font color="black"> 165.         &quot;&quot;&quot;</font>
<font color="green"> 166.         full_path = file_path + '.json'</font>
<font color="green"> 167.         if not os.path.isfile(full_path):</font>
<font color="green"> 168.             return</font>
<font color="black"> 169. </font>
<font color="black"> 170.         # By default the file will be opened with locale encoding on Python 3.</font>
<font color="black"> 171.         # We specify &quot;utf8&quot; here to ensure the correct behavior.</font>
<font color="green"> 172.         with open(full_path, 'rb') as fp:</font>
<font color="green"> 173.             payload = fp.read().decode('utf-8')</font>
<font color="green"> 174.             logger.debug(&quot;Loading JSON file: %s&quot;, full_path)</font>
<font color="green"> 175.             return json.loads(payload, object_pairs_hook=OrderedDict)</font>
<font color="black"> 176. </font>
<font color="black"> 177. </font>
<font color="green"> 178. def create_loader(search_path_string=None):</font>
<font color="black"> 179.     &quot;&quot;&quot;Create a Loader class.</font>
<font color="black"> 180. </font>
<font color="black"> 181.     This factory function creates a loader given a search string path.</font>
<font color="black"> 182. </font>
<font color="black"> 183.     :type search_string_path: str</font>
<font color="black"> 184.     :param search_string_path: The AWS_DATA_PATH value.  A string</font>
<font color="black"> 185.         of data path values separated by the ``os.path.pathsep`` value,</font>
<font color="black"> 186.         which is typically ``:`` on POSIX platforms and ``;`` on</font>
<font color="black"> 187.         windows.</font>
<font color="black"> 188. </font>
<font color="black"> 189.     :return: A ``Loader`` instance.</font>
<font color="black"> 190. </font>
<font color="black"> 191.     &quot;&quot;&quot;</font>
<font color="green"> 192.     if search_path_string is None:</font>
<font color="green"> 193.         return Loader()</font>
<font color="red"> 194.     paths = []</font>
<font color="red"> 195.     extra_paths = search_path_string.split(os.pathsep)</font>
<font color="red"> 196.     for path in extra_paths:</font>
<font color="red"> 197.         path = os.path.expanduser(os.path.expandvars(path))</font>
<font color="red"> 198.         paths.append(path)</font>
<font color="red"> 199.     return Loader(extra_search_paths=paths)</font>
<font color="black"> 200. </font>
<font color="black"> 201. </font>
<font color="green"> 202. class Loader(object):</font>
<font color="black"> 203.     &quot;&quot;&quot;Find and load data models.</font>
<font color="black"> 204. </font>
<font color="black"> 205.     This class will handle searching for and loading data models.</font>
<font color="black"> 206. </font>
<font color="black"> 207.     The main method used here is ``load_service_model``, which is a</font>
<font color="black"> 208.     convenience method over ``load_data`` and ``determine_latest_version``.</font>
<font color="black"> 209. </font>
<font color="green"> 210.     &quot;&quot;&quot;</font>
<font color="green"> 211.     FILE_LOADER_CLASS = JSONFileLoader</font>
<font color="black"> 212.     # The included models in botocore/data/ that we ship with botocore.</font>
<font color="green"> 213.     BUILTIN_DATA_PATH = os.path.join(BOTOCORE_ROOT, 'data')</font>
<font color="black"> 214.     # For convenience we automatically add ~/.aws/models to the data path.</font>
<font color="green"> 215.     CUSTOMER_DATA_PATH = os.path.join(os.path.expanduser('~'),</font>
<font color="green"> 216.                                       '.aws', 'models')</font>
<font color="green"> 217.     BUILTIN_EXTRAS_TYPES = ['sdk']</font>
<font color="black"> 218. </font>
<font color="green"> 219.     def __init__(self, extra_search_paths=None, file_loader=None,</font>
<font color="green"> 220.                  cache=None, include_default_search_paths=True,</font>
<font color="green"> 221.                  include_default_extras=True):</font>
<font color="green"> 222.         self._cache = {}</font>
<font color="green"> 223.         if file_loader is None:</font>
<font color="green"> 224.             file_loader = self.FILE_LOADER_CLASS()</font>
<font color="green"> 225.         self.file_loader = file_loader</font>
<font color="green"> 226.         if extra_search_paths is not None:</font>
<font color="red"> 227.             self._search_paths = extra_search_paths</font>
<font color="black"> 228.         else:</font>
<font color="green"> 229.             self._search_paths = []</font>
<font color="green"> 230.         if include_default_search_paths:</font>
<font color="green"> 231.             self._search_paths.extend([self.CUSTOMER_DATA_PATH,</font>
<font color="green"> 232.                                        self.BUILTIN_DATA_PATH])</font>
<font color="black"> 233. </font>
<font color="green"> 234.         self._extras_types = []</font>
<font color="green"> 235.         if include_default_extras:</font>
<font color="green"> 236.             self._extras_types.extend(self.BUILTIN_EXTRAS_TYPES)</font>
<font color="black"> 237. </font>
<font color="green"> 238.         self._extras_processor = ExtrasProcessor()</font>
<font color="black"> 239. </font>
<font color="green"> 240.     @property</font>
<font color="black"> 241.     def search_paths(self):</font>
<font color="green"> 242.         return self._search_paths</font>
<font color="black"> 243. </font>
<font color="green"> 244.     @property</font>
<font color="black"> 245.     def extras_types(self):</font>
<font color="green"> 246.         return self._extras_types</font>
<font color="black"> 247. </font>
<font color="green"> 248.     @instance_cache</font>
<font color="black"> 249.     def list_available_services(self, type_name):</font>
<font color="black"> 250.         &quot;&quot;&quot;List all known services.</font>
<font color="black"> 251. </font>
<font color="black"> 252.         This will traverse the search path and look for all known</font>
<font color="black"> 253.         services.</font>
<font color="black"> 254. </font>
<font color="black"> 255.         :type type_name: str</font>
<font color="black"> 256.         :param type_name: The type of the service (service-2,</font>
<font color="black"> 257.             paginators-1, waiters-2, etc).  This is needed because</font>
<font color="black"> 258.             the list of available services depends on the service</font>
<font color="black"> 259.             type.  For example, the latest API version available for</font>
<font color="black"> 260.             a resource-1.json file may not be the latest API version</font>
<font color="black"> 261.             available for a services-2.json file.</font>
<font color="black"> 262. </font>
<font color="black"> 263.         :return: A list of all services.  The list of services will</font>
<font color="black"> 264.             be sorted.</font>
<font color="black"> 265. </font>
<font color="black"> 266.         &quot;&quot;&quot;</font>
<font color="green"> 267.         services = set()</font>
<font color="green"> 268.         for possible_path in self._potential_locations():</font>
<font color="black"> 269.             # Any directory in the search path is potentially a service.</font>
<font color="black"> 270.             # We'll collect any initial list of potential services,</font>
<font color="black"> 271.             # but we'll then need to further process these directories</font>
<font color="black"> 272.             # by searching for the corresponding type_name in each</font>
<font color="black"> 273.             # potential directory.</font>
<font color="black"> 274.             possible_services = [</font>
<font color="green"> 275.                 d for d in os.listdir(possible_path)</font>
<font color="green"> 276.                 if os.path.isdir(os.path.join(possible_path, d))]</font>
<font color="green"> 277.             for service_name in possible_services:</font>
<font color="green"> 278.                 full_dirname = os.path.join(possible_path, service_name)</font>
<font color="green"> 279.                 api_versions = os.listdir(full_dirname)</font>
<font color="green"> 280.                 for api_version in api_versions:</font>
<font color="green"> 281.                     full_load_path = os.path.join(full_dirname,</font>
<font color="green"> 282.                                                   api_version,</font>
<font color="green"> 283.                                                   type_name)</font>
<font color="green"> 284.                     if self.file_loader.exists(full_load_path):</font>
<font color="green"> 285.                         services.add(service_name)</font>
<font color="green"> 286.                         break</font>
<font color="green"> 287.         return sorted(services)</font>
<font color="black"> 288. </font>
<font color="green"> 289.     @instance_cache</font>
<font color="black"> 290.     def determine_latest_version(self, service_name, type_name):</font>
<font color="black"> 291.         &quot;&quot;&quot;Find the latest API version available for a service.</font>
<font color="black"> 292. </font>
<font color="black"> 293.         :type service_name: str</font>
<font color="black"> 294.         :param service_name: The name of the service.</font>
<font color="black"> 295. </font>
<font color="black"> 296.         :type type_name: str</font>
<font color="black"> 297.         :param type_name: The type of the service (service-2,</font>
<font color="black"> 298.             paginators-1, waiters-2, etc).  This is needed because</font>
<font color="black"> 299.             the latest API version available can depend on the service</font>
<font color="black"> 300.             type.  For example, the latest API version available for</font>
<font color="black"> 301.             a resource-1.json file may not be the latest API version</font>
<font color="black"> 302.             available for a services-2.json file.</font>
<font color="black"> 303. </font>
<font color="black"> 304.         :rtype: str</font>
<font color="black"> 305.         :return: The latest API version.  If the service does not exist</font>
<font color="black"> 306.             or does not have any available API data, then a</font>
<font color="black"> 307.             ``DataNotFoundError`` exception will be raised.</font>
<font color="black"> 308. </font>
<font color="black"> 309.         &quot;&quot;&quot;</font>
<font color="green"> 310.         return max(self.list_api_versions(service_name, type_name))</font>
<font color="black"> 311. </font>
<font color="green"> 312.     @instance_cache</font>
<font color="black"> 313.     def list_api_versions(self, service_name, type_name):</font>
<font color="black"> 314.         &quot;&quot;&quot;List all API versions available for a particular service type</font>
<font color="black"> 315. </font>
<font color="black"> 316.         :type service_name: str</font>
<font color="black"> 317.         :param service_name: The name of the service</font>
<font color="black"> 318. </font>
<font color="black"> 319.         :type type_name: str</font>
<font color="black"> 320.         :param type_name: The type name for the service (i.e service-2,</font>
<font color="black"> 321.             paginators-1, etc.)</font>
<font color="black"> 322. </font>
<font color="black"> 323.         :rtype: list</font>
<font color="black"> 324.         :return: A list of API version strings in sorted order.</font>
<font color="black"> 325. </font>
<font color="black"> 326.         &quot;&quot;&quot;</font>
<font color="green"> 327.         known_api_versions = set()</font>
<font color="green"> 328.         for possible_path in self._potential_locations(service_name,</font>
<font color="green"> 329.                                                        must_exist=True,</font>
<font color="green"> 330.                                                        is_dir=True):</font>
<font color="green"> 331.             for dirname in os.listdir(possible_path):</font>
<font color="green"> 332.                 full_path = os.path.join(possible_path, dirname, type_name)</font>
<font color="black"> 333.                 # Only add to the known_api_versions if the directory</font>
<font color="black"> 334.                 # contains a service-2, paginators-1, etc. file corresponding</font>
<font color="black"> 335.                 # to the type_name passed in.</font>
<font color="green"> 336.                 if self.file_loader.exists(full_path):</font>
<font color="green"> 337.                     known_api_versions.add(dirname)</font>
<font color="green"> 338.         if not known_api_versions:</font>
<font color="red"> 339.             raise DataNotFoundError(data_path=service_name)</font>
<font color="green"> 340.         return sorted(known_api_versions)</font>
<font color="black"> 341. </font>
<font color="green"> 342.     @instance_cache</font>
<font color="green"> 343.     def load_service_model(self, service_name, type_name, api_version=None):</font>
<font color="black"> 344.         &quot;&quot;&quot;Load a botocore service model</font>
<font color="black"> 345. </font>
<font color="black"> 346.         This is the main method for loading botocore models (e.g. a service</font>
<font color="black"> 347.         model, pagination configs, waiter configs, etc.).</font>
<font color="black"> 348. </font>
<font color="black"> 349.         :type service_name: str</font>
<font color="black"> 350.         :param service_name: The name of the service (e.g ``ec2``, ``s3``).</font>
<font color="black"> 351. </font>
<font color="black"> 352.         :type type_name: str</font>
<font color="black"> 353.         :param type_name: The model type.  Valid types include, but are not</font>
<font color="black"> 354.             limited to: ``service-2``, ``paginators-1``, ``waiters-2``.</font>
<font color="black"> 355. </font>
<font color="black"> 356.         :type api_version: str</font>
<font color="black"> 357.         :param api_version: The API version to load.  If this is not</font>
<font color="black"> 358.             provided, then the latest API version will be used.</font>
<font color="black"> 359. </font>
<font color="black"> 360.         :type load_extras: bool</font>
<font color="black"> 361.         :param load_extras: Whether or not to load the tool extras which</font>
<font color="black"> 362.             contain additional data to be added to the model.</font>
<font color="black"> 363. </font>
<font color="black"> 364.         :raises: UnknownServiceError if there is no known service with</font>
<font color="black"> 365.             the provided service_name.</font>
<font color="black"> 366. </font>
<font color="black"> 367.         :raises: DataNotFoundError if no data could be found for the</font>
<font color="black"> 368.             service_name/type_name/api_version.</font>
<font color="black"> 369. </font>
<font color="black"> 370.         :return: The loaded data, as a python type (e.g. dict, list, etc).</font>
<font color="black"> 371.         &quot;&quot;&quot;</font>
<font color="black"> 372.         # Wrapper around the load_data.  This will calculate the path</font>
<font color="black"> 373.         # to call load_data with.</font>
<font color="green"> 374.         known_services = self.list_available_services(type_name)</font>
<font color="green"> 375.         if service_name not in known_services:</font>
<font color="red"> 376.             raise UnknownServiceError(</font>
<font color="red"> 377.                 service_name=service_name,</font>
<font color="red"> 378.                 known_service_names=', '.join(sorted(known_services)))</font>
<font color="green"> 379.         if api_version is None:</font>
<font color="green"> 380.             api_version = self.determine_latest_version(</font>
<font color="green"> 381.                 service_name, type_name)</font>
<font color="green"> 382.         full_path = os.path.join(service_name, api_version, type_name)</font>
<font color="green"> 383.         model = self.load_data(full_path)</font>
<font color="black"> 384. </font>
<font color="black"> 385.         # Load in all the extras</font>
<font color="green"> 386.         extras_data = self._find_extras(service_name, type_name, api_version)</font>
<font color="green"> 387.         self._extras_processor.process(model, extras_data)</font>
<font color="black"> 388. </font>
<font color="green"> 389.         return model</font>
<font color="black"> 390. </font>
<font color="green"> 391.     def _find_extras(self, service_name, type_name, api_version):</font>
<font color="black"> 392.         &quot;&quot;&quot;Creates an iterator over all the extras data.&quot;&quot;&quot;</font>
<font color="green"> 393.         for extras_type in self.extras_types:</font>
<font color="green"> 394.             extras_name = '%s.%s-extras' % (type_name, extras_type)</font>
<font color="green"> 395.             full_path = os.path.join(service_name, api_version, extras_name)</font>
<font color="black"> 396. </font>
<font color="green"> 397.             try:</font>
<font color="green"> 398.                 yield self.load_data(full_path)</font>
<font color="green"> 399.             except DataNotFoundError:</font>
<font color="green"> 400.                 pass</font>
<font color="black"> 401. </font>
<font color="green"> 402.     @instance_cache</font>
<font color="black"> 403.     def load_data(self, name):</font>
<font color="black"> 404.         &quot;&quot;&quot;Load data given a data path.</font>
<font color="black"> 405. </font>
<font color="black"> 406.         This is a low level method that will search through the various</font>
<font color="black"> 407.         search paths until it's able to load a value.  This is typically</font>
<font color="black"> 408.         only needed to load *non* model files (such as _endpoints and</font>
<font color="black"> 409.         _retry).  If you need to load model files, you should prefer</font>
<font color="black"> 410.         ``load_service_model``.</font>
<font color="black"> 411. </font>
<font color="black"> 412.         :type name: str</font>
<font color="black"> 413.         :param name: The data path, i.e ``ec2/2015-03-01/service-2``.</font>
<font color="black"> 414. </font>
<font color="black"> 415.         :return: The loaded data.  If no data could be found then</font>
<font color="black"> 416.             a DataNotFoundError is raised.</font>
<font color="black"> 417. </font>
<font color="black"> 418.         &quot;&quot;&quot;</font>
<font color="green"> 419.         for possible_path in self._potential_locations(name):</font>
<font color="green"> 420.             found = self.file_loader.load_file(possible_path)</font>
<font color="green"> 421.             if found is not None:</font>
<font color="green"> 422.                 return found</font>
<font color="black"> 423.         # We didn't find anything that matched on any path.</font>
<font color="green"> 424.         raise DataNotFoundError(data_path=name)</font>
<font color="black"> 425. </font>
<font color="green"> 426.     def _potential_locations(self, name=None, must_exist=False,</font>
<font color="green"> 427.                              is_dir=False):</font>
<font color="black"> 428.         # Will give an iterator over the full path of potential locations</font>
<font color="black"> 429.         # according to the search path.</font>
<font color="green"> 430.         for path in self.search_paths:</font>
<font color="green"> 431.             if os.path.isdir(path):</font>
<font color="green"> 432.                 full_path = path</font>
<font color="green"> 433.                 if name is not None:</font>
<font color="green"> 434.                     full_path = os.path.join(path, name)</font>
<font color="green"> 435.                 if not must_exist:</font>
<font color="green"> 436.                     yield full_path</font>
<font color="black"> 437.                 else:</font>
<font color="green"> 438.                     if is_dir and os.path.isdir(full_path):</font>
<font color="green"> 439.                         yield full_path</font>
<font color="red"> 440.                     elif os.path.exists(full_path):</font>
<font color="red"> 441.                         yield full_path</font>
<font color="black"> 442. </font>
<font color="black"> 443. </font>
<font color="green"> 444. class ExtrasProcessor(object):</font>
<font color="green"> 445.     &quot;&quot;&quot;Processes data from extras files into service models.&quot;&quot;&quot;</font>
<font color="green"> 446.     def process(self, original_model, extra_models):</font>
<font color="black"> 447.         &quot;&quot;&quot;Processes data from a list of loaded extras files into a model</font>
<font color="black"> 448. </font>
<font color="black"> 449.         :type original_model: dict</font>
<font color="black"> 450.         :param original_model: The service model to load all the extras into.</font>
<font color="black"> 451. </font>
<font color="black"> 452.         :type extra_models: iterable of dict</font>
<font color="black"> 453.         :param extra_models: A list of loaded extras models.</font>
<font color="black"> 454.         &quot;&quot;&quot;</font>
<font color="green"> 455.         for extras in extra_models:</font>
<font color="red"> 456.             self._process(original_model, extras)</font>
<font color="black"> 457. </font>
<font color="green"> 458.     def _process(self, model, extra_model):</font>
<font color="black"> 459.         &quot;&quot;&quot;Process a single extras model into a service model.&quot;&quot;&quot;</font>
<font color="red"> 460.         if 'merge' in extra_model:</font>
<font color="red"> 461.             deep_merge(model, extra_model['merge'])</font>
</pre>

