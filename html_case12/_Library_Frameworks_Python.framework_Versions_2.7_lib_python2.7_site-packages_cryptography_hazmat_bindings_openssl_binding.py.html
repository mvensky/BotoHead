source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/cryptography/hazmat/bindings/openssl/binding.py</b><br>


file stats: <b>80 lines, 57 executed: 71.2% covered</b>
<pre>
<font color="black">   1. # This file is dual licensed under the terms of the Apache License, Version</font>
<font color="black">   2. # 2.0, and the BSD License. See the LICENSE file in the root of this repository</font>
<font color="black">   3. # for complete details.</font>
<font color="black">   4. </font>
<font color="green">   5. from __future__ import absolute_import, division, print_function</font>
<font color="black">   6. </font>
<font color="green">   7. import collections</font>
<font color="green">   8. import threading</font>
<font color="green">   9. import types</font>
<font color="black">  10. </font>
<font color="green">  11. from cryptography.exceptions import InternalError</font>
<font color="green">  12. from cryptography.hazmat.bindings._openssl import ffi, lib</font>
<font color="green">  13. from cryptography.hazmat.bindings.openssl._conditional import CONDITIONAL_NAMES</font>
<font color="black">  14. </font>
<font color="green">  15. _OpenSSLError = collections.namedtuple(&quot;_OpenSSLError&quot;,</font>
<font color="green">  16.                                        [&quot;code&quot;, &quot;lib&quot;, &quot;func&quot;, &quot;reason&quot;])</font>
<font color="green">  17. _OpenSSLErrorWithText = collections.namedtuple(</font>
<font color="green">  18.     &quot;_OpenSSLErrorWithText&quot;, [&quot;code&quot;, &quot;lib&quot;, &quot;func&quot;, &quot;reason&quot;, &quot;reason_text&quot;]</font>
<font color="black">  19. )</font>
<font color="black">  20. </font>
<font color="black">  21. </font>
<font color="green">  22. def _consume_errors(lib):</font>
<font color="red">  23.     errors = []</font>
<font color="red">  24.     while True:</font>
<font color="red">  25.         code = lib.ERR_get_error()</font>
<font color="red">  26.         if code == 0:</font>
<font color="red">  27.             break</font>
<font color="black">  28. </font>
<font color="red">  29.         err_lib = lib.ERR_GET_LIB(code)</font>
<font color="red">  30.         err_func = lib.ERR_GET_FUNC(code)</font>
<font color="red">  31.         err_reason = lib.ERR_GET_REASON(code)</font>
<font color="black">  32. </font>
<font color="red">  33.         errors.append(_OpenSSLError(code, err_lib, err_func, err_reason))</font>
<font color="black">  34. </font>
<font color="red">  35.     return errors</font>
<font color="black">  36. </font>
<font color="black">  37. </font>
<font color="green">  38. def _openssl_assert(lib, ok):</font>
<font color="green">  39.     if not ok:</font>
<font color="red">  40.         errors = _consume_errors(lib)</font>
<font color="red">  41.         errors_with_text = []</font>
<font color="red">  42.         for err in errors:</font>
<font color="red">  43.             err_text_reason = ffi.string(</font>
<font color="red">  44.                 lib.ERR_error_string(err.code, ffi.NULL)</font>
<font color="black">  45.             )</font>
<font color="red">  46.             errors_with_text.append(</font>
<font color="red">  47.                 _OpenSSLErrorWithText(</font>
<font color="red">  48.                     err.code, err.lib, err.func, err.reason, err_text_reason</font>
<font color="black">  49.                 )</font>
<font color="black">  50.             )</font>
<font color="black">  51. </font>
<font color="red">  52.         raise InternalError(</font>
<font color="red">  53.             &quot;Unknown OpenSSL error. This error is commonly encountered when &quot;</font>
<font color="black">  54.             &quot;another library is not cleaning up the OpenSSL error stack. If &quot;</font>
<font color="black">  55.             &quot;you are using cryptography with another library that uses &quot;</font>
<font color="black">  56.             &quot;OpenSSL try disabling it before reporting a bug. Otherwise &quot;</font>
<font color="black">  57.             &quot;please file an issue at https://github.com/pyca/cryptography/&quot;</font>
<font color="black">  58.             &quot;issues with information on how to reproduce &quot;</font>
<font color="red">  59.             &quot;this. ({0!r})&quot;.format(errors_with_text),</font>
<font color="red">  60.             errors_with_text</font>
<font color="black">  61.         )</font>
<font color="black">  62. </font>
<font color="black">  63. </font>
<font color="green">  64. def build_conditional_library(lib, conditional_names):</font>
<font color="green">  65.     conditional_lib = types.ModuleType(&quot;lib&quot;)</font>
<font color="green">  66.     conditional_lib._original_lib = lib</font>
<font color="green">  67.     excluded_names = set()</font>
<font color="green">  68.     for condition, names in conditional_names.items():</font>
<font color="green">  69.         if not getattr(lib, condition):</font>
<font color="green">  70.             excluded_names |= set(names)</font>
<font color="black">  71. </font>
<font color="green">  72.     for attr in dir(lib):</font>
<font color="green">  73.         if attr not in excluded_names:</font>
<font color="green">  74.             setattr(conditional_lib, attr, getattr(lib, attr))</font>
<font color="black">  75. </font>
<font color="green">  76.     return conditional_lib</font>
<font color="black">  77. </font>
<font color="black">  78. </font>
<font color="green">  79. class Binding(object):</font>
<font color="black">  80.     &quot;&quot;&quot;</font>
<font color="black">  81.     OpenSSL API wrapper.</font>
<font color="green">  82.     &quot;&quot;&quot;</font>
<font color="green">  83.     lib = None</font>
<font color="green">  84.     ffi = ffi</font>
<font color="green">  85.     _lib_loaded = False</font>
<font color="green">  86.     _init_lock = threading.Lock()</font>
<font color="green">  87.     _lock_init_lock = threading.Lock()</font>
<font color="black">  88. </font>
<font color="green">  89.     def __init__(self):</font>
<font color="green">  90.         self._ensure_ffi_initialized()</font>
<font color="black">  91. </font>
<font color="green">  92.     @classmethod</font>
<font color="black">  93.     def _register_osrandom_engine(cls):</font>
<font color="black">  94.         # Clear any errors extant in the queue before we start. In many</font>
<font color="black">  95.         # scenarios other things may be interacting with OpenSSL in the same</font>
<font color="black">  96.         # process space and it has proven untenable to assume that they will</font>
<font color="black">  97.         # reliably clear the error queue. Once we clear it here we will</font>
<font color="black">  98.         # error on any subsequent unexpected item in the stack.</font>
<font color="green">  99.         cls.lib.ERR_clear_error()</font>
<font color="green"> 100.         cls._osrandom_engine_id = cls.lib.Cryptography_osrandom_engine_id</font>
<font color="green"> 101.         cls._osrandom_engine_name = cls.lib.Cryptography_osrandom_engine_name</font>
<font color="green"> 102.         result = cls.lib.Cryptography_add_osrandom_engine()</font>
<font color="green"> 103.         _openssl_assert(cls.lib, result in (1, 2))</font>
<font color="black"> 104. </font>
<font color="green"> 105.     @classmethod</font>
<font color="black"> 106.     def _ensure_ffi_initialized(cls):</font>
<font color="green"> 107.         with cls._init_lock:</font>
<font color="green"> 108.             if not cls._lib_loaded:</font>
<font color="green"> 109.                 cls.lib = build_conditional_library(lib, CONDITIONAL_NAMES)</font>
<font color="green"> 110.                 cls._lib_loaded = True</font>
<font color="black"> 111.                 # initialize the SSL library</font>
<font color="green"> 112.                 cls.lib.SSL_library_init()</font>
<font color="black"> 113.                 # adds all ciphers/digests for EVP</font>
<font color="green"> 114.                 cls.lib.OpenSSL_add_all_algorithms()</font>
<font color="black"> 115.                 # loads error strings for libcrypto and libssl functions</font>
<font color="green"> 116.                 cls.lib.SSL_load_error_strings()</font>
<font color="green"> 117.                 cls._register_osrandom_engine()</font>
<font color="black"> 118. </font>
<font color="green"> 119.     @classmethod</font>
<font color="black"> 120.     def init_static_locks(cls):</font>
<font color="green"> 121.         with cls._lock_init_lock:</font>
<font color="green"> 122.             cls._ensure_ffi_initialized()</font>
<font color="black"> 123.             # Use Python's implementation if available, importing _ssl triggers</font>
<font color="black"> 124.             # the setup for this.</font>
<font color="green"> 125.             __import__(&quot;_ssl&quot;)</font>
<font color="black"> 126. </font>
<font color="green"> 127.             if cls.lib.CRYPTO_get_locking_callback() != cls.ffi.NULL:</font>
<font color="red"> 128.                 return</font>
<font color="black"> 129. </font>
<font color="black"> 130.             # If nothing else has setup a locking callback already, we set up</font>
<font color="black"> 131.             # our own</font>
<font color="green"> 132.             res = lib._setup_ssl_threads()</font>
<font color="green"> 133.             _openssl_assert(cls.lib, res == 1)</font>
<font color="black"> 134. </font>
<font color="black"> 135. </font>
<font color="black"> 136. # OpenSSL is not thread safe until the locks are initialized. We call this</font>
<font color="black"> 137. # method in module scope so that it executes with the import lock. On</font>
<font color="black"> 138. # Pythons &lt; 3.4 this import lock is a global lock, which can prevent a race</font>
<font color="black"> 139. # condition registering the OpenSSL locks. On Python 3.4+ the import lock</font>
<font color="black"> 140. # is per module so this approach will not work.</font>
<font color="green"> 141. Binding.init_static_locks()</font>
</pre>

