source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/s3transfer/upload.py</b><br>


file stats: <b>338 lines, 87 executed: 25.7% covered</b>
<pre>
<font color="black">   1. # Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="green">  13. import math</font>
<font color="black">  14. </font>
<font color="green">  15. from botocore.compat import six</font>
<font color="black">  16. </font>
<font color="green">  17. from s3transfer.compat import seekable, readable</font>
<font color="green">  18. from s3transfer.futures import IN_MEMORY_UPLOAD_TAG</font>
<font color="green">  19. from s3transfer.tasks import Task</font>
<font color="green">  20. from s3transfer.tasks import SubmissionTask</font>
<font color="green">  21. from s3transfer.tasks import CreateMultipartUploadTask</font>
<font color="green">  22. from s3transfer.tasks import CompleteMultipartUploadTask</font>
<font color="green">  23. from s3transfer.utils import get_callbacks</font>
<font color="green">  24. from s3transfer.utils import get_filtered_dict</font>
<font color="green">  25. from s3transfer.utils import DeferredOpenFile, ChunksizeAdjuster</font>
<font color="black">  26. </font>
<font color="black">  27. </font>
<font color="green">  28. class AggregatedProgressCallback(object):</font>
<font color="green">  29.     def __init__(self, callbacks, threshold=1024 * 256):</font>
<font color="black">  30.         &quot;&quot;&quot;Aggregates progress updates for every provided progress callback</font>
<font color="black">  31. </font>
<font color="black">  32.         :type callbacks: A list of functions that accepts bytes_transferred</font>
<font color="black">  33.             as a single argument</font>
<font color="black">  34.         :param callbacks: The callbacks to invoke when threshold is reached</font>
<font color="black">  35. </font>
<font color="black">  36.         :type threshold: int</font>
<font color="black">  37.         :param threshold: The progress threshold in which to take the</font>
<font color="black">  38.             aggregated progress and invoke the progress callback with that</font>
<font color="black">  39.             aggregated progress total</font>
<font color="black">  40.         &quot;&quot;&quot;</font>
<font color="red">  41.         self._callbacks = callbacks</font>
<font color="red">  42.         self._threshold = threshold</font>
<font color="red">  43.         self._bytes_seen = 0</font>
<font color="black">  44. </font>
<font color="green">  45.     def __call__(self, bytes_transferred):</font>
<font color="red">  46.         self._bytes_seen += bytes_transferred</font>
<font color="red">  47.         if self._bytes_seen &gt;= self._threshold:</font>
<font color="red">  48.             self._trigger_callbacks()</font>
<font color="black">  49. </font>
<font color="green">  50.     def flush(self):</font>
<font color="black">  51.         &quot;&quot;&quot;Flushes out any progress that has not been sent to its callbacks&quot;&quot;&quot;</font>
<font color="red">  52.         if self._bytes_seen &gt; 0:</font>
<font color="red">  53.             self._trigger_callbacks()</font>
<font color="black">  54. </font>
<font color="green">  55.     def _trigger_callbacks(self):</font>
<font color="red">  56.         for callback in self._callbacks:</font>
<font color="red">  57.             callback(bytes_transferred=self._bytes_seen)</font>
<font color="red">  58.         self._bytes_seen = 0</font>
<font color="black">  59. </font>
<font color="black">  60. </font>
<font color="green">  61. class InterruptReader(object):</font>
<font color="black">  62.     &quot;&quot;&quot;Wrapper that can interrupt reading using an error</font>
<font color="black">  63. </font>
<font color="black">  64.     It uses a transfer coordinator to propogate an error if it notices</font>
<font color="black">  65.     that a read is being made while the file is being read from.</font>
<font color="black">  66. </font>
<font color="black">  67.     :type fileobj: file-like obj</font>
<font color="black">  68.     :param fileobj: The file-like object to read from</font>
<font color="black">  69. </font>
<font color="black">  70.     :type transfer_coordinator: s3transfer.futures.TransferCoordinator</font>
<font color="black">  71.     :param transfer_coordinator: The transfer coordinator to use if the</font>
<font color="black">  72.         reader needs to be interrupted.</font>
<font color="green">  73.     &quot;&quot;&quot;</font>
<font color="green">  74.     def __init__(self, fileobj, transfer_coordinator):</font>
<font color="red">  75.         self._fileobj = fileobj</font>
<font color="red">  76.         self._transfer_coordinator = transfer_coordinator</font>
<font color="black">  77. </font>
<font color="green">  78.     def read(self, amount=None):</font>
<font color="black">  79.         # If there is an exception, then raise the exception.</font>
<font color="black">  80.         # We raise an error instead of returning no bytes because for</font>
<font color="black">  81.         # requests where the content length and md5 was sent, it will</font>
<font color="black">  82.         # cause md5 mismatches and retries as there was no indication that</font>
<font color="black">  83.         # the stream being read from encountered any issues.</font>
<font color="red">  84.         if self._transfer_coordinator.exception:</font>
<font color="red">  85.             raise self._transfer_coordinator.exception</font>
<font color="red">  86.         return self._fileobj.read(amount)</font>
<font color="black">  87. </font>
<font color="green">  88.     def seek(self, where):</font>
<font color="red">  89.         self._fileobj.seek(where)</font>
<font color="black">  90. </font>
<font color="green">  91.     def tell(self):</font>
<font color="red">  92.         return self._fileobj.tell()</font>
<font color="black">  93. </font>
<font color="green">  94.     def close(self):</font>
<font color="red">  95.         self._fileobj.close()</font>
<font color="black">  96. </font>
<font color="green">  97.     def __enter__(self):</font>
<font color="red">  98.         return self</font>
<font color="black">  99. </font>
<font color="green"> 100.     def __exit__(self, *args, **kwargs):</font>
<font color="red"> 101.         self.close()</font>
<font color="black"> 102. </font>
<font color="black"> 103. </font>
<font color="green"> 104. class UploadInputManager(object):</font>
<font color="black"> 105.     &quot;&quot;&quot;Base manager class for handling various types of files for uploads</font>
<font color="black"> 106. </font>
<font color="black"> 107.     This class is typically used for the UploadSubmissionTask class to help</font>
<font color="black"> 108.     determine the following:</font>
<font color="black"> 109. </font>
<font color="black"> 110.         * How to determine the size of the file</font>
<font color="black"> 111.         * How to determine if a multipart upload is required</font>
<font color="black"> 112.         * How to retrieve the body for a PutObject</font>
<font color="black"> 113.         * How to retrieve the bodies for a set of UploadParts</font>
<font color="black"> 114. </font>
<font color="black"> 115.     The answers/implementations differ for the various types of file inputs</font>
<font color="black"> 116.     that may be accepted. All implementations must subclass and override</font>
<font color="black"> 117.     public methods from this class.</font>
<font color="green"> 118.     &quot;&quot;&quot;</font>
<font color="green"> 119.     def __init__(self, osutil, transfer_coordinator, bandwidth_limiter=None):</font>
<font color="red"> 120.         self._osutil = osutil</font>
<font color="red"> 121.         self._transfer_coordinator = transfer_coordinator</font>
<font color="red"> 122.         self._bandwidth_limiter = bandwidth_limiter</font>
<font color="black"> 123. </font>
<font color="green"> 124.     @classmethod</font>
<font color="black"> 125.     def is_compatible(cls, upload_source):</font>
<font color="black"> 126.         &quot;&quot;&quot;Determines if the source for the upload is compatible with manager</font>
<font color="black"> 127. </font>
<font color="black"> 128.         :param upload_source: The source for which the upload will pull data</font>
<font color="black"> 129.             from.</font>
<font color="black"> 130. </font>
<font color="black"> 131.         :returns: True if the manager can handle the type of source specified</font>
<font color="black"> 132.             otherwise returns False.</font>
<font color="black"> 133.         &quot;&quot;&quot;</font>
<font color="red"> 134.         raise NotImplementedError('must implement _is_compatible()')</font>
<font color="black"> 135. </font>
<font color="green"> 136.     def stores_body_in_memory(self, operation_name):</font>
<font color="black"> 137.         &quot;&quot;&quot;Whether the body it provides are stored in-memory</font>
<font color="black"> 138. </font>
<font color="black"> 139.         :type operation_name: str</font>
<font color="black"> 140.         :param operation_name: The name of the client operation that the body</font>
<font color="black"> 141.             is being used for. Valid operation_names are ``put_object`` and</font>
<font color="black"> 142.             ``upload_part``.</font>
<font color="black"> 143. </font>
<font color="black"> 144.         :rtype: boolean</font>
<font color="black"> 145.         :returns: True if the body returned by the manager will be stored in</font>
<font color="black"> 146.             memory. False if the manager will not directly store the body in</font>
<font color="black"> 147.             memory.</font>
<font color="black"> 148.         &quot;&quot;&quot;</font>
<font color="red"> 149.         raise NotImplemented('must implement store_body_in_memory()')</font>
<font color="black"> 150. </font>
<font color="green"> 151.     def provide_transfer_size(self, transfer_future):</font>
<font color="black"> 152.         &quot;&quot;&quot;Provides the transfer size of an upload</font>
<font color="black"> 153. </font>
<font color="black"> 154.         :type transfer_future: s3transfer.futures.TransferFuture</font>
<font color="black"> 155.         :param transfer_future: The future associated with upload request</font>
<font color="black"> 156.         &quot;&quot;&quot;</font>
<font color="red"> 157.         raise NotImplementedError('must implement provide_transfer_size()')</font>
<font color="black"> 158. </font>
<font color="green"> 159.     def requires_multipart_upload(self, transfer_future, config):</font>
<font color="black"> 160.         &quot;&quot;&quot;Determines where a multipart upload is required</font>
<font color="black"> 161. </font>
<font color="black"> 162.         :type transfer_future: s3transfer.futures.TransferFuture</font>
<font color="black"> 163.         :param transfer_future: The future associated with upload request</font>
<font color="black"> 164. </font>
<font color="black"> 165.         :type config: s3transfer.manager.TransferConfig</font>
<font color="black"> 166.         :param config: The config associated to the transfer manager</font>
<font color="black"> 167. </font>
<font color="black"> 168.         :rtype: boolean</font>
<font color="black"> 169.         :returns: True, if the upload should be multipart based on</font>
<font color="black"> 170.             configuartion and size. False, otherwise.</font>
<font color="black"> 171.         &quot;&quot;&quot;</font>
<font color="red"> 172.         raise NotImplementedError('must implement requires_multipart_upload()')</font>
<font color="black"> 173. </font>
<font color="green"> 174.     def get_put_object_body(self, transfer_future):</font>
<font color="black"> 175.         &quot;&quot;&quot;Returns the body to use for PutObject</font>
<font color="black"> 176. </font>
<font color="black"> 177.         :type transfer_future: s3transfer.futures.TransferFuture</font>
<font color="black"> 178.         :param transfer_future: The future associated with upload request</font>
<font color="black"> 179. </font>
<font color="black"> 180.         :type config: s3transfer.manager.TransferConfig</font>
<font color="black"> 181.         :param config: The config associated to the transfer manager</font>
<font color="black"> 182. </font>
<font color="black"> 183.         :rtype: s3transfer.utils.ReadFileChunk</font>
<font color="black"> 184.         :returns: A ReadFileChunk including all progress callbacks</font>
<font color="black"> 185.             associated with the transfer future.</font>
<font color="black"> 186.         &quot;&quot;&quot;</font>
<font color="red"> 187.         raise NotImplementedError('must implement get_put_object_body()')</font>
<font color="black"> 188. </font>
<font color="green"> 189.     def yield_upload_part_bodies(self, transfer_future, chunksize):</font>
<font color="black"> 190.         &quot;&quot;&quot;Yields the part number and body to use for each UploadPart</font>
<font color="black"> 191. </font>
<font color="black"> 192.         :type transfer_future: s3transfer.futures.TransferFuture</font>
<font color="black"> 193.         :param transfer_future: The future associated with upload request</font>
<font color="black"> 194. </font>
<font color="black"> 195.         :type chunksize: int</font>
<font color="black"> 196.         :param chunksize: The chunksize to use for this upload.</font>
<font color="black"> 197. </font>
<font color="black"> 198.         :rtype: int, s3transfer.utils.ReadFileChunk</font>
<font color="black"> 199.         :returns: Yields the part number and the ReadFileChunk including all</font>
<font color="black"> 200.             progress callbacks associated with the transfer future for that</font>
<font color="black"> 201.             specific yielded part.</font>
<font color="black"> 202.         &quot;&quot;&quot;</font>
<font color="red"> 203.         raise NotImplementedError('must implement yield_upload_part_bodies()')</font>
<font color="black"> 204. </font>
<font color="green"> 205.     def _wrap_fileobj(self, fileobj):</font>
<font color="red"> 206.         fileobj = InterruptReader(fileobj, self._transfer_coordinator)</font>
<font color="red"> 207.         if self._bandwidth_limiter:</font>
<font color="red"> 208.             fileobj = self._bandwidth_limiter.get_bandwith_limited_stream(</font>
<font color="red"> 209.                 fileobj, self._transfer_coordinator, enabled=False)</font>
<font color="red"> 210.         return fileobj</font>
<font color="black"> 211. </font>
<font color="green"> 212.     def _get_progress_callbacks(self, transfer_future):</font>
<font color="red"> 213.         callbacks = get_callbacks(transfer_future, 'progress')</font>
<font color="black"> 214.         # We only want to be wrapping the callbacks if there are callbacks to</font>
<font color="black"> 215.         # invoke because we do not want to be doing any unnecessary work if</font>
<font color="black"> 216.         # there are no callbacks to invoke.</font>
<font color="red"> 217.         if callbacks:</font>
<font color="red"> 218.             return [AggregatedProgressCallback(callbacks)]</font>
<font color="red"> 219.         return []</font>
<font color="black"> 220. </font>
<font color="green"> 221.     def _get_close_callbacks(self, aggregated_progress_callbacks):</font>
<font color="red"> 222.         return [callback.flush for callback in aggregated_progress_callbacks]</font>
<font color="black"> 223. </font>
<font color="black"> 224. </font>
<font color="green"> 225. class UploadFilenameInputManager(UploadInputManager):</font>
<font color="green"> 226.     &quot;&quot;&quot;Upload utility for filenames&quot;&quot;&quot;</font>
<font color="green"> 227.     @classmethod</font>
<font color="black"> 228.     def is_compatible(cls, upload_source):</font>
<font color="red"> 229.         return isinstance(upload_source, six.string_types)</font>
<font color="black"> 230. </font>
<font color="green"> 231.     def stores_body_in_memory(self, operation_name):</font>
<font color="red"> 232.         return False</font>
<font color="black"> 233. </font>
<font color="green"> 234.     def provide_transfer_size(self, transfer_future):</font>
<font color="red"> 235.         transfer_future.meta.provide_transfer_size(</font>
<font color="red"> 236.             self._osutil.get_file_size(</font>
<font color="red"> 237.                 transfer_future.meta.call_args.fileobj))</font>
<font color="black"> 238. </font>
<font color="green"> 239.     def requires_multipart_upload(self, transfer_future, config):</font>
<font color="red"> 240.         return transfer_future.meta.size &gt;= config.multipart_threshold</font>
<font color="black"> 241. </font>
<font color="green"> 242.     def get_put_object_body(self, transfer_future):</font>
<font color="black"> 243.         # Get a file-like object for the given input</font>
<font color="red"> 244.         fileobj, full_size = self._get_put_object_fileobj_with_full_size(</font>
<font color="red"> 245.             transfer_future)</font>
<font color="black"> 246. </font>
<font color="black"> 247.         # Wrap fileobj with interrupt reader that will quickly cancel</font>
<font color="black"> 248.         # uploads if needed instead of having to wait for the socket</font>
<font color="black"> 249.         # to completely read all of the data.</font>
<font color="red"> 250.         fileobj = self._wrap_fileobj(fileobj)</font>
<font color="black"> 251. </font>
<font color="red"> 252.         callbacks = self._get_progress_callbacks(transfer_future)</font>
<font color="red"> 253.         close_callbacks = self._get_close_callbacks(callbacks)</font>
<font color="red"> 254.         size = transfer_future.meta.size</font>
<font color="black"> 255.         # Return the file-like object wrapped into a ReadFileChunk to get</font>
<font color="black"> 256.         # progress.</font>
<font color="red"> 257.         return self._osutil.open_file_chunk_reader_from_fileobj(</font>
<font color="red"> 258.             fileobj=fileobj, chunk_size=size, full_file_size=full_size,</font>
<font color="red"> 259.             callbacks=callbacks, close_callbacks=close_callbacks)</font>
<font color="black"> 260. </font>
<font color="green"> 261.     def yield_upload_part_bodies(self, transfer_future, chunksize):</font>
<font color="red"> 262.         full_file_size = transfer_future.meta.size</font>
<font color="red"> 263.         num_parts = self._get_num_parts(transfer_future, chunksize)</font>
<font color="red"> 264.         for part_number in range(1, num_parts + 1):</font>
<font color="red"> 265.             callbacks = self._get_progress_callbacks(transfer_future)</font>
<font color="red"> 266.             close_callbacks = self._get_close_callbacks(callbacks)</font>
<font color="red"> 267.             start_byte = chunksize * (part_number - 1)</font>
<font color="black"> 268.             # Get a file-like object for that part and the size of the full</font>
<font color="black"> 269.             # file size for the associated file-like object for that part.</font>
<font color="red"> 270.             fileobj, full_size = self._get_upload_part_fileobj_with_full_size(</font>
<font color="red"> 271.                 transfer_future.meta.call_args.fileobj, start_byte=start_byte,</font>
<font color="red"> 272.                 part_size=chunksize, full_file_size=full_file_size)</font>
<font color="black"> 273. </font>
<font color="black"> 274.             # Wrap fileobj with interrupt reader that will quickly cancel</font>
<font color="black"> 275.             # uploads if needed instead of having to wait for the socket</font>
<font color="black"> 276.             # to completely read all of the data.</font>
<font color="red"> 277.             fileobj = self._wrap_fileobj(fileobj)</font>
<font color="black"> 278. </font>
<font color="black"> 279.             # Wrap the file-like object into a ReadFileChunk to get progress.</font>
<font color="red"> 280.             read_file_chunk = self._osutil.open_file_chunk_reader_from_fileobj(</font>
<font color="red"> 281.                 fileobj=fileobj, chunk_size=chunksize,</font>
<font color="red"> 282.                 full_file_size=full_size, callbacks=callbacks,</font>
<font color="red"> 283.                 close_callbacks=close_callbacks)</font>
<font color="red"> 284.             yield part_number, read_file_chunk</font>
<font color="black"> 285. </font>
<font color="green"> 286.     def _get_deferred_open_file(self, fileobj, start_byte):</font>
<font color="red"> 287.         fileobj = DeferredOpenFile(</font>
<font color="red"> 288.             fileobj, start_byte, open_function=self._osutil.open)</font>
<font color="red"> 289.         return fileobj</font>
<font color="black"> 290. </font>
<font color="green"> 291.     def _get_put_object_fileobj_with_full_size(self, transfer_future):</font>
<font color="red"> 292.         fileobj = transfer_future.meta.call_args.fileobj</font>
<font color="red"> 293.         size = transfer_future.meta.size</font>
<font color="red"> 294.         return self._get_deferred_open_file(fileobj, 0), size</font>
<font color="black"> 295. </font>
<font color="green"> 296.     def _get_upload_part_fileobj_with_full_size(self, fileobj, **kwargs):</font>
<font color="red"> 297.         start_byte = kwargs['start_byte']</font>
<font color="red"> 298.         full_size = kwargs['full_file_size']</font>
<font color="red"> 299.         return self._get_deferred_open_file(fileobj, start_byte), full_size</font>
<font color="black"> 300. </font>
<font color="green"> 301.     def _get_num_parts(self, transfer_future, part_size):</font>
<font color="red"> 302.         return int(</font>
<font color="red"> 303.             math.ceil(transfer_future.meta.size / float(part_size)))</font>
<font color="black"> 304. </font>
<font color="black"> 305. </font>
<font color="green"> 306. class UploadSeekableInputManager(UploadFilenameInputManager):</font>
<font color="green"> 307.     &quot;&quot;&quot;Upload utility for an open file object&quot;&quot;&quot;</font>
<font color="green"> 308.     @classmethod</font>
<font color="black"> 309.     def is_compatible(cls, upload_source):</font>
<font color="red"> 310.         return readable(upload_source) and seekable(upload_source)</font>
<font color="black"> 311. </font>
<font color="green"> 312.     def stores_body_in_memory(self, operation_name):</font>
<font color="red"> 313.         if operation_name == 'put_object':</font>
<font color="red"> 314.             return False</font>
<font color="black"> 315.         else:</font>
<font color="red"> 316.             return True</font>
<font color="black"> 317. </font>
<font color="green"> 318.     def provide_transfer_size(self, transfer_future):</font>
<font color="red"> 319.         fileobj = transfer_future.meta.call_args.fileobj</font>
<font color="black"> 320.         # To determine size, first determine the starting position</font>
<font color="black"> 321.         # Seek to the end and then find the difference in the length</font>
<font color="black"> 322.         # between the end and start positions.</font>
<font color="red"> 323.         start_position = fileobj.tell()</font>
<font color="red"> 324.         fileobj.seek(0, 2)</font>
<font color="red"> 325.         end_position = fileobj.tell()</font>
<font color="red"> 326.         fileobj.seek(start_position)</font>
<font color="red"> 327.         transfer_future.meta.provide_transfer_size(</font>
<font color="red"> 328.             end_position - start_position)</font>
<font color="black"> 329. </font>
<font color="green"> 330.     def _get_upload_part_fileobj_with_full_size(self, fileobj, **kwargs):</font>
<font color="black"> 331.         # Note: It is unfortunate that in order to do a multithreaded</font>
<font color="black"> 332.         # multipart upload we cannot simply copy the filelike object</font>
<font color="black"> 333.         # since there is not really a mechanism in python (i.e. os.dup</font>
<font color="black"> 334.         # points to the same OS filehandle which causes concurrency</font>
<font color="black"> 335.         # issues). So instead we need to read from the fileobj and</font>
<font color="black"> 336.         # chunk the data out to seperate file-like objects in memory.</font>
<font color="red"> 337.         data = fileobj.read(kwargs['part_size'])</font>
<font color="black"> 338.         # We return the length of the data instead of the full_file_size</font>
<font color="black"> 339.         # because we partitioned the data into seperate BytesIO objects</font>
<font color="black"> 340.         # meaning the BytesIO object has no knowledge of its start position</font>
<font color="black"> 341.         # relative the input source nor access to the rest of the input</font>
<font color="black"> 342.         # source. So we must treat it as its own standalone file.</font>
<font color="red"> 343.         return six.BytesIO(data), len(data)</font>
<font color="black"> 344. </font>
<font color="green"> 345.     def _get_put_object_fileobj_with_full_size(self, transfer_future):</font>
<font color="red"> 346.         fileobj = transfer_future.meta.call_args.fileobj</font>
<font color="black"> 347.         # The current position needs to be taken into account when retrieving</font>
<font color="black"> 348.         # the full size of the file.</font>
<font color="red"> 349.         size = fileobj.tell() + transfer_future.meta.size</font>
<font color="red"> 350.         return fileobj, size</font>
<font color="black"> 351. </font>
<font color="black"> 352. </font>
<font color="green"> 353. class UploadNonSeekableInputManager(UploadInputManager):</font>
<font color="green"> 354.     &quot;&quot;&quot;Upload utility for a file-like object that cannot seek.&quot;&quot;&quot;</font>
<font color="green"> 355.     def __init__(self, osutil, transfer_coordinator, bandwidth_limiter=None):</font>
<font color="red"> 356.         super(UploadNonSeekableInputManager, self).__init__(</font>
<font color="red"> 357.             osutil, transfer_coordinator, bandwidth_limiter)</font>
<font color="red"> 358.         self._initial_data = b''</font>
<font color="black"> 359. </font>
<font color="green"> 360.     @classmethod</font>
<font color="black"> 361.     def is_compatible(cls, upload_source):</font>
<font color="red"> 362.         return readable(upload_source)</font>
<font color="black"> 363. </font>
<font color="green"> 364.     def stores_body_in_memory(self, operation_name):</font>
<font color="red"> 365.         return True</font>
<font color="black"> 366. </font>
<font color="green"> 367.     def provide_transfer_size(self, transfer_future):</font>
<font color="black"> 368.         # No-op because there is no way to do this short of reading the entire</font>
<font color="black"> 369.         # body into memory.</font>
<font color="red"> 370.         return</font>
<font color="black"> 371. </font>
<font color="green"> 372.     def requires_multipart_upload(self, transfer_future, config):</font>
<font color="black"> 373.         # If the user has set the size, we can use that.</font>
<font color="red"> 374.         if transfer_future.meta.size is not None:</font>
<font color="red"> 375.             return transfer_future.meta.size &gt;= config.multipart_threshold</font>
<font color="black"> 376. </font>
<font color="black"> 377.         # This is tricky to determine in this case because we can't know how</font>
<font color="black"> 378.         # large the input is. So to figure it out, we read data into memory</font>
<font color="black"> 379.         # up until the threshold and compare how much data was actually read</font>
<font color="black"> 380.         # against the threshold.</font>
<font color="red"> 381.         fileobj = transfer_future.meta.call_args.fileobj</font>
<font color="red"> 382.         threshold = config.multipart_threshold</font>
<font color="red"> 383.         self._initial_data = self._read(fileobj, threshold, False)</font>
<font color="red"> 384.         if len(self._initial_data) &lt; threshold:</font>
<font color="red"> 385.             return False</font>
<font color="black"> 386.         else:</font>
<font color="red"> 387.             return True</font>
<font color="black"> 388. </font>
<font color="green"> 389.     def get_put_object_body(self, transfer_future):</font>
<font color="red"> 390.         callbacks = self._get_progress_callbacks(transfer_future)</font>
<font color="red"> 391.         close_callbacks = self._get_close_callbacks(callbacks)</font>
<font color="red"> 392.         fileobj = transfer_future.meta.call_args.fileobj</font>
<font color="black"> 393. </font>
<font color="red"> 394.         body = self._wrap_data(</font>
<font color="red"> 395.             self._initial_data + fileobj.read(), callbacks, close_callbacks)</font>
<font color="black"> 396. </font>
<font color="black"> 397.         # Zero out the stored data so we don't have additional copies</font>
<font color="black"> 398.         # hanging around in memory.</font>
<font color="red"> 399.         self._initial_data = None</font>
<font color="red"> 400.         return body</font>
<font color="black"> 401. </font>
<font color="green"> 402.     def yield_upload_part_bodies(self, transfer_future, chunksize):</font>
<font color="red"> 403.         file_object = transfer_future.meta.call_args.fileobj</font>
<font color="red"> 404.         part_number = 0</font>
<font color="black"> 405. </font>
<font color="black"> 406.         # Continue reading parts from the file-like object until it is empty.</font>
<font color="red"> 407.         while True:</font>
<font color="red"> 408.             callbacks = self._get_progress_callbacks(transfer_future)</font>
<font color="red"> 409.             close_callbacks = self._get_close_callbacks(callbacks)</font>
<font color="red"> 410.             part_number += 1</font>
<font color="red"> 411.             part_content = self._read(file_object, chunksize)</font>
<font color="red"> 412.             if not part_content:</font>
<font color="red"> 413.                 break</font>
<font color="red"> 414.             part_object = self._wrap_data(</font>
<font color="red"> 415.                 part_content, callbacks, close_callbacks)</font>
<font color="black"> 416. </font>
<font color="black"> 417.             # Zero out part_content to avoid hanging on to additional data.</font>
<font color="red"> 418.             part_content = None</font>
<font color="red"> 419.             yield part_number, part_object</font>
<font color="black"> 420. </font>
<font color="green"> 421.     def _read(self, fileobj, amount, truncate=True):</font>
<font color="black"> 422.         &quot;&quot;&quot;</font>
<font color="black"> 423.         Reads a specific amount of data from a stream and returns it. If there</font>
<font color="black"> 424.         is any data in initial_data, that will be popped out first.</font>
<font color="black"> 425. </font>
<font color="black"> 426.         :type fileobj: A file-like object that implements read</font>
<font color="black"> 427.         :param fileobj: The stream to read from.</font>
<font color="black"> 428. </font>
<font color="black"> 429.         :type amount: int</font>
<font color="black"> 430.         :param amount: The number of bytes to read from the stream.</font>
<font color="black"> 431. </font>
<font color="black"> 432.         :type truncate: bool</font>
<font color="black"> 433.         :param truncate: Whether or not to truncate initial_data after</font>
<font color="black"> 434.             reading from it.</font>
<font color="black"> 435. </font>
<font color="black"> 436.         :return: Generator which generates part bodies from the initial data.</font>
<font color="black"> 437.         &quot;&quot;&quot;</font>
<font color="black"> 438.         # If the the initial data is empty, we simply read from the fileobj</font>
<font color="red"> 439.         if len(self._initial_data) == 0:</font>
<font color="red"> 440.             return fileobj.read(amount)</font>
<font color="black"> 441. </font>
<font color="black"> 442.         # If the requested number of bytes is less thant the amount of</font>
<font color="black"> 443.         # initial data, pull entirely from initial data.</font>
<font color="red"> 444.         if amount &lt;= len(self._initial_data):</font>
<font color="red"> 445.             data = self._initial_data[:amount]</font>
<font color="black"> 446.             # Truncate initial data so we don't hang onto the data longer</font>
<font color="black"> 447.             # than we need.</font>
<font color="red"> 448.             if truncate:</font>
<font color="red"> 449.                 self._initial_data = self._initial_data[amount:]</font>
<font color="red"> 450.             return data</font>
<font color="black"> 451. </font>
<font color="black"> 452.         # At this point there is some initial data left, but not enough to</font>
<font color="black"> 453.         # satisfy the number of bytes requested. Pull out the remaining</font>
<font color="black"> 454.         # initial data and read the rest from the fileobj.</font>
<font color="red"> 455.         amount_to_read = amount - len(self._initial_data)</font>
<font color="red"> 456.         data = self._initial_data + fileobj.read(amount_to_read)</font>
<font color="black"> 457. </font>
<font color="black"> 458.         # Zero out initial data so we don't hang onto the data any more.</font>
<font color="red"> 459.         if truncate:</font>
<font color="red"> 460.             self._initial_data = b''</font>
<font color="red"> 461.         return data</font>
<font color="black"> 462. </font>
<font color="green"> 463.     def _wrap_data(self, data, callbacks, close_callbacks):</font>
<font color="black"> 464.         &quot;&quot;&quot;</font>
<font color="black"> 465.         Wraps data with the interrupt reader and the file chunk reader.</font>
<font color="black"> 466. </font>
<font color="black"> 467.         :type data: bytes</font>
<font color="black"> 468.         :param data: The data to wrap.</font>
<font color="black"> 469. </font>
<font color="black"> 470.         :type callbacks: list</font>
<font color="black"> 471.         :param callbacks: The callbacks associated with the transfer future.</font>
<font color="black"> 472. </font>
<font color="black"> 473.         :type close_callbacks: list</font>
<font color="black"> 474.         :param close_callbacks: The callbacks to be called when closing the</font>
<font color="black"> 475.             wrapper for the data.</font>
<font color="black"> 476. </font>
<font color="black"> 477.         :return: Fully wrapped data.</font>
<font color="black"> 478.         &quot;&quot;&quot;</font>
<font color="red"> 479.         fileobj = self._wrap_fileobj(six.BytesIO(data))</font>
<font color="red"> 480.         return self._osutil.open_file_chunk_reader_from_fileobj(</font>
<font color="red"> 481.             fileobj=fileobj, chunk_size=len(data), full_file_size=len(data),</font>
<font color="red"> 482.             callbacks=callbacks, close_callbacks=close_callbacks)</font>
<font color="black"> 483. </font>
<font color="black"> 484. </font>
<font color="green"> 485. class UploadSubmissionTask(SubmissionTask):</font>
<font color="green"> 486.     &quot;&quot;&quot;Task for submitting tasks to execute an upload&quot;&quot;&quot;</font>
<font color="black"> 487. </font>
<font color="black"> 488.     UPLOAD_PART_ARGS = [</font>
<font color="green"> 489.         'SSECustomerKey',</font>
<font color="green"> 490.         'SSECustomerAlgorithm',</font>
<font color="green"> 491.         'SSECustomerKeyMD5',</font>
<font color="green"> 492.         'RequestPayer',</font>
<font color="black"> 493.     ]</font>
<font color="black"> 494. </font>
<font color="black"> 495.     COMPLETE_MULTIPART_ARGS = [</font>
<font color="green"> 496.         'RequestPayer'</font>
<font color="black"> 497.     ]</font>
<font color="black"> 498. </font>
<font color="green"> 499.     def _get_upload_input_manager_cls(self, transfer_future):</font>
<font color="black"> 500.         &quot;&quot;&quot;Retieves a class for managing input for an upload based on file type</font>
<font color="black"> 501. </font>
<font color="black"> 502.         :type transfer_future: s3transfer.futures.TransferFuture</font>
<font color="black"> 503.         :param transfer_future: The transfer future for the request</font>
<font color="black"> 504. </font>
<font color="black"> 505.         :rtype: class of UploadInputManager</font>
<font color="black"> 506.         :returns: The appropriate class to use for managing a specific type of</font>
<font color="black"> 507.             input for uploads.</font>
<font color="black"> 508.         &quot;&quot;&quot;</font>
<font color="black"> 509.         upload_manager_resolver_chain = [</font>
<font color="red"> 510.             UploadFilenameInputManager,</font>
<font color="red"> 511.             UploadSeekableInputManager,</font>
<font color="red"> 512.             UploadNonSeekableInputManager</font>
<font color="black"> 513.         ]</font>
<font color="black"> 514. </font>
<font color="red"> 515.         fileobj = transfer_future.meta.call_args.fileobj</font>
<font color="red"> 516.         for upload_manager_cls in upload_manager_resolver_chain:</font>
<font color="red"> 517.             if upload_manager_cls.is_compatible(fileobj):</font>
<font color="red"> 518.                 return upload_manager_cls</font>
<font color="red"> 519.         raise RuntimeError(</font>
<font color="red"> 520.             'Input %s of type: %s is not supported.' % (</font>
<font color="red"> 521.                 fileobj, type(fileobj)))</font>
<font color="black"> 522. </font>
<font color="black"> 523.     def _submit(self, client, config, osutil, request_executor,</font>
<font color="green"> 524.                 transfer_future, bandwidth_limiter=None):</font>
<font color="black"> 525.         &quot;&quot;&quot;</font>
<font color="black"> 526.         :param client: The client associated with the transfer manager</font>
<font color="black"> 527. </font>
<font color="black"> 528.         :type config: s3transfer.manager.TransferConfig</font>
<font color="black"> 529.         :param config: The transfer config associated with the transfer</font>
<font color="black"> 530.             manager</font>
<font color="black"> 531. </font>
<font color="black"> 532.         :type osutil: s3transfer.utils.OSUtil</font>
<font color="black"> 533.         :param osutil: The os utility associated to the transfer manager</font>
<font color="black"> 534. </font>
<font color="black"> 535.         :type request_executor: s3transfer.futures.BoundedExecutor</font>
<font color="black"> 536.         :param request_executor: The request executor associated with the</font>
<font color="black"> 537.             transfer manager</font>
<font color="black"> 538. </font>
<font color="black"> 539.         :type transfer_future: s3transfer.futures.TransferFuture</font>
<font color="black"> 540.         :param transfer_future: The transfer future associated with the</font>
<font color="black"> 541.             transfer request that tasks are being submitted for</font>
<font color="black"> 542.         &quot;&quot;&quot;</font>
<font color="red"> 543.         upload_input_manager = self._get_upload_input_manager_cls(</font>
<font color="red"> 544.             transfer_future)(</font>
<font color="red"> 545.                 osutil, self._transfer_coordinator, bandwidth_limiter)</font>
<font color="black"> 546. </font>
<font color="black"> 547.         # Determine the size if it was not provided</font>
<font color="red"> 548.         if transfer_future.meta.size is None:</font>
<font color="red"> 549.             upload_input_manager.provide_transfer_size(transfer_future)</font>
<font color="black"> 550. </font>
<font color="black"> 551.         # Do a multipart upload if needed, otherwise do a regular put object.</font>
<font color="red"> 552.         if not upload_input_manager.requires_multipart_upload(</font>
<font color="red"> 553.                 transfer_future, config):</font>
<font color="red"> 554.             self._submit_upload_request(</font>
<font color="red"> 555.                 client, config, osutil, request_executor, transfer_future,</font>
<font color="red"> 556.                 upload_input_manager)</font>
<font color="black"> 557.         else:</font>
<font color="red"> 558.             self._submit_multipart_request(</font>
<font color="red"> 559.                 client, config, osutil, request_executor, transfer_future,</font>
<font color="red"> 560.                 upload_input_manager)</font>
<font color="black"> 561. </font>
<font color="green"> 562.     def _submit_upload_request(self, client, config, osutil, request_executor,</font>
<font color="black"> 563.                                transfer_future, upload_input_manager):</font>
<font color="red"> 564.         call_args = transfer_future.meta.call_args</font>
<font color="black"> 565. </font>
<font color="black"> 566.         # Get any tags that need to be associated to the put object task</font>
<font color="red"> 567.         put_object_tag = self._get_upload_task_tag(</font>
<font color="red"> 568.             upload_input_manager, 'put_object')</font>
<font color="black"> 569. </font>
<font color="black"> 570.         # Submit the request of a single upload.</font>
<font color="red"> 571.         self._transfer_coordinator.submit(</font>
<font color="red"> 572.             request_executor,</font>
<font color="red"> 573.             PutObjectTask(</font>
<font color="red"> 574.                 transfer_coordinator=self._transfer_coordinator,</font>
<font color="red"> 575.                 main_kwargs={</font>
<font color="red"> 576.                     'client': client,</font>
<font color="red"> 577.                     'fileobj': upload_input_manager.get_put_object_body(</font>
<font color="red"> 578.                         transfer_future),</font>
<font color="red"> 579.                     'bucket': call_args.bucket,</font>
<font color="red"> 580.                     'key': call_args.key,</font>
<font color="red"> 581.                     'extra_args': call_args.extra_args</font>
<font color="black"> 582.                 },</font>
<font color="red"> 583.                 is_final=True</font>
<font color="black"> 584.             ),</font>
<font color="red"> 585.             tag=put_object_tag</font>
<font color="black"> 586.         )</font>
<font color="black"> 587. </font>
<font color="green"> 588.     def _submit_multipart_request(self, client, config, osutil,</font>
<font color="black"> 589.                                   request_executor, transfer_future,</font>
<font color="black"> 590.                                   upload_input_manager):</font>
<font color="red"> 591.         call_args = transfer_future.meta.call_args</font>
<font color="black"> 592. </font>
<font color="black"> 593.         # Submit the request to create a multipart upload.</font>
<font color="red"> 594.         create_multipart_future = self._transfer_coordinator.submit(</font>
<font color="red"> 595.             request_executor,</font>
<font color="red"> 596.             CreateMultipartUploadTask(</font>
<font color="red"> 597.                 transfer_coordinator=self._transfer_coordinator,</font>
<font color="red"> 598.                 main_kwargs={</font>
<font color="red"> 599.                     'client': client,</font>
<font color="red"> 600.                     'bucket': call_args.bucket,</font>
<font color="red"> 601.                     'key': call_args.key,</font>
<font color="red"> 602.                     'extra_args': call_args.extra_args,</font>
<font color="black"> 603.                 }</font>
<font color="black"> 604.             )</font>
<font color="black"> 605.         )</font>
<font color="black"> 606. </font>
<font color="black"> 607.         # Submit requests to upload the parts of the file.</font>
<font color="red"> 608.         part_futures = []</font>
<font color="red"> 609.         extra_part_args = self._extra_upload_part_args(call_args.extra_args)</font>
<font color="black"> 610. </font>
<font color="black"> 611.         # Get any tags that need to be associated to the submitted task</font>
<font color="black"> 612.         # for upload the data</font>
<font color="red"> 613.         upload_part_tag = self._get_upload_task_tag(</font>
<font color="red"> 614.             upload_input_manager, 'upload_part')</font>
<font color="black"> 615. </font>
<font color="red"> 616.         size = transfer_future.meta.size</font>
<font color="red"> 617.         adjuster = ChunksizeAdjuster()</font>
<font color="red"> 618.         chunksize = adjuster.adjust_chunksize(config.multipart_chunksize, size)</font>
<font color="red"> 619.         part_iterator = upload_input_manager.yield_upload_part_bodies(</font>
<font color="red"> 620.             transfer_future, chunksize)</font>
<font color="black"> 621. </font>
<font color="red"> 622.         for part_number, fileobj in part_iterator:</font>
<font color="red"> 623.             part_futures.append(</font>
<font color="red"> 624.                 self._transfer_coordinator.submit(</font>
<font color="red"> 625.                     request_executor,</font>
<font color="red"> 626.                     UploadPartTask(</font>
<font color="red"> 627.                         transfer_coordinator=self._transfer_coordinator,</font>
<font color="red"> 628.                         main_kwargs={</font>
<font color="red"> 629.                             'client': client,</font>
<font color="red"> 630.                             'fileobj': fileobj,</font>
<font color="red"> 631.                             'bucket': call_args.bucket,</font>
<font color="red"> 632.                             'key': call_args.key,</font>
<font color="red"> 633.                             'part_number': part_number,</font>
<font color="red"> 634.                             'extra_args': extra_part_args</font>
<font color="black"> 635.                         },</font>
<font color="red"> 636.                         pending_main_kwargs={</font>
<font color="red"> 637.                             'upload_id': create_multipart_future</font>
<font color="black"> 638.                         }</font>
<font color="black"> 639.                     ),</font>
<font color="red"> 640.                     tag=upload_part_tag</font>
<font color="black"> 641.                 )</font>
<font color="black"> 642.             )</font>
<font color="black"> 643. </font>
<font color="red"> 644.         complete_multipart_extra_args = self._extra_complete_multipart_args(</font>
<font color="red"> 645.             call_args.extra_args)</font>
<font color="black"> 646.         # Submit the request to complete the multipart upload.</font>
<font color="red"> 647.         self._transfer_coordinator.submit(</font>
<font color="red"> 648.             request_executor,</font>
<font color="red"> 649.             CompleteMultipartUploadTask(</font>
<font color="red"> 650.                 transfer_coordinator=self._transfer_coordinator,</font>
<font color="red"> 651.                 main_kwargs={</font>
<font color="red"> 652.                     'client': client,</font>
<font color="red"> 653.                     'bucket': call_args.bucket,</font>
<font color="red"> 654.                     'key': call_args.key,</font>
<font color="red"> 655.                     'extra_args': complete_multipart_extra_args,</font>
<font color="black"> 656.                 },</font>
<font color="red"> 657.                 pending_main_kwargs={</font>
<font color="red"> 658.                     'upload_id': create_multipart_future,</font>
<font color="red"> 659.                     'parts': part_futures</font>
<font color="black"> 660.                 },</font>
<font color="red"> 661.                 is_final=True</font>
<font color="black"> 662.             )</font>
<font color="black"> 663.         )</font>
<font color="black"> 664. </font>
<font color="green"> 665.     def _extra_upload_part_args(self, extra_args):</font>
<font color="black"> 666.         # Only the args in UPLOAD_PART_ARGS actually need to be passed</font>
<font color="black"> 667.         # onto the upload_part calls.</font>
<font color="red"> 668.         return get_filtered_dict(extra_args, self.UPLOAD_PART_ARGS)</font>
<font color="black"> 669. </font>
<font color="green"> 670.     def _extra_complete_multipart_args(self, extra_args):</font>
<font color="red"> 671.         return get_filtered_dict(extra_args, self.COMPLETE_MULTIPART_ARGS)</font>
<font color="black"> 672. </font>
<font color="green"> 673.     def _get_upload_task_tag(self, upload_input_manager, operation_name):</font>
<font color="red"> 674.         tag = None</font>
<font color="red"> 675.         if upload_input_manager.stores_body_in_memory(operation_name):</font>
<font color="red"> 676.             tag = IN_MEMORY_UPLOAD_TAG</font>
<font color="red"> 677.         return tag</font>
<font color="black"> 678. </font>
<font color="black"> 679. </font>
<font color="green"> 680. class PutObjectTask(Task):</font>
<font color="green"> 681.     &quot;&quot;&quot;Task to do a nonmultipart upload&quot;&quot;&quot;</font>
<font color="green"> 682.     def _main(self, client, fileobj, bucket, key, extra_args):</font>
<font color="black"> 683.         &quot;&quot;&quot;</font>
<font color="black"> 684.         :param client: The client to use when calling PutObject</font>
<font color="black"> 685.         :param fileobj: The file to upload.</font>
<font color="black"> 686.         :param bucket: The name of the bucket to upload to</font>
<font color="black"> 687.         :param key: The name of the key to upload to</font>
<font color="black"> 688.         :param extra_args: A dictionary of any extra arguments that may be</font>
<font color="black"> 689.             used in the upload.</font>
<font color="black"> 690.         &quot;&quot;&quot;</font>
<font color="red"> 691.         with fileobj as body:</font>
<font color="red"> 692.             client.put_object(Bucket=bucket, Key=key, Body=body, **extra_args)</font>
<font color="black"> 693. </font>
<font color="black"> 694. </font>
<font color="green"> 695. class UploadPartTask(Task):</font>
<font color="green"> 696.     &quot;&quot;&quot;Task to upload a part in a multipart upload&quot;&quot;&quot;</font>
<font color="green"> 697.     def _main(self, client, fileobj, bucket, key, upload_id, part_number,</font>
<font color="black"> 698.               extra_args):</font>
<font color="black"> 699.         &quot;&quot;&quot;</font>
<font color="black"> 700.         :param client: The client to use when calling PutObject</font>
<font color="black"> 701.         :param fileobj: The file to upload.</font>
<font color="black"> 702.         :param bucket: The name of the bucket to upload to</font>
<font color="black"> 703.         :param key: The name of the key to upload to</font>
<font color="black"> 704.         :param upload_id: The id of the upload</font>
<font color="black"> 705.         :param part_number: The number representing the part of the multipart</font>
<font color="black"> 706.             upload</font>
<font color="black"> 707.         :param extra_args: A dictionary of any extra arguments that may be</font>
<font color="black"> 708.             used in the upload.</font>
<font color="black"> 709. </font>
<font color="black"> 710.         :rtype: dict</font>
<font color="black"> 711.         :returns: A dictionary representing a part::</font>
<font color="black"> 712. </font>
<font color="black"> 713.             {'Etag': etag_value, 'PartNumber': part_number}</font>
<font color="black"> 714. </font>
<font color="black"> 715.             This value can be appended to a list to be used to complete</font>
<font color="black"> 716.             the multipart upload.</font>
<font color="black"> 717.         &quot;&quot;&quot;</font>
<font color="red"> 718.         with fileobj as body:</font>
<font color="red"> 719.             response = client.upload_part(</font>
<font color="red"> 720.                 Bucket=bucket, Key=key,</font>
<font color="red"> 721.                 UploadId=upload_id, PartNumber=part_number,</font>
<font color="red"> 722.                 Body=body, **extra_args)</font>
<font color="red"> 723.         etag = response['ETag']</font>
<font color="red"> 724.         return {'ETag': etag, 'PartNumber': part_number}</font>
</pre>

