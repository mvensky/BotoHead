source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.py</b><br>


file stats: <b>619 lines, 56 executed: 9.0% covered</b>
<pre>
<font color="red">   1. &quot;&quot;&quot;Thread module emulating a subset of Java's threading model.&quot;&quot;&quot;</font>
<font color="black">   2. </font>
<font color="red">   3. import sys as _sys</font>
<font color="black">   4. </font>
<font color="red">   5. try:</font>
<font color="red">   6.     import thread</font>
<font color="red">   7. except ImportError:</font>
<font color="red">   8.     del _sys.modules[__name__]</font>
<font color="red">   9.     raise</font>
<font color="black">  10. </font>
<font color="red">  11. import warnings</font>
<font color="black">  12. </font>
<font color="red">  13. from collections import deque as _deque</font>
<font color="red">  14. from itertools import count as _count</font>
<font color="red">  15. from time import time as _time, sleep as _sleep</font>
<font color="red">  16. from traceback import format_exc as _format_exc</font>
<font color="black">  17. </font>
<font color="black">  18. # Note regarding PEP 8 compliant aliases</font>
<font color="black">  19. #  This threading model was originally inspired by Java, and inherited</font>
<font color="black">  20. # the convention of camelCase function and method names from that</font>
<font color="black">  21. # language. While those names are not in any imminent danger of being</font>
<font color="black">  22. # deprecated, starting with Python 2.6, the module now provides a</font>
<font color="black">  23. # PEP 8 compliant alias for any such method name.</font>
<font color="black">  24. # Using the new PEP 8 compliant names also facilitates substitution</font>
<font color="black">  25. # with the multiprocessing module, which doesn't provide the old</font>
<font color="black">  26. # Java inspired names.</font>
<font color="black">  27. </font>
<font color="black">  28. </font>
<font color="black">  29. # Rename some stuff so &quot;from threading import *&quot; is safe</font>
<font color="red">  30. __all__ = ['activeCount', 'active_count', 'Condition', 'currentThread',</font>
<font color="red">  31.            'current_thread', 'enumerate', 'Event',</font>
<font color="red">  32.            'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Thread',</font>
<font color="red">  33.            'Timer', 'setprofile', 'settrace', 'local', 'stack_size']</font>
<font color="black">  34. </font>
<font color="red">  35. _start_new_thread = thread.start_new_thread</font>
<font color="red">  36. _allocate_lock = thread.allocate_lock</font>
<font color="red">  37. _get_ident = thread.get_ident</font>
<font color="red">  38. ThreadError = thread.error</font>
<font color="red">  39. del thread</font>
<font color="black">  40. </font>
<font color="black">  41. </font>
<font color="black">  42. # sys.exc_clear is used to work around the fact that except blocks</font>
<font color="black">  43. # don't fully clear the exception until 3.0.</font>
<font color="red">  44. warnings.filterwarnings('ignore', category=DeprecationWarning,</font>
<font color="red">  45.                         module='threading', message='sys.exc_clear')</font>
<font color="black">  46. </font>
<font color="black">  47. # Debug support (adapted from ihooks.py).</font>
<font color="black">  48. # All the major classes here derive from _Verbose.  We force that to</font>
<font color="black">  49. # be a new-style class so that all the major classes here are new-style.</font>
<font color="black">  50. # This helps debugging (type(instance) is more revealing for instances</font>
<font color="black">  51. # of new-style classes).</font>
<font color="black">  52. </font>
<font color="red">  53. _VERBOSE = False</font>
<font color="black">  54. </font>
<font color="black">  55. if __debug__:</font>
<font color="black">  56. </font>
<font color="red">  57.     class _Verbose(object):</font>
<font color="black">  58. </font>
<font color="red">  59.         def __init__(self, verbose=None):</font>
<font color="green">  60.             if verbose is None:</font>
<font color="green">  61.                 verbose = _VERBOSE</font>
<font color="green">  62.             self.__verbose = verbose</font>
<font color="black">  63. </font>
<font color="red">  64.         def _note(self, format, *args):</font>
<font color="green">  65.             if self.__verbose:</font>
<font color="red">  66.                 format = format % args</font>
<font color="black">  67.                 # Issue #4188: calling current_thread() can incur an infinite</font>
<font color="black">  68.                 # recursion if it has to create a DummyThread on the fly.</font>
<font color="red">  69.                 ident = _get_ident()</font>
<font color="red">  70.                 try:</font>
<font color="red">  71.                     name = _active[ident].name</font>
<font color="red">  72.                 except KeyError:</font>
<font color="red">  73.                     name = &quot;&lt;OS thread %d&gt;&quot; % ident</font>
<font color="red">  74.                 format = &quot;%s: %s\n&quot; % (name, format)</font>
<font color="red">  75.                 _sys.stderr.write(format)</font>
<font color="black">  76. </font>
<font color="black">  77. else:</font>
<font color="black">  78.     # Disable this when using &quot;python -O&quot;</font>
<font color="black">  79.     class _Verbose(object):</font>
<font color="black">  80.         def __init__(self, verbose=None):</font>
<font color="black">  81.             pass</font>
<font color="black">  82.         def _note(self, *args):</font>
<font color="black">  83.             pass</font>
<font color="black">  84. </font>
<font color="black">  85. # Support for profile and trace hooks</font>
<font color="black">  86. </font>
<font color="red">  87. _profile_hook = None</font>
<font color="red">  88. _trace_hook = None</font>
<font color="black">  89. </font>
<font color="red">  90. def setprofile(func):</font>
<font color="black">  91.     &quot;&quot;&quot;Set a profile function for all threads started from the threading module.</font>
<font color="black">  92. </font>
<font color="black">  93.     The func will be passed to sys.setprofile() for each thread, before its</font>
<font color="black">  94.     run() method is called.</font>
<font color="black">  95. </font>
<font color="black">  96.     &quot;&quot;&quot;</font>
<font color="black">  97.     global _profile_hook</font>
<font color="red">  98.     _profile_hook = func</font>
<font color="black">  99. </font>
<font color="red"> 100. def settrace(func):</font>
<font color="black"> 101.     &quot;&quot;&quot;Set a trace function for all threads started from the threading module.</font>
<font color="black"> 102. </font>
<font color="black"> 103.     The func will be passed to sys.settrace() for each thread, before its run()</font>
<font color="black"> 104.     method is called.</font>
<font color="black"> 105. </font>
<font color="black"> 106.     &quot;&quot;&quot;</font>
<font color="black"> 107.     global _trace_hook</font>
<font color="green"> 108.     _trace_hook = func</font>
<font color="black"> 109. </font>
<font color="black"> 110. # Synchronization classes</font>
<font color="black"> 111. </font>
<font color="red"> 112. Lock = _allocate_lock</font>
<font color="black"> 113. </font>
<font color="red"> 114. def RLock(*args, **kwargs):</font>
<font color="black"> 115.     &quot;&quot;&quot;Factory function that returns a new reentrant lock.</font>
<font color="black"> 116. </font>
<font color="black"> 117.     A reentrant lock must be released by the thread that acquired it. Once a</font>
<font color="black"> 118.     thread has acquired a reentrant lock, the same thread may acquire it again</font>
<font color="black"> 119.     without blocking; the thread must release it once for each time it has</font>
<font color="black"> 120.     acquired it.</font>
<font color="black"> 121. </font>
<font color="black"> 122.     &quot;&quot;&quot;</font>
<font color="green"> 123.     return _RLock(*args, **kwargs)</font>
<font color="black"> 124. </font>
<font color="red"> 125. class _RLock(_Verbose):</font>
<font color="black"> 126.     &quot;&quot;&quot;A reentrant lock must be released by the thread that acquired it. Once a</font>
<font color="black"> 127.        thread has acquired a reentrant lock, the same thread may acquire it</font>
<font color="black"> 128.        again without blocking; the thread must release it once for each time it</font>
<font color="black"> 129.        has acquired it.</font>
<font color="red"> 130.     &quot;&quot;&quot;</font>
<font color="black"> 131. </font>
<font color="red"> 132.     def __init__(self, verbose=None):</font>
<font color="green"> 133.         _Verbose.__init__(self, verbose)</font>
<font color="green"> 134.         self.__block = _allocate_lock()</font>
<font color="green"> 135.         self.__owner = None</font>
<font color="green"> 136.         self.__count = 0</font>
<font color="black"> 137. </font>
<font color="red"> 138.     def __repr__(self):</font>
<font color="red"> 139.         owner = self.__owner</font>
<font color="red"> 140.         try:</font>
<font color="red"> 141.             owner = _active[owner].name</font>
<font color="red"> 142.         except KeyError:</font>
<font color="red"> 143.             pass</font>
<font color="red"> 144.         return &quot;&lt;%s owner=%r count=%d&gt;&quot; % (</font>
<font color="red"> 145.                 self.__class__.__name__, owner, self.__count)</font>
<font color="black"> 146. </font>
<font color="red"> 147.     def acquire(self, blocking=1):</font>
<font color="black"> 148.         &quot;&quot;&quot;Acquire a lock, blocking or non-blocking.</font>
<font color="black"> 149. </font>
<font color="black"> 150.         When invoked without arguments: if this thread already owns the lock,</font>
<font color="black"> 151.         increment the recursion level by one, and return immediately. Otherwise,</font>
<font color="black"> 152.         if another thread owns the lock, block until the lock is unlocked. Once</font>
<font color="black"> 153.         the lock is unlocked (not owned by any thread), then grab ownership, set</font>
<font color="black"> 154.         the recursion level to one, and return. If more than one thread is</font>
<font color="black"> 155.         blocked waiting until the lock is unlocked, only one at a time will be</font>
<font color="black"> 156.         able to grab ownership of the lock. There is no return value in this</font>
<font color="black"> 157.         case.</font>
<font color="black"> 158. </font>
<font color="black"> 159.         When invoked with the blocking argument set to true, do the same thing</font>
<font color="black"> 160.         as when called without arguments, and return true.</font>
<font color="black"> 161. </font>
<font color="black"> 162.         When invoked with the blocking argument set to false, do not block. If a</font>
<font color="black"> 163.         call without an argument would block, return false immediately;</font>
<font color="black"> 164.         otherwise, do the same thing as when called without arguments, and</font>
<font color="black"> 165.         return true.</font>
<font color="black"> 166. </font>
<font color="black"> 167.         &quot;&quot;&quot;</font>
<font color="green"> 168.         me = _get_ident()</font>
<font color="green"> 169.         if self.__owner == me:</font>
<font color="green"> 170.             self.__count = self.__count + 1</font>
<font color="black"> 171.             if __debug__:</font>
<font color="green"> 172.                 self._note(&quot;%s.acquire(%s): recursive success&quot;, self, blocking)</font>
<font color="green"> 173.             return 1</font>
<font color="green"> 174.         rc = self.__block.acquire(blocking)</font>
<font color="green"> 175.         if rc:</font>
<font color="green"> 176.             self.__owner = me</font>
<font color="green"> 177.             self.__count = 1</font>
<font color="black"> 178.             if __debug__:</font>
<font color="green"> 179.                 self._note(&quot;%s.acquire(%s): initial success&quot;, self, blocking)</font>
<font color="black"> 180.         else:</font>
<font color="black"> 181.             if __debug__:</font>
<font color="red"> 182.                 self._note(&quot;%s.acquire(%s): failure&quot;, self, blocking)</font>
<font color="green"> 183.         return rc</font>
<font color="black"> 184. </font>
<font color="red"> 185.     __enter__ = acquire</font>
<font color="black"> 186. </font>
<font color="red"> 187.     def release(self):</font>
<font color="black"> 188.         &quot;&quot;&quot;Release a lock, decrementing the recursion level.</font>
<font color="black"> 189. </font>
<font color="black"> 190.         If after the decrement it is zero, reset the lock to unlocked (not owned</font>
<font color="black"> 191.         by any thread), and if any other threads are blocked waiting for the</font>
<font color="black"> 192.         lock to become unlocked, allow exactly one of them to proceed. If after</font>
<font color="black"> 193.         the decrement the recursion level is still nonzero, the lock remains</font>
<font color="black"> 194.         locked and owned by the calling thread.</font>
<font color="black"> 195. </font>
<font color="black"> 196.         Only call this method when the calling thread owns the lock. A</font>
<font color="black"> 197.         RuntimeError is raised if this method is called when the lock is</font>
<font color="black"> 198.         unlocked.</font>
<font color="black"> 199. </font>
<font color="black"> 200.         There is no return value.</font>
<font color="black"> 201. </font>
<font color="black"> 202.         &quot;&quot;&quot;</font>
<font color="green"> 203.         if self.__owner != _get_ident():</font>
<font color="red"> 204.             raise RuntimeError(&quot;cannot release un-acquired lock&quot;)</font>
<font color="green"> 205.         self.__count = count = self.__count - 1</font>
<font color="green"> 206.         if not count:</font>
<font color="green"> 207.             self.__owner = None</font>
<font color="green"> 208.             self.__block.release()</font>
<font color="black"> 209.             if __debug__:</font>
<font color="green"> 210.                 self._note(&quot;%s.release(): final release&quot;, self)</font>
<font color="black"> 211.         else:</font>
<font color="black"> 212.             if __debug__:</font>
<font color="green"> 213.                 self._note(&quot;%s.release(): non-final release&quot;, self)</font>
<font color="black"> 214. </font>
<font color="red"> 215.     def __exit__(self, t, v, tb):</font>
<font color="green"> 216.         self.release()</font>
<font color="black"> 217. </font>
<font color="black"> 218.     # Internal methods used by condition variables</font>
<font color="black"> 219. </font>
<font color="red"> 220.     def _acquire_restore(self, count_owner):</font>
<font color="red"> 221.         count, owner = count_owner</font>
<font color="red"> 222.         self.__block.acquire()</font>
<font color="red"> 223.         self.__count = count</font>
<font color="red"> 224.         self.__owner = owner</font>
<font color="black"> 225.         if __debug__:</font>
<font color="red"> 226.             self._note(&quot;%s._acquire_restore()&quot;, self)</font>
<font color="black"> 227. </font>
<font color="red"> 228.     def _release_save(self):</font>
<font color="black"> 229.         if __debug__:</font>
<font color="red"> 230.             self._note(&quot;%s._release_save()&quot;, self)</font>
<font color="red"> 231.         count = self.__count</font>
<font color="red"> 232.         self.__count = 0</font>
<font color="red"> 233.         owner = self.__owner</font>
<font color="red"> 234.         self.__owner = None</font>
<font color="red"> 235.         self.__block.release()</font>
<font color="red"> 236.         return (count, owner)</font>
<font color="black"> 237. </font>
<font color="red"> 238.     def _is_owned(self):</font>
<font color="red"> 239.         return self.__owner == _get_ident()</font>
<font color="black"> 240. </font>
<font color="black"> 241. </font>
<font color="red"> 242. def Condition(*args, **kwargs):</font>
<font color="black"> 243.     &quot;&quot;&quot;Factory function that returns a new condition variable object.</font>
<font color="black"> 244. </font>
<font color="black"> 245.     A condition variable allows one or more threads to wait until they are</font>
<font color="black"> 246.     notified by another thread.</font>
<font color="black"> 247. </font>
<font color="black"> 248.     If the lock argument is given and not None, it must be a Lock or RLock</font>
<font color="black"> 249.     object, and it is used as the underlying lock. Otherwise, a new RLock object</font>
<font color="black"> 250.     is created and used as the underlying lock.</font>
<font color="black"> 251. </font>
<font color="black"> 252.     &quot;&quot;&quot;</font>
<font color="green"> 253.     return _Condition(*args, **kwargs)</font>
<font color="black"> 254. </font>
<font color="red"> 255. class _Condition(_Verbose):</font>
<font color="black"> 256.     &quot;&quot;&quot;Condition variables allow one or more threads to wait until they are</font>
<font color="black"> 257.        notified by another thread.</font>
<font color="red"> 258.     &quot;&quot;&quot;</font>
<font color="black"> 259. </font>
<font color="red"> 260.     def __init__(self, lock=None, verbose=None):</font>
<font color="green"> 261.         _Verbose.__init__(self, verbose)</font>
<font color="green"> 262.         if lock is None:</font>
<font color="red"> 263.             lock = RLock()</font>
<font color="green"> 264.         self.__lock = lock</font>
<font color="black"> 265.         # Export the lock's acquire() and release() methods</font>
<font color="green"> 266.         self.acquire = lock.acquire</font>
<font color="green"> 267.         self.release = lock.release</font>
<font color="black"> 268.         # If the lock defines _release_save() and/or _acquire_restore(),</font>
<font color="black"> 269.         # these override the default implementations (which just call</font>
<font color="black"> 270.         # release() and acquire() on the lock).  Ditto for _is_owned().</font>
<font color="green"> 271.         try:</font>
<font color="green"> 272.             self._release_save = lock._release_save</font>
<font color="green"> 273.         except AttributeError:</font>
<font color="green"> 274.             pass</font>
<font color="green"> 275.         try:</font>
<font color="green"> 276.             self._acquire_restore = lock._acquire_restore</font>
<font color="green"> 277.         except AttributeError:</font>
<font color="green"> 278.             pass</font>
<font color="green"> 279.         try:</font>
<font color="green"> 280.             self._is_owned = lock._is_owned</font>
<font color="green"> 281.         except AttributeError:</font>
<font color="green"> 282.             pass</font>
<font color="green"> 283.         self.__waiters = []</font>
<font color="black"> 284. </font>
<font color="red"> 285.     def __enter__(self):</font>
<font color="red"> 286.         return self.__lock.__enter__()</font>
<font color="black"> 287. </font>
<font color="red"> 288.     def __exit__(self, *args):</font>
<font color="red"> 289.         return self.__lock.__exit__(*args)</font>
<font color="black"> 290. </font>
<font color="red"> 291.     def __repr__(self):</font>
<font color="red"> 292.         return &quot;&lt;Condition(%s, %d)&gt;&quot; % (self.__lock, len(self.__waiters))</font>
<font color="black"> 293. </font>
<font color="red"> 294.     def _release_save(self):</font>
<font color="red"> 295.         self.__lock.release()           # No state to save</font>
<font color="black"> 296. </font>
<font color="red"> 297.     def _acquire_restore(self, x):</font>
<font color="red"> 298.         self.__lock.acquire()           # Ignore saved state</font>
<font color="black"> 299. </font>
<font color="red"> 300.     def _is_owned(self):</font>
<font color="black"> 301.         # Return True if lock is owned by current_thread.</font>
<font color="black"> 302.         # This method is called only if __lock doesn't have _is_owned().</font>
<font color="green"> 303.         if self.__lock.acquire(0):</font>
<font color="red"> 304.             self.__lock.release()</font>
<font color="red"> 305.             return False</font>
<font color="black"> 306.         else:</font>
<font color="green"> 307.             return True</font>
<font color="black"> 308. </font>
<font color="red"> 309.     def wait(self, timeout=None):</font>
<font color="black"> 310.         &quot;&quot;&quot;Wait until notified or until a timeout occurs.</font>
<font color="black"> 311. </font>
<font color="black"> 312.         If the calling thread has not acquired the lock when this method is</font>
<font color="black"> 313.         called, a RuntimeError is raised.</font>
<font color="black"> 314. </font>
<font color="black"> 315.         This method releases the underlying lock, and then blocks until it is</font>
<font color="black"> 316.         awakened by a notify() or notifyAll() call for the same condition</font>
<font color="black"> 317.         variable in another thread, or until the optional timeout occurs. Once</font>
<font color="black"> 318.         awakened or timed out, it re-acquires the lock and returns.</font>
<font color="black"> 319. </font>
<font color="black"> 320.         When the timeout argument is present and not None, it should be a</font>
<font color="black"> 321.         floating point number specifying a timeout for the operation in seconds</font>
<font color="black"> 322.         (or fractions thereof).</font>
<font color="black"> 323. </font>
<font color="black"> 324.         When the underlying lock is an RLock, it is not released using its</font>
<font color="black"> 325.         release() method, since this may not actually unlock the lock when it</font>
<font color="black"> 326.         was acquired multiple times recursively. Instead, an internal interface</font>
<font color="black"> 327.         of the RLock class is used, which really unlocks it even when it has</font>
<font color="black"> 328.         been recursively acquired several times. Another internal interface is</font>
<font color="black"> 329.         then used to restore the recursion level when the lock is reacquired.</font>
<font color="black"> 330. </font>
<font color="black"> 331.         &quot;&quot;&quot;</font>
<font color="red"> 332.         if not self._is_owned():</font>
<font color="red"> 333.             raise RuntimeError(&quot;cannot wait on un-acquired lock&quot;)</font>
<font color="red"> 334.         waiter = _allocate_lock()</font>
<font color="red"> 335.         waiter.acquire()</font>
<font color="red"> 336.         self.__waiters.append(waiter)</font>
<font color="red"> 337.         saved_state = self._release_save()</font>
<font color="red"> 338.         try:    # restore state no matter what (e.g., KeyboardInterrupt)</font>
<font color="red"> 339.             if timeout is None:</font>
<font color="red"> 340.                 waiter.acquire()</font>
<font color="black"> 341.                 if __debug__:</font>
<font color="red"> 342.                     self._note(&quot;%s.wait(): got it&quot;, self)</font>
<font color="black"> 343.             else:</font>
<font color="black"> 344.                 # Balancing act:  We can't afford a pure busy loop, so we</font>
<font color="black"> 345.                 # have to sleep; but if we sleep the whole timeout time,</font>
<font color="black"> 346.                 # we'll be unresponsive.  The scheme here sleeps very</font>
<font color="black"> 347.                 # little at first, longer as time goes on, but never longer</font>
<font color="black"> 348.                 # than 20 times per second (or the timeout time remaining).</font>
<font color="red"> 349.                 endtime = _time() + timeout</font>
<font color="red"> 350.                 delay = 0.0005 # 500 us -&gt; initial delay of 1 ms</font>
<font color="red"> 351.                 while True:</font>
<font color="red"> 352.                     gotit = waiter.acquire(0)</font>
<font color="red"> 353.                     if gotit:</font>
<font color="red"> 354.                         break</font>
<font color="red"> 355.                     remaining = endtime - _time()</font>
<font color="red"> 356.                     if remaining &lt;= 0:</font>
<font color="red"> 357.                         break</font>
<font color="red"> 358.                     delay = min(delay * 2, remaining, .05)</font>
<font color="red"> 359.                     _sleep(delay)</font>
<font color="red"> 360.                 if not gotit:</font>
<font color="black"> 361.                     if __debug__:</font>
<font color="red"> 362.                         self._note(&quot;%s.wait(%s): timed out&quot;, self, timeout)</font>
<font color="red"> 363.                     try:</font>
<font color="red"> 364.                         self.__waiters.remove(waiter)</font>
<font color="red"> 365.                     except ValueError:</font>
<font color="red"> 366.                         pass</font>
<font color="black"> 367.                 else:</font>
<font color="black"> 368.                     if __debug__:</font>
<font color="red"> 369.                         self._note(&quot;%s.wait(%s): got it&quot;, self, timeout)</font>
<font color="black"> 370.         finally:</font>
<font color="red"> 371.             self._acquire_restore(saved_state)</font>
<font color="black"> 372. </font>
<font color="red"> 373.     def notify(self, n=1):</font>
<font color="black"> 374.         &quot;&quot;&quot;Wake up one or more threads waiting on this condition, if any.</font>
<font color="black"> 375. </font>
<font color="black"> 376.         If the calling thread has not acquired the lock when this method is</font>
<font color="black"> 377.         called, a RuntimeError is raised.</font>
<font color="black"> 378. </font>
<font color="black"> 379.         This method wakes up at most n of the threads waiting for the condition</font>
<font color="black"> 380.         variable; it is a no-op if no threads are waiting.</font>
<font color="black"> 381. </font>
<font color="black"> 382.         &quot;&quot;&quot;</font>
<font color="green"> 383.         if not self._is_owned():</font>
<font color="red"> 384.             raise RuntimeError(&quot;cannot notify on un-acquired lock&quot;)</font>
<font color="green"> 385.         __waiters = self.__waiters</font>
<font color="green"> 386.         waiters = __waiters[:n]</font>
<font color="green"> 387.         if not waiters:</font>
<font color="black"> 388.             if __debug__:</font>
<font color="green"> 389.                 self._note(&quot;%s.notify(): no waiters&quot;, self)</font>
<font color="green"> 390.             return</font>
<font color="red"> 391.         self._note(&quot;%s.notify(): notifying %d waiter%s&quot;, self, n,</font>
<font color="red"> 392.                    n!=1 and &quot;s&quot; or &quot;&quot;)</font>
<font color="red"> 393.         for waiter in waiters:</font>
<font color="red"> 394.             waiter.release()</font>
<font color="red"> 395.             try:</font>
<font color="red"> 396.                 __waiters.remove(waiter)</font>
<font color="red"> 397.             except ValueError:</font>
<font color="red"> 398.                 pass</font>
<font color="black"> 399. </font>
<font color="red"> 400.     def notifyAll(self):</font>
<font color="black"> 401.         &quot;&quot;&quot;Wake up all threads waiting on this condition.</font>
<font color="black"> 402. </font>
<font color="black"> 403.         If the calling thread has not acquired the lock when this method</font>
<font color="black"> 404.         is called, a RuntimeError is raised.</font>
<font color="black"> 405. </font>
<font color="black"> 406.         &quot;&quot;&quot;</font>
<font color="red"> 407.         self.notify(len(self.__waiters))</font>
<font color="black"> 408. </font>
<font color="red"> 409.     notify_all = notifyAll</font>
<font color="black"> 410. </font>
<font color="black"> 411. </font>
<font color="red"> 412. def Semaphore(*args, **kwargs):</font>
<font color="black"> 413.     &quot;&quot;&quot;A factory function that returns a new semaphore.</font>
<font color="black"> 414. </font>
<font color="black"> 415.     Semaphores manage a counter representing the number of release() calls minus</font>
<font color="black"> 416.     the number of acquire() calls, plus an initial value. The acquire() method</font>
<font color="black"> 417.     blocks if necessary until it can return without making the counter</font>
<font color="black"> 418.     negative. If not given, value defaults to 1.</font>
<font color="black"> 419. </font>
<font color="black"> 420.     &quot;&quot;&quot;</font>
<font color="red"> 421.     return _Semaphore(*args, **kwargs)</font>
<font color="black"> 422. </font>
<font color="red"> 423. class _Semaphore(_Verbose):</font>
<font color="black"> 424.     &quot;&quot;&quot;Semaphores manage a counter representing the number of release() calls</font>
<font color="black"> 425.        minus the number of acquire() calls, plus an initial value. The acquire()</font>
<font color="black"> 426.        method blocks if necessary until it can return without making the counter</font>
<font color="black"> 427.        negative. If not given, value defaults to 1.</font>
<font color="black"> 428. </font>
<font color="red"> 429.     &quot;&quot;&quot;</font>
<font color="black"> 430. </font>
<font color="black"> 431.     # After Tim Peters' semaphore class, but not quite the same (no maximum)</font>
<font color="black"> 432. </font>
<font color="red"> 433.     def __init__(self, value=1, verbose=None):</font>
<font color="red"> 434.         if value &lt; 0:</font>
<font color="red"> 435.             raise ValueError(&quot;semaphore initial value must be &gt;= 0&quot;)</font>
<font color="red"> 436.         _Verbose.__init__(self, verbose)</font>
<font color="red"> 437.         self.__cond = Condition(Lock())</font>
<font color="red"> 438.         self.__value = value</font>
<font color="black"> 439. </font>
<font color="red"> 440.     def acquire(self, blocking=1):</font>
<font color="black"> 441.         &quot;&quot;&quot;Acquire a semaphore, decrementing the internal counter by one.</font>
<font color="black"> 442. </font>
<font color="black"> 443.         When invoked without arguments: if the internal counter is larger than</font>
<font color="black"> 444.         zero on entry, decrement it by one and return immediately. If it is zero</font>
<font color="black"> 445.         on entry, block, waiting until some other thread has called release() to</font>
<font color="black"> 446.         make it larger than zero. This is done with proper interlocking so that</font>
<font color="black"> 447.         if multiple acquire() calls are blocked, release() will wake exactly one</font>
<font color="black"> 448.         of them up. The implementation may pick one at random, so the order in</font>
<font color="black"> 449.         which blocked threads are awakened should not be relied on. There is no</font>
<font color="black"> 450.         return value in this case.</font>
<font color="black"> 451. </font>
<font color="black"> 452.         When invoked with blocking set to true, do the same thing as when called</font>
<font color="black"> 453.         without arguments, and return true.</font>
<font color="black"> 454. </font>
<font color="black"> 455.         When invoked with blocking set to false, do not block. If a call without</font>
<font color="black"> 456.         an argument would block, return false immediately; otherwise, do the</font>
<font color="black"> 457.         same thing as when called without arguments, and return true.</font>
<font color="black"> 458. </font>
<font color="black"> 459.         &quot;&quot;&quot;</font>
<font color="red"> 460.         rc = False</font>
<font color="red"> 461.         with self.__cond:</font>
<font color="red"> 462.             while self.__value == 0:</font>
<font color="red"> 463.                 if not blocking:</font>
<font color="red"> 464.                     break</font>
<font color="black"> 465.                 if __debug__:</font>
<font color="red"> 466.                     self._note(&quot;%s.acquire(%s): blocked waiting, value=%s&quot;,</font>
<font color="red"> 467.                             self, blocking, self.__value)</font>
<font color="red"> 468.                 self.__cond.wait()</font>
<font color="black"> 469.             else:</font>
<font color="red"> 470.                 self.__value = self.__value - 1</font>
<font color="black"> 471.                 if __debug__:</font>
<font color="red"> 472.                     self._note(&quot;%s.acquire: success, value=%s&quot;,</font>
<font color="red"> 473.                             self, self.__value)</font>
<font color="red"> 474.                 rc = True</font>
<font color="red"> 475.         return rc</font>
<font color="black"> 476. </font>
<font color="red"> 477.     __enter__ = acquire</font>
<font color="black"> 478. </font>
<font color="red"> 479.     def release(self):</font>
<font color="black"> 480.         &quot;&quot;&quot;Release a semaphore, incrementing the internal counter by one.</font>
<font color="black"> 481. </font>
<font color="black"> 482.         When the counter is zero on entry and another thread is waiting for it</font>
<font color="black"> 483.         to become larger than zero again, wake up that thread.</font>
<font color="black"> 484. </font>
<font color="black"> 485.         &quot;&quot;&quot;</font>
<font color="red"> 486.         with self.__cond:</font>
<font color="red"> 487.             self.__value = self.__value + 1</font>
<font color="black"> 488.             if __debug__:</font>
<font color="red"> 489.                 self._note(&quot;%s.release: success, value=%s&quot;,</font>
<font color="red"> 490.                         self, self.__value)</font>
<font color="red"> 491.             self.__cond.notify()</font>
<font color="black"> 492. </font>
<font color="red"> 493.     def __exit__(self, t, v, tb):</font>
<font color="red"> 494.         self.release()</font>
<font color="black"> 495. </font>
<font color="black"> 496. </font>
<font color="red"> 497. def BoundedSemaphore(*args, **kwargs):</font>
<font color="black"> 498.     &quot;&quot;&quot;A factory function that returns a new bounded semaphore.</font>
<font color="black"> 499. </font>
<font color="black"> 500.     A bounded semaphore checks to make sure its current value doesn't exceed its</font>
<font color="black"> 501.     initial value. If it does, ValueError is raised. In most situations</font>
<font color="black"> 502.     semaphores are used to guard resources with limited capacity.</font>
<font color="black"> 503. </font>
<font color="black"> 504.     If the semaphore is released too many times it's a sign of a bug. If not</font>
<font color="black"> 505.     given, value defaults to 1.</font>
<font color="black"> 506. </font>
<font color="black"> 507.     Like regular semaphores, bounded semaphores manage a counter representing</font>
<font color="black"> 508.     the number of release() calls minus the number of acquire() calls, plus an</font>
<font color="black"> 509.     initial value. The acquire() method blocks if necessary until it can return</font>
<font color="black"> 510.     without making the counter negative. If not given, value defaults to 1.</font>
<font color="black"> 511. </font>
<font color="black"> 512.     &quot;&quot;&quot;</font>
<font color="red"> 513.     return _BoundedSemaphore(*args, **kwargs)</font>
<font color="black"> 514. </font>
<font color="red"> 515. class _BoundedSemaphore(_Semaphore):</font>
<font color="black"> 516.     &quot;&quot;&quot;A bounded semaphore checks to make sure its current value doesn't exceed</font>
<font color="black"> 517.        its initial value. If it does, ValueError is raised. In most situations</font>
<font color="black"> 518.        semaphores are used to guard resources with limited capacity.</font>
<font color="red"> 519.     &quot;&quot;&quot;</font>
<font color="black"> 520. </font>
<font color="red"> 521.     def __init__(self, value=1, verbose=None):</font>
<font color="red"> 522.         _Semaphore.__init__(self, value, verbose)</font>
<font color="red"> 523.         self._initial_value = value</font>
<font color="black"> 524. </font>
<font color="red"> 525.     def release(self):</font>
<font color="black"> 526.         &quot;&quot;&quot;Release a semaphore, incrementing the internal counter by one.</font>
<font color="black"> 527. </font>
<font color="black"> 528.         When the counter is zero on entry and another thread is waiting for it</font>
<font color="black"> 529.         to become larger than zero again, wake up that thread.</font>
<font color="black"> 530. </font>
<font color="black"> 531.         If the number of releases exceeds the number of acquires,</font>
<font color="black"> 532.         raise a ValueError.</font>
<font color="black"> 533. </font>
<font color="black"> 534.         &quot;&quot;&quot;</font>
<font color="red"> 535.         with self._Semaphore__cond:</font>
<font color="red"> 536.             if self._Semaphore__value &gt;= self._initial_value:</font>
<font color="red"> 537.                 raise ValueError(&quot;Semaphore released too many times&quot;)</font>
<font color="red"> 538.             self._Semaphore__value += 1</font>
<font color="red"> 539.             self._Semaphore__cond.notify()</font>
<font color="black"> 540. </font>
<font color="black"> 541. </font>
<font color="red"> 542. def Event(*args, **kwargs):</font>
<font color="black"> 543.     &quot;&quot;&quot;A factory function that returns a new event.</font>
<font color="black"> 544. </font>
<font color="black"> 545.     Events manage a flag that can be set to true with the set() method and reset</font>
<font color="black"> 546.     to false with the clear() method. The wait() method blocks until the flag is</font>
<font color="black"> 547.     true.</font>
<font color="black"> 548. </font>
<font color="black"> 549.     &quot;&quot;&quot;</font>
<font color="red"> 550.     return _Event(*args, **kwargs)</font>
<font color="black"> 551. </font>
<font color="red"> 552. class _Event(_Verbose):</font>
<font color="black"> 553.     &quot;&quot;&quot;A factory function that returns a new event object. An event manages a</font>
<font color="black"> 554.        flag that can be set to true with the set() method and reset to false</font>
<font color="black"> 555.        with the clear() method. The wait() method blocks until the flag is true.</font>
<font color="black"> 556. </font>
<font color="red"> 557.     &quot;&quot;&quot;</font>
<font color="black"> 558. </font>
<font color="black"> 559.     # After Tim Peters' event class (without is_posted())</font>
<font color="black"> 560. </font>
<font color="red"> 561.     def __init__(self, verbose=None):</font>
<font color="red"> 562.         _Verbose.__init__(self, verbose)</font>
<font color="red"> 563.         self.__cond = Condition(Lock())</font>
<font color="red"> 564.         self.__flag = False</font>
<font color="black"> 565. </font>
<font color="red"> 566.     def _reset_internal_locks(self):</font>
<font color="black"> 567.         # private!  called by Thread._reset_internal_locks by _after_fork()</font>
<font color="red"> 568.         self.__cond.__init__(Lock())</font>
<font color="black"> 569. </font>
<font color="red"> 570.     def isSet(self):</font>
<font color="black"> 571.         'Return true if and only if the internal flag is true.'</font>
<font color="red"> 572.         return self.__flag</font>
<font color="black"> 573. </font>
<font color="red"> 574.     is_set = isSet</font>
<font color="black"> 575. </font>
<font color="red"> 576.     def set(self):</font>
<font color="black"> 577.         &quot;&quot;&quot;Set the internal flag to true.</font>
<font color="black"> 578. </font>
<font color="black"> 579.         All threads waiting for the flag to become true are awakened. Threads</font>
<font color="black"> 580.         that call wait() once the flag is true will not block at all.</font>
<font color="black"> 581. </font>
<font color="black"> 582.         &quot;&quot;&quot;</font>
<font color="red"> 583.         with self.__cond:</font>
<font color="red"> 584.             self.__flag = True</font>
<font color="red"> 585.             self.__cond.notify_all()</font>
<font color="black"> 586. </font>
<font color="red"> 587.     def clear(self):</font>
<font color="black"> 588.         &quot;&quot;&quot;Reset the internal flag to false.</font>
<font color="black"> 589. </font>
<font color="black"> 590.         Subsequently, threads calling wait() will block until set() is called to</font>
<font color="black"> 591.         set the internal flag to true again.</font>
<font color="black"> 592. </font>
<font color="black"> 593.         &quot;&quot;&quot;</font>
<font color="red"> 594.         with self.__cond:</font>
<font color="red"> 595.             self.__flag = False</font>
<font color="black"> 596. </font>
<font color="red"> 597.     def wait(self, timeout=None):</font>
<font color="black"> 598.         &quot;&quot;&quot;Block until the internal flag is true.</font>
<font color="black"> 599. </font>
<font color="black"> 600.         If the internal flag is true on entry, return immediately. Otherwise,</font>
<font color="black"> 601.         block until another thread calls set() to set the flag to true, or until</font>
<font color="black"> 602.         the optional timeout occurs.</font>
<font color="black"> 603. </font>
<font color="black"> 604.         When the timeout argument is present and not None, it should be a</font>
<font color="black"> 605.         floating point number specifying a timeout for the operation in seconds</font>
<font color="black"> 606.         (or fractions thereof).</font>
<font color="black"> 607. </font>
<font color="black"> 608.         This method returns the internal flag on exit, so it will always return</font>
<font color="black"> 609.         True except if a timeout is given and the operation times out.</font>
<font color="black"> 610. </font>
<font color="black"> 611.         &quot;&quot;&quot;</font>
<font color="red"> 612.         with self.__cond:</font>
<font color="red"> 613.             if not self.__flag:</font>
<font color="red"> 614.                 self.__cond.wait(timeout)</font>
<font color="red"> 615.             return self.__flag</font>
<font color="black"> 616. </font>
<font color="black"> 617. # Helper to generate new thread names</font>
<font color="red"> 618. _counter = _count().next</font>
<font color="red"> 619. _counter() # Consume 0 so first non-main thread has id 1.</font>
<font color="red"> 620. def _newname(template=&quot;Thread-%d&quot;):</font>
<font color="red"> 621.     return template % _counter()</font>
<font color="black"> 622. </font>
<font color="black"> 623. # Active thread administration</font>
<font color="red"> 624. _active_limbo_lock = _allocate_lock()</font>
<font color="red"> 625. _active = {}    # maps thread id to Thread object</font>
<font color="red"> 626. _limbo = {}</font>
<font color="black"> 627. </font>
<font color="black"> 628. </font>
<font color="black"> 629. # Main class for threads</font>
<font color="black"> 630. </font>
<font color="red"> 631. class Thread(_Verbose):</font>
<font color="black"> 632.     &quot;&quot;&quot;A class that represents a thread of control.</font>
<font color="black"> 633. </font>
<font color="black"> 634.     This class can be safely subclassed in a limited fashion.</font>
<font color="black"> 635. </font>
<font color="red"> 636.     &quot;&quot;&quot;</font>
<font color="red"> 637.     __initialized = False</font>
<font color="black"> 638.     # Need to store a reference to sys.exc_info for printing</font>
<font color="black"> 639.     # out exceptions when a thread tries to use a global var. during interp.</font>
<font color="black"> 640.     # shutdown and thus raises an exception about trying to perform some</font>
<font color="black"> 641.     # operation on/with a NoneType</font>
<font color="red"> 642.     __exc_info = _sys.exc_info</font>
<font color="black"> 643.     # Keep sys.exc_clear too to clear the exception just before</font>
<font color="black"> 644.     # allowing .join() to return.</font>
<font color="red"> 645.     __exc_clear = _sys.exc_clear</font>
<font color="black"> 646. </font>
<font color="red"> 647.     def __init__(self, group=None, target=None, name=None,</font>
<font color="red"> 648.                  args=(), kwargs=None, verbose=None):</font>
<font color="black"> 649.         &quot;&quot;&quot;This constructor should always be called with keyword arguments. Arguments are:</font>
<font color="black"> 650. </font>
<font color="black"> 651.         *group* should be None; reserved for future extension when a ThreadGroup</font>
<font color="black"> 652.         class is implemented.</font>
<font color="black"> 653. </font>
<font color="black"> 654.         *target* is the callable object to be invoked by the run()</font>
<font color="black"> 655.         method. Defaults to None, meaning nothing is called.</font>
<font color="black"> 656. </font>
<font color="black"> 657.         *name* is the thread name. By default, a unique name is constructed of</font>
<font color="black"> 658.         the form &quot;Thread-N&quot; where N is a small decimal number.</font>
<font color="black"> 659. </font>
<font color="black"> 660.         *args* is the argument tuple for the target invocation. Defaults to ().</font>
<font color="black"> 661. </font>
<font color="black"> 662.         *kwargs* is a dictionary of keyword arguments for the target</font>
<font color="black"> 663.         invocation. Defaults to {}.</font>
<font color="black"> 664. </font>
<font color="black"> 665.         If a subclass overrides the constructor, it must make sure to invoke</font>
<font color="black"> 666.         the base class constructor (Thread.__init__()) before doing anything</font>
<font color="black"> 667.         else to the thread.</font>
<font color="black"> 668. </font>
<font color="black"> 669. &quot;&quot;&quot;</font>
<font color="red"> 670.         assert group is None, &quot;group argument must be None for now&quot;</font>
<font color="red"> 671.         _Verbose.__init__(self, verbose)</font>
<font color="red"> 672.         if kwargs is None:</font>
<font color="red"> 673.             kwargs = {}</font>
<font color="red"> 674.         self.__target = target</font>
<font color="red"> 675.         self.__name = str(name or _newname())</font>
<font color="red"> 676.         self.__args = args</font>
<font color="red"> 677.         self.__kwargs = kwargs</font>
<font color="red"> 678.         self.__daemonic = self._set_daemon()</font>
<font color="red"> 679.         self.__ident = None</font>
<font color="red"> 680.         self.__started = Event()</font>
<font color="red"> 681.         self.__stopped = False</font>
<font color="red"> 682.         self.__block = Condition(Lock())</font>
<font color="red"> 683.         self.__initialized = True</font>
<font color="black"> 684.         # sys.stderr is not stored in the class like</font>
<font color="black"> 685.         # sys.exc_info since it can be changed between instances</font>
<font color="red"> 686.         self.__stderr = _sys.stderr</font>
<font color="black"> 687. </font>
<font color="red"> 688.     def _reset_internal_locks(self):</font>
<font color="black"> 689.         # private!  Called by _after_fork() to reset our internal locks as</font>
<font color="black"> 690.         # they may be in an invalid state leading to a deadlock or crash.</font>
<font color="red"> 691.         if hasattr(self, '_Thread__block'):  # DummyThread deletes self.__block</font>
<font color="red"> 692.             self.__block.__init__()</font>
<font color="red"> 693.         self.__started._reset_internal_locks()</font>
<font color="black"> 694. </font>
<font color="red"> 695.     @property</font>
<font color="black"> 696.     def _block(self):</font>
<font color="black"> 697.         # used by a unittest</font>
<font color="red"> 698.         return self.__block</font>
<font color="black"> 699. </font>
<font color="red"> 700.     def _set_daemon(self):</font>
<font color="black"> 701.         # Overridden in _MainThread and _DummyThread</font>
<font color="red"> 702.         return current_thread().daemon</font>
<font color="black"> 703. </font>
<font color="red"> 704.     def __repr__(self):</font>
<font color="red"> 705.         assert self.__initialized, &quot;Thread.__init__() was not called&quot;</font>
<font color="red"> 706.         status = &quot;initial&quot;</font>
<font color="red"> 707.         if self.__started.is_set():</font>
<font color="red"> 708.             status = &quot;started&quot;</font>
<font color="red"> 709.         if self.__stopped:</font>
<font color="red"> 710.             status = &quot;stopped&quot;</font>
<font color="red"> 711.         if self.__daemonic:</font>
<font color="red"> 712.             status += &quot; daemon&quot;</font>
<font color="red"> 713.         if self.__ident is not None:</font>
<font color="red"> 714.             status += &quot; %s&quot; % self.__ident</font>
<font color="red"> 715.         return &quot;&lt;%s(%s, %s)&gt;&quot; % (self.__class__.__name__, self.__name, status)</font>
<font color="black"> 716. </font>
<font color="red"> 717.     def start(self):</font>
<font color="black"> 718.         &quot;&quot;&quot;Start the thread's activity.</font>
<font color="black"> 719. </font>
<font color="black"> 720.         It must be called at most once per thread object. It arranges for the</font>
<font color="black"> 721.         object's run() method to be invoked in a separate thread of control.</font>
<font color="black"> 722. </font>
<font color="black"> 723.         This method will raise a RuntimeError if called more than once on the</font>
<font color="black"> 724.         same thread object.</font>
<font color="black"> 725. </font>
<font color="black"> 726.         &quot;&quot;&quot;</font>
<font color="red"> 727.         if not self.__initialized:</font>
<font color="red"> 728.             raise RuntimeError(&quot;thread.__init__() not called&quot;)</font>
<font color="red"> 729.         if self.__started.is_set():</font>
<font color="red"> 730.             raise RuntimeError(&quot;threads can only be started once&quot;)</font>
<font color="black"> 731.         if __debug__:</font>
<font color="red"> 732.             self._note(&quot;%s.start(): starting thread&quot;, self)</font>
<font color="red"> 733.         with _active_limbo_lock:</font>
<font color="red"> 734.             _limbo[self] = self</font>
<font color="red"> 735.         try:</font>
<font color="red"> 736.             _start_new_thread(self.__bootstrap, ())</font>
<font color="red"> 737.         except Exception:</font>
<font color="red"> 738.             with _active_limbo_lock:</font>
<font color="red"> 739.                 del _limbo[self]</font>
<font color="red"> 740.             raise</font>
<font color="red"> 741.         self.__started.wait()</font>
<font color="black"> 742. </font>
<font color="red"> 743.     def run(self):</font>
<font color="black"> 744.         &quot;&quot;&quot;Method representing the thread's activity.</font>
<font color="black"> 745. </font>
<font color="black"> 746.         You may override this method in a subclass. The standard run() method</font>
<font color="black"> 747.         invokes the callable object passed to the object's constructor as the</font>
<font color="black"> 748.         target argument, if any, with sequential and keyword arguments taken</font>
<font color="black"> 749.         from the args and kwargs arguments, respectively.</font>
<font color="black"> 750. </font>
<font color="black"> 751.         &quot;&quot;&quot;</font>
<font color="red"> 752.         try:</font>
<font color="red"> 753.             if self.__target:</font>
<font color="red"> 754.                 self.__target(*self.__args, **self.__kwargs)</font>
<font color="black"> 755.         finally:</font>
<font color="black"> 756.             # Avoid a refcycle if the thread is running a function with</font>
<font color="black"> 757.             # an argument that has a member that points to the thread.</font>
<font color="red"> 758.             del self.__target, self.__args, self.__kwargs</font>
<font color="black"> 759. </font>
<font color="red"> 760.     def __bootstrap(self):</font>
<font color="black"> 761.         # Wrapper around the real bootstrap code that ignores</font>
<font color="black"> 762.         # exceptions during interpreter cleanup.  Those typically</font>
<font color="black"> 763.         # happen when a daemon thread wakes up at an unfortunate</font>
<font color="black"> 764.         # moment, finds the world around it destroyed, and raises some</font>
<font color="black"> 765.         # random exception *** while trying to report the exception in</font>
<font color="black"> 766.         # __bootstrap_inner() below ***.  Those random exceptions</font>
<font color="black"> 767.         # don't help anybody, and they confuse users, so we suppress</font>
<font color="black"> 768.         # them.  We suppress them only when it appears that the world</font>
<font color="black"> 769.         # indeed has already been destroyed, so that exceptions in</font>
<font color="black"> 770.         # __bootstrap_inner() during normal business hours are properly</font>
<font color="black"> 771.         # reported.  Also, we only suppress them for daemonic threads;</font>
<font color="black"> 772.         # if a non-daemonic encounters this, something else is wrong.</font>
<font color="red"> 773.         try:</font>
<font color="red"> 774.             self.__bootstrap_inner()</font>
<font color="red"> 775.         except:</font>
<font color="red"> 776.             if self.__daemonic and _sys is None:</font>
<font color="red"> 777.                 return</font>
<font color="red"> 778.             raise</font>
<font color="black"> 779. </font>
<font color="red"> 780.     def _set_ident(self):</font>
<font color="red"> 781.         self.__ident = _get_ident()</font>
<font color="black"> 782. </font>
<font color="red"> 783.     def __bootstrap_inner(self):</font>
<font color="red"> 784.         try:</font>
<font color="red"> 785.             self._set_ident()</font>
<font color="red"> 786.             self.__started.set()</font>
<font color="red"> 787.             with _active_limbo_lock:</font>
<font color="red"> 788.                 _active[self.__ident] = self</font>
<font color="red"> 789.                 del _limbo[self]</font>
<font color="black"> 790.             if __debug__:</font>
<font color="red"> 791.                 self._note(&quot;%s.__bootstrap(): thread started&quot;, self)</font>
<font color="black"> 792. </font>
<font color="red"> 793.             if _trace_hook:</font>
<font color="red"> 794.                 self._note(&quot;%s.__bootstrap(): registering trace hook&quot;, self)</font>
<font color="red"> 795.                 _sys.settrace(_trace_hook)</font>
<font color="red"> 796.             if _profile_hook:</font>
<font color="red"> 797.                 self._note(&quot;%s.__bootstrap(): registering profile hook&quot;, self)</font>
<font color="red"> 798.                 _sys.setprofile(_profile_hook)</font>
<font color="black"> 799. </font>
<font color="red"> 800.             try:</font>
<font color="red"> 801.                 self.run()</font>
<font color="red"> 802.             except SystemExit:</font>
<font color="black"> 803.                 if __debug__:</font>
<font color="red"> 804.                     self._note(&quot;%s.__bootstrap(): raised SystemExit&quot;, self)</font>
<font color="red"> 805.             except:</font>
<font color="black"> 806.                 if __debug__:</font>
<font color="red"> 807.                     self._note(&quot;%s.__bootstrap(): unhandled exception&quot;, self)</font>
<font color="black"> 808.                 # If sys.stderr is no more (most likely from interpreter</font>
<font color="black"> 809.                 # shutdown) use self.__stderr.  Otherwise still use sys (as in</font>
<font color="black"> 810.                 # _sys) in case sys.stderr was redefined since the creation of</font>
<font color="black"> 811.                 # self.</font>
<font color="red"> 812.                 if _sys and _sys.stderr is not None:</font>
<font color="red"> 813.                     print&gt;&gt;_sys.stderr, (&quot;Exception in thread %s:\n%s&quot; %</font>
<font color="red"> 814.                                          (self.name, _format_exc()))</font>
<font color="red"> 815.                 elif self.__stderr is not None:</font>
<font color="black"> 816.                     # Do the best job possible w/o a huge amt. of code to</font>
<font color="black"> 817.                     # approximate a traceback (code ideas from</font>
<font color="black"> 818.                     # Lib/traceback.py)</font>
<font color="red"> 819.                     exc_type, exc_value, exc_tb = self.__exc_info()</font>
<font color="red"> 820.                     try:</font>
<font color="red"> 821.                         print&gt;&gt;self.__stderr, (</font>
<font color="red"> 822.                             &quot;Exception in thread &quot; + self.name +</font>
<font color="red"> 823.                             &quot; (most likely raised during interpreter shutdown):&quot;)</font>
<font color="red"> 824.                         print&gt;&gt;self.__stderr, (</font>
<font color="red"> 825.                             &quot;Traceback (most recent call last):&quot;)</font>
<font color="red"> 826.                         while exc_tb:</font>
<font color="red"> 827.                             print&gt;&gt;self.__stderr, (</font>
<font color="red"> 828.                                 '  File &quot;%s&quot;, line %s, in %s' %</font>
<font color="red"> 829.                                 (exc_tb.tb_frame.f_code.co_filename,</font>
<font color="red"> 830.                                     exc_tb.tb_lineno,</font>
<font color="red"> 831.                                     exc_tb.tb_frame.f_code.co_name))</font>
<font color="red"> 832.                             exc_tb = exc_tb.tb_next</font>
<font color="red"> 833.                         print&gt;&gt;self.__stderr, (&quot;%s: %s&quot; % (exc_type, exc_value))</font>
<font color="black"> 834.                     # Make sure that exc_tb gets deleted since it is a memory</font>
<font color="black"> 835.                     # hog; deleting everything else is just for thoroughness</font>
<font color="black"> 836.                     finally:</font>
<font color="red"> 837.                         del exc_type, exc_value, exc_tb</font>
<font color="black"> 838.             else:</font>
<font color="black"> 839.                 if __debug__:</font>
<font color="red"> 840.                     self._note(&quot;%s.__bootstrap(): normal return&quot;, self)</font>
<font color="black"> 841.             finally:</font>
<font color="black"> 842.                 # Prevent a race in</font>
<font color="black"> 843.                 # test_threading.test_no_refcycle_through_target when</font>
<font color="black"> 844.                 # the exception keeps the target alive past when we</font>
<font color="black"> 845.                 # assert that it's dead.</font>
<font color="red"> 846.                 self.__exc_clear()</font>
<font color="black"> 847.         finally:</font>
<font color="red"> 848.             with _active_limbo_lock:</font>
<font color="red"> 849.                 self.__stop()</font>
<font color="red"> 850.                 try:</font>
<font color="black"> 851.                     # We don't call self.__delete() because it also</font>
<font color="black"> 852.                     # grabs _active_limbo_lock.</font>
<font color="red"> 853.                     del _active[_get_ident()]</font>
<font color="red"> 854.                 except:</font>
<font color="red"> 855.                     pass</font>
<font color="black"> 856. </font>
<font color="red"> 857.     def __stop(self):</font>
<font color="black"> 858.         # DummyThreads delete self.__block, but they have no waiters to</font>
<font color="black"> 859.         # notify anyway (join() is forbidden on them).</font>
<font color="red"> 860.         if not hasattr(self, '_Thread__block'):</font>
<font color="red"> 861.             return</font>
<font color="red"> 862.         self.__block.acquire()</font>
<font color="red"> 863.         self.__stopped = True</font>
<font color="red"> 864.         self.__block.notify_all()</font>
<font color="red"> 865.         self.__block.release()</font>
<font color="black"> 866. </font>
<font color="red"> 867.     def __delete(self):</font>
<font color="black"> 868.         &quot;Remove current thread from the dict of currently running threads.&quot;</font>
<font color="black"> 869. </font>
<font color="black"> 870.         # Notes about running with dummy_thread:</font>
<font color="black"> 871.         #</font>
<font color="black"> 872.         # Must take care to not raise an exception if dummy_thread is being</font>
<font color="black"> 873.         # used (and thus this module is being used as an instance of</font>
<font color="black"> 874.         # dummy_threading).  dummy_thread.get_ident() always returns -1 since</font>
<font color="black"> 875.         # there is only one thread if dummy_thread is being used.  Thus</font>
<font color="black"> 876.         # len(_active) is always &lt;= 1 here, and any Thread instance created</font>
<font color="black"> 877.         # overwrites the (if any) thread currently registered in _active.</font>
<font color="black"> 878.         #</font>
<font color="black"> 879.         # An instance of _MainThread is always created by 'threading'.  This</font>
<font color="black"> 880.         # gets overwritten the instant an instance of Thread is created; both</font>
<font color="black"> 881.         # threads return -1 from dummy_thread.get_ident() and thus have the</font>
<font color="black"> 882.         # same key in the dict.  So when the _MainThread instance created by</font>
<font color="black"> 883.         # 'threading' tries to clean itself up when atexit calls this method</font>
<font color="black"> 884.         # it gets a KeyError if another Thread instance was created.</font>
<font color="black"> 885.         #</font>
<font color="black"> 886.         # This all means that KeyError from trying to delete something from</font>
<font color="black"> 887.         # _active if dummy_threading is being used is a red herring.  But</font>
<font color="black"> 888.         # since it isn't if dummy_threading is *not* being used then don't</font>
<font color="black"> 889.         # hide the exception.</font>
<font color="black"> 890. </font>
<font color="red"> 891.         try:</font>
<font color="red"> 892.             with _active_limbo_lock:</font>
<font color="red"> 893.                 del _active[_get_ident()]</font>
<font color="black"> 894.                 # There must not be any python code between the previous line</font>
<font color="black"> 895.                 # and after the lock is released.  Otherwise a tracing function</font>
<font color="black"> 896.                 # could try to acquire the lock again in the same thread, (in</font>
<font color="black"> 897.                 # current_thread()), and would block.</font>
<font color="red"> 898.         except KeyError:</font>
<font color="red"> 899.             if 'dummy_threading' not in _sys.modules:</font>
<font color="red"> 900.                 raise</font>
<font color="black"> 901. </font>
<font color="red"> 902.     def join(self, timeout=None):</font>
<font color="black"> 903.         &quot;&quot;&quot;Wait until the thread terminates.</font>
<font color="black"> 904. </font>
<font color="black"> 905.         This blocks the calling thread until the thread whose join() method is</font>
<font color="black"> 906.         called terminates -- either normally or through an unhandled exception</font>
<font color="black"> 907.         or until the optional timeout occurs.</font>
<font color="black"> 908. </font>
<font color="black"> 909.         When the timeout argument is present and not None, it should be a</font>
<font color="black"> 910.         floating point number specifying a timeout for the operation in seconds</font>
<font color="black"> 911.         (or fractions thereof). As join() always returns None, you must call</font>
<font color="black"> 912.         isAlive() after join() to decide whether a timeout happened -- if the</font>
<font color="black"> 913.         thread is still alive, the join() call timed out.</font>
<font color="black"> 914. </font>
<font color="black"> 915.         When the timeout argument is not present or None, the operation will</font>
<font color="black"> 916.         block until the thread terminates.</font>
<font color="black"> 917. </font>
<font color="black"> 918.         A thread can be join()ed many times.</font>
<font color="black"> 919. </font>
<font color="black"> 920.         join() raises a RuntimeError if an attempt is made to join the current</font>
<font color="black"> 921.         thread as that would cause a deadlock. It is also an error to join() a</font>
<font color="black"> 922.         thread before it has been started and attempts to do so raises the same</font>
<font color="black"> 923.         exception.</font>
<font color="black"> 924. </font>
<font color="black"> 925.         &quot;&quot;&quot;</font>
<font color="red"> 926.         if not self.__initialized:</font>
<font color="red"> 927.             raise RuntimeError(&quot;Thread.__init__() not called&quot;)</font>
<font color="red"> 928.         if not self.__started.is_set():</font>
<font color="red"> 929.             raise RuntimeError(&quot;cannot join thread before it is started&quot;)</font>
<font color="red"> 930.         if self is current_thread():</font>
<font color="red"> 931.             raise RuntimeError(&quot;cannot join current thread&quot;)</font>
<font color="black"> 932. </font>
<font color="black"> 933.         if __debug__:</font>
<font color="red"> 934.             if not self.__stopped:</font>
<font color="red"> 935.                 self._note(&quot;%s.join(): waiting until thread stops&quot;, self)</font>
<font color="red"> 936.         self.__block.acquire()</font>
<font color="red"> 937.         try:</font>
<font color="red"> 938.             if timeout is None:</font>
<font color="red"> 939.                 while not self.__stopped:</font>
<font color="red"> 940.                     self.__block.wait()</font>
<font color="black"> 941.                 if __debug__:</font>
<font color="red"> 942.                     self._note(&quot;%s.join(): thread stopped&quot;, self)</font>
<font color="black"> 943.             else:</font>
<font color="red"> 944.                 deadline = _time() + timeout</font>
<font color="red"> 945.                 while not self.__stopped:</font>
<font color="red"> 946.                     delay = deadline - _time()</font>
<font color="red"> 947.                     if delay &lt;= 0:</font>
<font color="black"> 948.                         if __debug__:</font>
<font color="red"> 949.                             self._note(&quot;%s.join(): timed out&quot;, self)</font>
<font color="red"> 950.                         break</font>
<font color="red"> 951.                     self.__block.wait(delay)</font>
<font color="black"> 952.                 else:</font>
<font color="black"> 953.                     if __debug__:</font>
<font color="red"> 954.                         self._note(&quot;%s.join(): thread stopped&quot;, self)</font>
<font color="black"> 955.         finally:</font>
<font color="red"> 956.             self.__block.release()</font>
<font color="black"> 957. </font>
<font color="red"> 958.     @property</font>
<font color="black"> 959.     def name(self):</font>
<font color="black"> 960.         &quot;&quot;&quot;A string used for identification purposes only.</font>
<font color="black"> 961. </font>
<font color="black"> 962.         It has no semantics. Multiple threads may be given the same name. The</font>
<font color="black"> 963.         initial name is set by the constructor.</font>
<font color="black"> 964. </font>
<font color="black"> 965.         &quot;&quot;&quot;</font>
<font color="red"> 966.         assert self.__initialized, &quot;Thread.__init__() not called&quot;</font>
<font color="red"> 967.         return self.__name</font>
<font color="black"> 968. </font>
<font color="red"> 969.     @name.setter</font>
<font color="black"> 970.     def name(self, name):</font>
<font color="red"> 971.         assert self.__initialized, &quot;Thread.__init__() not called&quot;</font>
<font color="red"> 972.         self.__name = str(name)</font>
<font color="black"> 973. </font>
<font color="red"> 974.     @property</font>
<font color="black"> 975.     def ident(self):</font>
<font color="black"> 976.         &quot;&quot;&quot;Thread identifier of this thread or None if it has not been started.</font>
<font color="black"> 977. </font>
<font color="black"> 978.         This is a nonzero integer. See the thread.get_ident() function. Thread</font>
<font color="black"> 979.         identifiers may be recycled when a thread exits and another thread is</font>
<font color="black"> 980.         created. The identifier is available even after the thread has exited.</font>
<font color="black"> 981. </font>
<font color="black"> 982.         &quot;&quot;&quot;</font>
<font color="red"> 983.         assert self.__initialized, &quot;Thread.__init__() not called&quot;</font>
<font color="red"> 984.         return self.__ident</font>
<font color="black"> 985. </font>
<font color="red"> 986.     def isAlive(self):</font>
<font color="black"> 987.         &quot;&quot;&quot;Return whether the thread is alive.</font>
<font color="black"> 988. </font>
<font color="black"> 989.         This method returns True just before the run() method starts until just</font>
<font color="black"> 990.         after the run() method terminates. The module function enumerate()</font>
<font color="black"> 991.         returns a list of all alive threads.</font>
<font color="black"> 992. </font>
<font color="black"> 993.         &quot;&quot;&quot;</font>
<font color="red"> 994.         assert self.__initialized, &quot;Thread.__init__() not called&quot;</font>
<font color="red"> 995.         return self.__started.is_set() and not self.__stopped</font>
<font color="black"> 996. </font>
<font color="red"> 997.     is_alive = isAlive</font>
<font color="black"> 998. </font>
<font color="red"> 999.     @property</font>
<font color="black">1000.     def daemon(self):</font>
<font color="black">1001.         &quot;&quot;&quot;A boolean value indicating whether this thread is a daemon thread (True) or not (False).</font>
<font color="black">1002. </font>
<font color="black">1003.         This must be set before start() is called, otherwise RuntimeError is</font>
<font color="black">1004.         raised. Its initial value is inherited from the creating thread; the</font>
<font color="black">1005.         main thread is not a daemon thread and therefore all threads created in</font>
<font color="black">1006.         the main thread default to daemon = False.</font>
<font color="black">1007. </font>
<font color="black">1008.         The entire Python program exits when no alive non-daemon threads are</font>
<font color="black">1009.         left.</font>
<font color="black">1010. </font>
<font color="black">1011.         &quot;&quot;&quot;</font>
<font color="red">1012.         assert self.__initialized, &quot;Thread.__init__() not called&quot;</font>
<font color="red">1013.         return self.__daemonic</font>
<font color="black">1014. </font>
<font color="red">1015.     @daemon.setter</font>
<font color="black">1016.     def daemon(self, daemonic):</font>
<font color="red">1017.         if not self.__initialized:</font>
<font color="red">1018.             raise RuntimeError(&quot;Thread.__init__() not called&quot;)</font>
<font color="red">1019.         if self.__started.is_set():</font>
<font color="red">1020.             raise RuntimeError(&quot;cannot set daemon status of active thread&quot;);</font>
<font color="red">1021.         self.__daemonic = daemonic</font>
<font color="black">1022. </font>
<font color="red">1023.     def isDaemon(self):</font>
<font color="red">1024.         return self.daemon</font>
<font color="black">1025. </font>
<font color="red">1026.     def setDaemon(self, daemonic):</font>
<font color="red">1027.         self.daemon = daemonic</font>
<font color="black">1028. </font>
<font color="red">1029.     def getName(self):</font>
<font color="red">1030.         return self.name</font>
<font color="black">1031. </font>
<font color="red">1032.     def setName(self, name):</font>
<font color="red">1033.         self.name = name</font>
<font color="black">1034. </font>
<font color="black">1035. # The timer class was contributed by Itamar Shtull-Trauring</font>
<font color="black">1036. </font>
<font color="red">1037. def Timer(*args, **kwargs):</font>
<font color="black">1038.     &quot;&quot;&quot;Factory function to create a Timer object.</font>
<font color="black">1039. </font>
<font color="black">1040.     Timers call a function after a specified number of seconds:</font>
<font color="black">1041. </font>
<font color="black">1042.         t = Timer(30.0, f, args=[], kwargs={})</font>
<font color="black">1043.         t.start()</font>
<font color="black">1044.         t.cancel()     # stop the timer's action if it's still waiting</font>
<font color="black">1045. </font>
<font color="black">1046.     &quot;&quot;&quot;</font>
<font color="red">1047.     return _Timer(*args, **kwargs)</font>
<font color="black">1048. </font>
<font color="red">1049. class _Timer(Thread):</font>
<font color="black">1050.     &quot;&quot;&quot;Call a function after a specified number of seconds:</font>
<font color="black">1051. </font>
<font color="black">1052.             t = Timer(30.0, f, args=[], kwargs={})</font>
<font color="black">1053.             t.start()</font>
<font color="black">1054.             t.cancel()     # stop the timer's action if it's still waiting</font>
<font color="black">1055. </font>
<font color="red">1056.     &quot;&quot;&quot;</font>
<font color="black">1057. </font>
<font color="red">1058.     def __init__(self, interval, function, args=[], kwargs={}):</font>
<font color="red">1059.         Thread.__init__(self)</font>
<font color="red">1060.         self.interval = interval</font>
<font color="red">1061.         self.function = function</font>
<font color="red">1062.         self.args = args</font>
<font color="red">1063.         self.kwargs = kwargs</font>
<font color="red">1064.         self.finished = Event()</font>
<font color="black">1065. </font>
<font color="red">1066.     def cancel(self):</font>
<font color="black">1067.         &quot;&quot;&quot;Stop the timer if it hasn't finished yet&quot;&quot;&quot;</font>
<font color="red">1068.         self.finished.set()</font>
<font color="black">1069. </font>
<font color="red">1070.     def run(self):</font>
<font color="red">1071.         self.finished.wait(self.interval)</font>
<font color="red">1072.         if not self.finished.is_set():</font>
<font color="red">1073.             self.function(*self.args, **self.kwargs)</font>
<font color="red">1074.         self.finished.set()</font>
<font color="black">1075. </font>
<font color="black">1076. # Special thread class to represent the main thread</font>
<font color="black">1077. # This is garbage collected through an exit handler</font>
<font color="black">1078. </font>
<font color="red">1079. class _MainThread(Thread):</font>
<font color="black">1080. </font>
<font color="red">1081.     def __init__(self):</font>
<font color="red">1082.         Thread.__init__(self, name=&quot;MainThread&quot;)</font>
<font color="red">1083.         self._Thread__started.set()</font>
<font color="red">1084.         self._set_ident()</font>
<font color="red">1085.         with _active_limbo_lock:</font>
<font color="red">1086.             _active[_get_ident()] = self</font>
<font color="black">1087. </font>
<font color="red">1088.     def _set_daemon(self):</font>
<font color="red">1089.         return False</font>
<font color="black">1090. </font>
<font color="red">1091.     def _exitfunc(self):</font>
<font color="red">1092.         self._Thread__stop()</font>
<font color="red">1093.         t = _pickSomeNonDaemonThread()</font>
<font color="red">1094.         if t:</font>
<font color="black">1095.             if __debug__:</font>
<font color="red">1096.                 self._note(&quot;%s: waiting for other threads&quot;, self)</font>
<font color="red">1097.         while t:</font>
<font color="red">1098.             t.join()</font>
<font color="red">1099.             t = _pickSomeNonDaemonThread()</font>
<font color="black">1100.         if __debug__:</font>
<font color="red">1101.             self._note(&quot;%s: exiting&quot;, self)</font>
<font color="red">1102.         self._Thread__delete()</font>
<font color="black">1103. </font>
<font color="red">1104. def _pickSomeNonDaemonThread():</font>
<font color="red">1105.     for t in enumerate():</font>
<font color="red">1106.         if not t.daemon and t.is_alive():</font>
<font color="red">1107.             return t</font>
<font color="red">1108.     return None</font>
<font color="black">1109. </font>
<font color="black">1110. </font>
<font color="black">1111. # Dummy thread class to represent threads not started here.</font>
<font color="black">1112. # These aren't garbage collected when they die, nor can they be waited for.</font>
<font color="black">1113. # If they invoke anything in threading.py that calls current_thread(), they</font>
<font color="black">1114. # leave an entry in the _active dict forever after.</font>
<font color="black">1115. # Their purpose is to return *something* from current_thread().</font>
<font color="black">1116. # They are marked as daemon threads so we won't wait for them</font>
<font color="black">1117. # when we exit (conform previous semantics).</font>
<font color="black">1118. </font>
<font color="red">1119. class _DummyThread(Thread):</font>
<font color="black">1120. </font>
<font color="red">1121.     def __init__(self):</font>
<font color="red">1122.         Thread.__init__(self, name=_newname(&quot;Dummy-%d&quot;))</font>
<font color="black">1123. </font>
<font color="black">1124.         # Thread.__block consumes an OS-level locking primitive, which</font>
<font color="black">1125.         # can never be used by a _DummyThread.  Since a _DummyThread</font>
<font color="black">1126.         # instance is immortal, that's bad, so release this resource.</font>
<font color="red">1127.         del self._Thread__block</font>
<font color="black">1128. </font>
<font color="red">1129.         self._Thread__started.set()</font>
<font color="red">1130.         self._set_ident()</font>
<font color="red">1131.         with _active_limbo_lock:</font>
<font color="red">1132.             _active[_get_ident()] = self</font>
<font color="black">1133. </font>
<font color="red">1134.     def _set_daemon(self):</font>
<font color="red">1135.         return True</font>
<font color="black">1136. </font>
<font color="red">1137.     def join(self, timeout=None):</font>
<font color="red">1138.         assert False, &quot;cannot join a dummy thread&quot;</font>
<font color="black">1139. </font>
<font color="black">1140. </font>
<font color="black">1141. # Global API functions</font>
<font color="black">1142. </font>
<font color="red">1143. def currentThread():</font>
<font color="black">1144.     &quot;&quot;&quot;Return the current Thread object, corresponding to the caller's thread of control.</font>
<font color="black">1145. </font>
<font color="black">1146.     If the caller's thread of control was not created through the threading</font>
<font color="black">1147.     module, a dummy thread object with limited functionality is returned.</font>
<font color="black">1148. </font>
<font color="black">1149.     &quot;&quot;&quot;</font>
<font color="red">1150.     try:</font>
<font color="red">1151.         return _active[_get_ident()]</font>
<font color="red">1152.     except KeyError:</font>
<font color="black">1153.         ##print &quot;current_thread(): no current thread for&quot;, _get_ident()</font>
<font color="red">1154.         return _DummyThread()</font>
<font color="black">1155. </font>
<font color="red">1156. current_thread = currentThread</font>
<font color="black">1157. </font>
<font color="red">1158. def activeCount():</font>
<font color="black">1159.     &quot;&quot;&quot;Return the number of Thread objects currently alive.</font>
<font color="black">1160. </font>
<font color="black">1161.     The returned count is equal to the length of the list returned by</font>
<font color="black">1162.     enumerate().</font>
<font color="black">1163. </font>
<font color="black">1164.     &quot;&quot;&quot;</font>
<font color="red">1165.     with _active_limbo_lock:</font>
<font color="red">1166.         return len(_active) + len(_limbo)</font>
<font color="black">1167. </font>
<font color="red">1168. active_count = activeCount</font>
<font color="black">1169. </font>
<font color="red">1170. def _enumerate():</font>
<font color="black">1171.     # Same as enumerate(), but without the lock. Internal use only.</font>
<font color="red">1172.     return _active.values() + _limbo.values()</font>
<font color="black">1173. </font>
<font color="red">1174. def enumerate():</font>
<font color="black">1175.     &quot;&quot;&quot;Return a list of all Thread objects currently alive.</font>
<font color="black">1176. </font>
<font color="black">1177.     The list includes daemonic threads, dummy thread objects created by</font>
<font color="black">1178.     current_thread(), and the main thread. It excludes terminated threads and</font>
<font color="black">1179.     threads that have not yet been started.</font>
<font color="black">1180. </font>
<font color="black">1181.     &quot;&quot;&quot;</font>
<font color="red">1182.     with _active_limbo_lock:</font>
<font color="red">1183.         return _active.values() + _limbo.values()</font>
<font color="black">1184. </font>
<font color="red">1185. from thread import stack_size</font>
<font color="black">1186. </font>
<font color="black">1187. # Create the main thread object,</font>
<font color="black">1188. # and make it available for the interpreter</font>
<font color="black">1189. # (Py_Main) as threading._shutdown.</font>
<font color="black">1190. </font>
<font color="red">1191. _shutdown = _MainThread()._exitfunc</font>
<font color="black">1192. </font>
<font color="black">1193. # get thread-local implementation, either from the thread</font>
<font color="black">1194. # module, or from the python fallback</font>
<font color="black">1195. </font>
<font color="red">1196. try:</font>
<font color="red">1197.     from thread import _local as local</font>
<font color="red">1198. except ImportError:</font>
<font color="red">1199.     from _threading_local import local</font>
<font color="black">1200. </font>
<font color="black">1201. </font>
<font color="red">1202. def _after_fork():</font>
<font color="black">1203.     # This function is called by Python/ceval.c:PyEval_ReInitThreads which</font>
<font color="black">1204.     # is called from PyOS_AfterFork.  Here we cleanup threading module state</font>
<font color="black">1205.     # that should not exist after a fork.</font>
<font color="black">1206. </font>
<font color="black">1207.     # Reset _active_limbo_lock, in case we forked while the lock was held</font>
<font color="black">1208.     # by another (non-forked) thread.  http://bugs.python.org/issue874900</font>
<font color="black">1209.     global _active_limbo_lock</font>
<font color="red">1210.     _active_limbo_lock = _allocate_lock()</font>
<font color="black">1211. </font>
<font color="black">1212.     # fork() only copied the current thread; clear references to others.</font>
<font color="red">1213.     new_active = {}</font>
<font color="red">1214.     current = current_thread()</font>
<font color="red">1215.     with _active_limbo_lock:</font>
<font color="red">1216.         for thread in _enumerate():</font>
<font color="black">1217.             # Any lock/condition variable may be currently locked or in an</font>
<font color="black">1218.             # invalid state, so we reinitialize them.</font>
<font color="red">1219.             if hasattr(thread, '_reset_internal_locks'):</font>
<font color="red">1220.                 thread._reset_internal_locks()</font>
<font color="red">1221.             if thread is current:</font>
<font color="black">1222.                 # There is only one active thread. We reset the ident to</font>
<font color="black">1223.                 # its new value since it can have changed.</font>
<font color="red">1224.                 ident = _get_ident()</font>
<font color="red">1225.                 thread._Thread__ident = ident</font>
<font color="red">1226.                 new_active[ident] = thread</font>
<font color="black">1227.             else:</font>
<font color="black">1228.                 # All the others are already stopped.</font>
<font color="red">1229.                 thread._Thread__stop()</font>
<font color="black">1230. </font>
<font color="red">1231.         _limbo.clear()</font>
<font color="red">1232.         _active.clear()</font>
<font color="red">1233.         _active.update(new_active)</font>
<font color="red">1234.         assert len(_active) == 1</font>
<font color="black">1235. </font>
<font color="black">1236. </font>
<font color="black">1237. # Self-test code</font>
<font color="black">1238. </font>
<font color="red">1239. def _test():</font>
<font color="black">1240. </font>
<font color="red">1241.     class BoundedQueue(_Verbose):</font>
<font color="black">1242. </font>
<font color="red">1243.         def __init__(self, limit):</font>
<font color="red">1244.             _Verbose.__init__(self)</font>
<font color="red">1245.             self.mon = RLock()</font>
<font color="red">1246.             self.rc = Condition(self.mon)</font>
<font color="red">1247.             self.wc = Condition(self.mon)</font>
<font color="red">1248.             self.limit = limit</font>
<font color="red">1249.             self.queue = _deque()</font>
<font color="black">1250. </font>
<font color="red">1251.         def put(self, item):</font>
<font color="red">1252.             self.mon.acquire()</font>
<font color="red">1253.             while len(self.queue) &gt;= self.limit:</font>
<font color="red">1254.                 self._note(&quot;put(%s): queue full&quot;, item)</font>
<font color="red">1255.                 self.wc.wait()</font>
<font color="red">1256.             self.queue.append(item)</font>
<font color="red">1257.             self._note(&quot;put(%s): appended, length now %d&quot;,</font>
<font color="red">1258.                        item, len(self.queue))</font>
<font color="red">1259.             self.rc.notify()</font>
<font color="red">1260.             self.mon.release()</font>
<font color="black">1261. </font>
<font color="red">1262.         def get(self):</font>
<font color="red">1263.             self.mon.acquire()</font>
<font color="red">1264.             while not self.queue:</font>
<font color="red">1265.                 self._note(&quot;get(): queue empty&quot;)</font>
<font color="red">1266.                 self.rc.wait()</font>
<font color="red">1267.             item = self.queue.popleft()</font>
<font color="red">1268.             self._note(&quot;get(): got %s, %d left&quot;, item, len(self.queue))</font>
<font color="red">1269.             self.wc.notify()</font>
<font color="red">1270.             self.mon.release()</font>
<font color="red">1271.             return item</font>
<font color="black">1272. </font>
<font color="red">1273.     class ProducerThread(Thread):</font>
<font color="black">1274. </font>
<font color="red">1275.         def __init__(self, queue, quota):</font>
<font color="red">1276.             Thread.__init__(self, name=&quot;Producer&quot;)</font>
<font color="red">1277.             self.queue = queue</font>
<font color="red">1278.             self.quota = quota</font>
<font color="black">1279. </font>
<font color="red">1280.         def run(self):</font>
<font color="red">1281.             from random import random</font>
<font color="red">1282.             counter = 0</font>
<font color="red">1283.             while counter &lt; self.quota:</font>
<font color="red">1284.                 counter = counter + 1</font>
<font color="red">1285.                 self.queue.put(&quot;%s.%d&quot; % (self.name, counter))</font>
<font color="red">1286.                 _sleep(random() * 0.00001)</font>
<font color="black">1287. </font>
<font color="black">1288. </font>
<font color="red">1289.     class ConsumerThread(Thread):</font>
<font color="black">1290. </font>
<font color="red">1291.         def __init__(self, queue, count):</font>
<font color="red">1292.             Thread.__init__(self, name=&quot;Consumer&quot;)</font>
<font color="red">1293.             self.queue = queue</font>
<font color="red">1294.             self.count = count</font>
<font color="black">1295. </font>
<font color="red">1296.         def run(self):</font>
<font color="red">1297.             while self.count &gt; 0:</font>
<font color="red">1298.                 item = self.queue.get()</font>
<font color="red">1299.                 print item</font>
<font color="red">1300.                 self.count = self.count - 1</font>
<font color="black">1301. </font>
<font color="red">1302.     NP = 3</font>
<font color="red">1303.     QL = 4</font>
<font color="red">1304.     NI = 5</font>
<font color="black">1305. </font>
<font color="red">1306.     Q = BoundedQueue(QL)</font>
<font color="red">1307.     P = []</font>
<font color="red">1308.     for i in range(NP):</font>
<font color="red">1309.         t = ProducerThread(Q, NI)</font>
<font color="red">1310.         t.name = (&quot;Producer-%d&quot; % (i+1))</font>
<font color="red">1311.         P.append(t)</font>
<font color="red">1312.     C = ConsumerThread(Q, NI*NP)</font>
<font color="red">1313.     for t in P:</font>
<font color="red">1314.         t.start()</font>
<font color="red">1315.         _sleep(0.000001)</font>
<font color="red">1316.     C.start()</font>
<font color="red">1317.     for t in P:</font>
<font color="red">1318.         t.join()</font>
<font color="red">1319.     C.join()</font>
<font color="black">1320. </font>
<font color="red">1321. if __name__ == '__main__':</font>
<font color="red">1322.     _test()</font>
</pre>

