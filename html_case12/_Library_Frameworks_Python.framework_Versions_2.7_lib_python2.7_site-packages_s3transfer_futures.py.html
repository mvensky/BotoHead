source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/s3transfer/futures.py</b><br>


file stats: <b>257 lines, 86 executed: 33.5% covered</b>
<pre>
<font color="black">   1. # Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="green">  13. from concurrent import futures</font>
<font color="green">  14. from collections import namedtuple</font>
<font color="green">  15. import copy</font>
<font color="green">  16. import logging</font>
<font color="green">  17. import sys</font>
<font color="green">  18. import threading</font>
<font color="black">  19. </font>
<font color="green">  20. from s3transfer.compat import MAXINT</font>
<font color="green">  21. from s3transfer.compat import six</font>
<font color="green">  22. from s3transfer.exceptions import CancelledError, TransferNotDoneError</font>
<font color="green">  23. from s3transfer.utils import FunctionContainer</font>
<font color="green">  24. from s3transfer.utils import TaskSemaphore</font>
<font color="black">  25. </font>
<font color="black">  26. </font>
<font color="green">  27. logger = logging.getLogger(__name__)</font>
<font color="black">  28. </font>
<font color="black">  29. </font>
<font color="green">  30. class TransferFuture(object):</font>
<font color="green">  31.     def __init__(self, meta=None, coordinator=None):</font>
<font color="black">  32.         &quot;&quot;&quot;The future associated to a submitted transfer request</font>
<font color="black">  33. </font>
<font color="black">  34.         :type meta: TransferMeta</font>
<font color="black">  35.         :param meta: The metadata associated to the request. This object</font>
<font color="black">  36.             is visible to the requester.</font>
<font color="black">  37. </font>
<font color="black">  38.         :type coordinator: TransferCoordinator</font>
<font color="black">  39.         :param coordinator: The coordinator associated to the request. This</font>
<font color="black">  40.             object is not visible to the requester.</font>
<font color="black">  41.         &quot;&quot;&quot;</font>
<font color="red">  42.         self._meta = meta</font>
<font color="red">  43.         if meta is None:</font>
<font color="red">  44.             self._meta = TransferMeta()</font>
<font color="black">  45. </font>
<font color="red">  46.         self._coordinator = coordinator</font>
<font color="red">  47.         if coordinator is None:</font>
<font color="red">  48.             self._coordinator = TransferCoordinator()</font>
<font color="black">  49. </font>
<font color="green">  50.     @property</font>
<font color="black">  51.     def meta(self):</font>
<font color="black">  52.         &quot;&quot;&quot;The metadata associated tio the TransferFuture&quot;&quot;&quot;</font>
<font color="red">  53.         return self._meta</font>
<font color="black">  54. </font>
<font color="green">  55.     def done(self):</font>
<font color="black">  56.         &quot;&quot;&quot;Determines if a TransferFuture has completed</font>
<font color="black">  57. </font>
<font color="black">  58.         :returns: True if completed. False, otherwise.</font>
<font color="black">  59.         &quot;&quot;&quot;</font>
<font color="red">  60.         return self._coordinator.done()</font>
<font color="black">  61. </font>
<font color="green">  62.     def result(self):</font>
<font color="black">  63.         &quot;&quot;&quot;Waits until TransferFuture is done and returns the result</font>
<font color="black">  64. </font>
<font color="black">  65.         If the TransferFuture succeeded, it will return the result. If the</font>
<font color="black">  66.         TransferFuture failed, it will raise the exception associated to the</font>
<font color="black">  67.         failure.</font>
<font color="black">  68.         &quot;&quot;&quot;</font>
<font color="red">  69.         try:</font>
<font color="black">  70.             # Usually the result() method blocks until the transfer is done,</font>
<font color="black">  71.             # however if a KeyboardInterrupt is raised we want want to exit</font>
<font color="black">  72.             # out of this and propogate the exception.</font>
<font color="red">  73.             return self._coordinator.result()</font>
<font color="red">  74.         except KeyboardInterrupt as e:</font>
<font color="red">  75.             self.cancel()</font>
<font color="red">  76.             raise e</font>
<font color="black">  77. </font>
<font color="green">  78.     def cancel(self):</font>
<font color="black">  79.         &quot;&quot;&quot;Cancels the request associated with the TransferFuture&quot;&quot;&quot;</font>
<font color="red">  80.         self._coordinator.cancel()</font>
<font color="black">  81. </font>
<font color="green">  82.     def set_exception(self, exception):</font>
<font color="black">  83.         &quot;&quot;&quot;Sets the exception on the future.&quot;&quot;&quot;</font>
<font color="red">  84.         if not self.done():</font>
<font color="red">  85.             raise TransferNotDoneError(</font>
<font color="red">  86.                 'set_exception can only be called once the transfer is '</font>
<font color="black">  87.                 'complete.')</font>
<font color="red">  88.         self._coordinator.set_exception(exception, override=True)</font>
<font color="black">  89. </font>
<font color="black">  90. </font>
<font color="green">  91. class TransferMeta(object):</font>
<font color="green">  92.     &quot;&quot;&quot;Holds metadata about the TransferFuture&quot;&quot;&quot;</font>
<font color="green">  93.     def __init__(self, call_args=None, transfer_id=None):</font>
<font color="red">  94.         self._call_args = call_args</font>
<font color="red">  95.         self._transfer_id = transfer_id</font>
<font color="red">  96.         self._size = None</font>
<font color="red">  97.         self._user_context = {}</font>
<font color="black">  98. </font>
<font color="green">  99.     @property</font>
<font color="black"> 100.     def call_args(self):</font>
<font color="black"> 101.         &quot;&quot;&quot;The call args used in the transfer request&quot;&quot;&quot;</font>
<font color="red"> 102.         return self._call_args</font>
<font color="black"> 103. </font>
<font color="green"> 104.     @property</font>
<font color="black"> 105.     def transfer_id(self):</font>
<font color="black"> 106.         &quot;&quot;&quot;The unique id of the transfer&quot;&quot;&quot;</font>
<font color="red"> 107.         return self._transfer_id</font>
<font color="black"> 108. </font>
<font color="green"> 109.     @property</font>
<font color="black"> 110.     def size(self):</font>
<font color="black"> 111.         &quot;&quot;&quot;The size of the transfer request if known&quot;&quot;&quot;</font>
<font color="red"> 112.         return self._size</font>
<font color="black"> 113. </font>
<font color="green"> 114.     @property</font>
<font color="black"> 115.     def user_context(self):</font>
<font color="black"> 116.         &quot;&quot;&quot;A dictionary that requesters can store data in&quot;&quot;&quot;</font>
<font color="red"> 117.         return self._user_context</font>
<font color="black"> 118. </font>
<font color="green"> 119.     def provide_transfer_size(self, size):</font>
<font color="black"> 120.         &quot;&quot;&quot;A method to provide the size of a transfer request</font>
<font color="black"> 121. </font>
<font color="black"> 122.         By providing this value, the TransferManager will not try to</font>
<font color="black"> 123.         call HeadObject or use the use OS to determine the size of the</font>
<font color="black"> 124.         transfer.</font>
<font color="black"> 125.         &quot;&quot;&quot;</font>
<font color="red"> 126.         self._size = size</font>
<font color="black"> 127. </font>
<font color="black"> 128. </font>
<font color="green"> 129. class TransferCoordinator(object):</font>
<font color="green"> 130.     &quot;&quot;&quot;A helper class for managing TransferFuture&quot;&quot;&quot;</font>
<font color="green"> 131.     def __init__(self, transfer_id=None):</font>
<font color="red"> 132.         self.transfer_id = transfer_id</font>
<font color="red"> 133.         self._status = 'not-started'</font>
<font color="red"> 134.         self._result = None</font>
<font color="red"> 135.         self._exception = None</font>
<font color="red"> 136.         self._associated_futures = set()</font>
<font color="red"> 137.         self._failure_cleanups = []</font>
<font color="red"> 138.         self._done_callbacks = []</font>
<font color="red"> 139.         self._done_event = threading.Event()</font>
<font color="red"> 140.         self._lock = threading.Lock()</font>
<font color="red"> 141.         self._associated_futures_lock = threading.Lock()</font>
<font color="red"> 142.         self._done_callbacks_lock = threading.Lock()</font>
<font color="red"> 143.         self._failure_cleanups_lock = threading.Lock()</font>
<font color="black"> 144. </font>
<font color="green"> 145.     def __repr__(self):</font>
<font color="red"> 146.         return '%s(transfer_id=%s)' % (</font>
<font color="red"> 147.             self.__class__.__name__, self.transfer_id)</font>
<font color="black"> 148. </font>
<font color="green"> 149.     @property</font>
<font color="black"> 150.     def exception(self):</font>
<font color="red"> 151.         return self._exception</font>
<font color="black"> 152. </font>
<font color="green"> 153.     @property</font>
<font color="black"> 154.     def associated_futures(self):</font>
<font color="black"> 155.         &quot;&quot;&quot;The list of futures associated to the inprogress TransferFuture</font>
<font color="black"> 156. </font>
<font color="black"> 157.         Once the transfer finishes this list becomes empty as the transfer</font>
<font color="black"> 158.         is considered done and there should be no running futures left.</font>
<font color="black"> 159.         &quot;&quot;&quot;</font>
<font color="red"> 160.         with self._associated_futures_lock:</font>
<font color="black"> 161.             # We return a copy of the list because we do not want to</font>
<font color="black"> 162.             # processing the returned list while another thread is adding</font>
<font color="black"> 163.             # more futures to the actual list.</font>
<font color="red"> 164.             return copy.copy(self._associated_futures)</font>
<font color="black"> 165. </font>
<font color="green"> 166.     @property</font>
<font color="black"> 167.     def failure_cleanups(self):</font>
<font color="black"> 168.         &quot;&quot;&quot;The list of callbacks to call when the TransferFuture fails&quot;&quot;&quot;</font>
<font color="red"> 169.         return self._failure_cleanups</font>
<font color="black"> 170. </font>
<font color="green"> 171.     @property</font>
<font color="black"> 172.     def status(self):</font>
<font color="black"> 173.         &quot;&quot;&quot;The status of the TransferFuture</font>
<font color="black"> 174. </font>
<font color="black"> 175.         The currently supported states are:</font>
<font color="black"> 176.             * not-started - Has yet to start. If in this state, a transfer</font>
<font color="black"> 177.               can be canceled immediately and nothing will happen.</font>
<font color="black"> 178.             * queued - SubmissionTask is about to submit tasks</font>
<font color="black"> 179.             * running - Is inprogress. In-progress as of now means that</font>
<font color="black"> 180.               the SubmissionTask that runs the transfer is being executed. So</font>
<font color="black"> 181.               there is no guarantee any transfer requests had been made to</font>
<font color="black"> 182.               S3 if this state is reached.</font>
<font color="black"> 183.             * cancelled - Was cancelled</font>
<font color="black"> 184.             * failed - An exception other than CancelledError was thrown</font>
<font color="black"> 185.             * success - No exceptions were thrown and is done.</font>
<font color="black"> 186.         &quot;&quot;&quot;</font>
<font color="red"> 187.         return self._status</font>
<font color="black"> 188. </font>
<font color="green"> 189.     def set_result(self, result):</font>
<font color="black"> 190.         &quot;&quot;&quot;Set a result for the TransferFuture</font>
<font color="black"> 191. </font>
<font color="black"> 192.         Implies that the TransferFuture succeeded. This will always set a</font>
<font color="black"> 193.         result because it is invoked on the final task where there is only</font>
<font color="black"> 194.         ever one final task and it is ran at the very end of a transfer</font>
<font color="black"> 195.         process. So if a result is being set for this final task, the transfer</font>
<font color="black"> 196.         succeeded even if something came a long and canceled the transfer</font>
<font color="black"> 197.         on the final task.</font>
<font color="black"> 198.         &quot;&quot;&quot;</font>
<font color="red"> 199.         with self._lock:</font>
<font color="red"> 200.             self._exception = None</font>
<font color="red"> 201.             self._result = result</font>
<font color="red"> 202.             self._status = 'success'</font>
<font color="black"> 203. </font>
<font color="green"> 204.     def set_exception(self, exception, override=False):</font>
<font color="black"> 205.         &quot;&quot;&quot;Set an exception for the TransferFuture</font>
<font color="black"> 206. </font>
<font color="black"> 207.         Implies the TransferFuture failed.</font>
<font color="black"> 208. </font>
<font color="black"> 209.         :param exception: The exception that cause the transfer to fail.</font>
<font color="black"> 210.         :param override: If True, override any existing state.</font>
<font color="black"> 211.         &quot;&quot;&quot;</font>
<font color="red"> 212.         with self._lock:</font>
<font color="red"> 213.             if not self.done() or override:</font>
<font color="red"> 214.                 self._exception = exception</font>
<font color="red"> 215.                 self._status = 'failed'</font>
<font color="black"> 216. </font>
<font color="green"> 217.     def result(self):</font>
<font color="black"> 218.         &quot;&quot;&quot;Waits until TransferFuture is done and returns the result</font>
<font color="black"> 219. </font>
<font color="black"> 220.         If the TransferFuture succeeded, it will return the result. If the</font>
<font color="black"> 221.         TransferFuture failed, it will raise the exception associated to the</font>
<font color="black"> 222.         failure.</font>
<font color="black"> 223.         &quot;&quot;&quot;</font>
<font color="black"> 224.         # Doing a wait() with no timeout cannot be interrupted in python2 but</font>
<font color="black"> 225.         # can be interrupted in python3 so we just wait with the largest</font>
<font color="black"> 226.         # possible value integer value, which is on the scale of billions of</font>
<font color="black"> 227.         # years...</font>
<font color="red"> 228.         self._done_event.wait(MAXINT)</font>
<font color="black"> 229. </font>
<font color="black"> 230.         # Once done waiting, raise an exception if present or return the</font>
<font color="black"> 231.         # final result.</font>
<font color="red"> 232.         if self._exception:</font>
<font color="red"> 233.             raise self._exception</font>
<font color="red"> 234.         return self._result</font>
<font color="black"> 235. </font>
<font color="green"> 236.     def cancel(self, msg='', exc_type=CancelledError):</font>
<font color="black"> 237.         &quot;&quot;&quot;Cancels the TransferFuture</font>
<font color="black"> 238. </font>
<font color="black"> 239.         :param msg: The message to attach to the cancellation</font>
<font color="black"> 240.         :param exc_type: The type of exception to set for the cancellation</font>
<font color="black"> 241.         &quot;&quot;&quot;</font>
<font color="red"> 242.         with self._lock:</font>
<font color="red"> 243.             if not self.done():</font>
<font color="red"> 244.                 should_announce_done = False</font>
<font color="red"> 245.                 logger.debug('%s cancel(%s) called', self, msg)</font>
<font color="red"> 246.                 self._exception = exc_type(msg)</font>
<font color="red"> 247.                 if self._status == 'not-started':</font>
<font color="red"> 248.                     should_announce_done = True</font>
<font color="red"> 249.                 self._status = 'cancelled'</font>
<font color="red"> 250.                 if should_announce_done:</font>
<font color="red"> 251.                     self.announce_done()</font>
<font color="black"> 252. </font>
<font color="green"> 253.     def set_status_to_queued(self):</font>
<font color="black"> 254.         &quot;&quot;&quot;Sets the TransferFutrue's status to running&quot;&quot;&quot;</font>
<font color="red"> 255.         self._transition_to_non_done_state('queued')</font>
<font color="black"> 256. </font>
<font color="green"> 257.     def set_status_to_running(self):</font>
<font color="black"> 258.         &quot;&quot;&quot;Sets the TransferFuture's status to running&quot;&quot;&quot;</font>
<font color="red"> 259.         self._transition_to_non_done_state('running')</font>
<font color="black"> 260. </font>
<font color="green"> 261.     def _transition_to_non_done_state(self, desired_state):</font>
<font color="red"> 262.         with self._lock:</font>
<font color="red"> 263.             if self.done():</font>
<font color="red"> 264.                 raise RuntimeError(</font>
<font color="red"> 265.                     'Unable to transition from done state %s to non-done '</font>
<font color="red"> 266.                     'state %s.' % (self.status, desired_state))</font>
<font color="red"> 267.             self._status = desired_state</font>
<font color="black"> 268. </font>
<font color="green"> 269.     def submit(self, executor, task, tag=None):</font>
<font color="black"> 270.         &quot;&quot;&quot;Submits a task to a provided executor</font>
<font color="black"> 271. </font>
<font color="black"> 272.         :type executor: s3transfer.futures.BoundedExecutor</font>
<font color="black"> 273.         :param executor: The executor to submit the callable to</font>
<font color="black"> 274. </font>
<font color="black"> 275.         :type task: s3transfer.tasks.Task</font>
<font color="black"> 276.         :param task: The task to submit to the executor</font>
<font color="black"> 277. </font>
<font color="black"> 278.         :type tag: s3transfer.futures.TaskTag</font>
<font color="black"> 279.         :param tag: A tag to associate to the submitted task</font>
<font color="black"> 280. </font>
<font color="black"> 281.         :rtype: concurrent.futures.Future</font>
<font color="black"> 282.         :returns: A future representing the submitted task</font>
<font color="black"> 283.         &quot;&quot;&quot;</font>
<font color="red"> 284.         logger.debug(</font>
<font color="red"> 285.             &quot;Submitting task %s to executor %s for transfer request: %s.&quot; % (</font>
<font color="red"> 286.                 task, executor, self.transfer_id)</font>
<font color="black"> 287.         )</font>
<font color="red"> 288.         future = executor.submit(task, tag=tag)</font>
<font color="black"> 289.         # Add this created future to the list of associated future just</font>
<font color="black"> 290.         # in case it is needed during cleanups.</font>
<font color="red"> 291.         self.add_associated_future(future)</font>
<font color="red"> 292.         future.add_done_callback(</font>
<font color="red"> 293.             FunctionContainer(self.remove_associated_future, future))</font>
<font color="red"> 294.         return future</font>
<font color="black"> 295. </font>
<font color="green"> 296.     def done(self):</font>
<font color="black"> 297.         &quot;&quot;&quot;Determines if a TransferFuture has completed</font>
<font color="black"> 298. </font>
<font color="black"> 299.         :returns: False if status is equal to 'failed', 'cancelled', or</font>
<font color="black"> 300.             'success'. True, otherwise</font>
<font color="black"> 301.         &quot;&quot;&quot;</font>
<font color="red"> 302.         return self.status in ['failed', 'cancelled', 'success']</font>
<font color="black"> 303. </font>
<font color="green"> 304.     def add_associated_future(self, future):</font>
<font color="black"> 305.         &quot;&quot;&quot;Adds a future to be associated with the TransferFuture&quot;&quot;&quot;</font>
<font color="red"> 306.         with self._associated_futures_lock:</font>
<font color="red"> 307.             self._associated_futures.add(future)</font>
<font color="black"> 308. </font>
<font color="green"> 309.     def remove_associated_future(self, future):</font>
<font color="black"> 310.         &quot;&quot;&quot;Removes a future's association to the TransferFuture&quot;&quot;&quot;</font>
<font color="red"> 311.         with self._associated_futures_lock:</font>
<font color="red"> 312.             self._associated_futures.remove(future)</font>
<font color="black"> 313. </font>
<font color="green"> 314.     def add_done_callback(self, function, *args, **kwargs):</font>
<font color="black"> 315.         &quot;&quot;&quot;Add a done callback to be invoked when transfer is done&quot;&quot;&quot;</font>
<font color="red"> 316.         with self._done_callbacks_lock:</font>
<font color="red"> 317.             self._done_callbacks.append(</font>
<font color="red"> 318.                 FunctionContainer(function, *args, **kwargs)</font>
<font color="black"> 319.             )</font>
<font color="black"> 320. </font>
<font color="green"> 321.     def add_failure_cleanup(self, function, *args, **kwargs):</font>
<font color="black"> 322.         &quot;&quot;&quot;Adds a callback to call upon failure&quot;&quot;&quot;</font>
<font color="red"> 323.         with self._failure_cleanups_lock:</font>
<font color="red"> 324.             self._failure_cleanups.append(</font>
<font color="red"> 325.                 FunctionContainer(function, *args, **kwargs))</font>
<font color="black"> 326. </font>
<font color="green"> 327.     def announce_done(self):</font>
<font color="black"> 328.         &quot;&quot;&quot;Announce that future is done running and run associated callbacks</font>
<font color="black"> 329. </font>
<font color="black"> 330.         This will run any failure cleanups if the transfer failed if not</font>
<font color="black"> 331.         they have not been run, allows the result() to be unblocked, and will</font>
<font color="black"> 332.         run any done callbacks associated to the TransferFuture if they have</font>
<font color="black"> 333.         not already been ran.</font>
<font color="black"> 334.         &quot;&quot;&quot;</font>
<font color="red"> 335.         if self.status != 'success':</font>
<font color="red"> 336.             self._run_failure_cleanups()</font>
<font color="red"> 337.         self._done_event.set()</font>
<font color="red"> 338.         self._run_done_callbacks()</font>
<font color="black"> 339. </font>
<font color="green"> 340.     def _run_done_callbacks(self):</font>
<font color="black"> 341.         # Run the callbacks and remove the callbacks from the internal</font>
<font color="black"> 342.         # list so they do not get ran again if done is announced more than</font>
<font color="black"> 343.         # once.</font>
<font color="red"> 344.         with self._done_callbacks_lock:</font>
<font color="red"> 345.             self._run_callbacks(self._done_callbacks)</font>
<font color="red"> 346.             self._done_callbacks = []</font>
<font color="black"> 347. </font>
<font color="green"> 348.     def _run_failure_cleanups(self):</font>
<font color="black"> 349.         # Run the cleanup callbacks and remove the callbacks from the internal</font>
<font color="black"> 350.         # list so they do not get ran again if done is announced more than</font>
<font color="black"> 351.         # once.</font>
<font color="red"> 352.         with self._failure_cleanups_lock:</font>
<font color="red"> 353.             self._run_callbacks(self.failure_cleanups)</font>
<font color="red"> 354.             self._failure_cleanups = []</font>
<font color="black"> 355. </font>
<font color="green"> 356.     def _run_callbacks(self, callbacks):</font>
<font color="red"> 357.         for callback in callbacks:</font>
<font color="red"> 358.             self._run_callback(callback)</font>
<font color="black"> 359. </font>
<font color="green"> 360.     def _run_callback(self, callback):</font>
<font color="red"> 361.         try:</font>
<font color="red"> 362.             callback()</font>
<font color="black"> 363.         # We do not want a callback interrupting the process, especially</font>
<font color="black"> 364.         # in the failure cleanups. So log and catch, the excpetion.</font>
<font color="red"> 365.         except Exception:</font>
<font color="red"> 366.             logger.debug(&quot;Exception raised in %s.&quot; % callback, exc_info=True)</font>
<font color="black"> 367. </font>
<font color="black"> 368. </font>
<font color="green"> 369. class BoundedExecutor(object):</font>
<font color="green"> 370.     EXECUTOR_CLS = futures.ThreadPoolExecutor</font>
<font color="black"> 371. </font>
<font color="green"> 372.     def __init__(self, max_size, max_num_threads, tag_semaphores=None,</font>
<font color="green"> 373.                  executor_cls=None):</font>
<font color="black"> 374.         &quot;&quot;&quot;An executor implentation that has a maximum queued up tasks</font>
<font color="black"> 375. </font>
<font color="black"> 376.         The executor will block if the number of tasks that have been</font>
<font color="black"> 377.         submitted and is currently working on is past its maximum.</font>
<font color="black"> 378. </font>
<font color="black"> 379.         :params max_size: The maximum number of inflight futures. An inflight</font>
<font color="black"> 380.             future means that the task is either queued up or is currently</font>
<font color="black"> 381.             being executed. A size of None or 0 means that the executor will</font>
<font color="black"> 382.             have no bound in terms of the number of inflight futures.</font>
<font color="black"> 383. </font>
<font color="black"> 384.         :params max_num_threads: The maximum number of threads the executor</font>
<font color="black"> 385.             uses.</font>
<font color="black"> 386. </font>
<font color="black"> 387.         :type tag_semaphores: dict</font>
<font color="black"> 388.         :params tag_semaphores: A dictionary where the key is the name of the</font>
<font color="black"> 389.             tag and the value is the semaphore to use when limiting the</font>
<font color="black"> 390.             number of tasks the executor is processing at a time.</font>
<font color="black"> 391. </font>
<font color="black"> 392.         :type executor_cls: BaseExecutor</font>
<font color="black"> 393.         :param underlying_executor_cls: The executor class that</font>
<font color="black"> 394.             get bounded by this executor. If None is provided, the</font>
<font color="black"> 395.             concurrent.futures.ThreadPoolExecutor class is used.</font>
<font color="black"> 396.         &quot;&quot;&quot;</font>
<font color="red"> 397.         self._max_num_threads = max_num_threads</font>
<font color="red"> 398.         if executor_cls is None:</font>
<font color="red"> 399.             executor_cls = self.EXECUTOR_CLS</font>
<font color="red"> 400.         self._executor = executor_cls(max_workers=self._max_num_threads)</font>
<font color="red"> 401.         self._semaphore = TaskSemaphore(max_size)</font>
<font color="red"> 402.         self._tag_semaphores = tag_semaphores</font>
<font color="black"> 403. </font>
<font color="green"> 404.     def submit(self, task, tag=None, block=True):</font>
<font color="black"> 405.         &quot;&quot;&quot;Submit a task to complete</font>
<font color="black"> 406. </font>
<font color="black"> 407.         :type task: s3transfer.tasks.Task</font>
<font color="black"> 408.         :param task: The task to run __call__ on</font>
<font color="black"> 409. </font>
<font color="black"> 410. </font>
<font color="black"> 411.         :type tag: s3transfer.futures.TaskTag</font>
<font color="black"> 412.         :param tag: An optional tag to associate to the task. This</font>
<font color="black"> 413.             is used to override which semaphore to use.</font>
<font color="black"> 414. </font>
<font color="black"> 415.         :type block: boolean</font>
<font color="black"> 416.         :param block: True if to wait till it is possible to submit a task.</font>
<font color="black"> 417.             False, if not to wait and raise an error if not able to submit</font>
<font color="black"> 418.             a task.</font>
<font color="black"> 419. </font>
<font color="black"> 420.         :returns: The future assocaited to the submitted task</font>
<font color="black"> 421.         &quot;&quot;&quot;</font>
<font color="red"> 422.         semaphore = self._semaphore</font>
<font color="black"> 423.         # If a tag was provided, use the semaphore associated to that</font>
<font color="black"> 424.         # tag.</font>
<font color="red"> 425.         if tag:</font>
<font color="red"> 426.             semaphore = self._tag_semaphores[tag]</font>
<font color="black"> 427. </font>
<font color="black"> 428.         # Call acquire on the semaphore.</font>
<font color="red"> 429.         acquire_token = semaphore.acquire(task.transfer_id, block)</font>
<font color="black"> 430.         # Create a callback to invoke when task is done in order to call</font>
<font color="black"> 431.         # release on the semaphore.</font>
<font color="red"> 432.         release_callback = FunctionContainer(</font>
<font color="red"> 433.             semaphore.release, task.transfer_id, acquire_token)</font>
<font color="black"> 434.         # Submit the task to the underlying executor.</font>
<font color="red"> 435.         future = ExecutorFuture(self._executor.submit(task))</font>
<font color="black"> 436.         # Add the Semaphore.release() callback to the future such that</font>
<font color="black"> 437.         # it is invoked once the future completes.</font>
<font color="red"> 438.         future.add_done_callback(release_callback)</font>
<font color="red"> 439.         return future</font>
<font color="black"> 440. </font>
<font color="green"> 441.     def shutdown(self, wait=True):</font>
<font color="red"> 442.         self._executor.shutdown(wait)</font>
<font color="black"> 443. </font>
<font color="black"> 444. </font>
<font color="green"> 445. class ExecutorFuture(object):</font>
<font color="green"> 446.     def __init__(self, future):</font>
<font color="black"> 447.         &quot;&quot;&quot;A future returned from the executor</font>
<font color="black"> 448. </font>
<font color="black"> 449.         Currently, it is just a wrapper around a concurrent.futures.Future.</font>
<font color="black"> 450.         However, this can eventually grow to implement the needed functionality</font>
<font color="black"> 451.         of concurrent.futures.Future if we move off of the library and not</font>
<font color="black"> 452.         affect the rest of the codebase.</font>
<font color="black"> 453. </font>
<font color="black"> 454.         :type future: concurrent.futures.Future</font>
<font color="black"> 455.         :param future: The underlying future</font>
<font color="black"> 456.         &quot;&quot;&quot;</font>
<font color="red"> 457.         self._future = future</font>
<font color="black"> 458. </font>
<font color="green"> 459.     def result(self):</font>
<font color="red"> 460.         return self._future.result()</font>
<font color="black"> 461. </font>
<font color="green"> 462.     def add_done_callback(self, fn):</font>
<font color="black"> 463.         &quot;&quot;&quot;Adds a callback to be completed once future is done</font>
<font color="black"> 464. </font>
<font color="black"> 465.         :parm fn: A callable that takes no arguments. Note that is different</font>
<font color="black"> 466.             than concurrent.futures.Future.add_done_callback that requires</font>
<font color="black"> 467.             a single argument for the future.</font>
<font color="black"> 468.         &quot;&quot;&quot;</font>
<font color="black"> 469.         # The done callback for concurrent.futures.Future will always pass a</font>
<font color="black"> 470.         # the future in as the only argument. So we need to create the</font>
<font color="black"> 471.         # proper signature wrapper that will invoke the callback provided.</font>
<font color="red"> 472.         def done_callback(future_passed_to_callback):</font>
<font color="red"> 473.             return fn()</font>
<font color="red"> 474.         self._future.add_done_callback(done_callback)</font>
<font color="black"> 475. </font>
<font color="green"> 476.     def done(self):</font>
<font color="red"> 477.         return self._future.done()</font>
<font color="black"> 478. </font>
<font color="black"> 479. </font>
<font color="green"> 480. class BaseExecutor(object):</font>
<font color="green"> 481.     &quot;&quot;&quot;Base Executor class implementation needed to work with s3transfer&quot;&quot;&quot;</font>
<font color="green"> 482.     def __init__(self, max_workers=None):</font>
<font color="red"> 483.         pass</font>
<font color="black"> 484. </font>
<font color="green"> 485.     def submit(self, fn, *args, **kwargs):</font>
<font color="red"> 486.         raise NotImplementedError('submit()')</font>
<font color="black"> 487. </font>
<font color="green"> 488.     def shutdown(self, wait=True):</font>
<font color="red"> 489.         raise NotImplementedError('shutdown()')</font>
<font color="black"> 490. </font>
<font color="black"> 491. </font>
<font color="green"> 492. class NonThreadedExecutor(BaseExecutor):</font>
<font color="green"> 493.     &quot;&quot;&quot;A drop-in replacement non-threaded version of ThreadPoolExecutor&quot;&quot;&quot;</font>
<font color="green"> 494.     def submit(self, fn, *args, **kwargs):</font>
<font color="red"> 495.         future = NonThreadedExecutorFuture()</font>
<font color="red"> 496.         try:</font>
<font color="red"> 497.             result = fn(*args, **kwargs)</font>
<font color="red"> 498.             future.set_result(result)</font>
<font color="red"> 499.         except Exception:</font>
<font color="red"> 500.             e, tb = sys.exc_info()[1:]</font>
<font color="red"> 501.             logger.debug(</font>
<font color="red"> 502.                 'Setting exception for %s to %s with traceback %s',</font>
<font color="red"> 503.                 future, e, tb</font>
<font color="black"> 504.             )</font>
<font color="red"> 505.             future.set_exception_info(e, tb)</font>
<font color="red"> 506.         return future</font>
<font color="black"> 507. </font>
<font color="green"> 508.     def shutdown(self, wait=True):</font>
<font color="red"> 509.         pass</font>
<font color="black"> 510. </font>
<font color="black"> 511. </font>
<font color="green"> 512. class NonThreadedExecutorFuture(object):</font>
<font color="black"> 513.     &quot;&quot;&quot;The Future returned from NonThreadedExecutor</font>
<font color="black"> 514. </font>
<font color="black"> 515.     Note that this future is **not** thread-safe as it is being used</font>
<font color="black"> 516.     from the context of a non-threaded environment.</font>
<font color="green"> 517.     &quot;&quot;&quot;</font>
<font color="green"> 518.     def __init__(self):</font>
<font color="red"> 519.         self._result = None</font>
<font color="red"> 520.         self._exception = None</font>
<font color="red"> 521.         self._traceback = None</font>
<font color="red"> 522.         self._done = False</font>
<font color="red"> 523.         self._done_callbacks = []</font>
<font color="black"> 524. </font>
<font color="green"> 525.     def set_result(self, result):</font>
<font color="red"> 526.         self._result = result</font>
<font color="red"> 527.         self._set_done()</font>
<font color="black"> 528. </font>
<font color="green"> 529.     def set_exception_info(self, exception, traceback):</font>
<font color="red"> 530.         self._exception = exception</font>
<font color="red"> 531.         self._traceback = traceback</font>
<font color="red"> 532.         self._set_done()</font>
<font color="black"> 533. </font>
<font color="green"> 534.     def result(self, timeout=None):</font>
<font color="red"> 535.         if self._exception:</font>
<font color="red"> 536.             six.reraise(</font>
<font color="red"> 537.                 type(self._exception), self._exception, self._traceback)</font>
<font color="red"> 538.         return self._result</font>
<font color="black"> 539. </font>
<font color="green"> 540.     def _set_done(self):</font>
<font color="red"> 541.         self._done = True</font>
<font color="red"> 542.         for done_callback in self._done_callbacks:</font>
<font color="red"> 543.             self._invoke_done_callback(done_callback)</font>
<font color="red"> 544.         self._done_callbacks = []</font>
<font color="black"> 545. </font>
<font color="green"> 546.     def _invoke_done_callback(self, done_callback):</font>
<font color="red"> 547.         return done_callback(self)</font>
<font color="black"> 548. </font>
<font color="green"> 549.     def done(self):</font>
<font color="red"> 550.         return self._done</font>
<font color="black"> 551. </font>
<font color="green"> 552.     def add_done_callback(self, fn):</font>
<font color="red"> 553.         if self._done:</font>
<font color="red"> 554.             self._invoke_done_callback(fn)</font>
<font color="black"> 555.         else:</font>
<font color="red"> 556.             self._done_callbacks.append(fn)</font>
<font color="black"> 557. </font>
<font color="black"> 558. </font>
<font color="green"> 559. TaskTag = namedtuple('TaskTag', ['name'])</font>
<font color="black"> 560. </font>
<font color="green"> 561. IN_MEMORY_UPLOAD_TAG = TaskTag('in_memory_upload')</font>
<font color="green"> 562. IN_MEMORY_DOWNLOAD_TAG = TaskTag('in_memory_download')</font>
</pre>

