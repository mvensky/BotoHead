source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/waiter.py</b><br>


file stats: <b>176 lines, 32 executed: 18.2% covered</b>
<pre>
<font color="black">   1. # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="green">  13. import jmespath</font>
<font color="green">  14. import logging</font>
<font color="green">  15. import time</font>
<font color="black">  16. </font>
<font color="green">  17. from botocore.utils import get_service_module_name</font>
<font color="green">  18. from botocore.docs.docstring import WaiterDocstring</font>
<font color="green">  19. from .exceptions import WaiterError, ClientError, WaiterConfigError</font>
<font color="green">  20. from . import xform_name</font>
<font color="black">  21. </font>
<font color="black">  22. </font>
<font color="green">  23. logger = logging.getLogger(__name__)</font>
<font color="black">  24. </font>
<font color="black">  25. </font>
<font color="green">  26. def create_waiter_with_client(waiter_name, waiter_model, client):</font>
<font color="black">  27.     &quot;&quot;&quot;</font>
<font color="black">  28. </font>
<font color="black">  29.     :type waiter_name: str</font>
<font color="black">  30.     :param waiter_name: The name of the waiter.  The name should match</font>
<font color="black">  31.         the name (including the casing) of the key name in the waiter</font>
<font color="black">  32.         model file (typically this is CamelCasing).</font>
<font color="black">  33. </font>
<font color="black">  34.     :type waiter_model: botocore.waiter.WaiterModel</font>
<font color="black">  35.     :param waiter_model: The model for the waiter configuration.</font>
<font color="black">  36. </font>
<font color="black">  37.     :type client: botocore.client.BaseClient</font>
<font color="black">  38.     :param client: The botocore client associated with the service.</font>
<font color="black">  39. </font>
<font color="black">  40.     :rtype: botocore.waiter.Waiter</font>
<font color="black">  41.     :return: The waiter object.</font>
<font color="black">  42. </font>
<font color="black">  43.     &quot;&quot;&quot;</font>
<font color="red">  44.     single_waiter_config = waiter_model.get_waiter(waiter_name)</font>
<font color="red">  45.     operation_name = xform_name(single_waiter_config.operation)</font>
<font color="red">  46.     operation_method = NormalizedOperationMethod(</font>
<font color="red">  47.         getattr(client, operation_name))</font>
<font color="black">  48. </font>
<font color="black">  49.     # Create a new wait method that will serve as a proxy to the underlying</font>
<font color="black">  50.     # Waiter.wait method. This is needed to attach a docstring to the</font>
<font color="black">  51.     # method.</font>
<font color="red">  52.     def wait(self, **kwargs):</font>
<font color="red">  53.         Waiter.wait(self, **kwargs)</font>
<font color="black">  54. </font>
<font color="red">  55.     wait.__doc__ = WaiterDocstring(</font>
<font color="red">  56.         waiter_name=waiter_name,</font>
<font color="red">  57.         event_emitter=client.meta.events,</font>
<font color="red">  58.         service_model=client.meta.service_model,</font>
<font color="red">  59.         service_waiter_model=waiter_model,</font>
<font color="red">  60.         include_signature=False</font>
<font color="black">  61.     )</font>
<font color="black">  62. </font>
<font color="black">  63.     # Rename the waiter class based on the type of waiter.</font>
<font color="red">  64.     waiter_class_name = str('%s.Waiter.%s' % (</font>
<font color="red">  65.         get_service_module_name(client.meta.service_model),</font>
<font color="red">  66.         waiter_name))</font>
<font color="black">  67. </font>
<font color="black">  68.     # Create the new waiter class</font>
<font color="red">  69.     documented_waiter_cls = type(</font>
<font color="red">  70.         waiter_class_name, (Waiter,), {'wait': wait})</font>
<font color="black">  71. </font>
<font color="black">  72.     # Return an instance of the new waiter class.</font>
<font color="red">  73.     return documented_waiter_cls(</font>
<font color="red">  74.         waiter_name, single_waiter_config, operation_method</font>
<font color="black">  75.     )</font>
<font color="black">  76. </font>
<font color="black">  77. </font>
<font color="green">  78. class NormalizedOperationMethod(object):</font>
<font color="green">  79.     def __init__(self, client_method):</font>
<font color="red">  80.         self._client_method = client_method</font>
<font color="black">  81. </font>
<font color="green">  82.     def __call__(self, **kwargs):</font>
<font color="red">  83.         try:</font>
<font color="red">  84.             return self._client_method(**kwargs)</font>
<font color="red">  85.         except ClientError as e:</font>
<font color="red">  86.             return e.response</font>
<font color="black">  87. </font>
<font color="black">  88. </font>
<font color="green">  89. class WaiterModel(object):</font>
<font color="green">  90.     SUPPORTED_VERSION = 2</font>
<font color="black">  91. </font>
<font color="green">  92.     def __init__(self, waiter_config):</font>
<font color="black">  93.         &quot;&quot;&quot;</font>
<font color="black">  94. </font>
<font color="black">  95.         Note that the WaiterModel takes ownership of the waiter_config.</font>
<font color="black">  96.         It may or may not mutate the waiter_config.  If this is a concern,</font>
<font color="black">  97.         it is best to make a copy of the waiter config before passing it to</font>
<font color="black">  98.         the WaiterModel.</font>
<font color="black">  99. </font>
<font color="black"> 100.         :type waiter_config: dict</font>
<font color="black"> 101.         :param waiter_config: The loaded waiter config</font>
<font color="black"> 102.             from the &lt;service&gt;*.waiters.json file.  This can be</font>
<font color="black"> 103.             obtained from a botocore Loader object as well.</font>
<font color="black"> 104. </font>
<font color="black"> 105.         &quot;&quot;&quot;</font>
<font color="red"> 106.         self._waiter_config = waiter_config['waiters']</font>
<font color="black"> 107. </font>
<font color="black"> 108.         # These are part of the public API.  Changing these</font>
<font color="black"> 109.         # will result in having to update the consuming code,</font>
<font color="black"> 110.         # so don't change unless you really need to.</font>
<font color="red"> 111.         version = waiter_config.get('version', 'unknown')</font>
<font color="red"> 112.         self._verify_supported_version(version)</font>
<font color="red"> 113.         self.version = version</font>
<font color="red"> 114.         self.waiter_names = list(sorted(waiter_config['waiters'].keys()))</font>
<font color="black"> 115. </font>
<font color="green"> 116.     def _verify_supported_version(self, version):</font>
<font color="red"> 117.         if version != self.SUPPORTED_VERSION:</font>
<font color="red"> 118.             raise WaiterConfigError(</font>
<font color="red"> 119.                 error_msg=(&quot;Unsupported waiter version, supported version &quot;</font>
<font color="black"> 120.                            &quot;must be: %s, but version of waiter config &quot;</font>
<font color="red"> 121.                            &quot;is: %s&quot; % (self.SUPPORTED_VERSION,</font>
<font color="red"> 122.                                        version)))</font>
<font color="black"> 123. </font>
<font color="green"> 124.     def get_waiter(self, waiter_name):</font>
<font color="red"> 125.         try:</font>
<font color="red"> 126.             single_waiter_config = self._waiter_config[waiter_name]</font>
<font color="red"> 127.         except KeyError:</font>
<font color="red"> 128.             raise ValueError(&quot;Waiter does not exist: %s&quot; % waiter_name)</font>
<font color="red"> 129.         return SingleWaiterConfig(single_waiter_config)</font>
<font color="black"> 130. </font>
<font color="black"> 131. </font>
<font color="green"> 132. class SingleWaiterConfig(object):</font>
<font color="black"> 133.     &quot;&quot;&quot;Represents the waiter configuration for a single waiter.</font>
<font color="black"> 134. </font>
<font color="black"> 135.     A single waiter is considered the configuration for a single</font>
<font color="black"> 136.     value associated with a named waiter (i.e TableExists).</font>
<font color="black"> 137. </font>
<font color="green"> 138.     &quot;&quot;&quot;</font>
<font color="green"> 139.     def __init__(self, single_waiter_config):</font>
<font color="red"> 140.         self._config = single_waiter_config</font>
<font color="black"> 141. </font>
<font color="black"> 142.         # These attributes are part of the public API.</font>
<font color="red"> 143.         self.description = single_waiter_config.get('description', '')</font>
<font color="black"> 144.         # Per the spec, these three fields are required.</font>
<font color="red"> 145.         self.operation = single_waiter_config['operation']</font>
<font color="red"> 146.         self.delay = single_waiter_config['delay']</font>
<font color="red"> 147.         self.max_attempts = single_waiter_config['maxAttempts']</font>
<font color="black"> 148. </font>
<font color="green"> 149.     @property</font>
<font color="black"> 150.     def acceptors(self):</font>
<font color="red"> 151.         acceptors = []</font>
<font color="red"> 152.         for acceptor_config in self._config['acceptors']:</font>
<font color="red"> 153.             acceptor = AcceptorConfig(acceptor_config)</font>
<font color="red"> 154.             acceptors.append(acceptor)</font>
<font color="red"> 155.         return acceptors</font>
<font color="black"> 156. </font>
<font color="black"> 157. </font>
<font color="green"> 158. class AcceptorConfig(object):</font>
<font color="green"> 159.     def __init__(self, config):</font>
<font color="red"> 160.         self.state = config['state']</font>
<font color="red"> 161.         self.matcher = config['matcher']</font>
<font color="red"> 162.         self.expected = config['expected']</font>
<font color="red"> 163.         self.argument = config.get('argument')</font>
<font color="red"> 164.         self.matcher_func = self._create_matcher_func()</font>
<font color="black"> 165. </font>
<font color="green"> 166.     def _create_matcher_func(self):</font>
<font color="black"> 167.         # An acceptor function is a callable that takes a single value.  The</font>
<font color="black"> 168.         # parsed AWS response.  Note that the parsed error response is also</font>
<font color="black"> 169.         # provided in the case of errors, so it's entirely possible to</font>
<font color="black"> 170.         # handle all the available matcher capabilities in the future.</font>
<font color="black"> 171.         # There's only three supported matchers, so for now, this is all</font>
<font color="black"> 172.         # contained to a single method.  If this grows, we can expand this</font>
<font color="black"> 173.         # out to separate methods or even objects.</font>
<font color="black"> 174. </font>
<font color="red"> 175.         if self.matcher == 'path':</font>
<font color="red"> 176.             return self._create_path_matcher()</font>
<font color="red"> 177.         elif self.matcher == 'pathAll':</font>
<font color="red"> 178.             return self._create_path_all_matcher()</font>
<font color="red"> 179.         elif self.matcher == 'pathAny':</font>
<font color="red"> 180.             return self._create_path_any_matcher()</font>
<font color="red"> 181.         elif self.matcher == 'status':</font>
<font color="red"> 182.             return self._create_status_matcher()</font>
<font color="red"> 183.         elif self.matcher == 'error':</font>
<font color="red"> 184.             return self._create_error_matcher()</font>
<font color="black"> 185.         else:</font>
<font color="red"> 186.             raise WaiterConfigError(</font>
<font color="red"> 187.                 error_msg=&quot;Unknown acceptor: %s&quot; % self.matcher)</font>
<font color="black"> 188. </font>
<font color="green"> 189.     def _create_path_matcher(self):</font>
<font color="red"> 190.         expression = jmespath.compile(self.argument)</font>
<font color="red"> 191.         expected = self.expected</font>
<font color="black"> 192. </font>
<font color="red"> 193.         def acceptor_matches(response):</font>
<font color="red"> 194.             if 'Error' in response:</font>
<font color="red"> 195.                 return</font>
<font color="red"> 196.             return expression.search(response) == expected</font>
<font color="red"> 197.         return acceptor_matches</font>
<font color="black"> 198. </font>
<font color="green"> 199.     def _create_path_all_matcher(self):</font>
<font color="red"> 200.         expression = jmespath.compile(self.argument)</font>
<font color="red"> 201.         expected = self.expected</font>
<font color="black"> 202. </font>
<font color="red"> 203.         def acceptor_matches(response):</font>
<font color="red"> 204.             if 'Error' in response:</font>
<font color="red"> 205.                 return</font>
<font color="red"> 206.             result = expression.search(response)</font>
<font color="red"> 207.             if not isinstance(result, list) or not result:</font>
<font color="black"> 208.                 # pathAll matcher must result in a list.</font>
<font color="black"> 209.                 # Also we require at least one element in the list,</font>
<font color="black"> 210.                 # that is, an empty list should not result in this</font>
<font color="black"> 211.                 # acceptor match.</font>
<font color="red"> 212.                 return False</font>
<font color="red"> 213.             for element in result:</font>
<font color="red"> 214.                 if element != expected:</font>
<font color="red"> 215.                     return False</font>
<font color="red"> 216.             return True</font>
<font color="red"> 217.         return acceptor_matches</font>
<font color="black"> 218. </font>
<font color="green"> 219.     def _create_path_any_matcher(self):</font>
<font color="red"> 220.         expression = jmespath.compile(self.argument)</font>
<font color="red"> 221.         expected = self.expected</font>
<font color="black"> 222. </font>
<font color="red"> 223.         def acceptor_matches(response):</font>
<font color="red"> 224.             if 'Error' in response:</font>
<font color="red"> 225.                 return</font>
<font color="red"> 226.             result = expression.search(response)</font>
<font color="red"> 227.             if not isinstance(result, list) or not result:</font>
<font color="black"> 228.                 # pathAny matcher must result in a list.</font>
<font color="black"> 229.                 # Also we require at least one element in the list,</font>
<font color="black"> 230.                 # that is, an empty list should not result in this</font>
<font color="black"> 231.                 # acceptor match.</font>
<font color="red"> 232.                 return False</font>
<font color="red"> 233.             for element in result:</font>
<font color="red"> 234.                 if element == expected:</font>
<font color="red"> 235.                     return True</font>
<font color="red"> 236.             return False</font>
<font color="red"> 237.         return acceptor_matches</font>
<font color="black"> 238. </font>
<font color="green"> 239.     def _create_status_matcher(self):</font>
<font color="red"> 240.         expected = self.expected</font>
<font color="black"> 241. </font>
<font color="red"> 242.         def acceptor_matches(response):</font>
<font color="black"> 243.             # We don't have any requirements on the expected incoming data</font>
<font color="black"> 244.             # other than it is a dict, so we don't assume there's</font>
<font color="black"> 245.             # a ResponseMetadata.HTTPStatusCode.</font>
<font color="red"> 246.             status_code = response.get('ResponseMetadata', {}).get(</font>
<font color="red"> 247.                 'HTTPStatusCode')</font>
<font color="red"> 248.             return status_code == expected</font>
<font color="red"> 249.         return acceptor_matches</font>
<font color="black"> 250. </font>
<font color="green"> 251.     def _create_error_matcher(self):</font>
<font color="red"> 252.         expected = self.expected</font>
<font color="black"> 253. </font>
<font color="red"> 254.         def acceptor_matches(response):</font>
<font color="black"> 255.             # When the client encounters an error, it will normally raise</font>
<font color="black"> 256.             # an exception.  However, the waiter implementation will catch</font>
<font color="black"> 257.             # this exception, and instead send us the parsed error</font>
<font color="black"> 258.             # response.  So response is still a dictionary, and in the case</font>
<font color="black"> 259.             # of an error response will contain the &quot;Error&quot; and</font>
<font color="black"> 260.             # &quot;ResponseMetadata&quot; key.</font>
<font color="red"> 261.             return response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;, &quot;&quot;) == expected</font>
<font color="red"> 262.         return acceptor_matches</font>
<font color="black"> 263. </font>
<font color="black"> 264. </font>
<font color="green"> 265. class Waiter(object):</font>
<font color="green"> 266.     def __init__(self, name, config, operation_method):</font>
<font color="black"> 267.         &quot;&quot;&quot;</font>
<font color="black"> 268. </font>
<font color="black"> 269.         :type name: string</font>
<font color="black"> 270.         :param name: The name of the waiter</font>
<font color="black"> 271. </font>
<font color="black"> 272.         :type config: botocore.waiter.SingleWaiterConfig</font>
<font color="black"> 273.         :param config: The configuration for the waiter.</font>
<font color="black"> 274. </font>
<font color="black"> 275.         :type operation_method: callable</font>
<font color="black"> 276.         :param operation_method: A callable that accepts **kwargs</font>
<font color="black"> 277.             and returns a response.  For example, this can be</font>
<font color="black"> 278.             a method from a botocore client.</font>
<font color="black"> 279. </font>
<font color="black"> 280.         &quot;&quot;&quot;</font>
<font color="red"> 281.         self._operation_method = operation_method</font>
<font color="black"> 282.         # The two attributes are exposed to allow for introspection</font>
<font color="black"> 283.         # and documentation.</font>
<font color="red"> 284.         self.name = name</font>
<font color="red"> 285.         self.config = config</font>
<font color="black"> 286. </font>
<font color="green"> 287.     def wait(self, **kwargs):</font>
<font color="red"> 288.         acceptors = list(self.config.acceptors)</font>
<font color="red"> 289.         current_state = 'waiting'</font>
<font color="black"> 290.         # pop the invocation specific config</font>
<font color="red"> 291.         config = kwargs.pop('WaiterConfig', {})</font>
<font color="red"> 292.         sleep_amount = config.get('Delay', self.config.delay)</font>
<font color="red"> 293.         max_attempts = config.get('MaxAttempts', self.config.max_attempts)</font>
<font color="red"> 294.         num_attempts = 0</font>
<font color="black"> 295. </font>
<font color="red"> 296.         while True:</font>
<font color="red"> 297.             response = self._operation_method(**kwargs)</font>
<font color="red"> 298.             num_attempts += 1</font>
<font color="red"> 299.             for acceptor in acceptors:</font>
<font color="red"> 300.                 if acceptor.matcher_func(response):</font>
<font color="red"> 301.                     current_state = acceptor.state</font>
<font color="red"> 302.                     break</font>
<font color="black"> 303.             else:</font>
<font color="black"> 304.                 # If none of the acceptors matched, we should</font>
<font color="black"> 305.                 # transition to the failure state if an error</font>
<font color="black"> 306.                 # response was received.</font>
<font color="red"> 307.                 if 'Error' in response:</font>
<font color="black"> 308.                     # Transition to a failure state, which we</font>
<font color="black"> 309.                     # can just handle here by raising an exception.</font>
<font color="red"> 310.                     raise WaiterError(</font>
<font color="red"> 311.                         name=self.name,</font>
<font color="red"> 312.                         reason=response['Error'].get('Message', 'Unknown'),</font>
<font color="red"> 313.                         last_response=response</font>
<font color="black"> 314.                     )</font>
<font color="red"> 315.             if current_state == 'success':</font>
<font color="red"> 316.                 logger.debug(&quot;Waiting complete, waiter matched the &quot;</font>
<font color="black"> 317.                              &quot;success state.&quot;)</font>
<font color="red"> 318.                 return</font>
<font color="red"> 319.             if current_state == 'failure':</font>
<font color="red"> 320.                 raise WaiterError(</font>
<font color="red"> 321.                     name=self.name,</font>
<font color="red"> 322.                     reason='Waiter encountered a terminal failure state',</font>
<font color="red"> 323.                     last_response=response,</font>
<font color="black"> 324.                 )</font>
<font color="red"> 325.             if num_attempts &gt;= max_attempts:</font>
<font color="red"> 326.                 raise WaiterError(</font>
<font color="red"> 327.                     name=self.name,</font>
<font color="red"> 328.                     reason='Max attempts exceeded',</font>
<font color="red"> 329.                     last_response=response</font>
<font color="black"> 330.                 )</font>
<font color="red"> 331.             time.sleep(sleep_amount)</font>
</pre>

