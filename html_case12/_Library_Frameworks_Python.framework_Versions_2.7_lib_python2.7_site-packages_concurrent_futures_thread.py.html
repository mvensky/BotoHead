source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/concurrent/futures/thread.py</b><br>


file stats: <b>84 lines, 23 executed: 27.4% covered</b>
<pre>
<font color="black">   1. # Copyright 2009 Brian Quinlan. All Rights Reserved.</font>
<font color="black">   2. # Licensed to PSF under a Contributor Agreement.</font>
<font color="black">   3. </font>
<font color="green">   4. &quot;&quot;&quot;Implements ThreadPoolExecutor.&quot;&quot;&quot;</font>
<font color="black">   5. </font>
<font color="green">   6. import atexit</font>
<font color="green">   7. from concurrent.futures import _base</font>
<font color="green">   8. import Queue as queue</font>
<font color="green">   9. import threading</font>
<font color="green">  10. import weakref</font>
<font color="green">  11. import sys</font>
<font color="black">  12. </font>
<font color="green">  13. __author__ = 'Brian Quinlan (brian@sweetapp.com)'</font>
<font color="black">  14. </font>
<font color="black">  15. # Workers are created as daemon threads. This is done to allow the interpreter</font>
<font color="black">  16. # to exit when there are still idle threads in a ThreadPoolExecutor's thread</font>
<font color="black">  17. # pool (i.e. shutdown() was not called). However, allowing workers to die with</font>
<font color="black">  18. # the interpreter has two undesirable properties:</font>
<font color="black">  19. #   - The workers would still be running during interpretor shutdown,</font>
<font color="black">  20. #     meaning that they would fail in unpredictable ways.</font>
<font color="black">  21. #   - The workers could be killed while evaluating a work item, which could</font>
<font color="black">  22. #     be bad if the callable being evaluated has external side-effects e.g.</font>
<font color="black">  23. #     writing to a file.</font>
<font color="black">  24. #</font>
<font color="black">  25. # To work around this problem, an exit handler is installed which tells the</font>
<font color="black">  26. # workers to exit when their work queues are empty and then waits until the</font>
<font color="black">  27. # threads finish.</font>
<font color="black">  28. </font>
<font color="green">  29. _threads_queues = weakref.WeakKeyDictionary()</font>
<font color="green">  30. _shutdown = False</font>
<font color="black">  31. </font>
<font color="green">  32. def _python_exit():</font>
<font color="black">  33.     global _shutdown</font>
<font color="red">  34.     _shutdown = True</font>
<font color="red">  35.     items = list(_threads_queues.items()) if _threads_queues else ()</font>
<font color="red">  36.     for t, q in items:</font>
<font color="red">  37.         q.put(None)</font>
<font color="red">  38.     for t, q in items:</font>
<font color="red">  39.         t.join(sys.maxint)</font>
<font color="black">  40. </font>
<font color="green">  41. atexit.register(_python_exit)</font>
<font color="black">  42. </font>
<font color="green">  43. class _WorkItem(object):</font>
<font color="green">  44.     def __init__(self, future, fn, args, kwargs):</font>
<font color="red">  45.         self.future = future</font>
<font color="red">  46.         self.fn = fn</font>
<font color="red">  47.         self.args = args</font>
<font color="red">  48.         self.kwargs = kwargs</font>
<font color="black">  49. </font>
<font color="green">  50.     def run(self):</font>
<font color="red">  51.         if not self.future.set_running_or_notify_cancel():</font>
<font color="red">  52.             return</font>
<font color="black">  53. </font>
<font color="red">  54.         try:</font>
<font color="red">  55.             result = self.fn(*self.args, **self.kwargs)</font>
<font color="red">  56.         except BaseException:</font>
<font color="red">  57.             e, tb = sys.exc_info()[1:]</font>
<font color="red">  58.             self.future.set_exception_info(e, tb)</font>
<font color="black">  59.         else:</font>
<font color="red">  60.             self.future.set_result(result)</font>
<font color="black">  61. </font>
<font color="green">  62. def _worker(executor_reference, work_queue):</font>
<font color="red">  63.     try:</font>
<font color="red">  64.         while True:</font>
<font color="red">  65.             work_item = work_queue.get(block=True)</font>
<font color="red">  66.             if work_item is not None:</font>
<font color="red">  67.                 work_item.run()</font>
<font color="black">  68.                 # Delete references to object. See issue16284</font>
<font color="red">  69.                 del work_item</font>
<font color="red">  70.                 continue</font>
<font color="red">  71.             executor = executor_reference()</font>
<font color="black">  72.             # Exit if:</font>
<font color="black">  73.             #   - The interpreter is shutting down OR</font>
<font color="black">  74.             #   - The executor that owns the worker has been collected OR</font>
<font color="black">  75.             #   - The executor that owns the worker has been shutdown.</font>
<font color="red">  76.             if _shutdown or executor is None or executor._shutdown:</font>
<font color="black">  77.                 # Notice other workers</font>
<font color="red">  78.                 work_queue.put(None)</font>
<font color="red">  79.                 return</font>
<font color="red">  80.             del executor</font>
<font color="red">  81.     except BaseException:</font>
<font color="red">  82.         _base.LOGGER.critical('Exception in worker', exc_info=True)</font>
<font color="black">  83. </font>
<font color="green">  84. class ThreadPoolExecutor(_base.Executor):</font>
<font color="green">  85.     def __init__(self, max_workers):</font>
<font color="black">  86.         &quot;&quot;&quot;Initializes a new ThreadPoolExecutor instance.</font>
<font color="black">  87. </font>
<font color="black">  88.         Args:</font>
<font color="black">  89.             max_workers: The maximum number of threads that can be used to</font>
<font color="black">  90.                 execute the given calls.</font>
<font color="black">  91.         &quot;&quot;&quot;</font>
<font color="red">  92.         self._max_workers = max_workers</font>
<font color="red">  93.         self._work_queue = queue.Queue()</font>
<font color="red">  94.         self._threads = set()</font>
<font color="red">  95.         self._shutdown = False</font>
<font color="red">  96.         self._shutdown_lock = threading.Lock()</font>
<font color="black">  97. </font>
<font color="green">  98.     def submit(self, fn, *args, **kwargs):</font>
<font color="red">  99.         with self._shutdown_lock:</font>
<font color="red"> 100.             if self._shutdown:</font>
<font color="red"> 101.                 raise RuntimeError('cannot schedule new futures after shutdown')</font>
<font color="black"> 102. </font>
<font color="red"> 103.             f = _base.Future()</font>
<font color="red"> 104.             w = _WorkItem(f, fn, args, kwargs)</font>
<font color="black"> 105. </font>
<font color="red"> 106.             self._work_queue.put(w)</font>
<font color="red"> 107.             self._adjust_thread_count()</font>
<font color="red"> 108.             return f</font>
<font color="green"> 109.     submit.__doc__ = _base.Executor.submit.__doc__</font>
<font color="black"> 110. </font>
<font color="green"> 111.     def _adjust_thread_count(self):</font>
<font color="black"> 112.         # When the executor gets lost, the weakref callback will wake up</font>
<font color="black"> 113.         # the worker threads.</font>
<font color="red"> 114.         def weakref_cb(_, q=self._work_queue):</font>
<font color="red"> 115.             q.put(None)</font>
<font color="black"> 116.         # TODO(bquinlan): Should avoid creating new threads if there are more</font>
<font color="black"> 117.         # idle threads than items in the work queue.</font>
<font color="red"> 118.         if len(self._threads) &lt; self._max_workers:</font>
<font color="red"> 119.             t = threading.Thread(target=_worker,</font>
<font color="red"> 120.                                  args=(weakref.ref(self, weakref_cb),</font>
<font color="red"> 121.                                        self._work_queue))</font>
<font color="red"> 122.             t.daemon = True</font>
<font color="red"> 123.             t.start()</font>
<font color="red"> 124.             self._threads.add(t)</font>
<font color="red"> 125.             _threads_queues[t] = self._work_queue</font>
<font color="black"> 126. </font>
<font color="green"> 127.     def shutdown(self, wait=True):</font>
<font color="red"> 128.         with self._shutdown_lock:</font>
<font color="red"> 129.             self._shutdown = True</font>
<font color="red"> 130.             self._work_queue.put(None)</font>
<font color="red"> 131.         if wait:</font>
<font color="red"> 132.             for t in self._threads:</font>
<font color="red"> 133.                 t.join(sys.maxint)</font>
<font color="green"> 134.     shutdown.__doc__ = _base.Executor.shutdown.__doc__</font>
</pre>

