source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/endpoint.py</b><br>


file stats: <b>205 lines, 163 executed: 79.5% covered</b>
<pre>
<font color="black">   1. # Copyright (c) 2012-2013 Mitch Garnaat http://garnaat.org/</font>
<font color="black">   2. # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   3. #</font>
<font color="black">   4. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   5. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   6. # the License is located at</font>
<font color="black">   7. #</font>
<font color="black">   8. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   9. #</font>
<font color="black">  10. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  11. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  12. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  13. # language governing permissions and limitations under the License.</font>
<font color="black">  14. </font>
<font color="green">  15. import os</font>
<font color="green">  16. import logging</font>
<font color="green">  17. import time</font>
<font color="green">  18. import threading</font>
<font color="black">  19. </font>
<font color="green">  20. from botocore.vendored.requests.adapters import HTTPAdapter</font>
<font color="green">  21. from botocore.vendored.requests.sessions import Session</font>
<font color="green">  22. from botocore.vendored.requests.utils import get_environ_proxies</font>
<font color="green">  23. from botocore.vendored.requests.exceptions import ConnectionError</font>
<font color="green">  24. from botocore.vendored import six</font>
<font color="black">  25. </font>
<font color="green">  26. from botocore.awsrequest import create_request_object</font>
<font color="green">  27. from botocore.exceptions import UnknownEndpointError</font>
<font color="green">  28. from botocore.exceptions import EndpointConnectionError</font>
<font color="green">  29. from botocore.exceptions import ConnectionClosedError</font>
<font color="green">  30. from botocore.compat import filter_ssl_warnings</font>
<font color="green">  31. from botocore.utils import is_valid_endpoint_url</font>
<font color="green">  32. from botocore.hooks import first_non_none_response</font>
<font color="green">  33. from botocore.history import get_global_history_recorder</font>
<font color="green">  34. from botocore.response import StreamingBody</font>
<font color="green">  35. from botocore import parsers</font>
<font color="black">  36. </font>
<font color="black">  37. </font>
<font color="green">  38. logger = logging.getLogger(__name__)</font>
<font color="green">  39. history_recorder = get_global_history_recorder()</font>
<font color="green">  40. DEFAULT_TIMEOUT = 60</font>
<font color="green">  41. MAX_POOL_CONNECTIONS = 10</font>
<font color="green">  42. filter_ssl_warnings()</font>
<font color="black">  43. </font>
<font color="green">  44. try:</font>
<font color="green">  45.     from botocore.vendored.requests.packages.urllib3.contrib import pyopenssl</font>
<font color="green">  46.     pyopenssl.extract_from_urllib3()</font>
<font color="red">  47. except ImportError:</font>
<font color="red">  48.     pass</font>
<font color="black">  49. </font>
<font color="black">  50. </font>
<font color="green">  51. def convert_to_response_dict(http_response, operation_model):</font>
<font color="black">  52.     &quot;&quot;&quot;Convert an HTTP response object to a request dict.</font>
<font color="black">  53. </font>
<font color="black">  54.     This converts the requests library's HTTP response object to</font>
<font color="black">  55.     a dictionary.</font>
<font color="black">  56. </font>
<font color="black">  57.     :type http_response: botocore.vendored.requests.model.Response</font>
<font color="black">  58.     :param http_response: The HTTP response from an AWS service request.</font>
<font color="black">  59. </font>
<font color="black">  60.     :rtype: dict</font>
<font color="black">  61.     :return: A response dictionary which will contain the following keys:</font>
<font color="black">  62.         * headers (dict)</font>
<font color="black">  63.         * status_code (int)</font>
<font color="black">  64.         * body (string or file-like object)</font>
<font color="black">  65. </font>
<font color="black">  66.     &quot;&quot;&quot;</font>
<font color="green">  67.     response_dict = {</font>
<font color="green">  68.         'headers': http_response.headers,</font>
<font color="green">  69.         'status_code': http_response.status_code,</font>
<font color="green">  70.         'context': {</font>
<font color="green">  71.             'operation_name': operation_model.name,</font>
<font color="black">  72.         }</font>
<font color="black">  73.     }</font>
<font color="green">  74.     if response_dict['status_code'] &gt;= 300:</font>
<font color="red">  75.         response_dict['body'] = http_response.content</font>
<font color="green">  76.     elif operation_model.has_event_stream_output:</font>
<font color="red">  77.         response_dict['body'] = http_response.raw</font>
<font color="green">  78.     elif operation_model.has_streaming_output:</font>
<font color="red">  79.         length = response_dict['headers'].get('content-length')</font>
<font color="red">  80.         response_dict['body'] = StreamingBody(http_response.raw, length)</font>
<font color="black">  81.     else:</font>
<font color="green">  82.         response_dict['body'] = http_response.content</font>
<font color="green">  83.     return response_dict</font>
<font color="black">  84. </font>
<font color="black">  85. </font>
<font color="green">  86. class BotocoreHTTPSession(Session):</font>
<font color="black">  87.     &quot;&quot;&quot;Internal session class used to workaround requests behavior.</font>
<font color="black">  88. </font>
<font color="black">  89.     This class is intended to be used only by the Endpoint class.</font>
<font color="black">  90. </font>
<font color="green">  91.     &quot;&quot;&quot;</font>
<font color="green">  92.     def __init__(self, max_pool_connections=MAX_POOL_CONNECTIONS,</font>
<font color="green">  93.                  http_adapter_cls=HTTPAdapter):</font>
<font color="green">  94.         super(BotocoreHTTPSession, self).__init__()</font>
<font color="black">  95.         # In order to support a user provided &quot;max_pool_connections&quot;, we need</font>
<font color="black">  96.         # to recreate the HTTPAdapter and pass in our max_pool_connections</font>
<font color="black">  97.         # value.</font>
<font color="green">  98.         adapter = http_adapter_cls(pool_maxsize=max_pool_connections)</font>
<font color="black">  99.         # requests uses an HTTPAdapter for mounting both http:// and https://</font>
<font color="green"> 100.         self.mount('https://', adapter)</font>
<font color="green"> 101.         self.mount('http://', adapter)</font>
<font color="black"> 102. </font>
<font color="green"> 103.     def rebuild_auth(self, prepared_request, response):</font>
<font color="black"> 104.         # Keep the existing auth information from the original prepared request.</font>
<font color="black"> 105.         # Normally this method would be where auth is regenerated as needed.</font>
<font color="black"> 106.         # By making this a noop, we're keeping the existing auth info.</font>
<font color="red"> 107.         pass</font>
<font color="black"> 108. </font>
<font color="black"> 109. </font>
<font color="green"> 110. class Endpoint(object):</font>
<font color="black"> 111.     &quot;&quot;&quot;</font>
<font color="black"> 112.     Represents an endpoint for a particular service in a specific</font>
<font color="black"> 113.     region.  Only an endpoint can make requests.</font>
<font color="black"> 114. </font>
<font color="black"> 115.     :ivar service: The Service object that describes this endpoints</font>
<font color="black"> 116.         service.</font>
<font color="black"> 117.     :ivar host: The fully qualified endpoint hostname.</font>
<font color="black"> 118.     :ivar session: The session object.</font>
<font color="green"> 119.     &quot;&quot;&quot;</font>
<font color="black"> 120. </font>
<font color="black"> 121.     def __init__(self, host, endpoint_prefix,</font>
<font color="green"> 122.                  event_emitter, proxies=None, verify=True,</font>
<font color="green"> 123.                  timeout=DEFAULT_TIMEOUT, response_parser_factory=None,</font>
<font color="green"> 124.                  max_pool_connections=MAX_POOL_CONNECTIONS):</font>
<font color="green"> 125.         self._endpoint_prefix = endpoint_prefix</font>
<font color="green"> 126.         self._event_emitter = event_emitter</font>
<font color="green"> 127.         self.host = host</font>
<font color="green"> 128.         self.verify = verify</font>
<font color="green"> 129.         if proxies is None:</font>
<font color="red"> 130.             proxies = {}</font>
<font color="green"> 131.         self.proxies = proxies</font>
<font color="green"> 132.         self.http_session = BotocoreHTTPSession(</font>
<font color="green"> 133.             max_pool_connections=max_pool_connections)</font>
<font color="green"> 134.         self.timeout = timeout</font>
<font color="green"> 135.         self.max_pool_connections = max_pool_connections</font>
<font color="green"> 136.         logger.debug('Setting %s timeout as %s', endpoint_prefix, self.timeout)</font>
<font color="green"> 137.         self._lock = threading.Lock()</font>
<font color="green"> 138.         if response_parser_factory is None:</font>
<font color="red"> 139.             response_parser_factory = parsers.ResponseParserFactory()</font>
<font color="green"> 140.         self._response_parser_factory = response_parser_factory</font>
<font color="black"> 141. </font>
<font color="green"> 142.     def __repr__(self):</font>
<font color="red"> 143.         return '%s(%s)' % (self._endpoint_prefix, self.host)</font>
<font color="black"> 144. </font>
<font color="green"> 145.     def make_request(self, operation_model, request_dict):</font>
<font color="green"> 146.         logger.debug(&quot;Making request for %s (verify_ssl=%s) with params: %s&quot;,</font>
<font color="green"> 147.                      operation_model, self.verify, request_dict)</font>
<font color="green"> 148.         return self._send_request(request_dict, operation_model)</font>
<font color="black"> 149. </font>
<font color="green"> 150.     def create_request(self, params, operation_model=None):</font>
<font color="green"> 151.         request = create_request_object(params)</font>
<font color="green"> 152.         if operation_model:</font>
<font color="green"> 153.             event_name = 'request-created.{endpoint_prefix}.{op_name}'.format(</font>
<font color="green"> 154.                 endpoint_prefix=self._endpoint_prefix,</font>
<font color="green"> 155.                 op_name=operation_model.name)</font>
<font color="green"> 156.             self._event_emitter.emit(event_name, request=request,</font>
<font color="green"> 157.                                      operation_name=operation_model.name)</font>
<font color="green"> 158.         prepared_request = self.prepare_request(request)</font>
<font color="green"> 159.         return prepared_request</font>
<font color="black"> 160. </font>
<font color="green"> 161.     def _encode_headers(self, headers):</font>
<font color="black"> 162.         # In place encoding of headers to utf-8 if they are unicode.</font>
<font color="green"> 163.         for key, value in headers.items():</font>
<font color="green"> 164.             if isinstance(value, six.text_type):</font>
<font color="green"> 165.                 headers[key] = value.encode('utf-8')</font>
<font color="black"> 166. </font>
<font color="green"> 167.     def prepare_request(self, request):</font>
<font color="green"> 168.         self._encode_headers(request.headers)</font>
<font color="green"> 169.         return request.prepare()</font>
<font color="black"> 170. </font>
<font color="green"> 171.     def _send_request(self, request_dict, operation_model):</font>
<font color="green"> 172.         attempts = 1</font>
<font color="green"> 173.         request = self.create_request(request_dict, operation_model)</font>
<font color="green"> 174.         success_response, exception = self._get_response(</font>
<font color="green"> 175.             request, operation_model, attempts)</font>
<font color="green"> 176.         while self._needs_retry(attempts, operation_model, request_dict,</font>
<font color="green"> 177.                                 success_response, exception):</font>
<font color="red"> 178.             attempts += 1</font>
<font color="black"> 179.             # If there is a stream associated with the request, we need</font>
<font color="black"> 180.             # to reset it before attempting to send the request again.</font>
<font color="black"> 181.             # This will ensure that we resend the entire contents of the</font>
<font color="black"> 182.             # body.</font>
<font color="red"> 183.             request.reset_stream()</font>
<font color="black"> 184.             # Create a new request when retried (including a new signature).</font>
<font color="red"> 185.             request = self.create_request(</font>
<font color="red"> 186.                 request_dict, operation_model)</font>
<font color="red"> 187.             success_response, exception = self._get_response(</font>
<font color="red"> 188.                 request, operation_model, attempts)</font>
<font color="green"> 189.         if success_response is not None and \</font>
<font color="green"> 190.                 'ResponseMetadata' in success_response[1]:</font>
<font color="black"> 191.             # We want to share num retries, not num attempts.</font>
<font color="green"> 192.             total_retries = attempts - 1</font>
<font color="black"> 193.             success_response[1]['ResponseMetadata']['RetryAttempts'] = \</font>
<font color="green"> 194.                     total_retries</font>
<font color="green"> 195.         if exception is not None:</font>
<font color="red"> 196.             raise exception</font>
<font color="black"> 197.         else:</font>
<font color="green"> 198.             return success_response</font>
<font color="black"> 199. </font>
<font color="green"> 200.     def _get_response(self, request, operation_model, attempts):</font>
<font color="black"> 201.         # This will return a tuple of (success_response, exception)</font>
<font color="black"> 202.         # and success_response is itself a tuple of</font>
<font color="black"> 203.         # (http_response, parsed_dict).</font>
<font color="black"> 204.         # If an exception occurs then the success_response is None.</font>
<font color="black"> 205.         # If no exception occurs then exception is None.</font>
<font color="green"> 206.         try:</font>
<font color="green"> 207.             logger.debug(&quot;Sending http request: %s&quot;, request)</font>
<font color="green"> 208.             history_recorder.record('HTTP_REQUEST', {</font>
<font color="green"> 209.                 'method': request.method,</font>
<font color="green"> 210.                 'headers': request.headers,</font>
<font color="green"> 211.                 'streaming': operation_model.has_streaming_input,</font>
<font color="green"> 212.                 'url': request.url,</font>
<font color="green"> 213.                 'body': request.body</font>
<font color="black"> 214.             })</font>
<font color="green"> 215.             streaming = any([</font>
<font color="green"> 216.                 operation_model.has_streaming_output,</font>
<font color="green"> 217.                 operation_model.has_event_stream_output</font>
<font color="black"> 218.             ])</font>
<font color="green"> 219.             http_response = self.http_session.send(</font>
<font color="green"> 220.                 request, verify=self.verify,</font>
<font color="green"> 221.                 stream=streaming,</font>
<font color="green"> 222.                 proxies=self.proxies, timeout=self.timeout)</font>
<font color="red"> 223.         except ConnectionError as e:</font>
<font color="black"> 224.             # For a connection error, if it looks like it's a DNS</font>
<font color="black"> 225.             # lookup issue, 99% of the time this is due to a misconfigured</font>
<font color="black"> 226.             # region/endpoint so we'll raise a more specific error message</font>
<font color="black"> 227.             # to help users.</font>
<font color="red"> 228.             logger.debug(&quot;ConnectionError received when sending HTTP request.&quot;,</font>
<font color="red"> 229.                          exc_info=True)</font>
<font color="red"> 230.             if self._looks_like_dns_error(e):</font>
<font color="red"> 231.                 endpoint_url = e.request.url</font>
<font color="red"> 232.                 better_exception = EndpointConnectionError(</font>
<font color="red"> 233.                     endpoint_url=endpoint_url, error=e)</font>
<font color="red"> 234.                 return (None, better_exception)</font>
<font color="red"> 235.             elif self._looks_like_bad_status_line(e):</font>
<font color="red"> 236.                 better_exception = ConnectionClosedError(</font>
<font color="red"> 237.                     endpoint_url=e.request.url, request=e.request)</font>
<font color="red"> 238.                 return (None, better_exception)</font>
<font color="black"> 239.             else:</font>
<font color="red"> 240.                 return (None, e)</font>
<font color="red"> 241.         except Exception as e:</font>
<font color="red"> 242.             logger.debug(&quot;Exception received when sending HTTP request.&quot;,</font>
<font color="red"> 243.                          exc_info=True)</font>
<font color="red"> 244.             return (None, e)</font>
<font color="black"> 245.         # This returns the http_response and the parsed_data.</font>
<font color="green"> 246.         response_dict = convert_to_response_dict(http_response, operation_model)</font>
<font color="black"> 247. </font>
<font color="green"> 248.         http_response_record_dict = response_dict.copy()</font>
<font color="black"> 249.         http_response_record_dict['streaming'] = \</font>
<font color="green"> 250.             operation_model.has_streaming_output</font>
<font color="green"> 251.         history_recorder.record('HTTP_RESPONSE', http_response_record_dict)</font>
<font color="black"> 252. </font>
<font color="green"> 253.         protocol = operation_model.metadata['protocol']</font>
<font color="green"> 254.         parser = self._response_parser_factory.create_parser(protocol)</font>
<font color="green"> 255.         parsed_response = parser.parse(</font>
<font color="green"> 256.             response_dict, operation_model.output_shape)</font>
<font color="green"> 257.         history_recorder.record('PARSED_RESPONSE', parsed_response)</font>
<font color="green"> 258.         return (http_response, parsed_response), None</font>
<font color="black"> 259. </font>
<font color="green"> 260.     def _looks_like_dns_error(self, e):</font>
<font color="red"> 261.         return 'gaierror' in str(e) and e.request is not None</font>
<font color="black"> 262. </font>
<font color="green"> 263.     def _looks_like_bad_status_line(self, e):</font>
<font color="red"> 264.         return 'BadStatusLine' in str(e) and e.request is not None</font>
<font color="black"> 265. </font>
<font color="black"> 266.     def _needs_retry(self, attempts, operation_model, request_dict,</font>
<font color="green"> 267.                      response=None, caught_exception=None):</font>
<font color="green"> 268.         event_name = 'needs-retry.%s.%s' % (self._endpoint_prefix,</font>
<font color="green"> 269.                                             operation_model.name)</font>
<font color="green"> 270.         responses = self._event_emitter.emit(</font>
<font color="green"> 271.             event_name, response=response, endpoint=self,</font>
<font color="green"> 272.             operation=operation_model, attempts=attempts,</font>
<font color="green"> 273.             caught_exception=caught_exception, request_dict=request_dict)</font>
<font color="green"> 274.         handler_response = first_non_none_response(responses)</font>
<font color="green"> 275.         if handler_response is None:</font>
<font color="green"> 276.             return False</font>
<font color="black"> 277.         else:</font>
<font color="black"> 278.             # Request needs to be retried, and we need to sleep</font>
<font color="black"> 279.             # for the specified number of times.</font>
<font color="red"> 280.             logger.debug(&quot;Response received to retry, sleeping for &quot;</font>
<font color="red"> 281.                          &quot;%s seconds&quot;, handler_response)</font>
<font color="red"> 282.             time.sleep(handler_response)</font>
<font color="red"> 283.             return True</font>
<font color="black"> 284. </font>
<font color="black"> 285. </font>
<font color="green"> 286. class EndpointCreator(object):</font>
<font color="green"> 287.     def __init__(self, event_emitter):</font>
<font color="green"> 288.         self._event_emitter = event_emitter</font>
<font color="black"> 289. </font>
<font color="black"> 290.     def create_endpoint(self, service_model, region_name, endpoint_url,</font>
<font color="green"> 291.                         verify=None, response_parser_factory=None,</font>
<font color="green"> 292.                         timeout=DEFAULT_TIMEOUT,</font>
<font color="green"> 293.                         max_pool_connections=MAX_POOL_CONNECTIONS,</font>
<font color="green"> 294.                         proxies=None):</font>
<font color="green"> 295.         if not is_valid_endpoint_url(endpoint_url):</font>
<font color="black"> 296. </font>
<font color="red"> 297.             raise ValueError(&quot;Invalid endpoint: %s&quot; % endpoint_url)</font>
<font color="green"> 298.         if proxies is None:</font>
<font color="green"> 299.             proxies = self._get_proxies(endpoint_url)</font>
<font color="green"> 300.         return Endpoint(</font>
<font color="green"> 301.             endpoint_url,</font>
<font color="green"> 302.             endpoint_prefix=service_model.endpoint_prefix,</font>
<font color="green"> 303.             event_emitter=self._event_emitter,</font>
<font color="green"> 304.             proxies=proxies,</font>
<font color="green"> 305.             verify=self._get_verify_value(verify),</font>
<font color="green"> 306.             timeout=timeout,</font>
<font color="green"> 307.             max_pool_connections=max_pool_connections,</font>
<font color="green"> 308.             response_parser_factory=response_parser_factory)</font>
<font color="black"> 309. </font>
<font color="green"> 310.     def _get_proxies(self, url):</font>
<font color="black"> 311.         # We could also support getting proxies from a config file,</font>
<font color="black"> 312.         # but for now proxy support is taken from the environment.</font>
<font color="green"> 313.         return get_environ_proxies(url)</font>
<font color="black"> 314. </font>
<font color="green"> 315.     def _get_verify_value(self, verify):</font>
<font color="black"> 316.         # This is to account for:</font>
<font color="black"> 317.         # https://github.com/kennethreitz/requests/issues/1436</font>
<font color="black"> 318.         # where we need to honor REQUESTS_CA_BUNDLE because we're creating our</font>
<font color="black"> 319.         # own request objects.</font>
<font color="black"> 320.         # First, if verify is not None, then the user explicitly specified</font>
<font color="black"> 321.         # a value so this automatically wins.</font>
<font color="green"> 322.         if verify is not None:</font>
<font color="red"> 323.             return verify</font>
<font color="black"> 324.         # Otherwise use the value from REQUESTS_CA_BUNDLE, or default to</font>
<font color="black"> 325.         # True if the env var does not exist.</font>
<font color="green"> 326.         return os.environ.get('REQUESTS_CA_BUNDLE', True)</font>
</pre>

