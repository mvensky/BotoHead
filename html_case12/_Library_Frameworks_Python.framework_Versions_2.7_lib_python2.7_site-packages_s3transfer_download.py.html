source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/s3transfer/download.py</b><br>


file stats: <b>350 lines, 98 executed: 28.0% covered</b>
<pre>
<font color="black">   1. # Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="green">  13. import logging</font>
<font color="green">  14. import os</font>
<font color="green">  15. import socket</font>
<font color="green">  16. import math</font>
<font color="green">  17. import threading</font>
<font color="green">  18. import heapq</font>
<font color="black">  19. </font>
<font color="black">  20. </font>
<font color="green">  21. from botocore.compat import six</font>
<font color="green">  22. from botocore.exceptions import IncompleteReadError</font>
<font color="green">  23. from botocore.vendored.requests.packages.urllib3.exceptions import \</font>
<font color="black">  24.     ReadTimeoutError</font>
<font color="black">  25. </font>
<font color="green">  26. from s3transfer.compat import SOCKET_ERROR</font>
<font color="green">  27. from s3transfer.compat import seekable</font>
<font color="green">  28. from s3transfer.exceptions import RetriesExceededError</font>
<font color="green">  29. from s3transfer.futures import IN_MEMORY_DOWNLOAD_TAG</font>
<font color="green">  30. from s3transfer.utils import random_file_extension</font>
<font color="green">  31. from s3transfer.utils import get_callbacks</font>
<font color="green">  32. from s3transfer.utils import invoke_progress_callbacks</font>
<font color="green">  33. from s3transfer.utils import calculate_range_parameter</font>
<font color="green">  34. from s3transfer.utils import FunctionContainer</font>
<font color="green">  35. from s3transfer.utils import CountCallbackInvoker</font>
<font color="green">  36. from s3transfer.utils import StreamReaderProgress</font>
<font color="green">  37. from s3transfer.utils import DeferredOpenFile</font>
<font color="green">  38. from s3transfer.tasks import Task</font>
<font color="green">  39. from s3transfer.tasks import SubmissionTask</font>
<font color="black">  40. </font>
<font color="black">  41. </font>
<font color="green">  42. logger = logging.getLogger(__name__)</font>
<font color="black">  43. </font>
<font color="black">  44. S3_RETRYABLE_ERRORS = (</font>
<font color="green">  45.     socket.timeout, SOCKET_ERROR, ReadTimeoutError, IncompleteReadError</font>
<font color="black">  46. )</font>
<font color="black">  47. </font>
<font color="black">  48. </font>
<font color="green">  49. class DownloadOutputManager(object):</font>
<font color="black">  50.     &quot;&quot;&quot;Base manager class for handling various types of files for downloads</font>
<font color="black">  51. </font>
<font color="black">  52.     This class is typically used for the DownloadSubmissionTask class to help</font>
<font color="black">  53.     determine the following:</font>
<font color="black">  54. </font>
<font color="black">  55.         * Provides the fileobj to write to downloads to</font>
<font color="black">  56.         * Get a task to complete once everything downloaded has been written</font>
<font color="black">  57. </font>
<font color="black">  58.     The answers/implementations differ for the various types of file outputs</font>
<font color="black">  59.     that may be accepted. All implementations must subclass and override</font>
<font color="black">  60.     public methods from this class.</font>
<font color="green">  61.     &quot;&quot;&quot;</font>
<font color="green">  62.     def __init__(self, osutil, transfer_coordinator, io_executor):</font>
<font color="red">  63.         self._osutil = osutil</font>
<font color="red">  64.         self._transfer_coordinator = transfer_coordinator</font>
<font color="red">  65.         self._io_executor = io_executor</font>
<font color="black">  66. </font>
<font color="green">  67.     @classmethod</font>
<font color="black">  68.     def is_compatible(cls, download_target, osutil):</font>
<font color="black">  69.         &quot;&quot;&quot;Determines if the target for the download is compatible with manager</font>
<font color="black">  70. </font>
<font color="black">  71.         :param download_target: The target for which the upload will write</font>
<font color="black">  72.             data to.</font>
<font color="black">  73. </font>
<font color="black">  74.         :param osutil: The os utility to be used for the transfer</font>
<font color="black">  75. </font>
<font color="black">  76.         :returns: True if the manager can handle the type of target specified</font>
<font color="black">  77.             otherwise returns False.</font>
<font color="black">  78.         &quot;&quot;&quot;</font>
<font color="red">  79.         raise NotImplementedError('must implement is_compatible()')</font>
<font color="black">  80. </font>
<font color="green">  81.     def get_download_task_tag(self):</font>
<font color="black">  82.         &quot;&quot;&quot;Get the tag (if any) to associate all GetObjectTasks</font>
<font color="black">  83. </font>
<font color="black">  84.         :rtype: s3transfer.futures.TaskTag</font>
<font color="black">  85.         :returns: The tag to associate all GetObjectTasks with</font>
<font color="black">  86.         &quot;&quot;&quot;</font>
<font color="red">  87.         return None</font>
<font color="black">  88. </font>
<font color="green">  89.     def get_fileobj_for_io_writes(self, transfer_future):</font>
<font color="black">  90.         &quot;&quot;&quot;Get file-like object to use for io writes in the io executor</font>
<font color="black">  91. </font>
<font color="black">  92.         :type transfer_future: s3transfer.futures.TransferFuture</font>
<font color="black">  93.         :param transfer_future: The future associated with upload request</font>
<font color="black">  94. </font>
<font color="black">  95.         returns: A file-like object to write to</font>
<font color="black">  96.         &quot;&quot;&quot;</font>
<font color="red">  97.         raise NotImplementedError('must implement get_fileobj_for_io_writes()')</font>
<font color="black">  98. </font>
<font color="green">  99.     def queue_file_io_task(self, fileobj, data, offset):</font>
<font color="black"> 100.         &quot;&quot;&quot;Queue IO write for submission to the IO executor.</font>
<font color="black"> 101. </font>
<font color="black"> 102.         This method accepts an IO executor and information about the</font>
<font color="black"> 103.         downloaded data, and handles submitting this to the IO executor.</font>
<font color="black"> 104. </font>
<font color="black"> 105.         This method may defer submission to the IO executor if necessary.</font>
<font color="black"> 106. </font>
<font color="black"> 107.         &quot;&quot;&quot;</font>
<font color="red"> 108.         self._transfer_coordinator.submit(</font>
<font color="red"> 109.             self._io_executor,</font>
<font color="red"> 110.             self.get_io_write_task(fileobj, data, offset)</font>
<font color="black"> 111.          )</font>
<font color="black"> 112. </font>
<font color="green"> 113.     def get_io_write_task(self, fileobj, data, offset):</font>
<font color="black"> 114.         &quot;&quot;&quot;Get an IO write task for the requested set of data</font>
<font color="black"> 115. </font>
<font color="black"> 116.         This task can be ran immediately or be submitted to the IO executor</font>
<font color="black"> 117.         for it to run.</font>
<font color="black"> 118. </font>
<font color="black"> 119.         :type fileobj: file-like object</font>
<font color="black"> 120.         :param fileobj: The file-like object to write to</font>
<font color="black"> 121. </font>
<font color="black"> 122.         :type data: bytes</font>
<font color="black"> 123.         :param data: The data to write out</font>
<font color="black"> 124. </font>
<font color="black"> 125.         :type offset: integer</font>
<font color="black"> 126.         :param offset: The offset to write the data to in the file-like object</font>
<font color="black"> 127. </font>
<font color="black"> 128.         :returns: An IO task to be used to write data to a file-like object</font>
<font color="black"> 129.         &quot;&quot;&quot;</font>
<font color="red"> 130.         return IOWriteTask(</font>
<font color="red"> 131.             self._transfer_coordinator,</font>
<font color="red"> 132.             main_kwargs={</font>
<font color="red"> 133.                 'fileobj': fileobj,</font>
<font color="red"> 134.                 'data': data,</font>
<font color="red"> 135.                 'offset': offset,</font>
<font color="black"> 136.             }</font>
<font color="black"> 137.         )</font>
<font color="black"> 138. </font>
<font color="green"> 139.     def get_final_io_task(self):</font>
<font color="black"> 140.         &quot;&quot;&quot;Get the final io task to complete the download</font>
<font color="black"> 141. </font>
<font color="black"> 142.         This is needed because based on the architecture of the TransferManager</font>
<font color="black"> 143.         the final tasks will be sent to the IO executor, but the executor</font>
<font color="black"> 144.         needs a final task for it to signal that the transfer is done and</font>
<font color="black"> 145.         all done callbacks can be run.</font>
<font color="black"> 146. </font>
<font color="black"> 147.         :rtype: s3transfer.tasks.Task</font>
<font color="black"> 148.         :returns: A final task to completed in the io executor</font>
<font color="black"> 149.         &quot;&quot;&quot;</font>
<font color="red"> 150.         raise NotImplementedError(</font>
<font color="red"> 151.             'must implement get_final_io_task()')</font>
<font color="black"> 152. </font>
<font color="green"> 153.     def _get_fileobj_from_filename(self, filename):</font>
<font color="red"> 154.         f = DeferredOpenFile(</font>
<font color="red"> 155.             filename, mode='wb', open_function=self._osutil.open)</font>
<font color="black"> 156.         # Make sure the file gets closed and we remove the temporary file</font>
<font color="black"> 157.         # if anything goes wrong during the process.</font>
<font color="red"> 158.         self._transfer_coordinator.add_failure_cleanup(f.close)</font>
<font color="red"> 159.         return f</font>
<font color="black"> 160. </font>
<font color="black"> 161. </font>
<font color="green"> 162. class DownloadFilenameOutputManager(DownloadOutputManager):</font>
<font color="green"> 163.     def __init__(self, osutil, transfer_coordinator, io_executor):</font>
<font color="red"> 164.         super(DownloadFilenameOutputManager, self).__init__(</font>
<font color="red"> 165.             osutil, transfer_coordinator, io_executor)</font>
<font color="red"> 166.         self._final_filename = None</font>
<font color="red"> 167.         self._temp_filename = None</font>
<font color="red"> 168.         self._temp_fileobj = None</font>
<font color="black"> 169. </font>
<font color="green"> 170.     @classmethod</font>
<font color="black"> 171.     def is_compatible(cls, download_target, osutil):</font>
<font color="red"> 172.         return isinstance(download_target, six.string_types)</font>
<font color="black"> 173. </font>
<font color="green"> 174.     def get_fileobj_for_io_writes(self, transfer_future):</font>
<font color="red"> 175.         fileobj = transfer_future.meta.call_args.fileobj</font>
<font color="red"> 176.         self._final_filename = fileobj</font>
<font color="red"> 177.         self._temp_filename = fileobj + os.extsep + random_file_extension()</font>
<font color="red"> 178.         self._temp_fileobj = self._get_temp_fileobj()</font>
<font color="red"> 179.         return self._temp_fileobj</font>
<font color="black"> 180. </font>
<font color="green"> 181.     def get_final_io_task(self):</font>
<font color="black"> 182.         # A task to rename the file from the temporary file to its final</font>
<font color="black"> 183.         # location is needed. This should be the last task needed to complete</font>
<font color="black"> 184.         # the download.</font>
<font color="red"> 185.         return IORenameFileTask(</font>
<font color="red"> 186.             transfer_coordinator=self._transfer_coordinator,</font>
<font color="red"> 187.             main_kwargs={</font>
<font color="red"> 188.                 'fileobj': self._temp_fileobj,</font>
<font color="red"> 189.                 'final_filename': self._final_filename,</font>
<font color="red"> 190.                 'osutil': self._osutil</font>
<font color="black"> 191.             },</font>
<font color="red"> 192.             is_final=True</font>
<font color="black"> 193.         )</font>
<font color="black"> 194. </font>
<font color="green"> 195.     def _get_temp_fileobj(self):</font>
<font color="red"> 196.         f = self._get_fileobj_from_filename(self._temp_filename)</font>
<font color="red"> 197.         self._transfer_coordinator.add_failure_cleanup(</font>
<font color="red"> 198.             self._osutil.remove_file, self._temp_filename)</font>
<font color="red"> 199.         return f</font>
<font color="black"> 200. </font>
<font color="black"> 201. </font>
<font color="green"> 202. class DownloadSeekableOutputManager(DownloadOutputManager):</font>
<font color="green"> 203.     @classmethod</font>
<font color="black"> 204.     def is_compatible(cls, download_target, osutil):</font>
<font color="red"> 205.         return seekable(download_target)</font>
<font color="black"> 206. </font>
<font color="green"> 207.     def get_fileobj_for_io_writes(self, transfer_future):</font>
<font color="black"> 208.         # Return the fileobj provided to the future.</font>
<font color="red"> 209.         return transfer_future.meta.call_args.fileobj</font>
<font color="black"> 210. </font>
<font color="green"> 211.     def get_final_io_task(self):</font>
<font color="black"> 212.         # This task will serve the purpose of signaling when all of the io</font>
<font color="black"> 213.         # writes have finished so done callbacks can be called.</font>
<font color="red"> 214.         return CompleteDownloadNOOPTask(</font>
<font color="red"> 215.             transfer_coordinator=self._transfer_coordinator)</font>
<font color="black"> 216. </font>
<font color="black"> 217. </font>
<font color="green"> 218. class DownloadNonSeekableOutputManager(DownloadOutputManager):</font>
<font color="black"> 219.     def __init__(self, osutil, transfer_coordinator, io_executor,</font>
<font color="green"> 220.                  defer_queue=None):</font>
<font color="red"> 221.         super(DownloadNonSeekableOutputManager, self).__init__(</font>
<font color="red"> 222.             osutil, transfer_coordinator, io_executor)</font>
<font color="red"> 223.         if defer_queue is None:</font>
<font color="red"> 224.             defer_queue = DeferQueue()</font>
<font color="red"> 225.         self._defer_queue = defer_queue</font>
<font color="red"> 226.         self._io_submit_lock = threading.Lock()</font>
<font color="black"> 227. </font>
<font color="green"> 228.     @classmethod</font>
<font color="black"> 229.     def is_compatible(cls, download_target, osutil):</font>
<font color="red"> 230.         return hasattr(download_target, 'write')</font>
<font color="black"> 231. </font>
<font color="green"> 232.     def get_download_task_tag(self):</font>
<font color="red"> 233.         return IN_MEMORY_DOWNLOAD_TAG</font>
<font color="black"> 234. </font>
<font color="green"> 235.     def get_fileobj_for_io_writes(self, transfer_future):</font>
<font color="red"> 236.         return transfer_future.meta.call_args.fileobj</font>
<font color="black"> 237. </font>
<font color="green"> 238.     def get_final_io_task(self):</font>
<font color="red"> 239.         return CompleteDownloadNOOPTask(</font>
<font color="red"> 240.             transfer_coordinator=self._transfer_coordinator)</font>
<font color="black"> 241. </font>
<font color="green"> 242.     def queue_file_io_task(self, fileobj, data, offset):</font>
<font color="red"> 243.         with self._io_submit_lock:</font>
<font color="red"> 244.             writes = self._defer_queue.request_writes(offset, data)</font>
<font color="red"> 245.             for write in writes:</font>
<font color="red"> 246.                 data = write['data']</font>
<font color="red"> 247.                 logger.debug(&quot;Queueing IO offset %s for fileobj: %s&quot;,</font>
<font color="red"> 248.                              write['offset'], fileobj)</font>
<font color="red"> 249.                 super(</font>
<font color="red"> 250.                     DownloadNonSeekableOutputManager, self).queue_file_io_task(</font>
<font color="red"> 251.                         fileobj, data, offset)</font>
<font color="black"> 252. </font>
<font color="green"> 253.     def get_io_write_task(self, fileobj, data, offset):</font>
<font color="red"> 254.         return IOStreamingWriteTask(</font>
<font color="red"> 255.             self._transfer_coordinator,</font>
<font color="red"> 256.             main_kwargs={</font>
<font color="red"> 257.                 'fileobj': fileobj,</font>
<font color="red"> 258.                 'data': data,</font>
<font color="black"> 259.             }</font>
<font color="black"> 260.         )</font>
<font color="black"> 261. </font>
<font color="black"> 262. </font>
<font color="green"> 263. class DownloadSpecialFilenameOutputManager(DownloadNonSeekableOutputManager):</font>
<font color="black"> 264.     def __init__(self, osutil, transfer_coordinator, io_executor,</font>
<font color="green"> 265.                  defer_queue=None):</font>
<font color="red"> 266.         super(DownloadSpecialFilenameOutputManager, self).__init__(</font>
<font color="red"> 267.             osutil, transfer_coordinator, io_executor, defer_queue)</font>
<font color="red"> 268.         self._fileobj = None</font>
<font color="black"> 269. </font>
<font color="green"> 270.     @classmethod</font>
<font color="black"> 271.     def is_compatible(cls, download_target, osutil):</font>
<font color="red"> 272.         return isinstance(download_target, six.string_types) and \</font>
<font color="red"> 273.                osutil.is_special_file(download_target)</font>
<font color="black"> 274. </font>
<font color="green"> 275.     def get_fileobj_for_io_writes(self, transfer_future):</font>
<font color="red"> 276.         filename = transfer_future.meta.call_args.fileobj</font>
<font color="red"> 277.         self._fileobj = self._get_fileobj_from_filename(filename)</font>
<font color="red"> 278.         return self._fileobj</font>
<font color="black"> 279. </font>
<font color="green"> 280.     def get_final_io_task(self):</font>
<font color="black"> 281.         # Make sure the file gets closed once the transfer is done.</font>
<font color="red"> 282.         return IOCloseTask(</font>
<font color="red"> 283.             transfer_coordinator=self._transfer_coordinator,</font>
<font color="red"> 284.             is_final=True,</font>
<font color="red"> 285.             main_kwargs={'fileobj': self._fileobj})</font>
<font color="black"> 286. </font>
<font color="black"> 287. </font>
<font color="green"> 288. class DownloadSubmissionTask(SubmissionTask):</font>
<font color="green"> 289.     &quot;&quot;&quot;Task for submitting tasks to execute a download&quot;&quot;&quot;</font>
<font color="black"> 290. </font>
<font color="green"> 291.     def _get_download_output_manager_cls(self, transfer_future, osutil):</font>
<font color="black"> 292.         &quot;&quot;&quot;Retrieves a class for managing output for a download</font>
<font color="black"> 293. </font>
<font color="black"> 294.         :type transfer_future: s3transfer.futures.TransferFuture</font>
<font color="black"> 295.         :param transfer_future: The transfer future for the request</font>
<font color="black"> 296. </font>
<font color="black"> 297.         :type osutil: s3transfer.utils.OSUtils</font>
<font color="black"> 298.         :param osutil: The os utility associated to the transfer</font>
<font color="black"> 299. </font>
<font color="black"> 300.         :rtype: class of DownloadOutputManager</font>
<font color="black"> 301.         :returns: The appropriate class to use for managing a specific type of</font>
<font color="black"> 302.             input for downloads.</font>
<font color="black"> 303.         &quot;&quot;&quot;</font>
<font color="black"> 304.         download_manager_resolver_chain = [</font>
<font color="red"> 305.             DownloadSpecialFilenameOutputManager,</font>
<font color="red"> 306.             DownloadFilenameOutputManager,</font>
<font color="red"> 307.             DownloadSeekableOutputManager,</font>
<font color="red"> 308.             DownloadNonSeekableOutputManager,</font>
<font color="black"> 309.         ]</font>
<font color="black"> 310. </font>
<font color="red"> 311.         fileobj = transfer_future.meta.call_args.fileobj</font>
<font color="red"> 312.         for download_manager_cls in download_manager_resolver_chain:</font>
<font color="red"> 313.             if download_manager_cls.is_compatible(fileobj, osutil):</font>
<font color="red"> 314.                 return download_manager_cls</font>
<font color="red"> 315.         raise RuntimeError(</font>
<font color="red"> 316.             'Output %s of type: %s is not supported.' % (</font>
<font color="red"> 317.                 fileobj, type(fileobj)))</font>
<font color="black"> 318. </font>
<font color="black"> 319.     def _submit(self, client, config, osutil, request_executor, io_executor,</font>
<font color="green"> 320.                 transfer_future, bandwidth_limiter=None):</font>
<font color="black"> 321.         &quot;&quot;&quot;</font>
<font color="black"> 322.         :param client: The client associated with the transfer manager</font>
<font color="black"> 323. </font>
<font color="black"> 324.         :type config: s3transfer.manager.TransferConfig</font>
<font color="black"> 325.         :param config: The transfer config associated with the transfer</font>
<font color="black"> 326.             manager</font>
<font color="black"> 327. </font>
<font color="black"> 328.         :type osutil: s3transfer.utils.OSUtil</font>
<font color="black"> 329.         :param osutil: The os utility associated to the transfer manager</font>
<font color="black"> 330. </font>
<font color="black"> 331.         :type request_executor: s3transfer.futures.BoundedExecutor</font>
<font color="black"> 332.         :param request_executor: The request executor associated with the</font>
<font color="black"> 333.             transfer manager</font>
<font color="black"> 334. </font>
<font color="black"> 335.         :type io_executor: s3transfer.futures.BoundedExecutor</font>
<font color="black"> 336.         :param io_executor: The io executor associated with the</font>
<font color="black"> 337.             transfer manager</font>
<font color="black"> 338. </font>
<font color="black"> 339.         :type transfer_future: s3transfer.futures.TransferFuture</font>
<font color="black"> 340.         :param transfer_future: The transfer future associated with the</font>
<font color="black"> 341.             transfer request that tasks are being submitted for</font>
<font color="black"> 342. </font>
<font color="black"> 343.         :type bandwidth_limiter: s3transfer.bandwidth.BandwidthLimiter</font>
<font color="black"> 344.         :param bandwidth_limiter: The bandwidth limiter to use when</font>
<font color="black"> 345.             downloading streams</font>
<font color="black"> 346.         &quot;&quot;&quot;</font>
<font color="red"> 347.         if transfer_future.meta.size is None:</font>
<font color="black"> 348.             # If a size was not provided figure out the size for the</font>
<font color="black"> 349.             # user.</font>
<font color="red"> 350.             response = client.head_object(</font>
<font color="red"> 351.                 Bucket=transfer_future.meta.call_args.bucket,</font>
<font color="red"> 352.                 Key=transfer_future.meta.call_args.key,</font>
<font color="red"> 353.                 **transfer_future.meta.call_args.extra_args</font>
<font color="black"> 354.             )</font>
<font color="red"> 355.             transfer_future.meta.provide_transfer_size(</font>
<font color="red"> 356.                 response['ContentLength'])</font>
<font color="black"> 357. </font>
<font color="red"> 358.         download_output_manager = self._get_download_output_manager_cls(</font>
<font color="red"> 359.             transfer_future, osutil)(osutil, self._transfer_coordinator,</font>
<font color="red"> 360.                                      io_executor)</font>
<font color="black"> 361. </font>
<font color="black"> 362.         # If it is greater than threshold do a ranged download, otherwise</font>
<font color="black"> 363.         # do a regular GetObject download.</font>
<font color="red"> 364.         if transfer_future.meta.size &lt; config.multipart_threshold:</font>
<font color="red"> 365.             self._submit_download_request(</font>
<font color="red"> 366.                 client, config, osutil, request_executor, io_executor,</font>
<font color="red"> 367.                 download_output_manager, transfer_future, bandwidth_limiter)</font>
<font color="black"> 368.         else:</font>
<font color="red"> 369.             self._submit_ranged_download_request(</font>
<font color="red"> 370.                 client, config, osutil, request_executor, io_executor,</font>
<font color="red"> 371.                 download_output_manager, transfer_future, bandwidth_limiter)</font>
<font color="black"> 372. </font>
<font color="green"> 373.     def _submit_download_request(self, client, config, osutil,</font>
<font color="black"> 374.                                  request_executor, io_executor,</font>
<font color="black"> 375.                                  download_output_manager, transfer_future,</font>
<font color="black"> 376.                                  bandwidth_limiter):</font>
<font color="red"> 377.         call_args = transfer_future.meta.call_args</font>
<font color="black"> 378. </font>
<font color="black"> 379.         # Get a handle to the file that will be used for writing downloaded</font>
<font color="black"> 380.         # contents</font>
<font color="red"> 381.         fileobj = download_output_manager.get_fileobj_for_io_writes(</font>
<font color="red"> 382.             transfer_future)</font>
<font color="black"> 383. </font>
<font color="black"> 384.         # Get the needed callbacks for the task</font>
<font color="red"> 385.         progress_callbacks = get_callbacks(transfer_future, 'progress')</font>
<font color="black"> 386. </font>
<font color="black"> 387.         # Get any associated tags for the get object task.</font>
<font color="red"> 388.         get_object_tag = download_output_manager.get_download_task_tag()</font>
<font color="black"> 389. </font>
<font color="black"> 390.         # Get the final io task to run once the download is complete.</font>
<font color="red"> 391.         final_task = download_output_manager.get_final_io_task()</font>
<font color="black"> 392. </font>
<font color="black"> 393.         # Submit the task to download the object.</font>
<font color="red"> 394.         self._transfer_coordinator.submit(</font>
<font color="red"> 395.             request_executor,</font>
<font color="red"> 396.             ImmediatelyWriteIOGetObjectTask(</font>
<font color="red"> 397.                 transfer_coordinator=self._transfer_coordinator,</font>
<font color="red"> 398.                 main_kwargs={</font>
<font color="red"> 399.                     'client': client,</font>
<font color="red"> 400.                     'bucket': call_args.bucket,</font>
<font color="red"> 401.                     'key': call_args.key,</font>
<font color="red"> 402.                     'fileobj': fileobj,</font>
<font color="red"> 403.                     'extra_args': call_args.extra_args,</font>
<font color="red"> 404.                     'callbacks': progress_callbacks,</font>
<font color="red"> 405.                     'max_attempts': config.num_download_attempts,</font>
<font color="red"> 406.                     'download_output_manager': download_output_manager,</font>
<font color="red"> 407.                     'io_chunksize': config.io_chunksize,</font>
<font color="red"> 408.                     'bandwidth_limiter': bandwidth_limiter</font>
<font color="black"> 409.                 },</font>
<font color="red"> 410.                 done_callbacks=[final_task]</font>
<font color="black"> 411.             ),</font>
<font color="red"> 412.             tag=get_object_tag</font>
<font color="black"> 413.         )</font>
<font color="black"> 414. </font>
<font color="green"> 415.     def _submit_ranged_download_request(self, client, config, osutil,</font>
<font color="black"> 416.                                         request_executor, io_executor,</font>
<font color="black"> 417.                                         download_output_manager,</font>
<font color="black"> 418.                                         transfer_future,</font>
<font color="black"> 419.                                         bandwidth_limiter):</font>
<font color="red"> 420.         call_args = transfer_future.meta.call_args</font>
<font color="black"> 421. </font>
<font color="black"> 422.         # Get the needed progress callbacks for the task</font>
<font color="red"> 423.         progress_callbacks = get_callbacks(transfer_future, 'progress')</font>
<font color="black"> 424. </font>
<font color="black"> 425.         # Get a handle to the file that will be used for writing downloaded</font>
<font color="black"> 426.         # contents</font>
<font color="red"> 427.         fileobj = download_output_manager.get_fileobj_for_io_writes(</font>
<font color="red"> 428.             transfer_future)</font>
<font color="black"> 429. </font>
<font color="black"> 430.         # Determine the number of parts</font>
<font color="red"> 431.         part_size = config.multipart_chunksize</font>
<font color="red"> 432.         num_parts = int(</font>
<font color="red"> 433.             math.ceil(transfer_future.meta.size / float(part_size)))</font>
<font color="black"> 434. </font>
<font color="black"> 435.         # Get any associated tags for the get object task.</font>
<font color="red"> 436.         get_object_tag = download_output_manager.get_download_task_tag()</font>
<font color="black"> 437. </font>
<font color="black"> 438.         # Callback invoker to submit the final io task once all downloads</font>
<font color="black"> 439.         # are complete.</font>
<font color="red"> 440.         finalize_download_invoker = CountCallbackInvoker(</font>
<font color="red"> 441.             self._get_final_io_task_submission_callback(</font>
<font color="red"> 442.                 download_output_manager, io_executor</font>
<font color="black"> 443.             )</font>
<font color="black"> 444.         )</font>
<font color="red"> 445.         for i in range(num_parts):</font>
<font color="black"> 446.             # Calculate the range parameter</font>
<font color="red"> 447.             range_parameter = calculate_range_parameter(</font>
<font color="red"> 448.                 part_size, i, num_parts)</font>
<font color="black"> 449. </font>
<font color="black"> 450.             # Inject the Range parameter to the parameters to be passed in</font>
<font color="black"> 451.             # as extra args</font>
<font color="red"> 452.             extra_args = {'Range': range_parameter}</font>
<font color="red"> 453.             extra_args.update(call_args.extra_args)</font>
<font color="red"> 454.             finalize_download_invoker.increment()</font>
<font color="black"> 455.             # Submit the ranged downloads</font>
<font color="red"> 456.             self._transfer_coordinator.submit(</font>
<font color="red"> 457.                 request_executor,</font>
<font color="red"> 458.                 GetObjectTask(</font>
<font color="red"> 459.                     transfer_coordinator=self._transfer_coordinator,</font>
<font color="red"> 460.                     main_kwargs={</font>
<font color="red"> 461.                         'client': client,</font>
<font color="red"> 462.                         'bucket': call_args.bucket,</font>
<font color="red"> 463.                         'key': call_args.key,</font>
<font color="red"> 464.                         'fileobj': fileobj,</font>
<font color="red"> 465.                         'extra_args': extra_args,</font>
<font color="red"> 466.                         'callbacks': progress_callbacks,</font>
<font color="red"> 467.                         'max_attempts': config.num_download_attempts,</font>
<font color="red"> 468.                         'start_index': i * part_size,</font>
<font color="red"> 469.                         'download_output_manager': download_output_manager,</font>
<font color="red"> 470.                         'io_chunksize': config.io_chunksize,</font>
<font color="red"> 471.                         'bandwidth_limiter': bandwidth_limiter</font>
<font color="black"> 472.                     },</font>
<font color="red"> 473.                     done_callbacks=[finalize_download_invoker.decrement]</font>
<font color="black"> 474.                 ),</font>
<font color="red"> 475.                 tag=get_object_tag</font>
<font color="black"> 476.             )</font>
<font color="red"> 477.         finalize_download_invoker.finalize()</font>
<font color="black"> 478. </font>
<font color="green"> 479.     def _get_final_io_task_submission_callback(self, download_manager,</font>
<font color="black"> 480.                                                io_executor):</font>
<font color="red"> 481.         final_task = download_manager.get_final_io_task()</font>
<font color="red"> 482.         return FunctionContainer(</font>
<font color="red"> 483.             self._transfer_coordinator.submit, io_executor, final_task)</font>
<font color="black"> 484. </font>
<font color="green"> 485.     def _calculate_range_param(self, part_size, part_index, num_parts):</font>
<font color="black"> 486.         # Used to calculate the Range parameter</font>
<font color="red"> 487.         start_range = part_index * part_size</font>
<font color="red"> 488.         if part_index == num_parts - 1:</font>
<font color="red"> 489.             end_range = ''</font>
<font color="black"> 490.         else:</font>
<font color="red"> 491.             end_range = start_range + part_size - 1</font>
<font color="red"> 492.         range_param = 'bytes=%s-%s' % (start_range, end_range)</font>
<font color="red"> 493.         return range_param</font>
<font color="black"> 494. </font>
<font color="black"> 495. </font>
<font color="green"> 496. class GetObjectTask(Task):</font>
<font color="black"> 497.     def _main(self, client, bucket, key, fileobj, extra_args, callbacks,</font>
<font color="black"> 498.               max_attempts, download_output_manager, io_chunksize,</font>
<font color="green"> 499.               start_index=0, bandwidth_limiter=None):</font>
<font color="black"> 500.         &quot;&quot;&quot;Downloads an object and places content into io queue</font>
<font color="black"> 501. </font>
<font color="black"> 502.         :param client: The client to use when calling GetObject</font>
<font color="black"> 503.         :param bucket: The bucket to download from</font>
<font color="black"> 504.         :param key: The key to download from</font>
<font color="black"> 505.         :param fileobj: The file handle to write content to</font>
<font color="black"> 506.         :param exta_args: Any extra arguements to include in GetObject request</font>
<font color="black"> 507.         :param callbacks: List of progress callbacks to invoke on download</font>
<font color="black"> 508.         :param max_attempts: The number of retries to do when downloading</font>
<font color="black"> 509.         :param download_output_manager: The download output manager associated</font>
<font color="black"> 510.             with the current download.</font>
<font color="black"> 511.         :param io_chunksize: The size of each io chunk to read from the</font>
<font color="black"> 512.             download stream and queue in the io queue.</font>
<font color="black"> 513.         :param start_index: The location in the file to start writing the</font>
<font color="black"> 514.             content of the key to.</font>
<font color="black"> 515.         :param bandwidth_limiter: The bandwidth limiter to use when throttling</font>
<font color="black"> 516.             the downloading of data in streams.</font>
<font color="black"> 517.         &quot;&quot;&quot;</font>
<font color="red"> 518.         last_exception = None</font>
<font color="red"> 519.         for i in range(max_attempts):</font>
<font color="red"> 520.             try:</font>
<font color="red"> 521.                 response = client.get_object(</font>
<font color="red"> 522.                     Bucket=bucket, Key=key, **extra_args)</font>
<font color="red"> 523.                 streaming_body = StreamReaderProgress(</font>
<font color="red"> 524.                     response['Body'], callbacks)</font>
<font color="red"> 525.                 if bandwidth_limiter:</font>
<font color="black"> 526.                     streaming_body = \</font>
<font color="red"> 527.                         bandwidth_limiter.get_bandwith_limited_stream(</font>
<font color="red"> 528.                             streaming_body, self._transfer_coordinator)</font>
<font color="black"> 529. </font>
<font color="red"> 530.                 current_index = start_index</font>
<font color="red"> 531.                 chunks = DownloadChunkIterator(streaming_body, io_chunksize)</font>
<font color="red"> 532.                 for chunk in chunks:</font>
<font color="black"> 533.                     # If the transfer is done because of a cancellation</font>
<font color="black"> 534.                     # or error somewhere else, stop trying to submit more</font>
<font color="black"> 535.                     # data to be written and break out of the download.</font>
<font color="red"> 536.                     if not self._transfer_coordinator.done():</font>
<font color="red"> 537.                         self._handle_io(</font>
<font color="red"> 538.                             download_output_manager, fileobj, chunk,</font>
<font color="red"> 539.                             current_index</font>
<font color="black"> 540.                         )</font>
<font color="red"> 541.                         current_index += len(chunk)</font>
<font color="black"> 542.                     else:</font>
<font color="red"> 543.                         return</font>
<font color="red"> 544.                 return</font>
<font color="red"> 545.             except S3_RETRYABLE_ERRORS as e:</font>
<font color="red"> 546.                 logger.debug(&quot;Retrying exception caught (%s), &quot;</font>
<font color="red"> 547.                              &quot;retrying request, (attempt %s / %s)&quot;, e, i,</font>
<font color="red"> 548.                              max_attempts, exc_info=True)</font>
<font color="red"> 549.                 last_exception = e</font>
<font color="black"> 550.                 # Also invoke the progress callbacks to indicate that we</font>
<font color="black"> 551.                 # are trying to download the stream again and all progress</font>
<font color="black"> 552.                 # for this GetObject has been lost.</font>
<font color="red"> 553.                 invoke_progress_callbacks(</font>
<font color="red"> 554.                     callbacks, start_index - current_index)</font>
<font color="red"> 555.                 continue</font>
<font color="red"> 556.         raise RetriesExceededError(last_exception)</font>
<font color="black"> 557. </font>
<font color="green"> 558.     def _handle_io(self, download_output_manager, fileobj, chunk, index):</font>
<font color="red"> 559.         download_output_manager.queue_file_io_task(fileobj, chunk, index)</font>
<font color="black"> 560. </font>
<font color="black"> 561. </font>
<font color="green"> 562. class ImmediatelyWriteIOGetObjectTask(GetObjectTask):</font>
<font color="black"> 563.     &quot;&quot;&quot;GetObjectTask that immediately writes to the provided file object</font>
<font color="black"> 564. </font>
<font color="black"> 565.     This is useful for downloads where it is known only one thread is</font>
<font color="black"> 566.     downloading the object so there is no reason to go through the</font>
<font color="black"> 567.     overhead of using an IO queue and executor.</font>
<font color="green"> 568.     &quot;&quot;&quot;</font>
<font color="green"> 569.     def _handle_io(self, download_output_manager, fileobj, chunk, index):</font>
<font color="red"> 570.         task = download_output_manager.get_io_write_task(fileobj, chunk, index)</font>
<font color="red"> 571.         task()</font>
<font color="black"> 572. </font>
<font color="black"> 573. </font>
<font color="green"> 574. class IOWriteTask(Task):</font>
<font color="green"> 575.     def _main(self, fileobj, data, offset):</font>
<font color="black"> 576.         &quot;&quot;&quot;Pulls off an io queue to write contents to a file</font>
<font color="black"> 577. </font>
<font color="black"> 578.         :param f: The file handle to write content to</font>
<font color="black"> 579.         :param data: The data to write</font>
<font color="black"> 580.         :param offset: The offset to write the data to.</font>
<font color="black"> 581.         &quot;&quot;&quot;</font>
<font color="red"> 582.         fileobj.seek(offset)</font>
<font color="red"> 583.         fileobj.write(data)</font>
<font color="black"> 584. </font>
<font color="black"> 585. </font>
<font color="green"> 586. class IOStreamingWriteTask(Task):</font>
<font color="green"> 587.     &quot;&quot;&quot;Task for writing data to a non-seekable stream.&quot;&quot;&quot;</font>
<font color="black"> 588. </font>
<font color="green"> 589.     def _main(self, fileobj, data):</font>
<font color="black"> 590.         &quot;&quot;&quot;Write data to a fileobj.</font>
<font color="black"> 591. </font>
<font color="black"> 592.         Data will be written directly to the fileboj without</font>
<font color="black"> 593.         any prior seeking.</font>
<font color="black"> 594. </font>
<font color="black"> 595.         :param fileobj: The fileobj to write content to</font>
<font color="black"> 596.         :param data: The data to write</font>
<font color="black"> 597. </font>
<font color="black"> 598.         &quot;&quot;&quot;</font>
<font color="red"> 599.         fileobj.write(data)</font>
<font color="black"> 600. </font>
<font color="black"> 601. </font>
<font color="green"> 602. class IORenameFileTask(Task):</font>
<font color="black"> 603.     &quot;&quot;&quot;A task to rename a temporary file to its final filename</font>
<font color="black"> 604. </font>
<font color="black"> 605.     :param f: The file handle that content was written to.</font>
<font color="black"> 606.     :param final_filename: The final name of the file to rename to</font>
<font color="black"> 607.         upon completion of writing the contents.</font>
<font color="black"> 608.     :param osutil: OS utility</font>
<font color="green"> 609.     &quot;&quot;&quot;</font>
<font color="green"> 610.     def _main(self, fileobj, final_filename, osutil):</font>
<font color="red"> 611.         fileobj.close()</font>
<font color="red"> 612.         osutil.rename_file(fileobj.name, final_filename)</font>
<font color="black"> 613. </font>
<font color="black"> 614. </font>
<font color="green"> 615. class IOCloseTask(Task):</font>
<font color="black"> 616.     &quot;&quot;&quot;A task to close out a file once the download is complete.</font>
<font color="black"> 617. </font>
<font color="black"> 618.     :param fileobj: The fileobj to close.</font>
<font color="green"> 619.     &quot;&quot;&quot;</font>
<font color="green"> 620.     def _main(self, fileobj):</font>
<font color="red"> 621.         fileobj.close()</font>
<font color="black"> 622. </font>
<font color="black"> 623. </font>
<font color="green"> 624. class CompleteDownloadNOOPTask(Task):</font>
<font color="black"> 625.     &quot;&quot;&quot;A NOOP task to serve as an indicator that the download is complete</font>
<font color="black"> 626. </font>
<font color="black"> 627.     Note that the default for is_final is set to True because this should</font>
<font color="black"> 628.     always be the last task.</font>
<font color="green"> 629.     &quot;&quot;&quot;</font>
<font color="green"> 630.     def __init__(self, transfer_coordinator, main_kwargs=None,</font>
<font color="green"> 631.                  pending_main_kwargs=None, done_callbacks=None,</font>
<font color="green"> 632.                  is_final=True):</font>
<font color="red"> 633.         super(CompleteDownloadNOOPTask, self).__init__(</font>
<font color="red"> 634.             transfer_coordinator=transfer_coordinator,</font>
<font color="red"> 635.             main_kwargs=main_kwargs,</font>
<font color="red"> 636.             pending_main_kwargs=pending_main_kwargs,</font>
<font color="red"> 637.             done_callbacks=done_callbacks,</font>
<font color="red"> 638.             is_final=is_final</font>
<font color="black"> 639.         )</font>
<font color="black"> 640. </font>
<font color="green"> 641.     def _main(self):</font>
<font color="red"> 642.         pass</font>
<font color="black"> 643. </font>
<font color="black"> 644. </font>
<font color="green"> 645. class DownloadChunkIterator(object):</font>
<font color="green"> 646.     def __init__(self, body, chunksize):</font>
<font color="black"> 647.         &quot;&quot;&quot;Iterator to chunk out a downloaded S3 stream</font>
<font color="black"> 648. </font>
<font color="black"> 649.         :param body: A readable file-like object</font>
<font color="black"> 650.         :param chunksize: The amount to read each time</font>
<font color="black"> 651.         &quot;&quot;&quot;</font>
<font color="red"> 652.         self._body = body</font>
<font color="red"> 653.         self._chunksize = chunksize</font>
<font color="red"> 654.         self._num_reads = 0</font>
<font color="black"> 655. </font>
<font color="green"> 656.     def __iter__(self):</font>
<font color="red"> 657.         return self</font>
<font color="black"> 658. </font>
<font color="green"> 659.     def __next__(self):</font>
<font color="red"> 660.         chunk = self._body.read(self._chunksize)</font>
<font color="red"> 661.         self._num_reads += 1</font>
<font color="red"> 662.         if chunk:</font>
<font color="red"> 663.             return chunk</font>
<font color="red"> 664.         elif self._num_reads == 1:</font>
<font color="black"> 665.             # Even though the response may have not had any</font>
<font color="black"> 666.             # content, we still want to account for an empty object's</font>
<font color="black"> 667.             # existance so return the empty chunk for that initial</font>
<font color="black"> 668.             # read.</font>
<font color="red"> 669.             return chunk</font>
<font color="red"> 670.         raise StopIteration()</font>
<font color="black"> 671. </font>
<font color="green"> 672.     next = __next__</font>
<font color="black"> 673. </font>
<font color="black"> 674. </font>
<font color="green"> 675. class DeferQueue(object):</font>
<font color="black"> 676.     &quot;&quot;&quot;IO queue that defers write requests until they are queued sequentially.</font>
<font color="black"> 677. </font>
<font color="black"> 678.     This class is used to track IO data for a *single* fileobj.</font>
<font color="black"> 679. </font>
<font color="black"> 680.     You can send data to this queue, and it will defer any IO write requests</font>
<font color="black"> 681.     until it has the next contiguous block available (starting at 0).</font>
<font color="black"> 682. </font>
<font color="green"> 683.     &quot;&quot;&quot;</font>
<font color="green"> 684.     def __init__(self):</font>
<font color="red"> 685.         self._writes = []</font>
<font color="red"> 686.         self._pending_offsets = set()</font>
<font color="red"> 687.         self._next_offset = 0</font>
<font color="black"> 688. </font>
<font color="green"> 689.     def request_writes(self, offset, data):</font>
<font color="black"> 690.         &quot;&quot;&quot;Request any available writes given new incoming data.</font>
<font color="black"> 691. </font>
<font color="black"> 692.         You call this method by providing new data along with the</font>
<font color="black"> 693.         offset associated with the data.  If that new data unlocks</font>
<font color="black"> 694.         any contiguous writes that can now be submitted, this</font>
<font color="black"> 695.         method will return all applicable writes.</font>
<font color="black"> 696. </font>
<font color="black"> 697.         This is done with 1 method call so you don't have to</font>
<font color="black"> 698.         make two method calls (put(), get()) which acquires a lock</font>
<font color="black"> 699.         each method call.</font>
<font color="black"> 700. </font>
<font color="black"> 701.         &quot;&quot;&quot;</font>
<font color="red"> 702.         if offset &lt; self._next_offset:</font>
<font color="black"> 703.             # This is a request for a write that we've already</font>
<font color="black"> 704.             # seen.  This can happen in the event of a retry</font>
<font color="black"> 705.             # where if we retry at at offset N/2, we'll requeue</font>
<font color="black"> 706.             # offsets 0-N/2 again.</font>
<font color="red"> 707.             return []</font>
<font color="red"> 708.         writes = []</font>
<font color="red"> 709.         if offset in self._pending_offsets:</font>
<font color="black"> 710.             # We've already queued this offset so this request is</font>
<font color="black"> 711.             # a duplicate.  In this case we should ignore</font>
<font color="black"> 712.             # this request and prefer what's already queued.</font>
<font color="red"> 713.             return []</font>
<font color="red"> 714.         heapq.heappush(self._writes, (offset, data))</font>
<font color="red"> 715.         self._pending_offsets.add(offset)</font>
<font color="red"> 716.         while self._writes and self._writes[0][0] == self._next_offset:</font>
<font color="red"> 717.             next_write = heapq.heappop(self._writes)</font>
<font color="red"> 718.             writes.append({'offset': next_write[0], 'data': next_write[1]})</font>
<font color="red"> 719.             self._pending_offsets.remove(next_write[0])</font>
<font color="red"> 720.             self._next_offset += len(next_write[1])</font>
<font color="red"> 721.         return writes</font>
</pre>

