source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/packages/urllib3/poolmanager.py</b><br>


file stats: <b>127 lines, 58 executed: 45.7% covered</b>
<pre>
<font color="green">   1. import logging</font>
<font color="black">   2. </font>
<font color="green">   3. try:  # Python 3</font>
<font color="green">   4.     from urllib.parse import urljoin</font>
<font color="green">   5. except ImportError:</font>
<font color="green">   6.     from urlparse import urljoin</font>
<font color="black">   7. </font>
<font color="green">   8. from ._collections import RecentlyUsedContainer</font>
<font color="green">   9. from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool</font>
<font color="green">  10. from .connectionpool import port_by_scheme</font>
<font color="green">  11. from .exceptions import LocationValueError, MaxRetryError</font>
<font color="green">  12. from .request import RequestMethods</font>
<font color="green">  13. from .util.url import parse_url</font>
<font color="green">  14. from .util.retry import Retry</font>
<font color="black">  15. </font>
<font color="black">  16. </font>
<font color="green">  17. __all__ = ['PoolManager', 'ProxyManager', 'proxy_from_url']</font>
<font color="black">  18. </font>
<font color="black">  19. </font>
<font color="green">  20. pool_classes_by_scheme = {</font>
<font color="green">  21.     'http': HTTPConnectionPool,</font>
<font color="green">  22.     'https': HTTPSConnectionPool,</font>
<font color="black">  23. }</font>
<font color="black">  24. </font>
<font color="green">  25. log = logging.getLogger(__name__)</font>
<font color="black">  26. </font>
<font color="black">  27. SSL_KEYWORDS = ('key_file', 'cert_file', 'cert_reqs', 'ca_certs',</font>
<font color="green">  28.                 'ssl_version')</font>
<font color="black">  29. </font>
<font color="black">  30. </font>
<font color="green">  31. class PoolManager(RequestMethods):</font>
<font color="black">  32.     &quot;&quot;&quot;</font>
<font color="black">  33.     Allows for arbitrary requests while transparently keeping track of</font>
<font color="black">  34.     necessary connection pools for you.</font>
<font color="black">  35. </font>
<font color="black">  36.     :param num_pools:</font>
<font color="black">  37.         Number of connection pools to cache before discarding the least</font>
<font color="black">  38.         recently used pool.</font>
<font color="black">  39. </font>
<font color="black">  40.     :param headers:</font>
<font color="black">  41.         Headers to include with all requests, unless other headers are given</font>
<font color="black">  42.         explicitly.</font>
<font color="black">  43. </font>
<font color="black">  44.     :param \**connection_pool_kw:</font>
<font color="black">  45.         Additional parameters are used to create fresh</font>
<font color="black">  46.         :class:`urllib3.connectionpool.ConnectionPool` instances.</font>
<font color="black">  47. </font>
<font color="black">  48.     Example::</font>
<font color="black">  49. </font>
<font color="black">  50.         &gt;&gt;&gt; manager = PoolManager(num_pools=2)</font>
<font color="black">  51.         &gt;&gt;&gt; r = manager.request('GET', 'http://google.com/')</font>
<font color="black">  52.         &gt;&gt;&gt; r = manager.request('GET', 'http://google.com/mail')</font>
<font color="black">  53.         &gt;&gt;&gt; r = manager.request('GET', 'http://yahoo.com/')</font>
<font color="black">  54.         &gt;&gt;&gt; len(manager.pools)</font>
<font color="black">  55.         2</font>
<font color="black">  56. </font>
<font color="green">  57.     &quot;&quot;&quot;</font>
<font color="black">  58. </font>
<font color="green">  59.     proxy = None</font>
<font color="black">  60. </font>
<font color="green">  61.     def __init__(self, num_pools=10, headers=None, **connection_pool_kw):</font>
<font color="green">  62.         RequestMethods.__init__(self, headers)</font>
<font color="green">  63.         self.connection_pool_kw = connection_pool_kw</font>
<font color="green">  64.         self.pools = RecentlyUsedContainer(num_pools,</font>
<font color="green">  65.                                            dispose_func=lambda p: p.close())</font>
<font color="black">  66. </font>
<font color="green">  67.     def __enter__(self):</font>
<font color="red">  68.         return self</font>
<font color="black">  69. </font>
<font color="green">  70.     def __exit__(self, exc_type, exc_val, exc_tb):</font>
<font color="red">  71.         self.clear()</font>
<font color="black">  72.         # Return False to re-raise any potential exceptions</font>
<font color="red">  73.         return False</font>
<font color="black">  74. </font>
<font color="green">  75.     def _new_pool(self, scheme, host, port):</font>
<font color="black">  76.         &quot;&quot;&quot;</font>
<font color="black">  77.         Create a new :class:`ConnectionPool` based on host, port and scheme.</font>
<font color="black">  78. </font>
<font color="black">  79.         This method is used to actually create the connection pools handed out</font>
<font color="black">  80.         by :meth:`connection_from_url` and companion methods. It is intended</font>
<font color="black">  81.         to be overridden for customization.</font>
<font color="black">  82.         &quot;&quot;&quot;</font>
<font color="green">  83.         pool_cls = pool_classes_by_scheme[scheme]</font>
<font color="green">  84.         kwargs = self.connection_pool_kw</font>
<font color="green">  85.         if scheme == 'http':</font>
<font color="red">  86.             kwargs = self.connection_pool_kw.copy()</font>
<font color="red">  87.             for kw in SSL_KEYWORDS:</font>
<font color="red">  88.                 kwargs.pop(kw, None)</font>
<font color="black">  89. </font>
<font color="green">  90.         return pool_cls(host, port, **kwargs)</font>
<font color="black">  91. </font>
<font color="green">  92.     def clear(self):</font>
<font color="black">  93.         &quot;&quot;&quot;</font>
<font color="black">  94.         Empty our store of pools and direct them all to close.</font>
<font color="black">  95. </font>
<font color="black">  96.         This will not affect in-flight connections, but they will not be</font>
<font color="black">  97.         re-used after completion.</font>
<font color="black">  98.         &quot;&quot;&quot;</font>
<font color="red">  99.         self.pools.clear()</font>
<font color="black"> 100. </font>
<font color="green"> 101.     def connection_from_host(self, host, port=None, scheme='http'):</font>
<font color="black"> 102.         &quot;&quot;&quot;</font>
<font color="black"> 103.         Get a :class:`ConnectionPool` based on the host, port, and scheme.</font>
<font color="black"> 104. </font>
<font color="black"> 105.         If ``port`` isn't given, it will be derived from the ``scheme`` using</font>
<font color="black"> 106.         ``urllib3.connectionpool.port_by_scheme``.</font>
<font color="black"> 107.         &quot;&quot;&quot;</font>
<font color="black"> 108. </font>
<font color="green"> 109.         if not host:</font>
<font color="red"> 110.             raise LocationValueError(&quot;No host specified.&quot;)</font>
<font color="black"> 111. </font>
<font color="green"> 112.         scheme = scheme or 'http'</font>
<font color="green"> 113.         port = port or port_by_scheme.get(scheme, 80)</font>
<font color="green"> 114.         pool_key = (scheme, host, port)</font>
<font color="black"> 115. </font>
<font color="green"> 116.         with self.pools.lock:</font>
<font color="black"> 117.             # If the scheme, host, or port doesn't match existing open</font>
<font color="black"> 118.             # connections, open a new ConnectionPool.</font>
<font color="green"> 119.             pool = self.pools.get(pool_key)</font>
<font color="green"> 120.             if pool:</font>
<font color="green"> 121.                 return pool</font>
<font color="black"> 122. </font>
<font color="black"> 123.             # Make a fresh ConnectionPool of the desired type</font>
<font color="green"> 124.             pool = self._new_pool(scheme, host, port)</font>
<font color="green"> 125.             self.pools[pool_key] = pool</font>
<font color="black"> 126. </font>
<font color="green"> 127.         return pool</font>
<font color="black"> 128. </font>
<font color="green"> 129.     def connection_from_url(self, url):</font>
<font color="black"> 130.         &quot;&quot;&quot;</font>
<font color="black"> 131.         Similar to :func:`urllib3.connectionpool.connection_from_url` but</font>
<font color="black"> 132.         doesn't pass any additional parameters to the</font>
<font color="black"> 133.         :class:`urllib3.connectionpool.ConnectionPool` constructor.</font>
<font color="black"> 134. </font>
<font color="black"> 135.         Additional parameters are taken from the :class:`.PoolManager`</font>
<font color="black"> 136.         constructor.</font>
<font color="black"> 137.         &quot;&quot;&quot;</font>
<font color="green"> 138.         u = parse_url(url)</font>
<font color="green"> 139.         return self.connection_from_host(u.host, port=u.port, scheme=u.scheme)</font>
<font color="black"> 140. </font>
<font color="green"> 141.     def urlopen(self, method, url, redirect=True, **kw):</font>
<font color="black"> 142.         &quot;&quot;&quot;</font>
<font color="black"> 143.         Same as :meth:`urllib3.connectionpool.HTTPConnectionPool.urlopen`</font>
<font color="black"> 144.         with custom cross-host redirect logic and only sends the request-uri</font>
<font color="black"> 145.         portion of the ``url``.</font>
<font color="black"> 146. </font>
<font color="black"> 147.         The given ``url`` parameter must be absolute, such that an appropriate</font>
<font color="black"> 148.         :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.</font>
<font color="black"> 149.         &quot;&quot;&quot;</font>
<font color="red"> 150.         u = parse_url(url)</font>
<font color="red"> 151.         conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)</font>
<font color="black"> 152. </font>
<font color="red"> 153.         kw['assert_same_host'] = False</font>
<font color="red"> 154.         kw['redirect'] = False</font>
<font color="red"> 155.         if 'headers' not in kw:</font>
<font color="red"> 156.             kw['headers'] = self.headers</font>
<font color="black"> 157. </font>
<font color="red"> 158.         if self.proxy is not None and u.scheme == &quot;http&quot;:</font>
<font color="red"> 159.             response = conn.urlopen(method, url, **kw)</font>
<font color="black"> 160.         else:</font>
<font color="red"> 161.             response = conn.urlopen(method, u.request_uri, **kw)</font>
<font color="black"> 162. </font>
<font color="red"> 163.         redirect_location = redirect and response.get_redirect_location()</font>
<font color="red"> 164.         if not redirect_location:</font>
<font color="red"> 165.             return response</font>
<font color="black"> 166. </font>
<font color="black"> 167.         # Support relative URLs for redirecting.</font>
<font color="red"> 168.         redirect_location = urljoin(url, redirect_location)</font>
<font color="black"> 169. </font>
<font color="black"> 170.         # RFC 7231, Section 6.4.4</font>
<font color="red"> 171.         if response.status == 303:</font>
<font color="red"> 172.             method = 'GET'</font>
<font color="black"> 173. </font>
<font color="red"> 174.         retries = kw.get('retries')</font>
<font color="red"> 175.         if not isinstance(retries, Retry):</font>
<font color="red"> 176.             retries = Retry.from_int(retries, redirect=redirect)</font>
<font color="black"> 177. </font>
<font color="red"> 178.         try:</font>
<font color="red"> 179.             retries = retries.increment(method, url, response=response, _pool=conn)</font>
<font color="red"> 180.         except MaxRetryError:</font>
<font color="red"> 181.             if retries.raise_on_redirect:</font>
<font color="red"> 182.                 raise</font>
<font color="red"> 183.             return response</font>
<font color="black"> 184. </font>
<font color="red"> 185.         kw['retries'] = retries</font>
<font color="red"> 186.         kw['redirect'] = redirect</font>
<font color="black"> 187. </font>
<font color="red"> 188.         log.info(&quot;Redirecting %s -&gt; %s&quot; % (url, redirect_location))</font>
<font color="red"> 189.         return self.urlopen(method, redirect_location, **kw)</font>
<font color="black"> 190. </font>
<font color="black"> 191. </font>
<font color="green"> 192. class ProxyManager(PoolManager):</font>
<font color="black"> 193.     &quot;&quot;&quot;</font>
<font color="black"> 194.     Behaves just like :class:`PoolManager`, but sends all requests through</font>
<font color="black"> 195.     the defined proxy, using the CONNECT method for HTTPS URLs.</font>
<font color="black"> 196. </font>
<font color="black"> 197.     :param proxy_url:</font>
<font color="black"> 198.         The URL of the proxy to be used.</font>
<font color="black"> 199. </font>
<font color="black"> 200.     :param proxy_headers:</font>
<font color="black"> 201.         A dictionary contaning headers that will be sent to the proxy. In case</font>
<font color="black"> 202.         of HTTP they are being sent with each request, while in the</font>
<font color="black"> 203.         HTTPS/CONNECT case they are sent only once. Could be used for proxy</font>
<font color="black"> 204.         authentication.</font>
<font color="black"> 205. </font>
<font color="black"> 206.     Example:</font>
<font color="black"> 207.         &gt;&gt;&gt; proxy = urllib3.ProxyManager('http://localhost:3128/')</font>
<font color="black"> 208.         &gt;&gt;&gt; r1 = proxy.request('GET', 'http://google.com/')</font>
<font color="black"> 209.         &gt;&gt;&gt; r2 = proxy.request('GET', 'http://httpbin.org/')</font>
<font color="black"> 210.         &gt;&gt;&gt; len(proxy.pools)</font>
<font color="black"> 211.         1</font>
<font color="black"> 212.         &gt;&gt;&gt; r3 = proxy.request('GET', 'https://httpbin.org/')</font>
<font color="black"> 213.         &gt;&gt;&gt; r4 = proxy.request('GET', 'https://twitter.com/')</font>
<font color="black"> 214.         &gt;&gt;&gt; len(proxy.pools)</font>
<font color="black"> 215.         3</font>
<font color="black"> 216. </font>
<font color="green"> 217.     &quot;&quot;&quot;</font>
<font color="black"> 218. </font>
<font color="green"> 219.     def __init__(self, proxy_url, num_pools=10, headers=None,</font>
<font color="green"> 220.                  proxy_headers=None, **connection_pool_kw):</font>
<font color="black"> 221. </font>
<font color="red"> 222.         if isinstance(proxy_url, HTTPConnectionPool):</font>
<font color="red"> 223.             proxy_url = '%s://%s:%i' % (proxy_url.scheme, proxy_url.host,</font>
<font color="red"> 224.                                         proxy_url.port)</font>
<font color="red"> 225.         proxy = parse_url(proxy_url)</font>
<font color="red"> 226.         if not proxy.port:</font>
<font color="red"> 227.             port = port_by_scheme.get(proxy.scheme, 80)</font>
<font color="red"> 228.             proxy = proxy._replace(port=port)</font>
<font color="black"> 229. </font>
<font color="red"> 230.         assert proxy.scheme in (&quot;http&quot;, &quot;https&quot;), \</font>
<font color="red"> 231.             'Not supported proxy scheme %s' % proxy.scheme</font>
<font color="black"> 232. </font>
<font color="red"> 233.         self.proxy = proxy</font>
<font color="red"> 234.         self.proxy_headers = proxy_headers or {}</font>
<font color="black"> 235. </font>
<font color="red"> 236.         connection_pool_kw['_proxy'] = self.proxy</font>
<font color="red"> 237.         connection_pool_kw['_proxy_headers'] = self.proxy_headers</font>
<font color="black"> 238. </font>
<font color="red"> 239.         super(ProxyManager, self).__init__(</font>
<font color="red"> 240.             num_pools, headers, **connection_pool_kw)</font>
<font color="black"> 241. </font>
<font color="green"> 242.     def connection_from_host(self, host, port=None, scheme='http'):</font>
<font color="red"> 243.         if scheme == &quot;https&quot;:</font>
<font color="red"> 244.             return super(ProxyManager, self).connection_from_host(</font>
<font color="red"> 245.                 host, port, scheme)</font>
<font color="black"> 246. </font>
<font color="red"> 247.         return super(ProxyManager, self).connection_from_host(</font>
<font color="red"> 248.             self.proxy.host, self.proxy.port, self.proxy.scheme)</font>
<font color="black"> 249. </font>
<font color="green"> 250.     def _set_proxy_headers(self, url, headers=None):</font>
<font color="black"> 251.         &quot;&quot;&quot;</font>
<font color="black"> 252.         Sets headers needed by proxies: specifically, the Accept and Host</font>
<font color="black"> 253.         headers. Only sets headers not provided by the user.</font>
<font color="black"> 254.         &quot;&quot;&quot;</font>
<font color="red"> 255.         headers_ = {'Accept': '*/*'}</font>
<font color="black"> 256. </font>
<font color="red"> 257.         netloc = parse_url(url).netloc</font>
<font color="red"> 258.         if netloc:</font>
<font color="red"> 259.             headers_['Host'] = netloc</font>
<font color="black"> 260. </font>
<font color="red"> 261.         if headers:</font>
<font color="red"> 262.             headers_.update(headers)</font>
<font color="red"> 263.         return headers_</font>
<font color="black"> 264. </font>
<font color="green"> 265.     def urlopen(self, method, url, redirect=True, **kw):</font>
<font color="black"> 266.         &quot;Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.&quot;</font>
<font color="red"> 267.         u = parse_url(url)</font>
<font color="black"> 268. </font>
<font color="red"> 269.         if u.scheme == &quot;http&quot;:</font>
<font color="black"> 270.             # For proxied HTTPS requests, httplib sets the necessary headers</font>
<font color="black"> 271.             # on the CONNECT to the proxy. For HTTP, we'll definitely</font>
<font color="black"> 272.             # need to set 'Host' at the very least.</font>
<font color="red"> 273.             headers = kw.get('headers', self.headers)</font>
<font color="red"> 274.             kw['headers'] = self._set_proxy_headers(url, headers)</font>
<font color="black"> 275. </font>
<font color="red"> 276.         return super(ProxyManager, self).urlopen(method, url, redirect=redirect, **kw)</font>
<font color="black"> 277. </font>
<font color="black"> 278. </font>
<font color="green"> 279. def proxy_from_url(url, **kw):</font>
<font color="red"> 280.     return ProxyManager(proxy_url=url, **kw)</font>
</pre>

