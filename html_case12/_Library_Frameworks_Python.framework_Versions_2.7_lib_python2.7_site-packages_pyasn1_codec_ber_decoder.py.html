source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/pyasn1/codec/ber/decoder.py</b><br>


file stats: <b>660 lines, 150 executed: 22.7% covered</b>
<pre>
<font color="black">   1. #</font>
<font color="black">   2. # This file is part of pyasn1 software.</font>
<font color="black">   3. #</font>
<font color="black">   4. # Copyright (c) 2005-2017, Ilya Etingof &lt;etingof@gmail.com&gt;</font>
<font color="black">   5. # License: http://pyasn1.sf.net/license.html</font>
<font color="black">   6. #</font>
<font color="green">   7. from pyasn1.type import base, tag, univ, char, useful, tagmap</font>
<font color="green">   8. from pyasn1.codec.ber import eoo</font>
<font color="green">   9. from pyasn1.compat.octets import oct2int, octs2ints, isOctetsType</font>
<font color="green">  10. from pyasn1.compat.integer import from_bytes</font>
<font color="green">  11. from pyasn1 import debug, error</font>
<font color="black">  12. </font>
<font color="green">  13. __all__ = ['decode']</font>
<font color="black">  14. </font>
<font color="black">  15. </font>
<font color="green">  16. class AbstractDecoder(object):</font>
<font color="green">  17.     protoComponent = None</font>
<font color="black">  18. </font>
<font color="green">  19.     def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black">  20.                      length, state, decodeFun, substrateFun):</font>
<font color="red">  21.         raise error.PyAsn1Error('Decoder not implemented for %s' % (tagSet,))</font>
<font color="black">  22. </font>
<font color="green">  23.     def indefLenValueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black">  24.                              length, state, decodeFun, substrateFun):</font>
<font color="red">  25.         raise error.PyAsn1Error('Indefinite length mode decoder not implemented for %s' % (tagSet,))</font>
<font color="black">  26. </font>
<font color="black">  27. </font>
<font color="green">  28. class AbstractSimpleDecoder(AbstractDecoder):</font>
<font color="green">  29.     tagFormats = (tag.tagFormatSimple,)</font>
<font color="black">  30. </font>
<font color="green">  31.     def _createComponent(self, asn1Spec, tagSet, value=None):</font>
<font color="red">  32.         if tagSet[0][1] not in self.tagFormats:</font>
<font color="red">  33.             raise error.PyAsn1Error('Invalid tag format %s for %s' % (tagSet[0], self.protoComponent.prettyPrintType()))</font>
<font color="red">  34.         if asn1Spec is None:</font>
<font color="red">  35.             return self.protoComponent.clone(value, tagSet)</font>
<font color="red">  36.         elif value is None:</font>
<font color="red">  37.             return asn1Spec</font>
<font color="black">  38.         else:</font>
<font color="red">  39.             return asn1Spec.clone(value)</font>
<font color="black">  40. </font>
<font color="black">  41. </font>
<font color="green">  42. class AbstractConstructedDecoder(AbstractDecoder):</font>
<font color="green">  43.     tagFormats = (tag.tagFormatConstructed,)</font>
<font color="black">  44. </font>
<font color="black">  45.     # noinspection PyUnusedLocal</font>
<font color="green">  46.     def _createComponent(self, asn1Spec, tagSet, value=None):</font>
<font color="red">  47.         if tagSet[0][1] not in self.tagFormats:</font>
<font color="red">  48.             raise error.PyAsn1Error('Invalid tag format %s for %s' % (tagSet[0], self.protoComponent.prettyPrintType()))</font>
<font color="red">  49.         if asn1Spec is None:</font>
<font color="red">  50.             return self.protoComponent.clone(tagSet)</font>
<font color="black">  51.         else:</font>
<font color="red">  52.             return asn1Spec.clone()</font>
<font color="black">  53. </font>
<font color="black">  54. </font>
<font color="green">  55. class ExplicitTagDecoder(AbstractSimpleDecoder):</font>
<font color="green">  56.     protoComponent = univ.Any('')</font>
<font color="green">  57.     tagFormats = (tag.tagFormatConstructed,)</font>
<font color="black">  58. </font>
<font color="green">  59.     def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black">  60.                      length, state, decodeFun, substrateFun):</font>
<font color="red">  61.         if substrateFun:</font>
<font color="red">  62.             return substrateFun(</font>
<font color="red">  63.                 self._createComponent(asn1Spec, tagSet, ''),</font>
<font color="red">  64.                 substrate, length</font>
<font color="black">  65.             )</font>
<font color="red">  66.         head, tail = substrate[:length], substrate[length:]</font>
<font color="red">  67.         value, _ = decodeFun(head, asn1Spec, tagSet, length)</font>
<font color="red">  68.         return value, tail</font>
<font color="black">  69. </font>
<font color="green">  70.     def indefLenValueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black">  71.                              length, state, decodeFun, substrateFun):</font>
<font color="red">  72.         if substrateFun:</font>
<font color="red">  73.             return substrateFun(</font>
<font color="red">  74.                 self._createComponent(asn1Spec, tagSet, ''),</font>
<font color="red">  75.                 substrate, length</font>
<font color="black">  76.             )</font>
<font color="red">  77.         value, substrate = decodeFun(substrate, asn1Spec, tagSet, length)</font>
<font color="red">  78.         terminator, substrate = decodeFun(substrate, allowEoo=True)</font>
<font color="red">  79.         if eoo.endOfOctets.isSameTypeWith(terminator) and \</font>
<font color="red">  80.                 terminator == eoo.endOfOctets:</font>
<font color="red">  81.             return value, substrate</font>
<font color="black">  82.         else:</font>
<font color="red">  83.             raise error.PyAsn1Error('Missing end-of-octets terminator')</font>
<font color="black">  84. </font>
<font color="black">  85. </font>
<font color="green">  86. explicitTagDecoder = ExplicitTagDecoder()</font>
<font color="black">  87. </font>
<font color="black">  88. </font>
<font color="green">  89. class IntegerDecoder(AbstractSimpleDecoder):</font>
<font color="green">  90.     protoComponent = univ.Integer(0)</font>
<font color="black">  91. </font>
<font color="green">  92.     def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet, length,</font>
<font color="black">  93.                      state, decodeFun, substrateFun):</font>
<font color="red">  94.         head, tail = substrate[:length], substrate[length:]</font>
<font color="black">  95. </font>
<font color="red">  96.         if not head:</font>
<font color="red">  97.             return self._createComponent(asn1Spec, tagSet, 0), tail</font>
<font color="black">  98. </font>
<font color="red">  99.         value = from_bytes(head, signed=True)</font>
<font color="black"> 100. </font>
<font color="red"> 101.         return self._createComponent(asn1Spec, tagSet, value), tail</font>
<font color="black"> 102. </font>
<font color="black"> 103. </font>
<font color="green"> 104. class BooleanDecoder(IntegerDecoder):</font>
<font color="green"> 105.     protoComponent = univ.Boolean(0)</font>
<font color="black"> 106. </font>
<font color="green"> 107.     def _createComponent(self, asn1Spec, tagSet, value=None):</font>
<font color="red"> 108.         return IntegerDecoder._createComponent(self, asn1Spec, tagSet, value and 1 or 0)</font>
<font color="black"> 109. </font>
<font color="black"> 110. </font>
<font color="green"> 111. class BitStringDecoder(AbstractSimpleDecoder):</font>
<font color="green"> 112.     protoComponent = univ.BitString(())</font>
<font color="green"> 113.     tagFormats = (tag.tagFormatSimple, tag.tagFormatConstructed)</font>
<font color="green"> 114.     supportConstructedForm = True</font>
<font color="black"> 115. </font>
<font color="green"> 116.     def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet, length,</font>
<font color="black"> 117.                      state, decodeFun, substrateFun):</font>
<font color="red"> 118.         head, tail = substrate[:length], substrate[length:]</font>
<font color="red"> 119.         if tagSet[0][1] == tag.tagFormatSimple:  # XXX what tag to check?</font>
<font color="red"> 120.             if not head:</font>
<font color="red"> 121.                 raise error.PyAsn1Error('Empty substrate')</font>
<font color="red"> 122.             trailingBits = oct2int(head[0])</font>
<font color="red"> 123.             if trailingBits &gt; 7:</font>
<font color="red"> 124.                 raise error.PyAsn1Error(</font>
<font color="red"> 125.                     'Trailing bits overflow %s' % trailingBits</font>
<font color="black"> 126.                 )</font>
<font color="red"> 127.             head = head[1:]</font>
<font color="red"> 128.             value = self.protoComponent.fromOctetString(head, trailingBits)</font>
<font color="red"> 129.             return self._createComponent(asn1Spec, tagSet, value), tail</font>
<font color="black"> 130. </font>
<font color="red"> 131.         if not self.supportConstructedForm:</font>
<font color="red"> 132.             raise error.PyAsn1Error('Constructed encoding form prohibited at %s' % self.__class__.__name__)</font>
<font color="black"> 133. </font>
<font color="red"> 134.         bitString = self._createComponent(asn1Spec, tagSet)</font>
<font color="black"> 135. </font>
<font color="red"> 136.         if substrateFun:</font>
<font color="red"> 137.             return substrateFun(bitString, substrate, length)</font>
<font color="black"> 138. </font>
<font color="red"> 139.         while head:</font>
<font color="red"> 140.             component, head = decodeFun(head, self.protoComponent)</font>
<font color="red"> 141.             bitString += component</font>
<font color="black"> 142. </font>
<font color="red"> 143.         return bitString, tail</font>
<font color="black"> 144. </font>
<font color="green"> 145.     def indefLenValueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black"> 146.                              length, state, decodeFun, substrateFun):</font>
<font color="red"> 147.         bitString = self._createComponent(asn1Spec, tagSet)</font>
<font color="black"> 148. </font>
<font color="red"> 149.         if substrateFun:</font>
<font color="red"> 150.             return substrateFun(bitString, substrate, length)</font>
<font color="black"> 151. </font>
<font color="red"> 152.         while substrate:</font>
<font color="red"> 153.             component, substrate = decodeFun(substrate, self.protoComponent, allowEoo=True)</font>
<font color="red"> 154.             if eoo.endOfOctets.isSameTypeWith(component) and component == eoo.endOfOctets:</font>
<font color="red"> 155.                 break</font>
<font color="black"> 156. </font>
<font color="red"> 157.             bitString += component</font>
<font color="black"> 158. </font>
<font color="black"> 159.         else:</font>
<font color="red"> 160.             raise error.SubstrateUnderrunError('No EOO seen before substrate ends')</font>
<font color="black"> 161. </font>
<font color="red"> 162.         return bitString, substrate</font>
<font color="black"> 163. </font>
<font color="black"> 164. </font>
<font color="green"> 165. class OctetStringDecoder(AbstractSimpleDecoder):</font>
<font color="green"> 166.     protoComponent = univ.OctetString('')</font>
<font color="green"> 167.     tagFormats = (tag.tagFormatSimple, tag.tagFormatConstructed)</font>
<font color="green"> 168.     supportConstructedForm = True</font>
<font color="black"> 169. </font>
<font color="green"> 170.     def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet, length,</font>
<font color="black"> 171.                      state, decodeFun, substrateFun):</font>
<font color="red"> 172.         head, tail = substrate[:length], substrate[length:]</font>
<font color="red"> 173.         if tagSet[0][1] == tag.tagFormatSimple:  # XXX what tag to check?</font>
<font color="red"> 174.             return self._createComponent(asn1Spec, tagSet, head), tail</font>
<font color="red"> 175.         if not self.supportConstructedForm:</font>
<font color="red"> 176.             raise error.PyAsn1Error('Constructed encoding form prohibited at %s' % self.__class__.__name__)</font>
<font color="red"> 177.         r = self._createComponent(asn1Spec, tagSet, '')</font>
<font color="red"> 178.         if substrateFun:</font>
<font color="red"> 179.             return substrateFun(r, substrate, length)</font>
<font color="red"> 180.         while head:</font>
<font color="red"> 181.             component, head = decodeFun(head, self.protoComponent)</font>
<font color="red"> 182.             r = r + component</font>
<font color="red"> 183.         return r, tail</font>
<font color="black"> 184. </font>
<font color="green"> 185.     def indefLenValueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black"> 186.                              length, state, decodeFun, substrateFun):</font>
<font color="red"> 187.         r = self._createComponent(asn1Spec, tagSet, '')</font>
<font color="red"> 188.         if substrateFun:</font>
<font color="red"> 189.             return substrateFun(r, substrate, length)</font>
<font color="red"> 190.         while substrate:</font>
<font color="red"> 191.             component, substrate = decodeFun(substrate, self.protoComponent,</font>
<font color="red"> 192.                                              allowEoo=True)</font>
<font color="red"> 193.             if eoo.endOfOctets.isSameTypeWith(component) and \</font>
<font color="red"> 194.                     component == eoo.endOfOctets:</font>
<font color="red"> 195.                 break</font>
<font color="red"> 196.             r = r + component</font>
<font color="black"> 197.         else:</font>
<font color="red"> 198.             raise error.SubstrateUnderrunError(</font>
<font color="red"> 199.                 'No EOO seen before substrate ends'</font>
<font color="black"> 200.             )</font>
<font color="red"> 201.         return r, substrate</font>
<font color="black"> 202. </font>
<font color="black"> 203. </font>
<font color="green"> 204. class NullDecoder(AbstractSimpleDecoder):</font>
<font color="green"> 205.     protoComponent = univ.Null('')</font>
<font color="black"> 206. </font>
<font color="green"> 207.     def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black"> 208.                      length, state, decodeFun, substrateFun):</font>
<font color="red"> 209.         head, tail = substrate[:length], substrate[length:]</font>
<font color="red"> 210.         r = self._createComponent(asn1Spec, tagSet)</font>
<font color="red"> 211.         if head:</font>
<font color="red"> 212.             raise error.PyAsn1Error('Unexpected %d-octet substrate for Null' % length)</font>
<font color="red"> 213.         return r, tail</font>
<font color="black"> 214. </font>
<font color="black"> 215. </font>
<font color="green"> 216. class ObjectIdentifierDecoder(AbstractSimpleDecoder):</font>
<font color="green"> 217.     protoComponent = univ.ObjectIdentifier(())</font>
<font color="black"> 218. </font>
<font color="green"> 219.     def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet, length,</font>
<font color="black"> 220.                      state, decodeFun, substrateFun):</font>
<font color="red"> 221.         head, tail = substrate[:length], substrate[length:]</font>
<font color="red"> 222.         if not head:</font>
<font color="red"> 223.             raise error.PyAsn1Error('Empty substrate')</font>
<font color="black"> 224. </font>
<font color="red"> 225.         head = octs2ints(head)</font>
<font color="black"> 226. </font>
<font color="red"> 227.         oid = ()</font>
<font color="red"> 228.         index = 0</font>
<font color="red"> 229.         substrateLen = len(head)</font>
<font color="red"> 230.         while index &lt; substrateLen:</font>
<font color="red"> 231.             subId = head[index]</font>
<font color="red"> 232.             index += 1</font>
<font color="red"> 233.             if subId &lt; 128:</font>
<font color="red"> 234.                 oid = oid + (subId,)</font>
<font color="red"> 235.             elif subId &gt; 128:</font>
<font color="black"> 236.                 # Construct subid from a number of octets</font>
<font color="red"> 237.                 nextSubId = subId</font>
<font color="red"> 238.                 subId = 0</font>
<font color="red"> 239.                 while nextSubId &gt;= 128:</font>
<font color="red"> 240.                     subId = (subId &lt;&lt; 7) + (nextSubId &amp; 0x7F)</font>
<font color="red"> 241.                     if index &gt;= substrateLen:</font>
<font color="red"> 242.                         raise error.SubstrateUnderrunError(</font>
<font color="red"> 243.                             'Short substrate for sub-OID past %s' % (oid,)</font>
<font color="black"> 244.                         )</font>
<font color="red"> 245.                     nextSubId = head[index]</font>
<font color="red"> 246.                     index += 1</font>
<font color="red"> 247.                 oid += ((subId &lt;&lt; 7) + nextSubId,)</font>
<font color="red"> 248.             elif subId == 128:</font>
<font color="black"> 249.                 # ASN.1 spec forbids leading zeros (0x80) in OID</font>
<font color="black"> 250.                 # encoding, tolerating it opens a vulnerability. See</font>
<font color="black"> 251.                 # http://www.cosic.esat.kuleuven.be/publications/article-1432.pdf</font>
<font color="black"> 252.                 # page 7</font>
<font color="red"> 253.                 raise error.PyAsn1Error('Invalid octet 0x80 in OID encoding')</font>
<font color="black"> 254. </font>
<font color="black"> 255.         # Decode two leading arcs</font>
<font color="red"> 256.         if 0 &lt;= oid[0] &lt;= 39:</font>
<font color="red"> 257.             oid = (0,) + oid</font>
<font color="red"> 258.         elif 40 &lt;= oid[0] &lt;= 79:</font>
<font color="red"> 259.             oid = (1, oid[0] - 40) + oid[1:]</font>
<font color="red"> 260.         elif oid[0] &gt;= 80:</font>
<font color="red"> 261.             oid = (2, oid[0] - 80) + oid[1:]</font>
<font color="black"> 262.         else:</font>
<font color="red"> 263.             raise error.PyAsn1Error('Malformed first OID octet: %s' % head[0])</font>
<font color="black"> 264. </font>
<font color="red"> 265.         return self._createComponent(asn1Spec, tagSet, oid), tail</font>
<font color="black"> 266. </font>
<font color="black"> 267. </font>
<font color="green"> 268. class RealDecoder(AbstractSimpleDecoder):</font>
<font color="green"> 269.     protoComponent = univ.Real()</font>
<font color="black"> 270. </font>
<font color="green"> 271.     def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black"> 272.                      length, state, decodeFun, substrateFun):</font>
<font color="red"> 273.         head, tail = substrate[:length], substrate[length:]</font>
<font color="red"> 274.         if not head:</font>
<font color="red"> 275.             return self._createComponent(asn1Spec, tagSet, 0.0), tail</font>
<font color="red"> 276.         fo = oct2int(head[0])</font>
<font color="red"> 277.         head = head[1:]</font>
<font color="red"> 278.         if fo &amp; 0x80:  # binary encoding</font>
<font color="red"> 279.             if not head:</font>
<font color="red"> 280.                 raise error.PyAsn1Error(&quot;Incomplete floating-point value&quot;)</font>
<font color="red"> 281.             n = (fo &amp; 0x03) + 1</font>
<font color="red"> 282.             if n == 4:</font>
<font color="red"> 283.                 n = oct2int(head[0])</font>
<font color="red"> 284.                 head = head[1:]</font>
<font color="red"> 285.             eo, head = head[:n], head[n:]</font>
<font color="red"> 286.             if not eo or not head:</font>
<font color="red"> 287.                 raise error.PyAsn1Error('Real exponent screwed')</font>
<font color="red"> 288.             e = oct2int(eo[0]) &amp; 0x80 and -1 or 0</font>
<font color="red"> 289.             while eo:  # exponent</font>
<font color="red"> 290.                 e &lt;&lt;= 8</font>
<font color="red"> 291.                 e |= oct2int(eo[0])</font>
<font color="red"> 292.                 eo = eo[1:]</font>
<font color="red"> 293.             b = fo &gt;&gt; 4 &amp; 0x03  # base bits</font>
<font color="red"> 294.             if b &gt; 2:</font>
<font color="red"> 295.                 raise error.PyAsn1Error('Illegal Real base')</font>
<font color="red"> 296.             if b == 1:  # encbase = 8</font>
<font color="red"> 297.                 e *= 3</font>
<font color="red"> 298.             elif b == 2:  # encbase = 16</font>
<font color="red"> 299.                 e *= 4</font>
<font color="red"> 300.             p = 0</font>
<font color="red"> 301.             while head:  # value</font>
<font color="red"> 302.                 p &lt;&lt;= 8</font>
<font color="red"> 303.                 p |= oct2int(head[0])</font>
<font color="red"> 304.                 head = head[1:]</font>
<font color="red"> 305.             if fo &amp; 0x40:  # sign bit</font>
<font color="red"> 306.                 p = -p</font>
<font color="red"> 307.             sf = fo &gt;&gt; 2 &amp; 0x03  # scale bits</font>
<font color="red"> 308.             p *= 2 ** sf</font>
<font color="red"> 309.             value = (p, 2, e)</font>
<font color="red"> 310.         elif fo &amp; 0x40:  # infinite value</font>
<font color="red"> 311.             value = fo &amp; 0x01 and '-inf' or 'inf'</font>
<font color="red"> 312.         elif fo &amp; 0xc0 == 0:  # character encoding</font>
<font color="red"> 313.             if not head:</font>
<font color="red"> 314.                 raise error.PyAsn1Error(&quot;Incomplete floating-point value&quot;)</font>
<font color="red"> 315.             try:</font>
<font color="red"> 316.                 if fo &amp; 0x3 == 0x1:  # NR1</font>
<font color="red"> 317.                     value = (int(head), 10, 0)</font>
<font color="red"> 318.                 elif fo &amp; 0x3 == 0x2:  # NR2</font>
<font color="red"> 319.                     value = float(head)</font>
<font color="red"> 320.                 elif fo &amp; 0x3 == 0x3:  # NR3</font>
<font color="red"> 321.                     value = float(head)</font>
<font color="black"> 322.                 else:</font>
<font color="red"> 323.                     raise error.SubstrateUnderrunError(</font>
<font color="red"> 324.                         'Unknown NR (tag %s)' % fo</font>
<font color="black"> 325.                     )</font>
<font color="red"> 326.             except ValueError:</font>
<font color="red"> 327.                 raise error.SubstrateUnderrunError(</font>
<font color="red"> 328.                     'Bad character Real syntax'</font>
<font color="black"> 329.                 )</font>
<font color="black"> 330.         else:</font>
<font color="red"> 331.             raise error.SubstrateUnderrunError(</font>
<font color="red"> 332.                 'Unknown encoding (tag %s)' % fo</font>
<font color="black"> 333.             )</font>
<font color="red"> 334.         return self._createComponent(asn1Spec, tagSet, value), tail</font>
<font color="black"> 335. </font>
<font color="black"> 336. </font>
<font color="green"> 337. class SequenceDecoder(AbstractConstructedDecoder):</font>
<font color="green"> 338.     protoComponent = univ.Sequence()</font>
<font color="black"> 339. </font>
<font color="green"> 340.     def _getComponentTagMap(self, r, idx):</font>
<font color="red"> 341.         try:</font>
<font color="red"> 342.             return r.getComponentTagMapNearPosition(idx)</font>
<font color="red"> 343.         except error.PyAsn1Error:</font>
<font color="red"> 344.             return</font>
<font color="black"> 345. </font>
<font color="green"> 346.     def _getComponentPositionByType(self, r, t, idx):</font>
<font color="red"> 347.         return r.getComponentPositionNearType(t, idx)</font>
<font color="black"> 348. </font>
<font color="green"> 349.     def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black"> 350.                      length, state, decodeFun, substrateFun):</font>
<font color="red"> 351.         head, tail = substrate[:length], substrate[length:]</font>
<font color="red"> 352.         r = self._createComponent(asn1Spec, tagSet)</font>
<font color="red"> 353.         idx = 0</font>
<font color="red"> 354.         if substrateFun:</font>
<font color="red"> 355.             return substrateFun(r, substrate, length)</font>
<font color="red"> 356.         while head:</font>
<font color="red"> 357.             asn1Spec = self._getComponentTagMap(r, idx)</font>
<font color="red"> 358.             component, head = decodeFun(head, asn1Spec)</font>
<font color="red"> 359.             idx = self._getComponentPositionByType(</font>
<font color="red"> 360.                 r, component.getEffectiveTagSet(), idx</font>
<font color="black"> 361.             )</font>
<font color="red"> 362.             r.setComponentByPosition(idx, component,</font>
<font color="red"> 363.                                      verifyConstraints=False,</font>
<font color="red"> 364.                                      matchTags=False, matchConstraints=False)</font>
<font color="red"> 365.             idx += 1</font>
<font color="red"> 366.         r.setDefaultComponents()</font>
<font color="red"> 367.         r.verifySizeSpec()</font>
<font color="red"> 368.         return r, tail</font>
<font color="black"> 369. </font>
<font color="green"> 370.     def indefLenValueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black"> 371.                              length, state, decodeFun, substrateFun):</font>
<font color="red"> 372.         r = self._createComponent(asn1Spec, tagSet)</font>
<font color="red"> 373.         if substrateFun:</font>
<font color="red"> 374.             return substrateFun(r, substrate, length)</font>
<font color="red"> 375.         idx = 0</font>
<font color="red"> 376.         while substrate:</font>
<font color="red"> 377.             asn1Spec = self._getComponentTagMap(r, idx)</font>
<font color="red"> 378.             component, substrate = decodeFun(substrate, asn1Spec, allowEoo=True)</font>
<font color="red"> 379.             if eoo.endOfOctets.isSameTypeWith(component) and \</font>
<font color="red"> 380.                     component == eoo.endOfOctets:</font>
<font color="red"> 381.                 break</font>
<font color="red"> 382.             idx = self._getComponentPositionByType(</font>
<font color="red"> 383.                 r, component.getEffectiveTagSet(), idx</font>
<font color="black"> 384.             )</font>
<font color="red"> 385.             r.setComponentByPosition(idx, component,</font>
<font color="red"> 386.                                      verifyConstraints=False,</font>
<font color="red"> 387.                                      matchTags=False, matchConstraints=False)</font>
<font color="red"> 388.             idx += 1</font>
<font color="black"> 389.         else:</font>
<font color="red"> 390.             raise error.SubstrateUnderrunError(</font>
<font color="red"> 391.                 'No EOO seen before substrate ends'</font>
<font color="black"> 392.             )</font>
<font color="red"> 393.         r.setDefaultComponents()</font>
<font color="red"> 394.         r.verifySizeSpec()</font>
<font color="red"> 395.         return r, substrate</font>
<font color="black"> 396. </font>
<font color="black"> 397. </font>
<font color="green"> 398. class SequenceOfDecoder(AbstractConstructedDecoder):</font>
<font color="green"> 399.     protoComponent = univ.SequenceOf()</font>
<font color="black"> 400. </font>
<font color="green"> 401.     def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black"> 402.                      length, state, decodeFun, substrateFun):</font>
<font color="red"> 403.         head, tail = substrate[:length], substrate[length:]</font>
<font color="red"> 404.         r = self._createComponent(asn1Spec, tagSet)</font>
<font color="red"> 405.         if substrateFun:</font>
<font color="red"> 406.             return substrateFun(r, substrate, length)</font>
<font color="red"> 407.         asn1Spec = r.getComponentType()</font>
<font color="red"> 408.         idx = 0</font>
<font color="red"> 409.         while head:</font>
<font color="red"> 410.             component, head = decodeFun(head, asn1Spec)</font>
<font color="red"> 411.             r.setComponentByPosition(idx, component,</font>
<font color="red"> 412.                                      verifyConstraints=False,</font>
<font color="red"> 413.                                      matchTags=False, matchConstraints=False)</font>
<font color="red"> 414.             idx += 1</font>
<font color="red"> 415.         r.verifySizeSpec()</font>
<font color="red"> 416.         return r, tail</font>
<font color="black"> 417. </font>
<font color="green"> 418.     def indefLenValueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black"> 419.                              length, state, decodeFun, substrateFun):</font>
<font color="red"> 420.         r = self._createComponent(asn1Spec, tagSet)</font>
<font color="red"> 421.         if substrateFun:</font>
<font color="red"> 422.             return substrateFun(r, substrate, length)</font>
<font color="red"> 423.         asn1Spec = r.getComponentType()</font>
<font color="red"> 424.         idx = 0</font>
<font color="red"> 425.         while substrate:</font>
<font color="red"> 426.             component, substrate = decodeFun(substrate, asn1Spec, allowEoo=True)</font>
<font color="red"> 427.             if eoo.endOfOctets.isSameTypeWith(component) and \</font>
<font color="red"> 428.                     component == eoo.endOfOctets:</font>
<font color="red"> 429.                 break</font>
<font color="red"> 430.             r.setComponentByPosition(idx, component,</font>
<font color="red"> 431.                                      verifyConstraints=False,</font>
<font color="red"> 432.                                      matchTags=False, matchConstraints=False)</font>
<font color="red"> 433.             idx += 1</font>
<font color="black"> 434.         else:</font>
<font color="red"> 435.             raise error.SubstrateUnderrunError(</font>
<font color="red"> 436.                 'No EOO seen before substrate ends'</font>
<font color="black"> 437.             )</font>
<font color="red"> 438.         r.verifySizeSpec()</font>
<font color="red"> 439.         return r, substrate</font>
<font color="black"> 440. </font>
<font color="black"> 441. </font>
<font color="green"> 442. class SetDecoder(SequenceDecoder):</font>
<font color="green"> 443.     protoComponent = univ.Set()</font>
<font color="black"> 444. </font>
<font color="green"> 445.     def _getComponentTagMap(self, r, idx):</font>
<font color="red"> 446.         return r.getComponentTagMap()</font>
<font color="black"> 447. </font>
<font color="green"> 448.     def _getComponentPositionByType(self, r, t, idx):</font>
<font color="red"> 449.         nextIdx = r.getComponentPositionByType(t)</font>
<font color="red"> 450.         if nextIdx is None:</font>
<font color="red"> 451.             return idx</font>
<font color="black"> 452.         else:</font>
<font color="red"> 453.             return nextIdx</font>
<font color="black"> 454. </font>
<font color="black"> 455. </font>
<font color="green"> 456. class SetOfDecoder(SequenceOfDecoder):</font>
<font color="green"> 457.     protoComponent = univ.SetOf()</font>
<font color="black"> 458. </font>
<font color="black"> 459. </font>
<font color="green"> 460. class ChoiceDecoder(AbstractConstructedDecoder):</font>
<font color="green"> 461.     protoComponent = univ.Choice()</font>
<font color="green"> 462.     tagFormats = (tag.tagFormatSimple, tag.tagFormatConstructed)</font>
<font color="black"> 463. </font>
<font color="green"> 464.     def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black"> 465.                      length, state, decodeFun, substrateFun):</font>
<font color="red"> 466.         head, tail = substrate[:length], substrate[length:]</font>
<font color="red"> 467.         r = self._createComponent(asn1Spec, tagSet)</font>
<font color="red"> 468.         if substrateFun:</font>
<font color="red"> 469.             return substrateFun(r, substrate, length)</font>
<font color="red"> 470.         if r.getTagSet() == tagSet:  # explicitly tagged Choice</font>
<font color="red"> 471.             component, head = decodeFun(</font>
<font color="red"> 472.                 head, r.getComponentTagMap()</font>
<font color="black"> 473.             )</font>
<font color="black"> 474.         else:</font>
<font color="red"> 475.             component, head = decodeFun(</font>
<font color="red"> 476.                 head, r.getComponentTagMap(), tagSet, length, state</font>
<font color="black"> 477.             )</font>
<font color="red"> 478.         if isinstance(component, univ.Choice):</font>
<font color="red"> 479.             effectiveTagSet = component.getEffectiveTagSet()</font>
<font color="black"> 480.         else:</font>
<font color="red"> 481.             effectiveTagSet = component.getTagSet()</font>
<font color="red"> 482.         r.setComponentByType(effectiveTagSet, component,</font>
<font color="red"> 483.                              verifyConstraints=False,</font>
<font color="red"> 484.                              matchTags=False, matchConstraints=False,</font>
<font color="red"> 485.                              innerFlag=False)</font>
<font color="red"> 486.         return r, tail</font>
<font color="black"> 487. </font>
<font color="green"> 488.     def indefLenValueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black"> 489.                              length, state, decodeFun, substrateFun):</font>
<font color="red"> 490.         r = self._createComponent(asn1Spec, tagSet)</font>
<font color="red"> 491.         if substrateFun:</font>
<font color="red"> 492.             return substrateFun(r, substrate, length)</font>
<font color="red"> 493.         if r.getTagSet() == tagSet:  # explicitly tagged Choice</font>
<font color="red"> 494.             component, substrate = decodeFun(substrate, r.getComponentTagMap())</font>
<font color="black"> 495.             # eat up EOO marker</font>
<font color="red"> 496.             eooMarker, substrate = decodeFun(substrate, allowEoo=True)</font>
<font color="red"> 497.             if not eoo.endOfOctets.isSameTypeWith(eooMarker) or \</font>
<font color="red"> 498.                     eooMarker != eoo.endOfOctets:</font>
<font color="red"> 499.                 raise error.PyAsn1Error('No EOO seen before substrate ends')</font>
<font color="black"> 500.         else:</font>
<font color="red"> 501.             component, substrate = decodeFun(</font>
<font color="red"> 502.                 substrate, r.getComponentTagMap(), tagSet, length, state</font>
<font color="black"> 503.             )</font>
<font color="red"> 504.         if isinstance(component, univ.Choice):</font>
<font color="red"> 505.             effectiveTagSet = component.getEffectiveTagSet()</font>
<font color="black"> 506.         else:</font>
<font color="red"> 507.             effectiveTagSet = component.getTagSet()</font>
<font color="red"> 508.         r.setComponentByType(effectiveTagSet, component,</font>
<font color="red"> 509.                              verifyConstraints=False,</font>
<font color="red"> 510.                              matchTags=False, matchConstraints=False,</font>
<font color="red"> 511.                              innerFlag=False)</font>
<font color="red"> 512.         return r, substrate</font>
<font color="black"> 513. </font>
<font color="black"> 514. </font>
<font color="green"> 515. class AnyDecoder(AbstractSimpleDecoder):</font>
<font color="green"> 516.     protoComponent = univ.Any()</font>
<font color="green"> 517.     tagFormats = (tag.tagFormatSimple, tag.tagFormatConstructed)</font>
<font color="black"> 518. </font>
<font color="green"> 519.     def valueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black"> 520.                      length, state, decodeFun, substrateFun):</font>
<font color="red"> 521.         if asn1Spec is None or asn1Spec is not None and tagSet != asn1Spec.getTagSet():</font>
<font color="black"> 522.             # untagged Any container, recover inner header substrate</font>
<font color="red"> 523.             length = length + len(fullSubstrate) - len(substrate)</font>
<font color="red"> 524.             substrate = fullSubstrate</font>
<font color="red"> 525.         if substrateFun:</font>
<font color="red"> 526.             return substrateFun(self._createComponent(asn1Spec, tagSet),</font>
<font color="red"> 527.                                 substrate, length)</font>
<font color="red"> 528.         head, tail = substrate[:length], substrate[length:]</font>
<font color="red"> 529.         return self._createComponent(asn1Spec, tagSet, value=head), tail</font>
<font color="black"> 530. </font>
<font color="green"> 531.     def indefLenValueDecoder(self, fullSubstrate, substrate, asn1Spec, tagSet,</font>
<font color="black"> 532.                              length, state, decodeFun, substrateFun):</font>
<font color="red"> 533.         if asn1Spec is not None and tagSet == asn1Spec.getTagSet():</font>
<font color="black"> 534.             # tagged Any type -- consume header substrate</font>
<font color="red"> 535.             header = ''</font>
<font color="black"> 536.         else:</font>
<font color="black"> 537.             # untagged Any, recover header substrate</font>
<font color="red"> 538.             header = fullSubstrate[:-len(substrate)]</font>
<font color="black"> 539. </font>
<font color="red"> 540.         r = self._createComponent(asn1Spec, tagSet, header)</font>
<font color="black"> 541. </font>
<font color="black"> 542.         # Any components do not inherit initial tag</font>
<font color="red"> 543.         asn1Spec = self.protoComponent</font>
<font color="black"> 544. </font>
<font color="red"> 545.         if substrateFun:</font>
<font color="red"> 546.             return substrateFun(r, substrate, length)</font>
<font color="red"> 547.         while substrate:</font>
<font color="red"> 548.             component, substrate = decodeFun(substrate, asn1Spec, allowEoo=True)</font>
<font color="red"> 549.             if eoo.endOfOctets.isSameTypeWith(component) and \</font>
<font color="red"> 550.                     component == eoo.endOfOctets:</font>
<font color="red"> 551.                 break</font>
<font color="red"> 552.             r = r + component</font>
<font color="black"> 553.         else:</font>
<font color="red"> 554.             raise error.SubstrateUnderrunError(</font>
<font color="red"> 555.                 'No EOO seen before substrate ends'</font>
<font color="black"> 556.             )</font>
<font color="red"> 557.         return r, substrate</font>
<font color="black"> 558. </font>
<font color="black"> 559. </font>
<font color="black"> 560. # character string types</font>
<font color="green"> 561. class UTF8StringDecoder(OctetStringDecoder):</font>
<font color="green"> 562.     protoComponent = char.UTF8String()</font>
<font color="black"> 563. </font>
<font color="black"> 564. </font>
<font color="green"> 565. class NumericStringDecoder(OctetStringDecoder):</font>
<font color="green"> 566.     protoComponent = char.NumericString()</font>
<font color="black"> 567. </font>
<font color="black"> 568. </font>
<font color="green"> 569. class PrintableStringDecoder(OctetStringDecoder):</font>
<font color="green"> 570.     protoComponent = char.PrintableString()</font>
<font color="black"> 571. </font>
<font color="black"> 572. </font>
<font color="green"> 573. class TeletexStringDecoder(OctetStringDecoder):</font>
<font color="green"> 574.     protoComponent = char.TeletexString()</font>
<font color="black"> 575. </font>
<font color="black"> 576. </font>
<font color="green"> 577. class VideotexStringDecoder(OctetStringDecoder):</font>
<font color="green"> 578.     protoComponent = char.VideotexString()</font>
<font color="black"> 579. </font>
<font color="black"> 580. </font>
<font color="green"> 581. class IA5StringDecoder(OctetStringDecoder):</font>
<font color="green"> 582.     protoComponent = char.IA5String()</font>
<font color="black"> 583. </font>
<font color="black"> 584. </font>
<font color="green"> 585. class GraphicStringDecoder(OctetStringDecoder):</font>
<font color="green"> 586.     protoComponent = char.GraphicString()</font>
<font color="black"> 587. </font>
<font color="black"> 588. </font>
<font color="green"> 589. class VisibleStringDecoder(OctetStringDecoder):</font>
<font color="green"> 590.     protoComponent = char.VisibleString()</font>
<font color="black"> 591. </font>
<font color="black"> 592. </font>
<font color="green"> 593. class GeneralStringDecoder(OctetStringDecoder):</font>
<font color="green"> 594.     protoComponent = char.GeneralString()</font>
<font color="black"> 595. </font>
<font color="black"> 596. </font>
<font color="green"> 597. class UniversalStringDecoder(OctetStringDecoder):</font>
<font color="green"> 598.     protoComponent = char.UniversalString()</font>
<font color="black"> 599. </font>
<font color="black"> 600. </font>
<font color="green"> 601. class BMPStringDecoder(OctetStringDecoder):</font>
<font color="green"> 602.     protoComponent = char.BMPString()</font>
<font color="black"> 603. </font>
<font color="black"> 604. </font>
<font color="black"> 605. # &quot;useful&quot; types</font>
<font color="green"> 606. class ObjectDescriptorDecoder(OctetStringDecoder):</font>
<font color="green"> 607.     protoComponent = useful.ObjectDescriptor()</font>
<font color="black"> 608. </font>
<font color="black"> 609. </font>
<font color="green"> 610. class GeneralizedTimeDecoder(OctetStringDecoder):</font>
<font color="green"> 611.     protoComponent = useful.GeneralizedTime()</font>
<font color="black"> 612. </font>
<font color="black"> 613. </font>
<font color="green"> 614. class UTCTimeDecoder(OctetStringDecoder):</font>
<font color="green"> 615.     protoComponent = useful.UTCTime()</font>
<font color="black"> 616. </font>
<font color="black"> 617. </font>
<font color="green"> 618. tagMap = {</font>
<font color="green"> 619.     univ.Integer.tagSet: IntegerDecoder(),</font>
<font color="green"> 620.     univ.Boolean.tagSet: BooleanDecoder(),</font>
<font color="green"> 621.     univ.BitString.tagSet: BitStringDecoder(),</font>
<font color="green"> 622.     univ.OctetString.tagSet: OctetStringDecoder(),</font>
<font color="green"> 623.     univ.Null.tagSet: NullDecoder(),</font>
<font color="green"> 624.     univ.ObjectIdentifier.tagSet: ObjectIdentifierDecoder(),</font>
<font color="green"> 625.     univ.Enumerated.tagSet: IntegerDecoder(),</font>
<font color="green"> 626.     univ.Real.tagSet: RealDecoder(),</font>
<font color="green"> 627.     univ.Sequence.tagSet: SequenceDecoder(),  # conflicts with SequenceOf</font>
<font color="green"> 628.     univ.Set.tagSet: SetDecoder(),  # conflicts with SetOf</font>
<font color="green"> 629.     univ.Choice.tagSet: ChoiceDecoder(),  # conflicts with Any</font>
<font color="black"> 630.     # character string types</font>
<font color="green"> 631.     char.UTF8String.tagSet: UTF8StringDecoder(),</font>
<font color="green"> 632.     char.NumericString.tagSet: NumericStringDecoder(),</font>
<font color="green"> 633.     char.PrintableString.tagSet: PrintableStringDecoder(),</font>
<font color="green"> 634.     char.TeletexString.tagSet: TeletexStringDecoder(),</font>
<font color="green"> 635.     char.VideotexString.tagSet: VideotexStringDecoder(),</font>
<font color="green"> 636.     char.IA5String.tagSet: IA5StringDecoder(),</font>
<font color="green"> 637.     char.GraphicString.tagSet: GraphicStringDecoder(),</font>
<font color="green"> 638.     char.VisibleString.tagSet: VisibleStringDecoder(),</font>
<font color="green"> 639.     char.GeneralString.tagSet: GeneralStringDecoder(),</font>
<font color="green"> 640.     char.UniversalString.tagSet: UniversalStringDecoder(),</font>
<font color="green"> 641.     char.BMPString.tagSet: BMPStringDecoder(),</font>
<font color="black"> 642.     # useful types</font>
<font color="green"> 643.     useful.ObjectDescriptor.tagSet: ObjectDescriptorDecoder(),</font>
<font color="green"> 644.     useful.GeneralizedTime.tagSet: GeneralizedTimeDecoder(),</font>
<font color="green"> 645.     useful.UTCTime.tagSet: UTCTimeDecoder()</font>
<font color="black"> 646. }</font>
<font color="black"> 647. </font>
<font color="black"> 648. # Type-to-codec map for ambiguous ASN.1 types</font>
<font color="green"> 649. typeMap = {</font>
<font color="green"> 650.     univ.Set.typeId: SetDecoder(),</font>
<font color="green"> 651.     univ.SetOf.typeId: SetOfDecoder(),</font>
<font color="green"> 652.     univ.Sequence.typeId: SequenceDecoder(),</font>
<font color="green"> 653.     univ.SequenceOf.typeId: SequenceOfDecoder(),</font>
<font color="green"> 654.     univ.Choice.typeId: ChoiceDecoder(),</font>
<font color="green"> 655.     univ.Any.typeId: AnyDecoder()</font>
<font color="black"> 656. }</font>
<font color="black"> 657. </font>
<font color="black"> 658. (stDecodeTag, stDecodeLength, stGetValueDecoder, stGetValueDecoderByAsn1Spec,</font>
<font color="black"> 659.  stGetValueDecoderByTag, stTryAsExplicitTag, stDecodeValue,</font>
<font color="green"> 660.  stDumpRawValue, stErrorCondition, stStop) = [x for x in range(10)]</font>
<font color="black"> 661. </font>
<font color="black"> 662. </font>
<font color="green"> 663. class Decoder(object):</font>
<font color="green"> 664.     defaultErrorState = stErrorCondition</font>
<font color="black"> 665.     #    defaultErrorState = stDumpRawValue</font>
<font color="green"> 666.     defaultRawDecoder = AnyDecoder()</font>
<font color="green"> 667.     supportIndefLength = True</font>
<font color="black"> 668. </font>
<font color="black"> 669.     # noinspection PyDefaultArgument</font>
<font color="green"> 670.     def __init__(self, tagMap, typeMap={}):</font>
<font color="green"> 671.         self.__tagMap = tagMap</font>
<font color="green"> 672.         self.__typeMap = typeMap</font>
<font color="black"> 673.         # Tag &amp; TagSet objects caches</font>
<font color="green"> 674.         self.__tagCache = {}</font>
<font color="green"> 675.         self.__tagSetCache = {}</font>
<font color="black"> 676. </font>
<font color="green"> 677.     def __call__(self, substrate, asn1Spec=None, tagSet=None,</font>
<font color="green"> 678.                  length=None, state=stDecodeTag, recursiveFlag=1,</font>
<font color="green"> 679.                  substrateFun=None, allowEoo=False):</font>
<font color="red"> 680.         if debug.logger &amp; debug.flagDecoder:</font>
<font color="red"> 681.             debug.logger('decoder called at scope %s with state %d, working with up to %d octets of substrate: %s' % (debug.scope, state, len(substrate), debug.hexdump(substrate)))</font>
<font color="red"> 682.         if asn1Spec is not None and not isinstance(asn1Spec, (base.Asn1Item, tagmap.TagMap)):</font>
<font color="red"> 683.             raise error.PyAsn1Error(</font>
<font color="red"> 684.                 'asn1Spec is not valid (should be an instance of an ASN.1 Item, not %s)' % asn1Spec.__class__.__name__)</font>
<font color="black"> 685. </font>
<font color="red"> 686.         value = base.noValue</font>
<font color="black"> 687. </font>
<font color="red"> 688.         fullSubstrate = substrate</font>
<font color="red"> 689.         while state != stStop:</font>
<font color="red"> 690.             if state == stDecodeTag:</font>
<font color="red"> 691.                 if not substrate:</font>
<font color="red"> 692.                     raise error.SubstrateUnderrunError(</font>
<font color="red"> 693.                         'Short octet stream on tag decoding'</font>
<font color="black"> 694.                     )</font>
<font color="red"> 695.                 if not isOctetsType(substrate) and \</font>
<font color="red"> 696.                         not isinstance(substrate, univ.OctetString):</font>
<font color="red"> 697.                     raise error.PyAsn1Error('Bad octet stream type')</font>
<font color="black"> 698.                 # Decode tag</font>
<font color="red"> 699.                 firstOctet = substrate[0]</font>
<font color="red"> 700.                 substrate = substrate[1:]</font>
<font color="red"> 701.                 if firstOctet in self.__tagCache:</font>
<font color="red"> 702.                     lastTag = self.__tagCache[firstOctet]</font>
<font color="black"> 703.                 else:</font>
<font color="red"> 704.                     t = oct2int(firstOctet)</font>
<font color="black"> 705.                     # Look for end-of-octets sentinel</font>
<font color="red"> 706.                     if t == 0:</font>
<font color="red"> 707.                         if substrate and oct2int(substrate[0]) == 0:</font>
<font color="red"> 708.                             if allowEoo and self.supportIndefLength:</font>
<font color="red"> 709.                                 debug.logger and debug.logger &amp; debug.flagDecoder and debug.logger(</font>
<font color="red"> 710.                                     'end-of-octets sentinel found')</font>
<font color="red"> 711.                                 value, substrate = eoo.endOfOctets, substrate[1:]</font>
<font color="red"> 712.                                 state = stStop</font>
<font color="red"> 713.                                 continue</font>
<font color="black"> 714.                             else:</font>
<font color="red"> 715.                                 raise error.PyAsn1Error('Unexpected end-of-contents sentinel')</font>
<font color="black"> 716.                         else:</font>
<font color="red"> 717.                             raise error.PyAsn1Error('Zero tag encountered')</font>
<font color="red"> 718.                     tagClass = t &amp; 0xC0</font>
<font color="red"> 719.                     tagFormat = t &amp; 0x20</font>
<font color="red"> 720.                     tagId = t &amp; 0x1F</font>
<font color="red"> 721.                     short = True</font>
<font color="red"> 722.                     if tagId == 0x1F:</font>
<font color="red"> 723.                         short = False</font>
<font color="red"> 724.                         tagId = 0</font>
<font color="red"> 725.                         while True:</font>
<font color="red"> 726.                             if not substrate:</font>
<font color="red"> 727.                                 raise error.SubstrateUnderrunError(</font>
<font color="red"> 728.                                     'Short octet stream on long tag decoding'</font>
<font color="black"> 729.                                 )</font>
<font color="red"> 730.                             t = oct2int(substrate[0])</font>
<font color="red"> 731.                             tagId = tagId &lt;&lt; 7 | (t &amp; 0x7F)</font>
<font color="red"> 732.                             substrate = substrate[1:]</font>
<font color="red"> 733.                             if not t &amp; 0x80:</font>
<font color="red"> 734.                                 break</font>
<font color="red"> 735.                     lastTag = tag.Tag(</font>
<font color="red"> 736.                         tagClass=tagClass, tagFormat=tagFormat, tagId=tagId</font>
<font color="black"> 737.                     )</font>
<font color="red"> 738.                     if short:</font>
<font color="black"> 739.                         # cache short tags</font>
<font color="red"> 740.                         self.__tagCache[firstOctet] = lastTag</font>
<font color="red"> 741.                 if tagSet is None:</font>
<font color="red"> 742.                     if firstOctet in self.__tagSetCache:</font>
<font color="red"> 743.                         tagSet = self.__tagSetCache[firstOctet]</font>
<font color="black"> 744.                     else:</font>
<font color="black"> 745.                         # base tag not recovered</font>
<font color="red"> 746.                         tagSet = tag.TagSet((), lastTag)</font>
<font color="red"> 747.                         if firstOctet in self.__tagCache:</font>
<font color="red"> 748.                             self.__tagSetCache[firstOctet] = tagSet</font>
<font color="black"> 749.                 else:</font>
<font color="red"> 750.                     tagSet = lastTag + tagSet</font>
<font color="red"> 751.                 state = stDecodeLength</font>
<font color="red"> 752.                 debug.logger and debug.logger &amp; debug.flagDecoder and debug.logger(</font>
<font color="red"> 753.                     'tag decoded into %s, decoding length' % tagSet)</font>
<font color="red"> 754.             if state == stDecodeLength:</font>
<font color="black"> 755.                 # Decode length</font>
<font color="red"> 756.                 if not substrate:</font>
<font color="red"> 757.                     raise error.SubstrateUnderrunError(</font>
<font color="red"> 758.                         'Short octet stream on length decoding'</font>
<font color="black"> 759.                     )</font>
<font color="red"> 760.                 firstOctet = oct2int(substrate[0])</font>
<font color="red"> 761.                 if firstOctet == 128:</font>
<font color="red"> 762.                     size = 1</font>
<font color="red"> 763.                     length = -1</font>
<font color="red"> 764.                 elif firstOctet &lt; 128:</font>
<font color="red"> 765.                     length, size = firstOctet, 1</font>
<font color="black"> 766.                 else:</font>
<font color="red"> 767.                     size = firstOctet &amp; 0x7F</font>
<font color="black"> 768.                     # encoded in size bytes</font>
<font color="red"> 769.                     length = 0</font>
<font color="red"> 770.                     lengthString = substrate[1:size + 1]</font>
<font color="black"> 771.                     # missing check on maximum size, which shouldn't be a</font>
<font color="black"> 772.                     # problem, we can handle more than is possible</font>
<font color="red"> 773.                     if len(lengthString) != size:</font>
<font color="red"> 774.                         raise error.SubstrateUnderrunError(</font>
<font color="red"> 775.                             '%s&lt;%s at %s' %</font>
<font color="red"> 776.                             (size, len(lengthString), tagSet)</font>
<font color="black"> 777.                         )</font>
<font color="red"> 778.                     for char in lengthString:</font>
<font color="red"> 779.                         length = (length &lt;&lt; 8) | oct2int(char)</font>
<font color="red"> 780.                     size += 1</font>
<font color="red"> 781.                 substrate = substrate[size:]</font>
<font color="red"> 782.                 if length != -1 and len(substrate) &lt; length:</font>
<font color="red"> 783.                     raise error.SubstrateUnderrunError(</font>
<font color="red"> 784.                         '%d-octet short' % (length - len(substrate))</font>
<font color="black"> 785.                     )</font>
<font color="red"> 786.                 if length == -1 and not self.supportIndefLength:</font>
<font color="red"> 787.                     raise error.PyAsn1Error('Indefinite length encoding not supported by this codec')</font>
<font color="red"> 788.                 state = stGetValueDecoder</font>
<font color="red"> 789.                 debug.logger and debug.logger &amp; debug.flagDecoder and debug.logger(</font>
<font color="red"> 790.                     'value length decoded into %d, payload substrate is: %s' % (length, debug.hexdump(length == -1 and substrate or substrate[:length]))</font>
<font color="black"> 791.                 )</font>
<font color="red"> 792.             if state == stGetValueDecoder:</font>
<font color="red"> 793.                 if asn1Spec is None:</font>
<font color="red"> 794.                     state = stGetValueDecoderByTag</font>
<font color="black"> 795.                 else:</font>
<font color="red"> 796.                     state = stGetValueDecoderByAsn1Spec</font>
<font color="black"> 797.             #</font>
<font color="black"> 798.             # There're two ways of creating subtypes in ASN.1 what influences</font>
<font color="black"> 799.             # decoder operation. These methods are:</font>
<font color="black"> 800.             # 1) Either base types used in or no IMPLICIT tagging has been</font>
<font color="black"> 801.             #    applied on subtyping.</font>
<font color="black"> 802.             # 2) Subtype syntax drops base type information (by means of</font>
<font color="black"> 803.             #    IMPLICIT tagging.</font>
<font color="black"> 804.             # The first case allows for complete tag recovery from substrate</font>
<font color="black"> 805.             # while the second one requires original ASN.1 type spec for</font>
<font color="black"> 806.             # decoding.</font>
<font color="black"> 807.             #</font>
<font color="black"> 808.             # In either case a set of tags (tagSet) is coming from substrate</font>
<font color="black"> 809.             # in an incremental, tag-by-tag fashion (this is the case of</font>
<font color="black"> 810.             # EXPLICIT tag which is most basic). Outermost tag comes first</font>
<font color="black"> 811.             # from the wire.</font>
<font color="black"> 812.             #</font>
<font color="red"> 813.             if state == stGetValueDecoderByTag:</font>
<font color="red"> 814.                 if tagSet in self.__tagMap:</font>
<font color="red"> 815.                     concreteDecoder = self.__tagMap[tagSet]</font>
<font color="black"> 816.                 else:</font>
<font color="red"> 817.                     concreteDecoder = None</font>
<font color="red"> 818.                 if concreteDecoder:</font>
<font color="red"> 819.                     state = stDecodeValue</font>
<font color="black"> 820.                 else:</font>
<font color="red"> 821.                     _k = tagSet[:1]</font>
<font color="red"> 822.                     if _k in self.__tagMap:</font>
<font color="red"> 823.                         concreteDecoder = self.__tagMap[_k]</font>
<font color="black"> 824.                     else:</font>
<font color="red"> 825.                         concreteDecoder = None</font>
<font color="red"> 826.                     if concreteDecoder:</font>
<font color="red"> 827.                         state = stDecodeValue</font>
<font color="black"> 828.                     else:</font>
<font color="red"> 829.                         state = stTryAsExplicitTag</font>
<font color="red"> 830.                 if debug.logger and debug.logger &amp; debug.flagDecoder:</font>
<font color="red"> 831.                     debug.logger('codec %s chosen by a built-in type, decoding %s' % (concreteDecoder and concreteDecoder.__class__.__name__ or &quot;&lt;none&gt;&quot;, state == stDecodeValue and 'value' or 'as explicit tag'))</font>
<font color="red"> 832.                     debug.scope.push(</font>
<font color="red"> 833.                         concreteDecoder is None and '?' or concreteDecoder.protoComponent.__class__.__name__)</font>
<font color="red"> 834.             if state == stGetValueDecoderByAsn1Spec:</font>
<font color="red"> 835.                 if isinstance(asn1Spec, (dict, tagmap.TagMap)):</font>
<font color="red"> 836.                     if tagSet in asn1Spec:</font>
<font color="red"> 837.                         __chosenSpec = asn1Spec[tagSet]</font>
<font color="black"> 838.                     else:</font>
<font color="red"> 839.                         __chosenSpec = None</font>
<font color="red"> 840.                     if debug.logger and debug.logger &amp; debug.flagDecoder:</font>
<font color="red"> 841.                         debug.logger('candidate ASN.1 spec is a map of:')</font>
<font color="red"> 842.                         for t, v in asn1Spec.getPosMap().items():</font>
<font color="red"> 843.                             debug.logger('  %s -&gt; %s' % (t, v.__class__.__name__))</font>
<font color="red"> 844.                         if asn1Spec.getNegMap():</font>
<font color="red"> 845.                             debug.logger('but neither of: ')</font>
<font color="red"> 846.                             for t, v in asn1Spec.getNegMap().items():</font>
<font color="red"> 847.                                 debug.logger('  %s -&gt; %s' % (t, v.__class__.__name__))</font>
<font color="red"> 848.                         debug.logger('new candidate ASN.1 spec is %s, chosen by %s' % (__chosenSpec is None and '&lt;none&gt;' or __chosenSpec.prettyPrintType(), tagSet))</font>
<font color="black"> 849.                 else:</font>
<font color="red"> 850.                     __chosenSpec = asn1Spec</font>
<font color="red"> 851.                     debug.logger and debug.logger &amp; debug.flagDecoder and debug.logger(</font>
<font color="red"> 852.                         'candidate ASN.1 spec is %s' % asn1Spec.__class__.__name__)</font>
<font color="red"> 853.                 if __chosenSpec is not None and (tagSet == __chosenSpec.getTagSet() or</font>
<font color="red"> 854.                                                  tagSet in __chosenSpec.getTagMap()):</font>
<font color="black"> 855.                     # use base type for codec lookup to recover untagged types</font>
<font color="red"> 856.                     baseTagSet = __chosenSpec.baseTagSet</font>
<font color="red"> 857.                     if __chosenSpec.typeId is not None and \</font>
<font color="red"> 858.                             __chosenSpec.typeId in self.__typeMap:</font>
<font color="black"> 859.                         # ambiguous type</font>
<font color="red"> 860.                         concreteDecoder = self.__typeMap[__chosenSpec.typeId]</font>
<font color="red"> 861.                         debug.logger and debug.logger &amp; debug.flagDecoder and debug.logger(</font>
<font color="red"> 862.                             'value decoder chosen for an ambiguous type by type ID %s' % (__chosenSpec.typeId,))</font>
<font color="red"> 863.                     elif baseTagSet in self.__tagMap:</font>
<font color="black"> 864.                         # base type or tagged subtype</font>
<font color="red"> 865.                         concreteDecoder = self.__tagMap[baseTagSet]</font>
<font color="red"> 866.                         debug.logger and debug.logger &amp; debug.flagDecoder and debug.logger(</font>
<font color="red"> 867.                             'value decoder chosen by base %s' % (baseTagSet,))</font>
<font color="black"> 868.                     else:</font>
<font color="red"> 869.                         concreteDecoder = None</font>
<font color="red"> 870.                     if concreteDecoder:</font>
<font color="red"> 871.                         asn1Spec = __chosenSpec</font>
<font color="red"> 872.                         state = stDecodeValue</font>
<font color="black"> 873.                     else:</font>
<font color="red"> 874.                         state = stTryAsExplicitTag</font>
<font color="black"> 875.                 else:</font>
<font color="red"> 876.                     concreteDecoder = None</font>
<font color="red"> 877.                     state = stTryAsExplicitTag</font>
<font color="red"> 878.                 if debug.logger and debug.logger &amp; debug.flagDecoder:</font>
<font color="red"> 879.                     debug.logger('codec %s chosen by ASN.1 spec, decoding %s' % (state == stDecodeValue and concreteDecoder.__class__.__name__ or &quot;&lt;none&gt;&quot;, state == stDecodeValue and 'value' or 'as explicit tag'))</font>
<font color="red"> 880.                     debug.scope.push(__chosenSpec is None and '?' or __chosenSpec.__class__.__name__)</font>
<font color="red"> 881.             if state == stTryAsExplicitTag:</font>
<font color="red"> 882.                 if tagSet and tagSet[0][1] == tag.tagFormatConstructed and \</font>
<font color="red"> 883.                         tagSet[0][0] != tag.tagClassUniversal:</font>
<font color="black"> 884.                     # Assume explicit tagging</font>
<font color="red"> 885.                     concreteDecoder = explicitTagDecoder</font>
<font color="red"> 886.                     state = stDecodeValue</font>
<font color="black"> 887.                 else:</font>
<font color="red"> 888.                     concreteDecoder = None</font>
<font color="red"> 889.                     state = self.defaultErrorState</font>
<font color="red"> 890.                 debug.logger and debug.logger &amp; debug.flagDecoder and debug.logger('codec %s chosen, decoding %s' % (concreteDecoder and concreteDecoder.__class__.__name__ or &quot;&lt;none&gt;&quot;, state == stDecodeValue and 'value' or 'as failure'))</font>
<font color="red"> 891.             if state == stDumpRawValue:</font>
<font color="red"> 892.                 concreteDecoder = self.defaultRawDecoder</font>
<font color="red"> 893.                 debug.logger and debug.logger &amp; debug.flagDecoder and debug.logger(</font>
<font color="red"> 894.                     'codec %s chosen, decoding value' % concreteDecoder.__class__.__name__)</font>
<font color="red"> 895.                 state = stDecodeValue</font>
<font color="red"> 896.             if state == stDecodeValue:</font>
<font color="red"> 897.                 if recursiveFlag == 0 and not substrateFun:  # legacy</font>
<font color="red"> 898.                     def substrateFun(a, b, c):</font>
<font color="red"> 899.                         return a, b[:c]</font>
<font color="red"> 900.                 if length == -1:  # indef length</font>
<font color="red"> 901.                     value, substrate = concreteDecoder.indefLenValueDecoder(</font>
<font color="red"> 902.                         fullSubstrate, substrate, asn1Spec, tagSet, length,</font>
<font color="red"> 903.                         stGetValueDecoder, self, substrateFun</font>
<font color="black"> 904.                     )</font>
<font color="black"> 905.                 else:</font>
<font color="red"> 906.                     value, substrate = concreteDecoder.valueDecoder(</font>
<font color="red"> 907.                         fullSubstrate, substrate, asn1Spec, tagSet, length,</font>
<font color="red"> 908.                         stGetValueDecoder, self, substrateFun</font>
<font color="black"> 909.                     )</font>
<font color="red"> 910.                 state = stStop</font>
<font color="red"> 911.                 debug.logger and debug.logger &amp; debug.flagDecoder and debug.logger(</font>
<font color="red"> 912.                     'codec %s yields type %s, value:\n%s\n...remaining substrate is: %s' % (concreteDecoder.__class__.__name__, value.__class__.__name__, value.prettyPrint(), substrate and debug.hexdump(substrate) or '&lt;none&gt;'))</font>
<font color="red"> 913.             if state == stErrorCondition:</font>
<font color="red"> 914.                 raise error.PyAsn1Error(</font>
<font color="red"> 915.                     '%s not in asn1Spec: %s' % (tagSet, asn1Spec)</font>
<font color="black"> 916.                 )</font>
<font color="red"> 917.         if debug.logger and debug.logger &amp; debug.flagDecoder:</font>
<font color="red"> 918.             debug.scope.pop()</font>
<font color="red"> 919.             debug.logger('decoder left scope %s, call completed' % debug.scope)</font>
<font color="red"> 920.         return value, substrate</font>
<font color="black"> 921. </font>
<font color="black"> 922. </font>
<font color="black"> 923. #: Turns BER octet stream into an ASN.1 object.</font>
<font color="black"> 924. #:</font>
<font color="black"> 925. #: Takes BER octetstream and decode it into an ASN.1 object</font>
<font color="black"> 926. #: (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which</font>
<font color="black"> 927. #: may be a scalar or an arbitrary nested structure.</font>
<font color="black"> 928. #:</font>
<font color="black"> 929. #: Parameters</font>
<font color="black"> 930. #: ----------</font>
<font color="black"> 931. #: substrate: :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)</font>
<font color="black"> 932. #:     BER octetstream</font>
<font color="black"> 933. #:</font>
<font color="black"> 934. #: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative</font>
<font color="black"> 935. #:     A pyasn1 type object to act as a template guiding the decoder. Depending on the ASN.1 structure</font>
<font color="black"> 936. #:     being decoded, *asn1Spec* may or may not be required. Most common reason for</font>
<font color="black"> 937. #:     it to require is that ASN.1 structure is encoded in *IMPLICIT* tagging mode.</font>
<font color="black"> 938. #:</font>
<font color="black"> 939. #: Returns</font>
<font color="black"> 940. #: -------</font>
<font color="black"> 941. #: : :py:class:`tuple`</font>
<font color="black"> 942. #:     A tuple of pyasn1 object recovered from BER substrate (:py:class:`~pyasn1.type.base.PyAsn1Item` derivative)</font>
<font color="black"> 943. #:     and the unprocessed trailing portion of the *substrate* (may be empty)</font>
<font color="black"> 944. #:</font>
<font color="black"> 945. #: Raises</font>
<font color="black"> 946. #: ------</font>
<font color="black"> 947. #: : :py:class:`pyasn1.error.PyAsn1Error`</font>
<font color="black"> 948. #:     On decoding errors</font>
<font color="green"> 949. decode = Decoder(tagMap, typeMap)</font>
<font color="black"> 950. </font>
<font color="black"> 951. # XXX</font>
<font color="black"> 952. # non-recursive decoding; return position rather than substrate</font>
</pre>

