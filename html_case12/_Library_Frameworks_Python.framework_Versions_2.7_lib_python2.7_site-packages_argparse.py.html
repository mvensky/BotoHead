source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/argparse.py</b><br>


file stats: <b>1398 lines, 547 executed: 39.1% covered</b>
<pre>
<font color="black">   1. # Author: Steven J. Bethard &lt;steven.bethard@gmail.com&gt;.</font>
<font color="black">   2. </font>
<font color="black">   3. &quot;&quot;&quot;Command-line parsing library</font>
<font color="black">   4. </font>
<font color="black">   5. This module is an optparse-inspired command-line parsing library that:</font>
<font color="black">   6. </font>
<font color="black">   7.     - handles both optional and positional arguments</font>
<font color="black">   8.     - produces highly informative usage messages</font>
<font color="black">   9.     - supports parsers that dispatch to sub-parsers</font>
<font color="black">  10. </font>
<font color="black">  11. The following is a simple usage example that sums integers from the</font>
<font color="black">  12. command-line and writes the result to a file::</font>
<font color="black">  13. </font>
<font color="black">  14.     parser = argparse.ArgumentParser(</font>
<font color="black">  15.         description='sum the integers at the command line')</font>
<font color="black">  16.     parser.add_argument(</font>
<font color="black">  17.         'integers', metavar='int', nargs='+', type=int,</font>
<font color="black">  18.         help='an integer to be summed')</font>
<font color="black">  19.     parser.add_argument(</font>
<font color="black">  20.         '--log', default=sys.stdout, type=argparse.FileType('w'),</font>
<font color="black">  21.         help='the file where the sum should be written')</font>
<font color="black">  22.     args = parser.parse_args()</font>
<font color="black">  23.     args.log.write('%s' % sum(args.integers))</font>
<font color="black">  24.     args.log.close()</font>
<font color="black">  25. </font>
<font color="black">  26. The module contains the following public classes:</font>
<font color="black">  27. </font>
<font color="black">  28.     - ArgumentParser -- The main entry point for command-line parsing. As the</font>
<font color="black">  29.         example above shows, the add_argument() method is used to populate</font>
<font color="black">  30.         the parser with actions for optional and positional arguments. Then</font>
<font color="black">  31.         the parse_args() method is invoked to convert the args at the</font>
<font color="black">  32.         command-line into an object with attributes.</font>
<font color="black">  33. </font>
<font color="black">  34.     - ArgumentError -- The exception raised by ArgumentParser objects when</font>
<font color="black">  35.         there are errors with the parser's actions. Errors raised while</font>
<font color="black">  36.         parsing the command-line are caught by ArgumentParser and emitted</font>
<font color="black">  37.         as command-line messages.</font>
<font color="black">  38. </font>
<font color="black">  39.     - FileType -- A factory for defining types of files to be created. As the</font>
<font color="black">  40.         example above shows, instances of FileType are typically passed as</font>
<font color="black">  41.         the type= argument of add_argument() calls.</font>
<font color="black">  42. </font>
<font color="black">  43.     - Action -- The base class for parser actions. Typically actions are</font>
<font color="black">  44.         selected by passing strings like 'store_true' or 'append_const' to</font>
<font color="black">  45.         the action= argument of add_argument(). However, for greater</font>
<font color="black">  46.         customization of ArgumentParser actions, subclasses of Action may</font>
<font color="black">  47.         be defined and passed as the action= argument.</font>
<font color="black">  48. </font>
<font color="black">  49.     - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,</font>
<font color="black">  50.         ArgumentDefaultsHelpFormatter -- Formatter classes which</font>
<font color="black">  51.         may be passed as the formatter_class= argument to the</font>
<font color="black">  52.         ArgumentParser constructor. HelpFormatter is the default,</font>
<font color="black">  53.         RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser</font>
<font color="black">  54.         not to change the formatting for help text, and</font>
<font color="black">  55.         ArgumentDefaultsHelpFormatter adds information about argument defaults</font>
<font color="black">  56.         to the help.</font>
<font color="black">  57. </font>
<font color="black">  58. All other classes in this module are considered implementation details.</font>
<font color="black">  59. (Also note that HelpFormatter and RawDescriptionHelpFormatter are only</font>
<font color="black">  60. considered public as object names -- the API of the formatter objects is</font>
<font color="black">  61. still considered an implementation detail.)</font>
<font color="green">  62. &quot;&quot;&quot;</font>
<font color="black">  63. </font>
<font color="green">  64. __version__ = '1.3.0'  # we use our own version number independant of the</font>
<font color="black">  65.                        # one in stdlib and we release this on pypi.</font>
<font color="black">  66. </font>
<font color="green">  67. __external_lib__ = True  # to make sure the tests really test THIS lib,</font>
<font color="black">  68.                          # not the builtin one in Python stdlib</font>
<font color="black">  69. </font>
<font color="black">  70. __all__ = [</font>
<font color="green">  71.     'ArgumentParser',</font>
<font color="green">  72.     'ArgumentError',</font>
<font color="green">  73.     'ArgumentTypeError',</font>
<font color="green">  74.     'FileType',</font>
<font color="green">  75.     'HelpFormatter',</font>
<font color="green">  76.     'ArgumentDefaultsHelpFormatter',</font>
<font color="green">  77.     'RawDescriptionHelpFormatter',</font>
<font color="green">  78.     'RawTextHelpFormatter',</font>
<font color="green">  79.     'Namespace',</font>
<font color="green">  80.     'Action',</font>
<font color="green">  81.     'ONE_OR_MORE',</font>
<font color="green">  82.     'OPTIONAL',</font>
<font color="green">  83.     'PARSER',</font>
<font color="green">  84.     'REMAINDER',</font>
<font color="green">  85.     'SUPPRESS',</font>
<font color="green">  86.     'ZERO_OR_MORE',</font>
<font color="black">  87. ]</font>
<font color="black">  88. </font>
<font color="black">  89. </font>
<font color="green">  90. import copy as _copy</font>
<font color="green">  91. import os as _os</font>
<font color="green">  92. import re as _re</font>
<font color="green">  93. import sys as _sys</font>
<font color="green">  94. import textwrap as _textwrap</font>
<font color="black">  95. </font>
<font color="green">  96. from gettext import gettext as _</font>
<font color="black">  97. </font>
<font color="green">  98. try:</font>
<font color="green">  99.     set</font>
<font color="red"> 100. except NameError:</font>
<font color="black"> 101.     # for python &lt; 2.4 compatibility (sets module is there since 2.3):</font>
<font color="red"> 102.     from sets import Set as set</font>
<font color="black"> 103. </font>
<font color="green"> 104. try:</font>
<font color="green"> 105.     basestring</font>
<font color="red"> 106. except NameError:</font>
<font color="red"> 107.     basestring = str</font>
<font color="black"> 108. </font>
<font color="green"> 109. try:</font>
<font color="green"> 110.     sorted</font>
<font color="red"> 111. except NameError:</font>
<font color="black"> 112.     # for python &lt; 2.4 compatibility:</font>
<font color="red"> 113.     def sorted(iterable, reverse=False):</font>
<font color="red"> 114.         result = list(iterable)</font>
<font color="red"> 115.         result.sort()</font>
<font color="red"> 116.         if reverse:</font>
<font color="red"> 117.             result.reverse()</font>
<font color="red"> 118.         return result</font>
<font color="black"> 119. </font>
<font color="black"> 120. </font>
<font color="green"> 121. def _callable(obj):</font>
<font color="green"> 122.     return hasattr(obj, '__call__') or hasattr(obj, '__bases__')</font>
<font color="black"> 123. </font>
<font color="black"> 124. </font>
<font color="green"> 125. SUPPRESS = '==SUPPRESS=='</font>
<font color="black"> 126. </font>
<font color="green"> 127. OPTIONAL = '?'</font>
<font color="green"> 128. ZERO_OR_MORE = '*'</font>
<font color="green"> 129. ONE_OR_MORE = '+'</font>
<font color="green"> 130. PARSER = 'A...'</font>
<font color="green"> 131. REMAINDER = '...'</font>
<font color="green"> 132. _UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'</font>
<font color="black"> 133. </font>
<font color="black"> 134. # =============================</font>
<font color="black"> 135. # Utility functions and classes</font>
<font color="black"> 136. # =============================</font>
<font color="black"> 137. </font>
<font color="green"> 138. class _AttributeHolder(object):</font>
<font color="black"> 139.     &quot;&quot;&quot;Abstract base class that provides __repr__.</font>
<font color="black"> 140. </font>
<font color="black"> 141.     The __repr__ method returns a string in the format::</font>
<font color="black"> 142.         ClassName(attr=name, attr=name, ...)</font>
<font color="black"> 143.     The attributes are determined either by a class-level attribute,</font>
<font color="black"> 144.     '_kwarg_names', or by inspecting the instance __dict__.</font>
<font color="green"> 145.     &quot;&quot;&quot;</font>
<font color="black"> 146. </font>
<font color="green"> 147.     def __repr__(self):</font>
<font color="red"> 148.         type_name = type(self).__name__</font>
<font color="red"> 149.         arg_strings = []</font>
<font color="red"> 150.         for arg in self._get_args():</font>
<font color="red"> 151.             arg_strings.append(repr(arg))</font>
<font color="red"> 152.         for name, value in self._get_kwargs():</font>
<font color="red"> 153.             arg_strings.append('%s=%r' % (name, value))</font>
<font color="red"> 154.         return '%s(%s)' % (type_name, ', '.join(arg_strings))</font>
<font color="black"> 155. </font>
<font color="green"> 156.     def _get_kwargs(self):</font>
<font color="red"> 157.         return sorted(self.__dict__.items())</font>
<font color="black"> 158. </font>
<font color="green"> 159.     def _get_args(self):</font>
<font color="red"> 160.         return []</font>
<font color="black"> 161. </font>
<font color="black"> 162. </font>
<font color="green"> 163. def _ensure_value(namespace, name, value):</font>
<font color="red"> 164.     if getattr(namespace, name, None) is None:</font>
<font color="red"> 165.         setattr(namespace, name, value)</font>
<font color="red"> 166.     return getattr(namespace, name)</font>
<font color="black"> 167. </font>
<font color="black"> 168. </font>
<font color="black"> 169. # ===============</font>
<font color="black"> 170. # Formatting Help</font>
<font color="black"> 171. # ===============</font>
<font color="black"> 172. </font>
<font color="green"> 173. class HelpFormatter(object):</font>
<font color="black"> 174.     &quot;&quot;&quot;Formatter for generating usage messages and argument help strings.</font>
<font color="black"> 175. </font>
<font color="black"> 176.     Only the name of this class is considered a public API. All the methods</font>
<font color="black"> 177.     provided by the class are considered an implementation detail.</font>
<font color="green"> 178.     &quot;&quot;&quot;</font>
<font color="black"> 179. </font>
<font color="black"> 180.     def __init__(self,</font>
<font color="black"> 181.                  prog,</font>
<font color="green"> 182.                  indent_increment=2,</font>
<font color="green"> 183.                  max_help_position=24,</font>
<font color="green"> 184.                  width=None):</font>
<font color="black"> 185. </font>
<font color="black"> 186.         # default setting for width</font>
<font color="red"> 187.         if width is None:</font>
<font color="red"> 188.             try:</font>
<font color="red"> 189.                 width = int(_os.environ['COLUMNS'])</font>
<font color="red"> 190.             except (KeyError, ValueError):</font>
<font color="red"> 191.                 width = 80</font>
<font color="red"> 192.             width -= 2</font>
<font color="black"> 193. </font>
<font color="red"> 194.         self._prog = prog</font>
<font color="red"> 195.         self._indent_increment = indent_increment</font>
<font color="red"> 196.         self._max_help_position = max_help_position</font>
<font color="red"> 197.         self._width = width</font>
<font color="black"> 198. </font>
<font color="red"> 199.         self._current_indent = 0</font>
<font color="red"> 200.         self._level = 0</font>
<font color="red"> 201.         self._action_max_length = 0</font>
<font color="black"> 202. </font>
<font color="red"> 203.         self._root_section = self._Section(self, None)</font>
<font color="red"> 204.         self._current_section = self._root_section</font>
<font color="black"> 205. </font>
<font color="red"> 206.         self._whitespace_matcher = _re.compile(r'\s+')</font>
<font color="red"> 207.         self._long_break_matcher = _re.compile(r'\n\n\n+')</font>
<font color="black"> 208. </font>
<font color="black"> 209.     # ===============================</font>
<font color="black"> 210.     # Section and indentation methods</font>
<font color="black"> 211.     # ===============================</font>
<font color="green"> 212.     def _indent(self):</font>
<font color="red"> 213.         self._current_indent += self._indent_increment</font>
<font color="red"> 214.         self._level += 1</font>
<font color="black"> 215. </font>
<font color="green"> 216.     def _dedent(self):</font>
<font color="red"> 217.         self._current_indent -= self._indent_increment</font>
<font color="red"> 218.         assert self._current_indent &gt;= 0, 'Indent decreased below 0.'</font>
<font color="red"> 219.         self._level -= 1</font>
<font color="black"> 220. </font>
<font color="green"> 221.     class _Section(object):</font>
<font color="black"> 222. </font>
<font color="green"> 223.         def __init__(self, formatter, parent, heading=None):</font>
<font color="red"> 224.             self.formatter = formatter</font>
<font color="red"> 225.             self.parent = parent</font>
<font color="red"> 226.             self.heading = heading</font>
<font color="red"> 227.             self.items = []</font>
<font color="black"> 228. </font>
<font color="green"> 229.         def format_help(self):</font>
<font color="black"> 230.             # format the indented section</font>
<font color="red"> 231.             if self.parent is not None:</font>
<font color="red"> 232.                 self.formatter._indent()</font>
<font color="red"> 233.             join = self.formatter._join_parts</font>
<font color="red"> 234.             for func, args in self.items:</font>
<font color="red"> 235.                 func(*args)</font>
<font color="red"> 236.             item_help = join([func(*args) for func, args in self.items])</font>
<font color="red"> 237.             if self.parent is not None:</font>
<font color="red"> 238.                 self.formatter._dedent()</font>
<font color="black"> 239. </font>
<font color="black"> 240.             # return nothing if the section was empty</font>
<font color="red"> 241.             if not item_help:</font>
<font color="red"> 242.                 return ''</font>
<font color="black"> 243. </font>
<font color="black"> 244.             # add the heading if the section was non-empty</font>
<font color="red"> 245.             if self.heading is not SUPPRESS and self.heading is not None:</font>
<font color="red"> 246.                 current_indent = self.formatter._current_indent</font>
<font color="red"> 247.                 heading = '%*s%s:\n' % (current_indent, '', self.heading)</font>
<font color="black"> 248.             else:</font>
<font color="red"> 249.                 heading = ''</font>
<font color="black"> 250. </font>
<font color="black"> 251.             # join the section-initial newline, the heading and the help</font>
<font color="red"> 252.             return join(['\n', heading, item_help, '\n'])</font>
<font color="black"> 253. </font>
<font color="green"> 254.     def _add_item(self, func, args):</font>
<font color="red"> 255.         self._current_section.items.append((func, args))</font>
<font color="black"> 256. </font>
<font color="black"> 257.     # ========================</font>
<font color="black"> 258.     # Message building methods</font>
<font color="black"> 259.     # ========================</font>
<font color="green"> 260.     def start_section(self, heading):</font>
<font color="red"> 261.         self._indent()</font>
<font color="red"> 262.         section = self._Section(self, self._current_section, heading)</font>
<font color="red"> 263.         self._add_item(section.format_help, [])</font>
<font color="red"> 264.         self._current_section = section</font>
<font color="black"> 265. </font>
<font color="green"> 266.     def end_section(self):</font>
<font color="red"> 267.         self._current_section = self._current_section.parent</font>
<font color="red"> 268.         self._dedent()</font>
<font color="black"> 269. </font>
<font color="green"> 270.     def add_text(self, text):</font>
<font color="red"> 271.         if text is not SUPPRESS and text is not None:</font>
<font color="red"> 272.             self._add_item(self._format_text, [text])</font>
<font color="black"> 273. </font>
<font color="green"> 274.     def add_usage(self, usage, actions, groups, prefix=None):</font>
<font color="red"> 275.         if usage is not SUPPRESS:</font>
<font color="red"> 276.             args = usage, actions, groups, prefix</font>
<font color="red"> 277.             self._add_item(self._format_usage, args)</font>
<font color="black"> 278. </font>
<font color="green"> 279.     def add_argument(self, action):</font>
<font color="red"> 280.         if action.help is not SUPPRESS:</font>
<font color="black"> 281. </font>
<font color="black"> 282.             # find all invocations</font>
<font color="red"> 283.             get_invocation = self._format_action_invocation</font>
<font color="red"> 284.             invocations = [get_invocation(action)]</font>
<font color="red"> 285.             for subaction in self._iter_indented_subactions(action):</font>
<font color="red"> 286.                 invocations.append(get_invocation(subaction))</font>
<font color="black"> 287. </font>
<font color="black"> 288.             # update the maximum item length</font>
<font color="red"> 289.             invocation_length = max([len(s) for s in invocations])</font>
<font color="red"> 290.             action_length = invocation_length + self._current_indent</font>
<font color="red"> 291.             self._action_max_length = max(self._action_max_length,</font>
<font color="red"> 292.                                           action_length)</font>
<font color="black"> 293. </font>
<font color="black"> 294.             # add the item to the list</font>
<font color="red"> 295.             self._add_item(self._format_action, [action])</font>
<font color="black"> 296. </font>
<font color="green"> 297.     def add_arguments(self, actions):</font>
<font color="red"> 298.         for action in actions:</font>
<font color="red"> 299.             self.add_argument(action)</font>
<font color="black"> 300. </font>
<font color="black"> 301.     # =======================</font>
<font color="black"> 302.     # Help-formatting methods</font>
<font color="black"> 303.     # =======================</font>
<font color="green"> 304.     def format_help(self):</font>
<font color="red"> 305.         help = self._root_section.format_help()</font>
<font color="red"> 306.         if help:</font>
<font color="red"> 307.             help = self._long_break_matcher.sub('\n\n', help)</font>
<font color="red"> 308.             help = help.strip('\n') + '\n'</font>
<font color="red"> 309.         return help</font>
<font color="black"> 310. </font>
<font color="green"> 311.     def _join_parts(self, part_strings):</font>
<font color="red"> 312.         return ''.join([part</font>
<font color="red"> 313.                         for part in part_strings</font>
<font color="red"> 314.                         if part and part is not SUPPRESS])</font>
<font color="black"> 315. </font>
<font color="green"> 316.     def _format_usage(self, usage, actions, groups, prefix):</font>
<font color="red"> 317.         if prefix is None:</font>
<font color="red"> 318.             prefix = _('usage: ')</font>
<font color="black"> 319. </font>
<font color="black"> 320.         # if usage is specified, use that</font>
<font color="red"> 321.         if usage is not None:</font>
<font color="red"> 322.             usage = usage % dict(prog=self._prog)</font>
<font color="black"> 323. </font>
<font color="black"> 324.         # if no optionals or positionals are available, usage is just prog</font>
<font color="red"> 325.         elif usage is None and not actions:</font>
<font color="red"> 326.             usage = '%(prog)s' % dict(prog=self._prog)</font>
<font color="black"> 327. </font>
<font color="black"> 328.         # if optionals and positionals are available, calculate usage</font>
<font color="red"> 329.         elif usage is None:</font>
<font color="red"> 330.             prog = '%(prog)s' % dict(prog=self._prog)</font>
<font color="black"> 331. </font>
<font color="black"> 332.             # split optionals from positionals</font>
<font color="red"> 333.             optionals = []</font>
<font color="red"> 334.             positionals = []</font>
<font color="red"> 335.             for action in actions:</font>
<font color="red"> 336.                 if action.option_strings:</font>
<font color="red"> 337.                     optionals.append(action)</font>
<font color="black"> 338.                 else:</font>
<font color="red"> 339.                     positionals.append(action)</font>
<font color="black"> 340. </font>
<font color="black"> 341.             # build full usage string</font>
<font color="red"> 342.             format = self._format_actions_usage</font>
<font color="red"> 343.             action_usage = format(optionals + positionals, groups)</font>
<font color="red"> 344.             usage = ' '.join([s for s in [prog, action_usage] if s])</font>
<font color="black"> 345. </font>
<font color="black"> 346.             # wrap the usage parts if it's too long</font>
<font color="red"> 347.             text_width = self._width - self._current_indent</font>
<font color="red"> 348.             if len(prefix) + len(usage) &gt; text_width:</font>
<font color="black"> 349. </font>
<font color="black"> 350.                 # break usage into wrappable parts</font>
<font color="red"> 351.                 part_regexp = r'\(.*?\)+|\[.*?\]+|\S+'</font>
<font color="red"> 352.                 opt_usage = format(optionals, groups)</font>
<font color="red"> 353.                 pos_usage = format(positionals, groups)</font>
<font color="red"> 354.                 opt_parts = _re.findall(part_regexp, opt_usage)</font>
<font color="red"> 355.                 pos_parts = _re.findall(part_regexp, pos_usage)</font>
<font color="red"> 356.                 assert ' '.join(opt_parts) == opt_usage</font>
<font color="red"> 357.                 assert ' '.join(pos_parts) == pos_usage</font>
<font color="black"> 358. </font>
<font color="black"> 359.                 # helper for wrapping lines</font>
<font color="red"> 360.                 def get_lines(parts, indent, prefix=None):</font>
<font color="red"> 361.                     lines = []</font>
<font color="red"> 362.                     line = []</font>
<font color="red"> 363.                     if prefix is not None:</font>
<font color="red"> 364.                         line_len = len(prefix) - 1</font>
<font color="black"> 365.                     else:</font>
<font color="red"> 366.                         line_len = len(indent) - 1</font>
<font color="red"> 367.                     for part in parts:</font>
<font color="red"> 368.                         if line_len + 1 + len(part) &gt; text_width:</font>
<font color="red"> 369.                             lines.append(indent + ' '.join(line))</font>
<font color="red"> 370.                             line = []</font>
<font color="red"> 371.                             line_len = len(indent) - 1</font>
<font color="red"> 372.                         line.append(part)</font>
<font color="red"> 373.                         line_len += len(part) + 1</font>
<font color="red"> 374.                     if line:</font>
<font color="red"> 375.                         lines.append(indent + ' '.join(line))</font>
<font color="red"> 376.                     if prefix is not None:</font>
<font color="red"> 377.                         lines[0] = lines[0][len(indent):]</font>
<font color="red"> 378.                     return lines</font>
<font color="black"> 379. </font>
<font color="black"> 380.                 # if prog is short, follow it with optionals or positionals</font>
<font color="red"> 381.                 if len(prefix) + len(prog) &lt;= 0.75 * text_width:</font>
<font color="red"> 382.                     indent = ' ' * (len(prefix) + len(prog) + 1)</font>
<font color="red"> 383.                     if opt_parts:</font>
<font color="red"> 384.                         lines = get_lines([prog] + opt_parts, indent, prefix)</font>
<font color="red"> 385.                         lines.extend(get_lines(pos_parts, indent))</font>
<font color="red"> 386.                     elif pos_parts:</font>
<font color="red"> 387.                         lines = get_lines([prog] + pos_parts, indent, prefix)</font>
<font color="black"> 388.                     else:</font>
<font color="red"> 389.                         lines = [prog]</font>
<font color="black"> 390. </font>
<font color="black"> 391.                 # if prog is long, put it on its own line</font>
<font color="black"> 392.                 else:</font>
<font color="red"> 393.                     indent = ' ' * len(prefix)</font>
<font color="red"> 394.                     parts = opt_parts + pos_parts</font>
<font color="red"> 395.                     lines = get_lines(parts, indent)</font>
<font color="red"> 396.                     if len(lines) &gt; 1:</font>
<font color="red"> 397.                         lines = []</font>
<font color="red"> 398.                         lines.extend(get_lines(opt_parts, indent))</font>
<font color="red"> 399.                         lines.extend(get_lines(pos_parts, indent))</font>
<font color="red"> 400.                     lines = [prog] + lines</font>
<font color="black"> 401. </font>
<font color="black"> 402.                 # join lines into usage</font>
<font color="red"> 403.                 usage = '\n'.join(lines)</font>
<font color="black"> 404. </font>
<font color="black"> 405.         # prefix with 'usage:'</font>
<font color="red"> 406.         return '%s%s\n\n' % (prefix, usage)</font>
<font color="black"> 407. </font>
<font color="green"> 408.     def _format_actions_usage(self, actions, groups):</font>
<font color="black"> 409.         # find group indices and identify actions in groups</font>
<font color="red"> 410.         group_actions = set()</font>
<font color="red"> 411.         inserts = {}</font>
<font color="red"> 412.         for group in groups:</font>
<font color="red"> 413.             try:</font>
<font color="red"> 414.                 start = actions.index(group._group_actions[0])</font>
<font color="red"> 415.             except ValueError:</font>
<font color="red"> 416.                 continue</font>
<font color="black"> 417.             else:</font>
<font color="red"> 418.                 end = start + len(group._group_actions)</font>
<font color="red"> 419.                 if actions[start:end] == group._group_actions:</font>
<font color="red"> 420.                     for action in group._group_actions:</font>
<font color="red"> 421.                         group_actions.add(action)</font>
<font color="red"> 422.                     if not group.required:</font>
<font color="red"> 423.                         if start in inserts:</font>
<font color="red"> 424.                             inserts[start] += ' ['</font>
<font color="black"> 425.                         else:</font>
<font color="red"> 426.                             inserts[start] = '['</font>
<font color="red"> 427.                         inserts[end] = ']'</font>
<font color="black"> 428.                     else:</font>
<font color="red"> 429.                         if start in inserts:</font>
<font color="red"> 430.                             inserts[start] += ' ('</font>
<font color="black"> 431.                         else:</font>
<font color="red"> 432.                             inserts[start] = '('</font>
<font color="red"> 433.                         inserts[end] = ')'</font>
<font color="red"> 434.                     for i in range(start + 1, end):</font>
<font color="red"> 435.                         inserts[i] = '|'</font>
<font color="black"> 436. </font>
<font color="black"> 437.         # collect all actions format strings</font>
<font color="red"> 438.         parts = []</font>
<font color="red"> 439.         for i, action in enumerate(actions):</font>
<font color="black"> 440. </font>
<font color="black"> 441.             # suppressed arguments are marked with None</font>
<font color="black"> 442.             # remove | separators for suppressed arguments</font>
<font color="red"> 443.             if action.help is SUPPRESS:</font>
<font color="red"> 444.                 parts.append(None)</font>
<font color="red"> 445.                 if inserts.get(i) == '|':</font>
<font color="red"> 446.                     inserts.pop(i)</font>
<font color="red"> 447.                 elif inserts.get(i + 1) == '|':</font>
<font color="red"> 448.                     inserts.pop(i + 1)</font>
<font color="black"> 449. </font>
<font color="black"> 450.             # produce all arg strings</font>
<font color="red"> 451.             elif not action.option_strings:</font>
<font color="red"> 452.                 part = self._format_args(action, action.dest)</font>
<font color="black"> 453. </font>
<font color="black"> 454.                 # if it's in a group, strip the outer []</font>
<font color="red"> 455.                 if action in group_actions:</font>
<font color="red"> 456.                     if part[0] == '[' and part[-1] == ']':</font>
<font color="red"> 457.                         part = part[1:-1]</font>
<font color="black"> 458. </font>
<font color="black"> 459.                 # add the action string to the list</font>
<font color="red"> 460.                 parts.append(part)</font>
<font color="black"> 461. </font>
<font color="black"> 462.             # produce the first way to invoke the option in brackets</font>
<font color="black"> 463.             else:</font>
<font color="red"> 464.                 option_string = action.option_strings[0]</font>
<font color="black"> 465. </font>
<font color="black"> 466.                 # if the Optional doesn't take a value, format is:</font>
<font color="black"> 467.                 #    -s or --long</font>
<font color="red"> 468.                 if action.nargs == 0:</font>
<font color="red"> 469.                     part = '%s' % option_string</font>
<font color="black"> 470. </font>
<font color="black"> 471.                 # if the Optional takes a value, format is:</font>
<font color="black"> 472.                 #    -s ARGS or --long ARGS</font>
<font color="black"> 473.                 else:</font>
<font color="red"> 474.                     default = action.dest.upper()</font>
<font color="red"> 475.                     args_string = self._format_args(action, default)</font>
<font color="red"> 476.                     part = '%s %s' % (option_string, args_string)</font>
<font color="black"> 477. </font>
<font color="black"> 478.                 # make it look optional if it's not required or in a group</font>
<font color="red"> 479.                 if not action.required and action not in group_actions:</font>
<font color="red"> 480.                     part = '[%s]' % part</font>
<font color="black"> 481. </font>
<font color="black"> 482.                 # add the action string to the list</font>
<font color="red"> 483.                 parts.append(part)</font>
<font color="black"> 484. </font>
<font color="black"> 485.         # insert things at the necessary indices</font>
<font color="red"> 486.         for i in sorted(inserts, reverse=True):</font>
<font color="red"> 487.             parts[i:i] = [inserts[i]]</font>
<font color="black"> 488. </font>
<font color="black"> 489.         # join all the action items with spaces</font>
<font color="red"> 490.         text = ' '.join([item for item in parts if item is not None])</font>
<font color="black"> 491. </font>
<font color="black"> 492.         # clean up separators for mutually exclusive groups</font>
<font color="red"> 493.         open = r'[\[(]'</font>
<font color="red"> 494.         close = r'[\])]'</font>
<font color="red"> 495.         text = _re.sub(r'(%s) ' % open, r'\1', text)</font>
<font color="red"> 496.         text = _re.sub(r' (%s)' % close, r'\1', text)</font>
<font color="red"> 497.         text = _re.sub(r'%s *%s' % (open, close), r'', text)</font>
<font color="red"> 498.         text = _re.sub(r'\(([^|]*)\)', r'\1', text)</font>
<font color="red"> 499.         text = text.strip()</font>
<font color="black"> 500. </font>
<font color="black"> 501.         # return the text</font>
<font color="red"> 502.         return text</font>
<font color="black"> 503. </font>
<font color="green"> 504.     def _format_text(self, text):</font>
<font color="red"> 505.         if '%(prog)' in text:</font>
<font color="red"> 506.             text = text % dict(prog=self._prog)</font>
<font color="red"> 507.         text_width = self._width - self._current_indent</font>
<font color="red"> 508.         indent = ' ' * self._current_indent</font>
<font color="red"> 509.         return self._fill_text(text, text_width, indent) + '\n\n'</font>
<font color="black"> 510. </font>
<font color="green"> 511.     def _format_action(self, action):</font>
<font color="black"> 512.         # determine the required width and the entry label</font>
<font color="red"> 513.         help_position = min(self._action_max_length + 2,</font>
<font color="red"> 514.                             self._max_help_position)</font>
<font color="red"> 515.         help_width = self._width - help_position</font>
<font color="red"> 516.         action_width = help_position - self._current_indent - 2</font>
<font color="red"> 517.         action_header = self._format_action_invocation(action)</font>
<font color="black"> 518. </font>
<font color="black"> 519.         # ho nelp; start on same line and add a final newline</font>
<font color="red"> 520.         if not action.help:</font>
<font color="red"> 521.             tup = self._current_indent, '', action_header</font>
<font color="red"> 522.             action_header = '%*s%s\n' % tup</font>
<font color="black"> 523. </font>
<font color="black"> 524.         # short action name; start on the same line and pad two spaces</font>
<font color="red"> 525.         elif len(action_header) &lt;= action_width:</font>
<font color="red"> 526.             tup = self._current_indent, '', action_width, action_header</font>
<font color="red"> 527.             action_header = '%*s%-*s  ' % tup</font>
<font color="red"> 528.             indent_first = 0</font>
<font color="black"> 529. </font>
<font color="black"> 530.         # long action name; start on the next line</font>
<font color="black"> 531.         else:</font>
<font color="red"> 532.             tup = self._current_indent, '', action_header</font>
<font color="red"> 533.             action_header = '%*s%s\n' % tup</font>
<font color="red"> 534.             indent_first = help_position</font>
<font color="black"> 535. </font>
<font color="black"> 536.         # collect the pieces of the action help</font>
<font color="red"> 537.         parts = [action_header]</font>
<font color="black"> 538. </font>
<font color="black"> 539.         # if there was help for the action, add lines of help text</font>
<font color="red"> 540.         if action.help:</font>
<font color="red"> 541.             help_text = self._expand_help(action)</font>
<font color="red"> 542.             help_lines = self._split_lines(help_text, help_width)</font>
<font color="red"> 543.             parts.append('%*s%s\n' % (indent_first, '', help_lines[0]))</font>
<font color="red"> 544.             for line in help_lines[1:]:</font>
<font color="red"> 545.                 parts.append('%*s%s\n' % (help_position, '', line))</font>
<font color="black"> 546. </font>
<font color="black"> 547.         # or add a newline if the description doesn't end with one</font>
<font color="red"> 548.         elif not action_header.endswith('\n'):</font>
<font color="red"> 549.             parts.append('\n')</font>
<font color="black"> 550. </font>
<font color="black"> 551.         # if there are any sub-actions, add their help as well</font>
<font color="red"> 552.         for subaction in self._iter_indented_subactions(action):</font>
<font color="red"> 553.             parts.append(self._format_action(subaction))</font>
<font color="black"> 554. </font>
<font color="black"> 555.         # return a single string</font>
<font color="red"> 556.         return self._join_parts(parts)</font>
<font color="black"> 557. </font>
<font color="green"> 558.     def _format_action_invocation(self, action):</font>
<font color="red"> 559.         if not action.option_strings:</font>
<font color="red"> 560.             metavar, = self._metavar_formatter(action, action.dest)(1)</font>
<font color="red"> 561.             return metavar</font>
<font color="black"> 562. </font>
<font color="black"> 563.         else:</font>
<font color="red"> 564.             parts = []</font>
<font color="black"> 565. </font>
<font color="black"> 566.             # if the Optional doesn't take a value, format is:</font>
<font color="black"> 567.             #    -s, --long</font>
<font color="red"> 568.             if action.nargs == 0:</font>
<font color="red"> 569.                 parts.extend(action.option_strings)</font>
<font color="black"> 570. </font>
<font color="black"> 571.             # if the Optional takes a value, format is:</font>
<font color="black"> 572.             #    -s ARGS, --long ARGS</font>
<font color="black"> 573.             else:</font>
<font color="red"> 574.                 default = action.dest.upper()</font>
<font color="red"> 575.                 args_string = self._format_args(action, default)</font>
<font color="red"> 576.                 for option_string in action.option_strings:</font>
<font color="red"> 577.                     parts.append('%s %s' % (option_string, args_string))</font>
<font color="black"> 578. </font>
<font color="red"> 579.             return ', '.join(parts)</font>
<font color="black"> 580. </font>
<font color="green"> 581.     def _metavar_formatter(self, action, default_metavar):</font>
<font color="red"> 582.         if action.metavar is not None:</font>
<font color="red"> 583.             result = action.metavar</font>
<font color="red"> 584.         elif action.choices is not None:</font>
<font color="red"> 585.             choice_strs = [str(choice) for choice in action.choices]</font>
<font color="red"> 586.             result = '{%s}' % ','.join(choice_strs)</font>
<font color="black"> 587.         else:</font>
<font color="red"> 588.             result = default_metavar</font>
<font color="black"> 589. </font>
<font color="red"> 590.         def format(tuple_size):</font>
<font color="red"> 591.             if isinstance(result, tuple):</font>
<font color="red"> 592.                 return result</font>
<font color="black"> 593.             else:</font>
<font color="red"> 594.                 return (result, ) * tuple_size</font>
<font color="red"> 595.         return format</font>
<font color="black"> 596. </font>
<font color="green"> 597.     def _format_args(self, action, default_metavar):</font>
<font color="red"> 598.         get_metavar = self._metavar_formatter(action, default_metavar)</font>
<font color="red"> 599.         if action.nargs is None:</font>
<font color="red"> 600.             result = '%s' % get_metavar(1)</font>
<font color="red"> 601.         elif action.nargs == OPTIONAL:</font>
<font color="red"> 602.             result = '[%s]' % get_metavar(1)</font>
<font color="red"> 603.         elif action.nargs == ZERO_OR_MORE:</font>
<font color="red"> 604.             result = '[%s [%s ...]]' % get_metavar(2)</font>
<font color="red"> 605.         elif action.nargs == ONE_OR_MORE:</font>
<font color="red"> 606.             result = '%s [%s ...]' % get_metavar(2)</font>
<font color="red"> 607.         elif action.nargs == REMAINDER:</font>
<font color="red"> 608.             result = '...'</font>
<font color="red"> 609.         elif action.nargs == PARSER:</font>
<font color="red"> 610.             result = '%s ...' % get_metavar(1)</font>
<font color="black"> 611.         else:</font>
<font color="red"> 612.             formats = ['%s' for _ in range(action.nargs)]</font>
<font color="red"> 613.             result = ' '.join(formats) % get_metavar(action.nargs)</font>
<font color="red"> 614.         return result</font>
<font color="black"> 615. </font>
<font color="green"> 616.     def _expand_help(self, action):</font>
<font color="red"> 617.         params = dict(vars(action), prog=self._prog)</font>
<font color="red"> 618.         for name in list(params):</font>
<font color="red"> 619.             if params[name] is SUPPRESS:</font>
<font color="red"> 620.                 del params[name]</font>
<font color="red"> 621.         for name in list(params):</font>
<font color="red"> 622.             if hasattr(params[name], '__name__'):</font>
<font color="red"> 623.                 params[name] = params[name].__name__</font>
<font color="red"> 624.         if params.get('choices') is not None:</font>
<font color="red"> 625.             choices_str = ', '.join([str(c) for c in params['choices']])</font>
<font color="red"> 626.             params['choices'] = choices_str</font>
<font color="red"> 627.         return self._get_help_string(action) % params</font>
<font color="black"> 628. </font>
<font color="green"> 629.     def _iter_indented_subactions(self, action):</font>
<font color="red"> 630.         try:</font>
<font color="red"> 631.             get_subactions = action._get_subactions</font>
<font color="red"> 632.         except AttributeError:</font>
<font color="red"> 633.             pass</font>
<font color="black"> 634.         else:</font>
<font color="red"> 635.             self._indent()</font>
<font color="red"> 636.             for subaction in get_subactions():</font>
<font color="red"> 637.                 yield subaction</font>
<font color="red"> 638.             self._dedent()</font>
<font color="black"> 639. </font>
<font color="green"> 640.     def _split_lines(self, text, width):</font>
<font color="red"> 641.         text = self._whitespace_matcher.sub(' ', text).strip()</font>
<font color="red"> 642.         return _textwrap.wrap(text, width)</font>
<font color="black"> 643. </font>
<font color="green"> 644.     def _fill_text(self, text, width, indent):</font>
<font color="red"> 645.         text = self._whitespace_matcher.sub(' ', text).strip()</font>
<font color="red"> 646.         return _textwrap.fill(text, width, initial_indent=indent,</font>
<font color="red"> 647.                                            subsequent_indent=indent)</font>
<font color="black"> 648. </font>
<font color="green"> 649.     def _get_help_string(self, action):</font>
<font color="red"> 650.         return action.help</font>
<font color="black"> 651. </font>
<font color="black"> 652. </font>
<font color="green"> 653. class RawDescriptionHelpFormatter(HelpFormatter):</font>
<font color="black"> 654.     &quot;&quot;&quot;Help message formatter which retains any formatting in descriptions.</font>
<font color="black"> 655. </font>
<font color="black"> 656.     Only the name of this class is considered a public API. All the methods</font>
<font color="black"> 657.     provided by the class are considered an implementation detail.</font>
<font color="green"> 658.     &quot;&quot;&quot;</font>
<font color="black"> 659. </font>
<font color="green"> 660.     def _fill_text(self, text, width, indent):</font>
<font color="red"> 661.         return ''.join([indent + line for line in text.splitlines(True)])</font>
<font color="black"> 662. </font>
<font color="black"> 663. </font>
<font color="green"> 664. class RawTextHelpFormatter(RawDescriptionHelpFormatter):</font>
<font color="black"> 665.     &quot;&quot;&quot;Help message formatter which retains formatting of all help text.</font>
<font color="black"> 666. </font>
<font color="black"> 667.     Only the name of this class is considered a public API. All the methods</font>
<font color="black"> 668.     provided by the class are considered an implementation detail.</font>
<font color="green"> 669.     &quot;&quot;&quot;</font>
<font color="black"> 670. </font>
<font color="green"> 671.     def _split_lines(self, text, width):</font>
<font color="red"> 672.         return text.splitlines()</font>
<font color="black"> 673. </font>
<font color="black"> 674. </font>
<font color="green"> 675. class ArgumentDefaultsHelpFormatter(HelpFormatter):</font>
<font color="black"> 676.     &quot;&quot;&quot;Help message formatter which adds default values to argument help.</font>
<font color="black"> 677. </font>
<font color="black"> 678.     Only the name of this class is considered a public API. All the methods</font>
<font color="black"> 679.     provided by the class are considered an implementation detail.</font>
<font color="green"> 680.     &quot;&quot;&quot;</font>
<font color="black"> 681. </font>
<font color="green"> 682.     def _get_help_string(self, action):</font>
<font color="red"> 683.         help = action.help</font>
<font color="red"> 684.         if '%(default)' not in action.help:</font>
<font color="red"> 685.             if action.default is not SUPPRESS:</font>
<font color="red"> 686.                 defaulting_nargs = [OPTIONAL, ZERO_OR_MORE]</font>
<font color="red"> 687.                 if action.option_strings or action.nargs in defaulting_nargs:</font>
<font color="red"> 688.                     help += ' (default: %(default)s)'</font>
<font color="red"> 689.         return help</font>
<font color="black"> 690. </font>
<font color="black"> 691. </font>
<font color="black"> 692. # =====================</font>
<font color="black"> 693. # Options and Arguments</font>
<font color="black"> 694. # =====================</font>
<font color="black"> 695. </font>
<font color="green"> 696. def _get_action_name(argument):</font>
<font color="red"> 697.     if argument is None:</font>
<font color="red"> 698.         return None</font>
<font color="red"> 699.     elif argument.option_strings:</font>
<font color="red"> 700.         return  '/'.join(argument.option_strings)</font>
<font color="red"> 701.     elif argument.metavar not in (None, SUPPRESS):</font>
<font color="red"> 702.         return argument.metavar</font>
<font color="red"> 703.     elif argument.dest not in (None, SUPPRESS):</font>
<font color="red"> 704.         return argument.dest</font>
<font color="black"> 705.     else:</font>
<font color="red"> 706.         return None</font>
<font color="black"> 707. </font>
<font color="black"> 708. </font>
<font color="green"> 709. class ArgumentError(Exception):</font>
<font color="black"> 710.     &quot;&quot;&quot;An error from creating or using an argument (optional or positional).</font>
<font color="black"> 711. </font>
<font color="black"> 712.     The string value of this exception is the message, augmented with</font>
<font color="black"> 713.     information about the argument that caused it.</font>
<font color="green"> 714.     &quot;&quot;&quot;</font>
<font color="black"> 715. </font>
<font color="green"> 716.     def __init__(self, argument, message):</font>
<font color="red"> 717.         self.argument_name = _get_action_name(argument)</font>
<font color="red"> 718.         self.message = message</font>
<font color="black"> 719. </font>
<font color="green"> 720.     def __str__(self):</font>
<font color="red"> 721.         if self.argument_name is None:</font>
<font color="red"> 722.             format = '%(message)s'</font>
<font color="black"> 723.         else:</font>
<font color="red"> 724.             format = 'argument %(argument_name)s: %(message)s'</font>
<font color="red"> 725.         return format % dict(message=self.message,</font>
<font color="red"> 726.                              argument_name=self.argument_name)</font>
<font color="black"> 727. </font>
<font color="black"> 728. </font>
<font color="green"> 729. class ArgumentTypeError(Exception):</font>
<font color="green"> 730.     &quot;&quot;&quot;An error from trying to convert a command line string to a type.&quot;&quot;&quot;</font>
<font color="green"> 731.     pass</font>
<font color="black"> 732. </font>
<font color="black"> 733. </font>
<font color="black"> 734. # ==============</font>
<font color="black"> 735. # Action classes</font>
<font color="black"> 736. # ==============</font>
<font color="black"> 737. </font>
<font color="green"> 738. class Action(_AttributeHolder):</font>
<font color="black"> 739.     &quot;&quot;&quot;Information about how to convert command line strings to Python objects.</font>
<font color="black"> 740. </font>
<font color="black"> 741.     Action objects are used by an ArgumentParser to represent the information</font>
<font color="black"> 742.     needed to parse a single argument from one or more strings from the</font>
<font color="black"> 743.     command line. The keyword arguments to the Action constructor are also</font>
<font color="black"> 744.     all attributes of Action instances.</font>
<font color="black"> 745. </font>
<font color="black"> 746.     Keyword Arguments:</font>
<font color="black"> 747. </font>
<font color="black"> 748.         - option_strings -- A list of command-line option strings which</font>
<font color="black"> 749.             should be associated with this action.</font>
<font color="black"> 750. </font>
<font color="black"> 751.         - dest -- The name of the attribute to hold the created object(s)</font>
<font color="black"> 752. </font>
<font color="black"> 753.         - nargs -- The number of command-line arguments that should be</font>
<font color="black"> 754.             consumed. By default, one argument will be consumed and a single</font>
<font color="black"> 755.             value will be produced.  Other values include:</font>
<font color="black"> 756.                 - N (an integer) consumes N arguments (and produces a list)</font>
<font color="black"> 757.                 - '?' consumes zero or one arguments</font>
<font color="black"> 758.                 - '*' consumes zero or more arguments (and produces a list)</font>
<font color="black"> 759.                 - '+' consumes one or more arguments (and produces a list)</font>
<font color="black"> 760.             Note that the difference between the default and nargs=1 is that</font>
<font color="black"> 761.             with the default, a single value will be produced, while with</font>
<font color="black"> 762.             nargs=1, a list containing a single value will be produced.</font>
<font color="black"> 763. </font>
<font color="black"> 764.         - const -- The value to be produced if the option is specified and the</font>
<font color="black"> 765.             option uses an action that takes no values.</font>
<font color="black"> 766. </font>
<font color="black"> 767.         - default -- The value to be produced if the option is not specified.</font>
<font color="black"> 768. </font>
<font color="black"> 769.         - type -- The type which the command-line arguments should be converted</font>
<font color="black"> 770.             to, should be one of 'string', 'int', 'float', 'complex' or a</font>
<font color="black"> 771.             callable object that accepts a single string argument. If None,</font>
<font color="black"> 772.             'string' is assumed.</font>
<font color="black"> 773. </font>
<font color="black"> 774.         - choices -- A container of values that should be allowed. If not None,</font>
<font color="black"> 775.             after a command-line argument has been converted to the appropriate</font>
<font color="black"> 776.             type, an exception will be raised if it is not a member of this</font>
<font color="black"> 777.             collection.</font>
<font color="black"> 778. </font>
<font color="black"> 779.         - required -- True if the action must always be specified at the</font>
<font color="black"> 780.             command line. This is only meaningful for optional command-line</font>
<font color="black"> 781.             arguments.</font>
<font color="black"> 782. </font>
<font color="black"> 783.         - help -- The help string describing the argument.</font>
<font color="black"> 784. </font>
<font color="black"> 785.         - metavar -- The name to be used for the option's argument with the</font>
<font color="black"> 786.             help string. If None, the 'dest' value will be used as the name.</font>
<font color="green"> 787.     &quot;&quot;&quot;</font>
<font color="black"> 788. </font>
<font color="black"> 789.     def __init__(self,</font>
<font color="black"> 790.                  option_strings,</font>
<font color="black"> 791.                  dest,</font>
<font color="green"> 792.                  nargs=None,</font>
<font color="green"> 793.                  const=None,</font>
<font color="green"> 794.                  default=None,</font>
<font color="green"> 795.                  type=None,</font>
<font color="green"> 796.                  choices=None,</font>
<font color="green"> 797.                  required=False,</font>
<font color="green"> 798.                  help=None,</font>
<font color="green"> 799.                  metavar=None):</font>
<font color="green"> 800.         self.option_strings = option_strings</font>
<font color="green"> 801.         self.dest = dest</font>
<font color="green"> 802.         self.nargs = nargs</font>
<font color="green"> 803.         self.const = const</font>
<font color="green"> 804.         self.default = default</font>
<font color="green"> 805.         self.type = type</font>
<font color="green"> 806.         self.choices = choices</font>
<font color="green"> 807.         self.required = required</font>
<font color="green"> 808.         self.help = help</font>
<font color="green"> 809.         self.metavar = metavar</font>
<font color="black"> 810. </font>
<font color="green"> 811.     def _get_kwargs(self):</font>
<font color="black"> 812.         names = [</font>
<font color="red"> 813.             'option_strings',</font>
<font color="red"> 814.             'dest',</font>
<font color="red"> 815.             'nargs',</font>
<font color="red"> 816.             'const',</font>
<font color="red"> 817.             'default',</font>
<font color="red"> 818.             'type',</font>
<font color="red"> 819.             'choices',</font>
<font color="red"> 820.             'help',</font>
<font color="red"> 821.             'metavar',</font>
<font color="black"> 822.         ]</font>
<font color="red"> 823.         return [(name, getattr(self, name)) for name in names]</font>
<font color="black"> 824. </font>
<font color="green"> 825.     def __call__(self, parser, namespace, values, option_string=None):</font>
<font color="red"> 826.         raise NotImplementedError(_('.__call__() not defined'))</font>
<font color="black"> 827. </font>
<font color="black"> 828. </font>
<font color="green"> 829. class _StoreAction(Action):</font>
<font color="black"> 830. </font>
<font color="black"> 831.     def __init__(self,</font>
<font color="black"> 832.                  option_strings,</font>
<font color="black"> 833.                  dest,</font>
<font color="green"> 834.                  nargs=None,</font>
<font color="green"> 835.                  const=None,</font>
<font color="green"> 836.                  default=None,</font>
<font color="green"> 837.                  type=None,</font>
<font color="green"> 838.                  choices=None,</font>
<font color="green"> 839.                  required=False,</font>
<font color="green"> 840.                  help=None,</font>
<font color="green"> 841.                  metavar=None):</font>
<font color="green"> 842.         if nargs == 0:</font>
<font color="red"> 843.             raise ValueError('nargs for store actions must be &gt; 0; if you '</font>
<font color="black"> 844.                              'have nothing to store, actions such as store '</font>
<font color="black"> 845.                              'true or store const may be more appropriate')</font>
<font color="green"> 846.         if const is not None and nargs != OPTIONAL:</font>
<font color="red"> 847.             raise ValueError('nargs must be %r to supply const' % OPTIONAL)</font>
<font color="green"> 848.         super(_StoreAction, self).__init__(</font>
<font color="green"> 849.             option_strings=option_strings,</font>
<font color="green"> 850.             dest=dest,</font>
<font color="green"> 851.             nargs=nargs,</font>
<font color="green"> 852.             const=const,</font>
<font color="green"> 853.             default=default,</font>
<font color="green"> 854.             type=type,</font>
<font color="green"> 855.             choices=choices,</font>
<font color="green"> 856.             required=required,</font>
<font color="green"> 857.             help=help,</font>
<font color="green"> 858.             metavar=metavar)</font>
<font color="black"> 859. </font>
<font color="green"> 860.     def __call__(self, parser, namespace, values, option_string=None):</font>
<font color="green"> 861.         setattr(namespace, self.dest, values)</font>
<font color="black"> 862. </font>
<font color="black"> 863. </font>
<font color="green"> 864. class _StoreConstAction(Action):</font>
<font color="black"> 865. </font>
<font color="black"> 866.     def __init__(self,</font>
<font color="black"> 867.                  option_strings,</font>
<font color="black"> 868.                  dest,</font>
<font color="black"> 869.                  const,</font>
<font color="green"> 870.                  default=None,</font>
<font color="green"> 871.                  required=False,</font>
<font color="green"> 872.                  help=None,</font>
<font color="green"> 873.                  metavar=None):</font>
<font color="red"> 874.         super(_StoreConstAction, self).__init__(</font>
<font color="red"> 875.             option_strings=option_strings,</font>
<font color="red"> 876.             dest=dest,</font>
<font color="red"> 877.             nargs=0,</font>
<font color="red"> 878.             const=const,</font>
<font color="red"> 879.             default=default,</font>
<font color="red"> 880.             required=required,</font>
<font color="red"> 881.             help=help)</font>
<font color="black"> 882. </font>
<font color="green"> 883.     def __call__(self, parser, namespace, values, option_string=None):</font>
<font color="red"> 884.         setattr(namespace, self.dest, self.const)</font>
<font color="black"> 885. </font>
<font color="black"> 886. </font>
<font color="green"> 887. class _StoreTrueAction(_StoreConstAction):</font>
<font color="black"> 888. </font>
<font color="black"> 889.     def __init__(self,</font>
<font color="black"> 890.                  option_strings,</font>
<font color="black"> 891.                  dest,</font>
<font color="green"> 892.                  default=False,</font>
<font color="green"> 893.                  required=False,</font>
<font color="green"> 894.                  help=None):</font>
<font color="red"> 895.         super(_StoreTrueAction, self).__init__(</font>
<font color="red"> 896.             option_strings=option_strings,</font>
<font color="red"> 897.             dest=dest,</font>
<font color="red"> 898.             const=True,</font>
<font color="red"> 899.             default=default,</font>
<font color="red"> 900.             required=required,</font>
<font color="red"> 901.             help=help)</font>
<font color="black"> 902. </font>
<font color="black"> 903. </font>
<font color="green"> 904. class _StoreFalseAction(_StoreConstAction):</font>
<font color="black"> 905. </font>
<font color="black"> 906.     def __init__(self,</font>
<font color="black"> 907.                  option_strings,</font>
<font color="black"> 908.                  dest,</font>
<font color="green"> 909.                  default=True,</font>
<font color="green"> 910.                  required=False,</font>
<font color="green"> 911.                  help=None):</font>
<font color="red"> 912.         super(_StoreFalseAction, self).__init__(</font>
<font color="red"> 913.             option_strings=option_strings,</font>
<font color="red"> 914.             dest=dest,</font>
<font color="red"> 915.             const=False,</font>
<font color="red"> 916.             default=default,</font>
<font color="red"> 917.             required=required,</font>
<font color="red"> 918.             help=help)</font>
<font color="black"> 919. </font>
<font color="black"> 920. </font>
<font color="green"> 921. class _AppendAction(Action):</font>
<font color="black"> 922. </font>
<font color="black"> 923.     def __init__(self,</font>
<font color="black"> 924.                  option_strings,</font>
<font color="black"> 925.                  dest,</font>
<font color="green"> 926.                  nargs=None,</font>
<font color="green"> 927.                  const=None,</font>
<font color="green"> 928.                  default=None,</font>
<font color="green"> 929.                  type=None,</font>
<font color="green"> 930.                  choices=None,</font>
<font color="green"> 931.                  required=False,</font>
<font color="green"> 932.                  help=None,</font>
<font color="green"> 933.                  metavar=None):</font>
<font color="red"> 934.         if nargs == 0:</font>
<font color="red"> 935.             raise ValueError('nargs for append actions must be &gt; 0; if arg '</font>
<font color="black"> 936.                              'strings are not supplying the value to append, '</font>
<font color="black"> 937.                              'the append const action may be more appropriate')</font>
<font color="red"> 938.         if const is not None and nargs != OPTIONAL:</font>
<font color="red"> 939.             raise ValueError('nargs must be %r to supply const' % OPTIONAL)</font>
<font color="red"> 940.         super(_AppendAction, self).__init__(</font>
<font color="red"> 941.             option_strings=option_strings,</font>
<font color="red"> 942.             dest=dest,</font>
<font color="red"> 943.             nargs=nargs,</font>
<font color="red"> 944.             const=const,</font>
<font color="red"> 945.             default=default,</font>
<font color="red"> 946.             type=type,</font>
<font color="red"> 947.             choices=choices,</font>
<font color="red"> 948.             required=required,</font>
<font color="red"> 949.             help=help,</font>
<font color="red"> 950.             metavar=metavar)</font>
<font color="black"> 951. </font>
<font color="green"> 952.     def __call__(self, parser, namespace, values, option_string=None):</font>
<font color="red"> 953.         items = _copy.copy(_ensure_value(namespace, self.dest, []))</font>
<font color="red"> 954.         items.append(values)</font>
<font color="red"> 955.         setattr(namespace, self.dest, items)</font>
<font color="black"> 956. </font>
<font color="black"> 957. </font>
<font color="green"> 958. class _AppendConstAction(Action):</font>
<font color="black"> 959. </font>
<font color="black"> 960.     def __init__(self,</font>
<font color="black"> 961.                  option_strings,</font>
<font color="black"> 962.                  dest,</font>
<font color="black"> 963.                  const,</font>
<font color="green"> 964.                  default=None,</font>
<font color="green"> 965.                  required=False,</font>
<font color="green"> 966.                  help=None,</font>
<font color="green"> 967.                  metavar=None):</font>
<font color="red"> 968.         super(_AppendConstAction, self).__init__(</font>
<font color="red"> 969.             option_strings=option_strings,</font>
<font color="red"> 970.             dest=dest,</font>
<font color="red"> 971.             nargs=0,</font>
<font color="red"> 972.             const=const,</font>
<font color="red"> 973.             default=default,</font>
<font color="red"> 974.             required=required,</font>
<font color="red"> 975.             help=help,</font>
<font color="red"> 976.             metavar=metavar)</font>
<font color="black"> 977. </font>
<font color="green"> 978.     def __call__(self, parser, namespace, values, option_string=None):</font>
<font color="red"> 979.         items = _copy.copy(_ensure_value(namespace, self.dest, []))</font>
<font color="red"> 980.         items.append(self.const)</font>
<font color="red"> 981.         setattr(namespace, self.dest, items)</font>
<font color="black"> 982. </font>
<font color="black"> 983. </font>
<font color="green"> 984. class _CountAction(Action):</font>
<font color="black"> 985. </font>
<font color="black"> 986.     def __init__(self,</font>
<font color="black"> 987.                  option_strings,</font>
<font color="black"> 988.                  dest,</font>
<font color="green"> 989.                  default=None,</font>
<font color="green"> 990.                  required=False,</font>
<font color="green"> 991.                  help=None):</font>
<font color="red"> 992.         super(_CountAction, self).__init__(</font>
<font color="red"> 993.             option_strings=option_strings,</font>
<font color="red"> 994.             dest=dest,</font>
<font color="red"> 995.             nargs=0,</font>
<font color="red"> 996.             default=default,</font>
<font color="red"> 997.             required=required,</font>
<font color="red"> 998.             help=help)</font>
<font color="black"> 999. </font>
<font color="green">1000.     def __call__(self, parser, namespace, values, option_string=None):</font>
<font color="red">1001.         new_count = _ensure_value(namespace, self.dest, 0) + 1</font>
<font color="red">1002.         setattr(namespace, self.dest, new_count)</font>
<font color="black">1003. </font>
<font color="black">1004. </font>
<font color="green">1005. class _HelpAction(Action):</font>
<font color="black">1006. </font>
<font color="black">1007.     def __init__(self,</font>
<font color="black">1008.                  option_strings,</font>
<font color="green">1009.                  dest=SUPPRESS,</font>
<font color="green">1010.                  default=SUPPRESS,</font>
<font color="green">1011.                  help=None):</font>
<font color="green">1012.         super(_HelpAction, self).__init__(</font>
<font color="green">1013.             option_strings=option_strings,</font>
<font color="green">1014.             dest=dest,</font>
<font color="green">1015.             default=default,</font>
<font color="green">1016.             nargs=0,</font>
<font color="green">1017.             help=help)</font>
<font color="black">1018. </font>
<font color="green">1019.     def __call__(self, parser, namespace, values, option_string=None):</font>
<font color="red">1020.         parser.print_help()</font>
<font color="red">1021.         parser.exit()</font>
<font color="black">1022. </font>
<font color="black">1023. </font>
<font color="green">1024. class _VersionAction(Action):</font>
<font color="black">1025. </font>
<font color="black">1026.     def __init__(self,</font>
<font color="black">1027.                  option_strings,</font>
<font color="green">1028.                  version=None,</font>
<font color="green">1029.                  dest=SUPPRESS,</font>
<font color="green">1030.                  default=SUPPRESS,</font>
<font color="green">1031.                  help=&quot;show program's version number and exit&quot;):</font>
<font color="red">1032.         super(_VersionAction, self).__init__(</font>
<font color="red">1033.             option_strings=option_strings,</font>
<font color="red">1034.             dest=dest,</font>
<font color="red">1035.             default=default,</font>
<font color="red">1036.             nargs=0,</font>
<font color="red">1037.             help=help)</font>
<font color="red">1038.         self.version = version</font>
<font color="black">1039. </font>
<font color="green">1040.     def __call__(self, parser, namespace, values, option_string=None):</font>
<font color="red">1041.         version = self.version</font>
<font color="red">1042.         if version is None:</font>
<font color="red">1043.             version = parser.version</font>
<font color="red">1044.         formatter = parser._get_formatter()</font>
<font color="red">1045.         formatter.add_text(version)</font>
<font color="red">1046.         parser.exit(message=formatter.format_help())</font>
<font color="black">1047. </font>
<font color="black">1048. </font>
<font color="green">1049. class _SubParsersAction(Action):</font>
<font color="black">1050. </font>
<font color="green">1051.     class _ChoicesPseudoAction(Action):</font>
<font color="black">1052. </font>
<font color="green">1053.         def __init__(self, name, aliases, help):</font>
<font color="red">1054.             metavar = dest = name</font>
<font color="red">1055.             if aliases:</font>
<font color="red">1056.                 metavar += ' (%s)' % ', '.join(aliases)</font>
<font color="red">1057.             sup = super(_SubParsersAction._ChoicesPseudoAction, self)</font>
<font color="red">1058.             sup.__init__(option_strings=[], dest=dest, help=help,</font>
<font color="red">1059.                         metavar=metavar)</font>
<font color="black">1060. </font>
<font color="black">1061.     def __init__(self,</font>
<font color="black">1062.                  option_strings,</font>
<font color="black">1063.                  prog,</font>
<font color="black">1064.                  parser_class,</font>
<font color="green">1065.                  dest=SUPPRESS,</font>
<font color="green">1066.                  help=None,</font>
<font color="green">1067.                  metavar=None):</font>
<font color="black">1068. </font>
<font color="red">1069.         self._prog_prefix = prog</font>
<font color="red">1070.         self._parser_class = parser_class</font>
<font color="red">1071.         self._name_parser_map = {}</font>
<font color="red">1072.         self._choices_actions = []</font>
<font color="black">1073. </font>
<font color="red">1074.         super(_SubParsersAction, self).__init__(</font>
<font color="red">1075.             option_strings=option_strings,</font>
<font color="red">1076.             dest=dest,</font>
<font color="red">1077.             nargs=PARSER,</font>
<font color="red">1078.             choices=self._name_parser_map,</font>
<font color="red">1079.             help=help,</font>
<font color="red">1080.             metavar=metavar)</font>
<font color="black">1081. </font>
<font color="green">1082.     def add_parser(self, name, **kwargs):</font>
<font color="black">1083.         # set prog from the existing prefix</font>
<font color="red">1084.         if kwargs.get('prog') is None:</font>
<font color="red">1085.             kwargs['prog'] = '%s %s' % (self._prog_prefix, name)</font>
<font color="black">1086. </font>
<font color="red">1087.         aliases = kwargs.pop('aliases', ())</font>
<font color="black">1088. </font>
<font color="black">1089.         # create a pseudo-action to hold the choice help</font>
<font color="red">1090.         if 'help' in kwargs:</font>
<font color="red">1091.             help = kwargs.pop('help')</font>
<font color="red">1092.             choice_action = self._ChoicesPseudoAction(name, aliases, help)</font>
<font color="red">1093.             self._choices_actions.append(choice_action)</font>
<font color="black">1094. </font>
<font color="black">1095.         # create the parser and add it to the map</font>
<font color="red">1096.         parser = self._parser_class(**kwargs)</font>
<font color="red">1097.         self._name_parser_map[name] = parser</font>
<font color="black">1098. </font>
<font color="black">1099.         # make parser available under aliases also</font>
<font color="red">1100.         for alias in aliases:</font>
<font color="red">1101.             self._name_parser_map[alias] = parser</font>
<font color="black">1102. </font>
<font color="red">1103.         return parser</font>
<font color="black">1104. </font>
<font color="green">1105.     def _get_subactions(self):</font>
<font color="red">1106.         return self._choices_actions</font>
<font color="black">1107. </font>
<font color="green">1108.     def __call__(self, parser, namespace, values, option_string=None):</font>
<font color="red">1109.         parser_name = values[0]</font>
<font color="red">1110.         arg_strings = values[1:]</font>
<font color="black">1111. </font>
<font color="black">1112.         # set the parser name if requested</font>
<font color="red">1113.         if self.dest is not SUPPRESS:</font>
<font color="red">1114.             setattr(namespace, self.dest, parser_name)</font>
<font color="black">1115. </font>
<font color="black">1116.         # select the parser</font>
<font color="red">1117.         try:</font>
<font color="red">1118.             parser = self._name_parser_map[parser_name]</font>
<font color="red">1119.         except KeyError:</font>
<font color="red">1120.             tup = parser_name, ', '.join(self._name_parser_map)</font>
<font color="red">1121.             msg = _('unknown parser %r (choices: %s)' % tup)</font>
<font color="red">1122.             raise ArgumentError(self, msg)</font>
<font color="black">1123. </font>
<font color="black">1124.         # parse all the remaining options into the namespace</font>
<font color="black">1125.         # store any unrecognized options on the object, so that the top</font>
<font color="black">1126.         # level parser can decide what to do with them</font>
<font color="red">1127.         namespace, arg_strings = parser.parse_known_args(arg_strings, namespace)</font>
<font color="red">1128.         if arg_strings:</font>
<font color="red">1129.             vars(namespace).setdefault(_UNRECOGNIZED_ARGS_ATTR, [])</font>
<font color="red">1130.             getattr(namespace, _UNRECOGNIZED_ARGS_ATTR).extend(arg_strings)</font>
<font color="black">1131. </font>
<font color="black">1132. </font>
<font color="black">1133. # ==============</font>
<font color="black">1134. # Type classes</font>
<font color="black">1135. # ==============</font>
<font color="black">1136. </font>
<font color="green">1137. class FileType(object):</font>
<font color="black">1138.     &quot;&quot;&quot;Factory for creating file object types</font>
<font color="black">1139. </font>
<font color="black">1140.     Instances of FileType are typically passed as type= arguments to the</font>
<font color="black">1141.     ArgumentParser add_argument() method.</font>
<font color="black">1142. </font>
<font color="black">1143.     Keyword Arguments:</font>
<font color="black">1144.         - mode -- A string indicating how the file is to be opened. Accepts the</font>
<font color="black">1145.             same values as the builtin open() function.</font>
<font color="black">1146.         - bufsize -- The file's desired buffer size. Accepts the same values as</font>
<font color="black">1147.             the builtin open() function.</font>
<font color="green">1148.     &quot;&quot;&quot;</font>
<font color="black">1149. </font>
<font color="green">1150.     def __init__(self, mode='r', bufsize=None):</font>
<font color="red">1151.         self._mode = mode</font>
<font color="red">1152.         self._bufsize = bufsize</font>
<font color="black">1153. </font>
<font color="green">1154.     def __call__(self, string):</font>
<font color="black">1155.         # the special argument &quot;-&quot; means sys.std{in,out}</font>
<font color="red">1156.         if string == '-':</font>
<font color="red">1157.             if 'r' in self._mode:</font>
<font color="red">1158.                 return _sys.stdin</font>
<font color="red">1159.             elif 'w' in self._mode:</font>
<font color="red">1160.                 return _sys.stdout</font>
<font color="black">1161.             else:</font>
<font color="red">1162.                 msg = _('argument &quot;-&quot; with mode %r' % self._mode)</font>
<font color="red">1163.                 raise ValueError(msg)</font>
<font color="black">1164. </font>
<font color="black">1165.         # all other arguments are used as file names</font>
<font color="red">1166.         if self._bufsize:</font>
<font color="red">1167.             return open(string, self._mode, self._bufsize)</font>
<font color="black">1168.         else:</font>
<font color="red">1169.             return open(string, self._mode)</font>
<font color="black">1170. </font>
<font color="green">1171.     def __repr__(self):</font>
<font color="red">1172.         args = [self._mode, self._bufsize]</font>
<font color="red">1173.         args_str = ', '.join([repr(arg) for arg in args if arg is not None])</font>
<font color="red">1174.         return '%s(%s)' % (type(self).__name__, args_str)</font>
<font color="black">1175. </font>
<font color="black">1176. # ===========================</font>
<font color="black">1177. # Optional and Positional Parsing</font>
<font color="black">1178. # ===========================</font>
<font color="black">1179. </font>
<font color="green">1180. class Namespace(_AttributeHolder):</font>
<font color="black">1181.     &quot;&quot;&quot;Simple object for storing attributes.</font>
<font color="black">1182. </font>
<font color="black">1183.     Implements equality by attribute names and values, and provides a simple</font>
<font color="black">1184.     string representation.</font>
<font color="green">1185.     &quot;&quot;&quot;</font>
<font color="black">1186. </font>
<font color="green">1187.     def __init__(self, **kwargs):</font>
<font color="green">1188.         for name in kwargs:</font>
<font color="red">1189.             setattr(self, name, kwargs[name])</font>
<font color="black">1190. </font>
<font color="green">1191.     __hash__ = None</font>
<font color="black">1192. </font>
<font color="green">1193.     def __eq__(self, other):</font>
<font color="red">1194.         return vars(self) == vars(other)</font>
<font color="black">1195. </font>
<font color="green">1196.     def __ne__(self, other):</font>
<font color="red">1197.         return not (self == other)</font>
<font color="black">1198. </font>
<font color="green">1199.     def __contains__(self, key):</font>
<font color="red">1200.         return key in self.__dict__</font>
<font color="black">1201. </font>
<font color="black">1202. </font>
<font color="green">1203. class _ActionsContainer(object):</font>
<font color="black">1204. </font>
<font color="green">1205.     def __init__(self,</font>
<font color="black">1206.                  description,</font>
<font color="black">1207.                  prefix_chars,</font>
<font color="black">1208.                  argument_default,</font>
<font color="black">1209.                  conflict_handler):</font>
<font color="green">1210.         super(_ActionsContainer, self).__init__()</font>
<font color="black">1211. </font>
<font color="green">1212.         self.description = description</font>
<font color="green">1213.         self.argument_default = argument_default</font>
<font color="green">1214.         self.prefix_chars = prefix_chars</font>
<font color="green">1215.         self.conflict_handler = conflict_handler</font>
<font color="black">1216. </font>
<font color="black">1217.         # set up registries</font>
<font color="green">1218.         self._registries = {}</font>
<font color="black">1219. </font>
<font color="black">1220.         # register actions</font>
<font color="green">1221.         self.register('action', None, _StoreAction)</font>
<font color="green">1222.         self.register('action', 'store', _StoreAction)</font>
<font color="green">1223.         self.register('action', 'store_const', _StoreConstAction)</font>
<font color="green">1224.         self.register('action', 'store_true', _StoreTrueAction)</font>
<font color="green">1225.         self.register('action', 'store_false', _StoreFalseAction)</font>
<font color="green">1226.         self.register('action', 'append', _AppendAction)</font>
<font color="green">1227.         self.register('action', 'append_const', _AppendConstAction)</font>
<font color="green">1228.         self.register('action', 'count', _CountAction)</font>
<font color="green">1229.         self.register('action', 'help', _HelpAction)</font>
<font color="green">1230.         self.register('action', 'version', _VersionAction)</font>
<font color="green">1231.         self.register('action', 'parsers', _SubParsersAction)</font>
<font color="black">1232. </font>
<font color="black">1233.         # raise an exception if the conflict handler is invalid</font>
<font color="green">1234.         self._get_handler()</font>
<font color="black">1235. </font>
<font color="black">1236.         # action storage</font>
<font color="green">1237.         self._actions = []</font>
<font color="green">1238.         self._option_string_actions = {}</font>
<font color="black">1239. </font>
<font color="black">1240.         # groups</font>
<font color="green">1241.         self._action_groups = []</font>
<font color="green">1242.         self._mutually_exclusive_groups = []</font>
<font color="black">1243. </font>
<font color="black">1244.         # defaults storage</font>
<font color="green">1245.         self._defaults = {}</font>
<font color="black">1246. </font>
<font color="black">1247.         # determines whether an &quot;option&quot; looks like a negative number</font>
<font color="green">1248.         self._negative_number_matcher = _re.compile(r'^-\d+$|^-\d*\.\d+$')</font>
<font color="black">1249. </font>
<font color="black">1250.         # whether or not there are any optionals that look like negative</font>
<font color="black">1251.         # numbers -- uses a list so it can be shared and edited</font>
<font color="green">1252.         self._has_negative_number_optionals = []</font>
<font color="black">1253. </font>
<font color="black">1254.     # ====================</font>
<font color="black">1255.     # Registration methods</font>
<font color="black">1256.     # ====================</font>
<font color="green">1257.     def register(self, registry_name, value, object):</font>
<font color="green">1258.         registry = self._registries.setdefault(registry_name, {})</font>
<font color="green">1259.         registry[value] = object</font>
<font color="black">1260. </font>
<font color="green">1261.     def _registry_get(self, registry_name, value, default=None):</font>
<font color="green">1262.         return self._registries[registry_name].get(value, default)</font>
<font color="black">1263. </font>
<font color="black">1264.     # ==================================</font>
<font color="black">1265.     # Namespace default accessor methods</font>
<font color="black">1266.     # ==================================</font>
<font color="green">1267.     def set_defaults(self, **kwargs):</font>
<font color="red">1268.         self._defaults.update(kwargs)</font>
<font color="black">1269. </font>
<font color="black">1270.         # if these defaults match any existing arguments, replace</font>
<font color="black">1271.         # the previous default on the object with the new one</font>
<font color="red">1272.         for action in self._actions:</font>
<font color="red">1273.             if action.dest in kwargs:</font>
<font color="red">1274.                 action.default = kwargs[action.dest]</font>
<font color="black">1275. </font>
<font color="green">1276.     def get_default(self, dest):</font>
<font color="red">1277.         for action in self._actions:</font>
<font color="red">1278.             if action.dest == dest and action.default is not None:</font>
<font color="red">1279.                 return action.default</font>
<font color="red">1280.         return self._defaults.get(dest, None)</font>
<font color="black">1281. </font>
<font color="black">1282. </font>
<font color="black">1283.     # =======================</font>
<font color="black">1284.     # Adding argument actions</font>
<font color="black">1285.     # =======================</font>
<font color="green">1286.     def add_argument(self, *args, **kwargs):</font>
<font color="black">1287.         &quot;&quot;&quot;</font>
<font color="black">1288.         add_argument(dest, ..., name=value, ...)</font>
<font color="black">1289.         add_argument(option_string, option_string, ..., name=value, ...)</font>
<font color="black">1290.         &quot;&quot;&quot;</font>
<font color="black">1291. </font>
<font color="black">1292.         # if no positional args are supplied or only one is supplied and</font>
<font color="black">1293.         # it doesn't look like an option string, parse a positional</font>
<font color="black">1294.         # argument</font>
<font color="green">1295.         chars = self.prefix_chars</font>
<font color="green">1296.         if not args or len(args) == 1 and args[0][0] not in chars:</font>
<font color="red">1297.             if args and 'dest' in kwargs:</font>
<font color="red">1298.                 raise ValueError('dest supplied twice for positional argument')</font>
<font color="red">1299.             kwargs = self._get_positional_kwargs(*args, **kwargs)</font>
<font color="black">1300. </font>
<font color="black">1301.         # otherwise, we're adding an optional argument</font>
<font color="black">1302.         else:</font>
<font color="green">1303.             kwargs = self._get_optional_kwargs(*args, **kwargs)</font>
<font color="black">1304. </font>
<font color="black">1305.         # if no default was supplied, use the parser-level default</font>
<font color="green">1306.         if 'default' not in kwargs:</font>
<font color="green">1307.             dest = kwargs['dest']</font>
<font color="green">1308.             if dest in self._defaults:</font>
<font color="red">1309.                 kwargs['default'] = self._defaults[dest]</font>
<font color="green">1310.             elif self.argument_default is not None:</font>
<font color="red">1311.                 kwargs['default'] = self.argument_default</font>
<font color="black">1312. </font>
<font color="black">1313.         # create the action object, and add it to the parser</font>
<font color="green">1314.         action_class = self._pop_action_class(kwargs)</font>
<font color="green">1315.         if not _callable(action_class):</font>
<font color="red">1316.             raise ValueError('unknown action &quot;%s&quot;' % action_class)</font>
<font color="green">1317.         action = action_class(**kwargs)</font>
<font color="black">1318. </font>
<font color="black">1319.         # raise an error if the action type is not callable</font>
<font color="green">1320.         type_func = self._registry_get('type', action.type, action.type)</font>
<font color="green">1321.         if not _callable(type_func):</font>
<font color="red">1322.             raise ValueError('%r is not callable' % type_func)</font>
<font color="black">1323. </font>
<font color="green">1324.         return self._add_action(action)</font>
<font color="black">1325. </font>
<font color="green">1326.     def add_argument_group(self, *args, **kwargs):</font>
<font color="green">1327.         group = _ArgumentGroup(self, *args, **kwargs)</font>
<font color="green">1328.         self._action_groups.append(group)</font>
<font color="green">1329.         return group</font>
<font color="black">1330. </font>
<font color="green">1331.     def add_mutually_exclusive_group(self, **kwargs):</font>
<font color="red">1332.         group = _MutuallyExclusiveGroup(self, **kwargs)</font>
<font color="red">1333.         self._mutually_exclusive_groups.append(group)</font>
<font color="red">1334.         return group</font>
<font color="black">1335. </font>
<font color="green">1336.     def _add_action(self, action):</font>
<font color="black">1337.         # resolve any conflicts</font>
<font color="green">1338.         self._check_conflict(action)</font>
<font color="black">1339. </font>
<font color="black">1340.         # add to actions list</font>
<font color="green">1341.         self._actions.append(action)</font>
<font color="green">1342.         action.container = self</font>
<font color="black">1343. </font>
<font color="black">1344.         # index the action by any option strings it has</font>
<font color="green">1345.         for option_string in action.option_strings:</font>
<font color="green">1346.             self._option_string_actions[option_string] = action</font>
<font color="black">1347. </font>
<font color="black">1348.         # set the flag if any option strings look like negative numbers</font>
<font color="green">1349.         for option_string in action.option_strings:</font>
<font color="green">1350.             if self._negative_number_matcher.match(option_string):</font>
<font color="red">1351.                 if not self._has_negative_number_optionals:</font>
<font color="red">1352.                     self._has_negative_number_optionals.append(True)</font>
<font color="black">1353. </font>
<font color="black">1354.         # return the created action</font>
<font color="green">1355.         return action</font>
<font color="black">1356. </font>
<font color="green">1357.     def _remove_action(self, action):</font>
<font color="red">1358.         self._actions.remove(action)</font>
<font color="black">1359. </font>
<font color="green">1360.     def _add_container_actions(self, container):</font>
<font color="black">1361.         # collect groups by titles</font>
<font color="red">1362.         title_group_map = {}</font>
<font color="red">1363.         for group in self._action_groups:</font>
<font color="red">1364.             if group.title in title_group_map:</font>
<font color="red">1365.                 msg = _('cannot merge actions - two groups are named %r')</font>
<font color="red">1366.                 raise ValueError(msg % (group.title))</font>
<font color="red">1367.             title_group_map[group.title] = group</font>
<font color="black">1368. </font>
<font color="black">1369.         # map each action to its group</font>
<font color="red">1370.         group_map = {}</font>
<font color="red">1371.         for group in container._action_groups:</font>
<font color="black">1372. </font>
<font color="black">1373.             # if a group with the title exists, use that, otherwise</font>
<font color="black">1374.             # create a new group matching the container's group</font>
<font color="red">1375.             if group.title not in title_group_map:</font>
<font color="red">1376.                 title_group_map[group.title] = self.add_argument_group(</font>
<font color="red">1377.                     title=group.title,</font>
<font color="red">1378.                     description=group.description,</font>
<font color="red">1379.                     conflict_handler=group.conflict_handler)</font>
<font color="black">1380. </font>
<font color="black">1381.             # map the actions to their new group</font>
<font color="red">1382.             for action in group._group_actions:</font>
<font color="red">1383.                 group_map[action] = title_group_map[group.title]</font>
<font color="black">1384. </font>
<font color="black">1385.         # add container's mutually exclusive groups</font>
<font color="black">1386.         # NOTE: if add_mutually_exclusive_group ever gains title= and</font>
<font color="black">1387.         # description= then this code will need to be expanded as above</font>
<font color="red">1388.         for group in container._mutually_exclusive_groups:</font>
<font color="red">1389.             mutex_group = self.add_mutually_exclusive_group(</font>
<font color="red">1390.                 required=group.required)</font>
<font color="black">1391. </font>
<font color="black">1392.             # map the actions to their new mutex group</font>
<font color="red">1393.             for action in group._group_actions:</font>
<font color="red">1394.                 group_map[action] = mutex_group</font>
<font color="black">1395. </font>
<font color="black">1396.         # add all actions to this container or their group</font>
<font color="red">1397.         for action in container._actions:</font>
<font color="red">1398.             group_map.get(action, self)._add_action(action)</font>
<font color="black">1399. </font>
<font color="green">1400.     def _get_positional_kwargs(self, dest, **kwargs):</font>
<font color="black">1401.         # make sure required is not specified</font>
<font color="red">1402.         if 'required' in kwargs:</font>
<font color="red">1403.             msg = _(&quot;'required' is an invalid argument for positionals&quot;)</font>
<font color="red">1404.             raise TypeError(msg)</font>
<font color="black">1405. </font>
<font color="black">1406.         # mark positional arguments as required if at least one is</font>
<font color="black">1407.         # always required</font>
<font color="red">1408.         if kwargs.get('nargs') not in [OPTIONAL, ZERO_OR_MORE]:</font>
<font color="red">1409.             kwargs['required'] = True</font>
<font color="red">1410.         if kwargs.get('nargs') == ZERO_OR_MORE and 'default' not in kwargs:</font>
<font color="red">1411.             kwargs['required'] = True</font>
<font color="black">1412. </font>
<font color="black">1413.         # return the keyword arguments with no option strings</font>
<font color="red">1414.         return dict(kwargs, dest=dest, option_strings=[])</font>
<font color="black">1415. </font>
<font color="green">1416.     def _get_optional_kwargs(self, *args, **kwargs):</font>
<font color="black">1417.         # determine short and long option strings</font>
<font color="green">1418.         option_strings = []</font>
<font color="green">1419.         long_option_strings = []</font>
<font color="green">1420.         for option_string in args:</font>
<font color="black">1421.             # error on strings that don't start with an appropriate prefix</font>
<font color="green">1422.             if not option_string[0] in self.prefix_chars:</font>
<font color="red">1423.                 msg = _('invalid option string %r: '</font>
<font color="black">1424.                         'must start with a character %r')</font>
<font color="red">1425.                 tup = option_string, self.prefix_chars</font>
<font color="red">1426.                 raise ValueError(msg % tup)</font>
<font color="black">1427. </font>
<font color="black">1428.             # strings starting with two prefix characters are long options</font>
<font color="green">1429.             option_strings.append(option_string)</font>
<font color="green">1430.             if option_string[0] in self.prefix_chars:</font>
<font color="green">1431.                 if len(option_string) &gt; 1:</font>
<font color="green">1432.                     if option_string[1] in self.prefix_chars:</font>
<font color="green">1433.                         long_option_strings.append(option_string)</font>
<font color="black">1434. </font>
<font color="black">1435.         # infer destination, '--foo-bar' -&gt; 'foo_bar' and '-x' -&gt; 'x'</font>
<font color="green">1436.         dest = kwargs.pop('dest', None)</font>
<font color="green">1437.         if dest is None:</font>
<font color="green">1438.             if long_option_strings:</font>
<font color="green">1439.                 dest_option_string = long_option_strings[0]</font>
<font color="black">1440.             else:</font>
<font color="red">1441.                 dest_option_string = option_strings[0]</font>
<font color="green">1442.             dest = dest_option_string.lstrip(self.prefix_chars)</font>
<font color="green">1443.             if not dest:</font>
<font color="red">1444.                 msg = _('dest= is required for options like %r')</font>
<font color="red">1445.                 raise ValueError(msg % option_string)</font>
<font color="green">1446.             dest = dest.replace('-', '_')</font>
<font color="black">1447. </font>
<font color="black">1448.         # return the updated keyword arguments</font>
<font color="green">1449.         return dict(kwargs, dest=dest, option_strings=option_strings)</font>
<font color="black">1450. </font>
<font color="green">1451.     def _pop_action_class(self, kwargs, default=None):</font>
<font color="green">1452.         action = kwargs.pop('action', default)</font>
<font color="green">1453.         return self._registry_get('action', action, action)</font>
<font color="black">1454. </font>
<font color="green">1455.     def _get_handler(self):</font>
<font color="black">1456.         # determine function from conflict handler string</font>
<font color="green">1457.         handler_func_name = '_handle_conflict_%s' % self.conflict_handler</font>
<font color="green">1458.         try:</font>
<font color="green">1459.             return getattr(self, handler_func_name)</font>
<font color="red">1460.         except AttributeError:</font>
<font color="red">1461.             msg = _('invalid conflict_resolution value: %r')</font>
<font color="red">1462.             raise ValueError(msg % self.conflict_handler)</font>
<font color="black">1463. </font>
<font color="green">1464.     def _check_conflict(self, action):</font>
<font color="black">1465. </font>
<font color="black">1466.         # find all options that conflict with this option</font>
<font color="green">1467.         confl_optionals = []</font>
<font color="green">1468.         for option_string in action.option_strings:</font>
<font color="green">1469.             if option_string in self._option_string_actions:</font>
<font color="red">1470.                 confl_optional = self._option_string_actions[option_string]</font>
<font color="red">1471.                 confl_optionals.append((option_string, confl_optional))</font>
<font color="black">1472. </font>
<font color="black">1473.         # resolve any conflicts</font>
<font color="green">1474.         if confl_optionals:</font>
<font color="red">1475.             conflict_handler = self._get_handler()</font>
<font color="red">1476.             conflict_handler(action, confl_optionals)</font>
<font color="black">1477. </font>
<font color="green">1478.     def _handle_conflict_error(self, action, conflicting_actions):</font>
<font color="red">1479.         message = _('conflicting option string(s): %s')</font>
<font color="red">1480.         conflict_string = ', '.join([option_string</font>
<font color="black">1481.                                      for option_string, action</font>
<font color="red">1482.                                      in conflicting_actions])</font>
<font color="red">1483.         raise ArgumentError(action, message % conflict_string)</font>
<font color="black">1484. </font>
<font color="green">1485.     def _handle_conflict_resolve(self, action, conflicting_actions):</font>
<font color="black">1486. </font>
<font color="black">1487.         # remove all conflicting options</font>
<font color="red">1488.         for option_string, action in conflicting_actions:</font>
<font color="black">1489. </font>
<font color="black">1490.             # remove the conflicting option</font>
<font color="red">1491.             action.option_strings.remove(option_string)</font>
<font color="red">1492.             self._option_string_actions.pop(option_string, None)</font>
<font color="black">1493. </font>
<font color="black">1494.             # if the option now has no option string, remove it from the</font>
<font color="black">1495.             # container holding it</font>
<font color="red">1496.             if not action.option_strings:</font>
<font color="red">1497.                 action.container._remove_action(action)</font>
<font color="black">1498. </font>
<font color="black">1499. </font>
<font color="green">1500. class _ArgumentGroup(_ActionsContainer):</font>
<font color="black">1501. </font>
<font color="green">1502.     def __init__(self, container, title=None, description=None, **kwargs):</font>
<font color="black">1503.         # add any missing keyword arguments by checking the container</font>
<font color="green">1504.         update = kwargs.setdefault</font>
<font color="green">1505.         update('conflict_handler', container.conflict_handler)</font>
<font color="green">1506.         update('prefix_chars', container.prefix_chars)</font>
<font color="green">1507.         update('argument_default', container.argument_default)</font>
<font color="green">1508.         super_init = super(_ArgumentGroup, self).__init__</font>
<font color="green">1509.         super_init(description=description, **kwargs)</font>
<font color="black">1510. </font>
<font color="black">1511.         # group attributes</font>
<font color="green">1512.         self.title = title</font>
<font color="green">1513.         self._group_actions = []</font>
<font color="black">1514. </font>
<font color="black">1515.         # share most attributes with the container</font>
<font color="green">1516.         self._registries = container._registries</font>
<font color="green">1517.         self._actions = container._actions</font>
<font color="green">1518.         self._option_string_actions = container._option_string_actions</font>
<font color="green">1519.         self._defaults = container._defaults</font>
<font color="black">1520.         self._has_negative_number_optionals = \</font>
<font color="green">1521.             container._has_negative_number_optionals</font>
<font color="black">1522. </font>
<font color="green">1523.     def _add_action(self, action):</font>
<font color="green">1524.         action = super(_ArgumentGroup, self)._add_action(action)</font>
<font color="green">1525.         self._group_actions.append(action)</font>
<font color="green">1526.         return action</font>
<font color="black">1527. </font>
<font color="green">1528.     def _remove_action(self, action):</font>
<font color="red">1529.         super(_ArgumentGroup, self)._remove_action(action)</font>
<font color="red">1530.         self._group_actions.remove(action)</font>
<font color="black">1531. </font>
<font color="black">1532. </font>
<font color="green">1533. class _MutuallyExclusiveGroup(_ArgumentGroup):</font>
<font color="black">1534. </font>
<font color="green">1535.     def __init__(self, container, required=False):</font>
<font color="red">1536.         super(_MutuallyExclusiveGroup, self).__init__(container)</font>
<font color="red">1537.         self.required = required</font>
<font color="red">1538.         self._container = container</font>
<font color="black">1539. </font>
<font color="green">1540.     def _add_action(self, action):</font>
<font color="red">1541.         if action.required:</font>
<font color="red">1542.             msg = _('mutually exclusive arguments must be optional')</font>
<font color="red">1543.             raise ValueError(msg)</font>
<font color="red">1544.         action = self._container._add_action(action)</font>
<font color="red">1545.         self._group_actions.append(action)</font>
<font color="red">1546.         return action</font>
<font color="black">1547. </font>
<font color="green">1548.     def _remove_action(self, action):</font>
<font color="red">1549.         self._container._remove_action(action)</font>
<font color="red">1550.         self._group_actions.remove(action)</font>
<font color="black">1551. </font>
<font color="black">1552. </font>
<font color="green">1553. class ArgumentParser(_AttributeHolder, _ActionsContainer):</font>
<font color="black">1554.     &quot;&quot;&quot;Object for parsing command line strings into Python objects.</font>
<font color="black">1555. </font>
<font color="black">1556.     Keyword Arguments:</font>
<font color="black">1557.         - prog -- The name of the program (default: sys.argv[0])</font>
<font color="black">1558.         - usage -- A usage message (default: auto-generated from arguments)</font>
<font color="black">1559.         - description -- A description of what the program does</font>
<font color="black">1560.         - epilog -- Text following the argument descriptions</font>
<font color="black">1561.         - parents -- Parsers whose arguments should be copied into this one</font>
<font color="black">1562.         - formatter_class -- HelpFormatter class for printing help messages</font>
<font color="black">1563.         - prefix_chars -- Characters that prefix optional arguments</font>
<font color="black">1564.         - fromfile_prefix_chars -- Characters that prefix files containing</font>
<font color="black">1565.             additional arguments</font>
<font color="black">1566.         - argument_default -- The default value for all arguments</font>
<font color="black">1567.         - conflict_handler -- String indicating how to handle conflicts</font>
<font color="black">1568.         - add_help -- Add a -h/-help option</font>
<font color="green">1569.     &quot;&quot;&quot;</font>
<font color="black">1570. </font>
<font color="black">1571.     def __init__(self,</font>
<font color="green">1572.                  prog=None,</font>
<font color="green">1573.                  usage=None,</font>
<font color="green">1574.                  description=None,</font>
<font color="green">1575.                  epilog=None,</font>
<font color="green">1576.                  version=None,</font>
<font color="green">1577.                  parents=[],</font>
<font color="green">1578.                  formatter_class=HelpFormatter,</font>
<font color="green">1579.                  prefix_chars='-',</font>
<font color="green">1580.                  fromfile_prefix_chars=None,</font>
<font color="green">1581.                  argument_default=None,</font>
<font color="green">1582.                  conflict_handler='error',</font>
<font color="green">1583.                  add_help=True):</font>
<font color="black">1584. </font>
<font color="green">1585.         if version is not None:</font>
<font color="red">1586.             import warnings</font>
<font color="red">1587.             warnings.warn(</font>
<font color="red">1588.                 &quot;&quot;&quot;The &quot;version&quot; argument to ArgumentParser is deprecated. &quot;&quot;&quot;</font>
<font color="black">1589.                 &quot;&quot;&quot;Please use &quot;&quot;&quot;</font>
<font color="black">1590.                 &quot;&quot;&quot;&quot;add_argument(..., action='version', version=&quot;N&quot;, ...)&quot; &quot;&quot;&quot;</font>
<font color="red">1591.                 &quot;&quot;&quot;instead&quot;&quot;&quot;, DeprecationWarning)</font>
<font color="black">1592. </font>
<font color="green">1593.         superinit = super(ArgumentParser, self).__init__</font>
<font color="green">1594.         superinit(description=description,</font>
<font color="green">1595.                   prefix_chars=prefix_chars,</font>
<font color="green">1596.                   argument_default=argument_default,</font>
<font color="green">1597.                   conflict_handler=conflict_handler)</font>
<font color="black">1598. </font>
<font color="black">1599.         # default setting for prog</font>
<font color="green">1600.         if prog is None:</font>
<font color="green">1601.             prog = _os.path.basename(_sys.argv[0])</font>
<font color="black">1602. </font>
<font color="green">1603.         self.prog = prog</font>
<font color="green">1604.         self.usage = usage</font>
<font color="green">1605.         self.epilog = epilog</font>
<font color="green">1606.         self.version = version</font>
<font color="green">1607.         self.formatter_class = formatter_class</font>
<font color="green">1608.         self.fromfile_prefix_chars = fromfile_prefix_chars</font>
<font color="green">1609.         self.add_help = add_help</font>
<font color="black">1610. </font>
<font color="green">1611.         add_group = self.add_argument_group</font>
<font color="green">1612.         self._positionals = add_group(_('positional arguments'))</font>
<font color="green">1613.         self._optionals = add_group(_('optional arguments'))</font>
<font color="green">1614.         self._subparsers = None</font>
<font color="black">1615. </font>
<font color="black">1616.         # register types</font>
<font color="green">1617.         def identity(string):</font>
<font color="red">1618.             return string</font>
<font color="green">1619.         self.register('type', None, identity)</font>
<font color="black">1620. </font>
<font color="black">1621.         # add help and version arguments if necessary</font>
<font color="black">1622.         # (using explicit default to override global argument_default)</font>
<font color="green">1623.         if '-' in prefix_chars:</font>
<font color="green">1624.             default_prefix = '-'</font>
<font color="black">1625.         else:</font>
<font color="red">1626.             default_prefix = prefix_chars[0]</font>
<font color="green">1627.         if self.add_help:</font>
<font color="green">1628.             self.add_argument(</font>
<font color="green">1629.                 default_prefix+'h', default_prefix*2+'help',</font>
<font color="green">1630.                 action='help', default=SUPPRESS,</font>
<font color="green">1631.                 help=_('show this help message and exit'))</font>
<font color="green">1632.         if self.version:</font>
<font color="red">1633.             self.add_argument(</font>
<font color="red">1634.                 default_prefix+'v', default_prefix*2+'version',</font>
<font color="red">1635.                 action='version', default=SUPPRESS,</font>
<font color="red">1636.                 version=self.version,</font>
<font color="red">1637.                 help=_(&quot;show program's version number and exit&quot;))</font>
<font color="black">1638. </font>
<font color="black">1639.         # add parent arguments and defaults</font>
<font color="green">1640.         for parent in parents:</font>
<font color="red">1641.             self._add_container_actions(parent)</font>
<font color="red">1642.             try:</font>
<font color="red">1643.                 defaults = parent._defaults</font>
<font color="red">1644.             except AttributeError:</font>
<font color="red">1645.                 pass</font>
<font color="black">1646.             else:</font>
<font color="red">1647.                 self._defaults.update(defaults)</font>
<font color="black">1648. </font>
<font color="black">1649.     # =======================</font>
<font color="black">1650.     # Pretty __repr__ methods</font>
<font color="black">1651.     # =======================</font>
<font color="green">1652.     def _get_kwargs(self):</font>
<font color="black">1653.         names = [</font>
<font color="red">1654.             'prog',</font>
<font color="red">1655.             'usage',</font>
<font color="red">1656.             'description',</font>
<font color="red">1657.             'version',</font>
<font color="red">1658.             'formatter_class',</font>
<font color="red">1659.             'conflict_handler',</font>
<font color="red">1660.             'add_help',</font>
<font color="black">1661.         ]</font>
<font color="red">1662.         return [(name, getattr(self, name)) for name in names]</font>
<font color="black">1663. </font>
<font color="black">1664.     # ==================================</font>
<font color="black">1665.     # Optional/Positional adding methods</font>
<font color="black">1666.     # ==================================</font>
<font color="green">1667.     def add_subparsers(self, **kwargs):</font>
<font color="red">1668.         if self._subparsers is not None:</font>
<font color="red">1669.             self.error(_('cannot have multiple subparser arguments'))</font>
<font color="black">1670. </font>
<font color="black">1671.         # add the parser class to the arguments if it's not present</font>
<font color="red">1672.         kwargs.setdefault('parser_class', type(self))</font>
<font color="black">1673. </font>
<font color="red">1674.         if 'title' in kwargs or 'description' in kwargs:</font>
<font color="red">1675.             title = _(kwargs.pop('title', 'subcommands'))</font>
<font color="red">1676.             description = _(kwargs.pop('description', None))</font>
<font color="red">1677.             self._subparsers = self.add_argument_group(title, description)</font>
<font color="black">1678.         else:</font>
<font color="red">1679.             self._subparsers = self._positionals</font>
<font color="black">1680. </font>
<font color="black">1681.         # prog defaults to the usage message of this parser, skipping</font>
<font color="black">1682.         # optional arguments and with no &quot;usage:&quot; prefix</font>
<font color="red">1683.         if kwargs.get('prog') is None:</font>
<font color="red">1684.             formatter = self._get_formatter()</font>
<font color="red">1685.             positionals = self._get_positional_actions()</font>
<font color="red">1686.             groups = self._mutually_exclusive_groups</font>
<font color="red">1687.             formatter.add_usage(self.usage, positionals, groups, '')</font>
<font color="red">1688.             kwargs['prog'] = formatter.format_help().strip()</font>
<font color="black">1689. </font>
<font color="black">1690.         # create the parsers action and add it to the positionals list</font>
<font color="red">1691.         parsers_class = self._pop_action_class(kwargs, 'parsers')</font>
<font color="red">1692.         action = parsers_class(option_strings=[], **kwargs)</font>
<font color="red">1693.         self._subparsers._add_action(action)</font>
<font color="black">1694. </font>
<font color="black">1695.         # return the created parsers action</font>
<font color="red">1696.         return action</font>
<font color="black">1697. </font>
<font color="green">1698.     def _add_action(self, action):</font>
<font color="green">1699.         if action.option_strings:</font>
<font color="green">1700.             self._optionals._add_action(action)</font>
<font color="black">1701.         else:</font>
<font color="red">1702.             self._positionals._add_action(action)</font>
<font color="green">1703.         return action</font>
<font color="black">1704. </font>
<font color="green">1705.     def _get_optional_actions(self):</font>
<font color="red">1706.         return [action</font>
<font color="red">1707.                 for action in self._actions</font>
<font color="red">1708.                 if action.option_strings]</font>
<font color="black">1709. </font>
<font color="green">1710.     def _get_positional_actions(self):</font>
<font color="green">1711.         return [action</font>
<font color="green">1712.                 for action in self._actions</font>
<font color="green">1713.                 if not action.option_strings]</font>
<font color="black">1714. </font>
<font color="black">1715.     # =====================================</font>
<font color="black">1716.     # Command line argument parsing methods</font>
<font color="black">1717.     # =====================================</font>
<font color="green">1718.     def parse_args(self, args=None, namespace=None):</font>
<font color="green">1719.         args, argv = self.parse_known_args(args, namespace)</font>
<font color="green">1720.         if argv:</font>
<font color="red">1721.             msg = _('unrecognized arguments: %s')</font>
<font color="red">1722.             self.error(msg % ' '.join(argv))</font>
<font color="green">1723.         return args</font>
<font color="black">1724. </font>
<font color="green">1725.     def parse_known_args(self, args=None, namespace=None):</font>
<font color="black">1726.         # args default to the system args</font>
<font color="green">1727.         if args is None:</font>
<font color="green">1728.             args = _sys.argv[1:]</font>
<font color="black">1729. </font>
<font color="black">1730.         # default Namespace built from parser defaults</font>
<font color="green">1731.         if namespace is None:</font>
<font color="green">1732.             namespace = Namespace()</font>
<font color="black">1733. </font>
<font color="black">1734.         # add any action defaults that aren't present</font>
<font color="green">1735.         for action in self._actions:</font>
<font color="green">1736.             if action.dest is not SUPPRESS:</font>
<font color="green">1737.                 if not hasattr(namespace, action.dest):</font>
<font color="green">1738.                     if action.default is not SUPPRESS:</font>
<font color="green">1739.                         default = action.default</font>
<font color="green">1740.                         if isinstance(action.default, basestring):</font>
<font color="red">1741.                             default = self._get_value(action, default)</font>
<font color="green">1742.                         setattr(namespace, action.dest, default)</font>
<font color="black">1743. </font>
<font color="black">1744.         # add any parser defaults that aren't present</font>
<font color="green">1745.         for dest in self._defaults:</font>
<font color="red">1746.             if not hasattr(namespace, dest):</font>
<font color="red">1747.                 setattr(namespace, dest, self._defaults[dest])</font>
<font color="black">1748. </font>
<font color="black">1749.         # parse the arguments and exit if there are any errors</font>
<font color="green">1750.         try:</font>
<font color="green">1751.             namespace, args = self._parse_known_args(args, namespace)</font>
<font color="green">1752.             if hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR):</font>
<font color="red">1753.                 args.extend(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR))</font>
<font color="red">1754.                 delattr(namespace, _UNRECOGNIZED_ARGS_ATTR)</font>
<font color="green">1755.             return namespace, args</font>
<font color="red">1756.         except ArgumentError:</font>
<font color="red">1757.             err = _sys.exc_info()[1]</font>
<font color="red">1758.             self.error(str(err))</font>
<font color="black">1759. </font>
<font color="green">1760.     def _parse_known_args(self, arg_strings, namespace):</font>
<font color="black">1761.         # replace arg strings that are file references</font>
<font color="green">1762.         if self.fromfile_prefix_chars is not None:</font>
<font color="red">1763.             arg_strings = self._read_args_from_files(arg_strings)</font>
<font color="black">1764. </font>
<font color="black">1765.         # map all mutually exclusive arguments to the other arguments</font>
<font color="black">1766.         # they can't occur with</font>
<font color="green">1767.         action_conflicts = {}</font>
<font color="green">1768.         for mutex_group in self._mutually_exclusive_groups:</font>
<font color="red">1769.             group_actions = mutex_group._group_actions</font>
<font color="red">1770.             for i, mutex_action in enumerate(mutex_group._group_actions):</font>
<font color="red">1771.                 conflicts = action_conflicts.setdefault(mutex_action, [])</font>
<font color="red">1772.                 conflicts.extend(group_actions[:i])</font>
<font color="red">1773.                 conflicts.extend(group_actions[i + 1:])</font>
<font color="black">1774. </font>
<font color="black">1775.         # find all option indices, and determine the arg_string_pattern</font>
<font color="black">1776.         # which has an 'O' if there is an option at an index,</font>
<font color="black">1777.         # an 'A' if there is an argument, or a '-' if there is a '--'</font>
<font color="green">1778.         option_string_indices = {}</font>
<font color="green">1779.         arg_string_pattern_parts = []</font>
<font color="green">1780.         arg_strings_iter = iter(arg_strings)</font>
<font color="green">1781.         for i, arg_string in enumerate(arg_strings_iter):</font>
<font color="black">1782. </font>
<font color="black">1783.             # all args after -- are non-options</font>
<font color="green">1784.             if arg_string == '--':</font>
<font color="red">1785.                 arg_string_pattern_parts.append('-')</font>
<font color="red">1786.                 for arg_string in arg_strings_iter:</font>
<font color="red">1787.                     arg_string_pattern_parts.append('A')</font>
<font color="black">1788. </font>
<font color="black">1789.             # otherwise, add the arg to the arg strings</font>
<font color="black">1790.             # and note the index if it was an option</font>
<font color="black">1791.             else:</font>
<font color="green">1792.                 option_tuple = self._parse_optional(arg_string)</font>
<font color="green">1793.                 if option_tuple is None:</font>
<font color="green">1794.                     pattern = 'A'</font>
<font color="black">1795.                 else:</font>
<font color="green">1796.                     option_string_indices[i] = option_tuple</font>
<font color="green">1797.                     pattern = 'O'</font>
<font color="green">1798.                 arg_string_pattern_parts.append(pattern)</font>
<font color="black">1799. </font>
<font color="black">1800.         # join the pieces together to form the pattern</font>
<font color="green">1801.         arg_strings_pattern = ''.join(arg_string_pattern_parts)</font>
<font color="black">1802. </font>
<font color="black">1803.         # converts arg strings to the appropriate and then takes the action</font>
<font color="green">1804.         seen_actions = set()</font>
<font color="green">1805.         seen_non_default_actions = set()</font>
<font color="black">1806. </font>
<font color="green">1807.         def take_action(action, argument_strings, option_string=None):</font>
<font color="green">1808.             seen_actions.add(action)</font>
<font color="green">1809.             argument_values = self._get_values(action, argument_strings)</font>
<font color="black">1810. </font>
<font color="black">1811.             # error if this argument is not allowed with other previously</font>
<font color="black">1812.             # seen arguments, assuming that actions that use the default</font>
<font color="black">1813.             # value don't really count as &quot;present&quot;</font>
<font color="green">1814.             if argument_values is not action.default:</font>
<font color="green">1815.                 seen_non_default_actions.add(action)</font>
<font color="green">1816.                 for conflict_action in action_conflicts.get(action, []):</font>
<font color="red">1817.                     if conflict_action in seen_non_default_actions:</font>
<font color="red">1818.                         msg = _('not allowed with argument %s')</font>
<font color="red">1819.                         action_name = _get_action_name(conflict_action)</font>
<font color="red">1820.                         raise ArgumentError(action, msg % action_name)</font>
<font color="black">1821. </font>
<font color="black">1822.             # take the action if we didn't receive a SUPPRESS value</font>
<font color="black">1823.             # (e.g. from a default)</font>
<font color="green">1824.             if argument_values is not SUPPRESS:</font>
<font color="green">1825.                 action(self, namespace, argument_values, option_string)</font>
<font color="black">1826. </font>
<font color="black">1827.         # function to convert arg_strings into an optional action</font>
<font color="green">1828.         def consume_optional(start_index):</font>
<font color="black">1829. </font>
<font color="black">1830.             # get the optional identified at this index</font>
<font color="green">1831.             option_tuple = option_string_indices[start_index]</font>
<font color="green">1832.             action, option_string, explicit_arg = option_tuple</font>
<font color="black">1833. </font>
<font color="black">1834.             # identify additional optionals in the same arg string</font>
<font color="black">1835.             # (e.g. -xyz is the same as -x -y -z if no args are required)</font>
<font color="green">1836.             match_argument = self._match_argument</font>
<font color="green">1837.             action_tuples = []</font>
<font color="green">1838.             while True:</font>
<font color="black">1839. </font>
<font color="black">1840.                 # if we found no optional action, skip it</font>
<font color="green">1841.                 if action is None:</font>
<font color="red">1842.                     extras.append(arg_strings[start_index])</font>
<font color="red">1843.                     return start_index + 1</font>
<font color="black">1844. </font>
<font color="black">1845.                 # if there is an explicit argument, try to match the</font>
<font color="black">1846.                 # optional's string arguments to only this</font>
<font color="green">1847.                 if explicit_arg is not None:</font>
<font color="red">1848.                     arg_count = match_argument(action, 'A')</font>
<font color="black">1849. </font>
<font color="black">1850.                     # if the action is a single-dash option and takes no</font>
<font color="black">1851.                     # arguments, try to parse more single-dash options out</font>
<font color="black">1852.                     # of the tail of the option string</font>
<font color="red">1853.                     chars = self.prefix_chars</font>
<font color="red">1854.                     if arg_count == 0 and option_string[1] not in chars:</font>
<font color="red">1855.                         action_tuples.append((action, [], option_string))</font>
<font color="red">1856.                         char = option_string[0]</font>
<font color="red">1857.                         option_string = char + explicit_arg[0]</font>
<font color="red">1858.                         new_explicit_arg = explicit_arg[1:] or None</font>
<font color="red">1859.                         optionals_map = self._option_string_actions</font>
<font color="red">1860.                         if option_string in optionals_map:</font>
<font color="red">1861.                             action = optionals_map[option_string]</font>
<font color="red">1862.                             explicit_arg = new_explicit_arg</font>
<font color="black">1863.                         else:</font>
<font color="red">1864.                             msg = _('ignored explicit argument %r')</font>
<font color="red">1865.                             raise ArgumentError(action, msg % explicit_arg)</font>
<font color="black">1866. </font>
<font color="black">1867.                     # if the action expect exactly one argument, we've</font>
<font color="black">1868.                     # successfully matched the option; exit the loop</font>
<font color="red">1869.                     elif arg_count == 1:</font>
<font color="red">1870.                         stop = start_index + 1</font>
<font color="red">1871.                         args = [explicit_arg]</font>
<font color="red">1872.                         action_tuples.append((action, args, option_string))</font>
<font color="red">1873.                         break</font>
<font color="black">1874. </font>
<font color="black">1875.                     # error if a double-dash option did not use the</font>
<font color="black">1876.                     # explicit argument</font>
<font color="black">1877.                     else:</font>
<font color="red">1878.                         msg = _('ignored explicit argument %r')</font>
<font color="red">1879.                         raise ArgumentError(action, msg % explicit_arg)</font>
<font color="black">1880. </font>
<font color="black">1881.                 # if there is no explicit argument, try to match the</font>
<font color="black">1882.                 # optional's string arguments with the following strings</font>
<font color="black">1883.                 # if successful, exit the loop</font>
<font color="black">1884.                 else:</font>
<font color="green">1885.                     start = start_index + 1</font>
<font color="green">1886.                     selected_patterns = arg_strings_pattern[start:]</font>
<font color="green">1887.                     arg_count = match_argument(action, selected_patterns)</font>
<font color="green">1888.                     stop = start + arg_count</font>
<font color="green">1889.                     args = arg_strings[start:stop]</font>
<font color="green">1890.                     action_tuples.append((action, args, option_string))</font>
<font color="green">1891.                     break</font>
<font color="black">1892. </font>
<font color="black">1893.             # add the Optional to the list and return the index at which</font>
<font color="black">1894.             # the Optional's string args stopped</font>
<font color="green">1895.             assert action_tuples</font>
<font color="green">1896.             for action, args, option_string in action_tuples:</font>
<font color="green">1897.                 take_action(action, args, option_string)</font>
<font color="green">1898.             return stop</font>
<font color="black">1899. </font>
<font color="black">1900.         # the list of Positionals left to be parsed; this is modified</font>
<font color="black">1901.         # by consume_positionals()</font>
<font color="green">1902.         positionals = self._get_positional_actions()</font>
<font color="black">1903. </font>
<font color="black">1904.         # function to convert arg_strings into positional actions</font>
<font color="green">1905.         def consume_positionals(start_index):</font>
<font color="black">1906.             # match as many Positionals as possible</font>
<font color="green">1907.             match_partial = self._match_arguments_partial</font>
<font color="green">1908.             selected_pattern = arg_strings_pattern[start_index:]</font>
<font color="green">1909.             arg_counts = match_partial(positionals, selected_pattern)</font>
<font color="black">1910. </font>
<font color="black">1911.             # slice off the appropriate arg strings for each Positional</font>
<font color="black">1912.             # and add the Positional and its args to the list</font>
<font color="green">1913.             for action, arg_count in zip(positionals, arg_counts):</font>
<font color="red">1914.                 args = arg_strings[start_index: start_index + arg_count]</font>
<font color="red">1915.                 start_index += arg_count</font>
<font color="red">1916.                 take_action(action, args)</font>
<font color="black">1917. </font>
<font color="black">1918.             # slice off the Positionals that we just parsed and return the</font>
<font color="black">1919.             # index at which the Positionals' string args stopped</font>
<font color="green">1920.             positionals[:] = positionals[len(arg_counts):]</font>
<font color="green">1921.             return start_index</font>
<font color="black">1922. </font>
<font color="black">1923.         # consume Positionals and Optionals alternately, until we have</font>
<font color="black">1924.         # passed the last option string</font>
<font color="green">1925.         extras = []</font>
<font color="green">1926.         start_index = 0</font>
<font color="green">1927.         if option_string_indices:</font>
<font color="green">1928.             max_option_string_index = max(option_string_indices)</font>
<font color="black">1929.         else:</font>
<font color="red">1930.             max_option_string_index = -1</font>
<font color="green">1931.         while start_index &lt;= max_option_string_index:</font>
<font color="black">1932. </font>
<font color="black">1933.             # consume any Positionals preceding the next option</font>
<font color="green">1934.             next_option_string_index = min([</font>
<font color="green">1935.                 index</font>
<font color="green">1936.                 for index in option_string_indices</font>
<font color="green">1937.                 if index &gt;= start_index])</font>
<font color="green">1938.             if start_index != next_option_string_index:</font>
<font color="red">1939.                 positionals_end_index = consume_positionals(start_index)</font>
<font color="black">1940. </font>
<font color="black">1941.                 # only try to parse the next optional if we didn't consume</font>
<font color="black">1942.                 # the option string during the positionals parsing</font>
<font color="red">1943.                 if positionals_end_index &gt; start_index:</font>
<font color="red">1944.                     start_index = positionals_end_index</font>
<font color="red">1945.                     continue</font>
<font color="black">1946.                 else:</font>
<font color="red">1947.                     start_index = positionals_end_index</font>
<font color="black">1948. </font>
<font color="black">1949.             # if we consumed all the positionals we could and we're not</font>
<font color="black">1950.             # at the index of an option string, there were extra arguments</font>
<font color="green">1951.             if start_index not in option_string_indices:</font>
<font color="red">1952.                 strings = arg_strings[start_index:next_option_string_index]</font>
<font color="red">1953.                 extras.extend(strings)</font>
<font color="red">1954.                 start_index = next_option_string_index</font>
<font color="black">1955. </font>
<font color="black">1956.             # consume the next optional and any arguments for it</font>
<font color="green">1957.             start_index = consume_optional(start_index)</font>
<font color="black">1958. </font>
<font color="black">1959.         # consume any positionals following the last Optional</font>
<font color="green">1960.         stop_index = consume_positionals(start_index)</font>
<font color="black">1961. </font>
<font color="black">1962.         # if we didn't consume all the argument strings, there were extras</font>
<font color="green">1963.         extras.extend(arg_strings[stop_index:])</font>
<font color="black">1964. </font>
<font color="black">1965.         # if we didn't use all the Positional objects, there were too few</font>
<font color="black">1966.         # arg strings supplied.</font>
<font color="green">1967.         if positionals:</font>
<font color="red">1968.             self.error(_('too few arguments'))</font>
<font color="black">1969. </font>
<font color="black">1970.         # make sure all required actions were present</font>
<font color="green">1971.         for action in self._actions:</font>
<font color="green">1972.             if action.required:</font>
<font color="red">1973.                 if action not in seen_actions:</font>
<font color="red">1974.                     name = _get_action_name(action)</font>
<font color="red">1975.                     self.error(_('argument %s is required') % name)</font>
<font color="black">1976. </font>
<font color="black">1977.         # make sure all required groups had one option present</font>
<font color="green">1978.         for group in self._mutually_exclusive_groups:</font>
<font color="red">1979.             if group.required:</font>
<font color="red">1980.                 for action in group._group_actions:</font>
<font color="red">1981.                     if action in seen_non_default_actions:</font>
<font color="red">1982.                         break</font>
<font color="black">1983. </font>
<font color="black">1984.                 # if no actions were used, report the error</font>
<font color="black">1985.                 else:</font>
<font color="red">1986.                     names = [_get_action_name(action)</font>
<font color="red">1987.                              for action in group._group_actions</font>
<font color="red">1988.                              if action.help is not SUPPRESS]</font>
<font color="red">1989.                     msg = _('one of the arguments %s is required')</font>
<font color="red">1990.                     self.error(msg % ' '.join(names))</font>
<font color="black">1991. </font>
<font color="black">1992.         # return the updated namespace and the extra arguments</font>
<font color="green">1993.         return namespace, extras</font>
<font color="black">1994. </font>
<font color="green">1995.     def _read_args_from_files(self, arg_strings):</font>
<font color="black">1996.         # expand arguments referencing files</font>
<font color="red">1997.         new_arg_strings = []</font>
<font color="red">1998.         for arg_string in arg_strings:</font>
<font color="black">1999. </font>
<font color="black">2000.             # for regular arguments, just add them back into the list</font>
<font color="red">2001.             if arg_string[0] not in self.fromfile_prefix_chars:</font>
<font color="red">2002.                 new_arg_strings.append(arg_string)</font>
<font color="black">2003. </font>
<font color="black">2004.             # replace arguments referencing files with the file content</font>
<font color="black">2005.             else:</font>
<font color="red">2006.                 try:</font>
<font color="red">2007.                     args_file = open(arg_string[1:])</font>
<font color="red">2008.                     try:</font>
<font color="red">2009.                         arg_strings = []</font>
<font color="red">2010.                         for arg_line in args_file.read().splitlines():</font>
<font color="red">2011.                             for arg in self.convert_arg_line_to_args(arg_line):</font>
<font color="red">2012.                                 arg_strings.append(arg)</font>
<font color="red">2013.                         arg_strings = self._read_args_from_files(arg_strings)</font>
<font color="red">2014.                         new_arg_strings.extend(arg_strings)</font>
<font color="black">2015.                     finally:</font>
<font color="red">2016.                         args_file.close()</font>
<font color="red">2017.                 except IOError:</font>
<font color="red">2018.                     err = _sys.exc_info()[1]</font>
<font color="red">2019.                     self.error(str(err))</font>
<font color="black">2020. </font>
<font color="black">2021.         # return the modified argument list</font>
<font color="red">2022.         return new_arg_strings</font>
<font color="black">2023. </font>
<font color="green">2024.     def convert_arg_line_to_args(self, arg_line):</font>
<font color="red">2025.         return [arg_line]</font>
<font color="black">2026. </font>
<font color="green">2027.     def _match_argument(self, action, arg_strings_pattern):</font>
<font color="black">2028.         # match the pattern for this action to the arg strings</font>
<font color="green">2029.         nargs_pattern = self._get_nargs_pattern(action)</font>
<font color="green">2030.         match = _re.match(nargs_pattern, arg_strings_pattern)</font>
<font color="black">2031. </font>
<font color="black">2032.         # raise an exception if we weren't able to find a match</font>
<font color="green">2033.         if match is None:</font>
<font color="red">2034.             nargs_errors = {</font>
<font color="red">2035.                 None: _('expected one argument'),</font>
<font color="red">2036.                 OPTIONAL: _('expected at most one argument'),</font>
<font color="red">2037.                 ONE_OR_MORE: _('expected at least one argument'),</font>
<font color="black">2038.             }</font>
<font color="red">2039.             default = _('expected %s argument(s)') % action.nargs</font>
<font color="red">2040.             msg = nargs_errors.get(action.nargs, default)</font>
<font color="red">2041.             raise ArgumentError(action, msg)</font>
<font color="black">2042. </font>
<font color="black">2043.         # return the number of arguments matched</font>
<font color="green">2044.         return len(match.group(1))</font>
<font color="black">2045. </font>
<font color="green">2046.     def _match_arguments_partial(self, actions, arg_strings_pattern):</font>
<font color="black">2047.         # progressively shorten the actions list by slicing off the</font>
<font color="black">2048.         # final actions until we find a match</font>
<font color="green">2049.         result = []</font>
<font color="green">2050.         for i in range(len(actions), 0, -1):</font>
<font color="red">2051.             actions_slice = actions[:i]</font>
<font color="red">2052.             pattern = ''.join([self._get_nargs_pattern(action)</font>
<font color="red">2053.                                for action in actions_slice])</font>
<font color="red">2054.             match = _re.match(pattern, arg_strings_pattern)</font>
<font color="red">2055.             if match is not None:</font>
<font color="red">2056.                 result.extend([len(string) for string in match.groups()])</font>
<font color="red">2057.                 break</font>
<font color="black">2058. </font>
<font color="black">2059.         # return the list of arg string counts</font>
<font color="green">2060.         return result</font>
<font color="black">2061. </font>
<font color="green">2062.     def _parse_optional(self, arg_string):</font>
<font color="black">2063.         # if it's an empty string, it was meant to be a positional</font>
<font color="green">2064.         if not arg_string:</font>
<font color="red">2065.             return None</font>
<font color="black">2066. </font>
<font color="black">2067.         # if it doesn't start with a prefix, it was meant to be positional</font>
<font color="green">2068.         if not arg_string[0] in self.prefix_chars:</font>
<font color="green">2069.             return None</font>
<font color="black">2070. </font>
<font color="black">2071.         # if the option string is present in the parser, return the action</font>
<font color="green">2072.         if arg_string in self._option_string_actions:</font>
<font color="green">2073.             action = self._option_string_actions[arg_string]</font>
<font color="green">2074.             return action, arg_string, None</font>
<font color="black">2075. </font>
<font color="black">2076.         # if it's just a single character, it was meant to be positional</font>
<font color="red">2077.         if len(arg_string) == 1:</font>
<font color="red">2078.             return None</font>
<font color="black">2079. </font>
<font color="black">2080.         # if the option string before the &quot;=&quot; is present, return the action</font>
<font color="red">2081.         if '=' in arg_string:</font>
<font color="red">2082.             option_string, explicit_arg = arg_string.split('=', 1)</font>
<font color="red">2083.             if option_string in self._option_string_actions:</font>
<font color="red">2084.                 action = self._option_string_actions[option_string]</font>
<font color="red">2085.                 return action, option_string, explicit_arg</font>
<font color="black">2086. </font>
<font color="black">2087.         # search through all possible prefixes of the option string</font>
<font color="black">2088.         # and all actions in the parser for possible interpretations</font>
<font color="red">2089.         option_tuples = self._get_option_tuples(arg_string)</font>
<font color="black">2090. </font>
<font color="black">2091.         # if multiple actions match, the option string was ambiguous</font>
<font color="red">2092.         if len(option_tuples) &gt; 1:</font>
<font color="red">2093.             options = ', '.join([option_string</font>
<font color="red">2094.                 for action, option_string, explicit_arg in option_tuples])</font>
<font color="red">2095.             tup = arg_string, options</font>
<font color="red">2096.             self.error(_('ambiguous option: %s could match %s') % tup)</font>
<font color="black">2097. </font>
<font color="black">2098.         # if exactly one action matched, this segmentation is good,</font>
<font color="black">2099.         # so return the parsed action</font>
<font color="red">2100.         elif len(option_tuples) == 1:</font>
<font color="red">2101.             option_tuple, = option_tuples</font>
<font color="red">2102.             return option_tuple</font>
<font color="black">2103. </font>
<font color="black">2104.         # if it was not found as an option, but it looks like a negative</font>
<font color="black">2105.         # number, it was meant to be positional</font>
<font color="black">2106.         # unless there are negative-number-like options</font>
<font color="red">2107.         if self._negative_number_matcher.match(arg_string):</font>
<font color="red">2108.             if not self._has_negative_number_optionals:</font>
<font color="red">2109.                 return None</font>
<font color="black">2110. </font>
<font color="black">2111.         # if it contains a space, it was meant to be a positional</font>
<font color="red">2112.         if ' ' in arg_string:</font>
<font color="red">2113.             return None</font>
<font color="black">2114. </font>
<font color="black">2115.         # it was meant to be an optional but there is no such option</font>
<font color="black">2116.         # in this parser (though it might be a valid option in a subparser)</font>
<font color="red">2117.         return None, arg_string, None</font>
<font color="black">2118. </font>
<font color="green">2119.     def _get_option_tuples(self, option_string):</font>
<font color="red">2120.         result = []</font>
<font color="black">2121. </font>
<font color="black">2122.         # option strings starting with two prefix characters are only</font>
<font color="black">2123.         # split at the '='</font>
<font color="red">2124.         chars = self.prefix_chars</font>
<font color="red">2125.         if option_string[0] in chars and option_string[1] in chars:</font>
<font color="red">2126.             if '=' in option_string:</font>
<font color="red">2127.                 option_prefix, explicit_arg = option_string.split('=', 1)</font>
<font color="black">2128.             else:</font>
<font color="red">2129.                 option_prefix = option_string</font>
<font color="red">2130.                 explicit_arg = None</font>
<font color="red">2131.             for option_string in self._option_string_actions:</font>
<font color="red">2132.                 if option_string.startswith(option_prefix):</font>
<font color="red">2133.                     action = self._option_string_actions[option_string]</font>
<font color="red">2134.                     tup = action, option_string, explicit_arg</font>
<font color="red">2135.                     result.append(tup)</font>
<font color="black">2136. </font>
<font color="black">2137.         # single character options can be concatenated with their arguments</font>
<font color="black">2138.         # but multiple character options always have to have their argument</font>
<font color="black">2139.         # separate</font>
<font color="red">2140.         elif option_string[0] in chars and option_string[1] not in chars:</font>
<font color="red">2141.             option_prefix = option_string</font>
<font color="red">2142.             explicit_arg = None</font>
<font color="red">2143.             short_option_prefix = option_string[:2]</font>
<font color="red">2144.             short_explicit_arg = option_string[2:]</font>
<font color="black">2145. </font>
<font color="red">2146.             for option_string in self._option_string_actions:</font>
<font color="red">2147.                 if option_string == short_option_prefix:</font>
<font color="red">2148.                     action = self._option_string_actions[option_string]</font>
<font color="red">2149.                     tup = action, option_string, short_explicit_arg</font>
<font color="red">2150.                     result.append(tup)</font>
<font color="red">2151.                 elif option_string.startswith(option_prefix):</font>
<font color="red">2152.                     action = self._option_string_actions[option_string]</font>
<font color="red">2153.                     tup = action, option_string, explicit_arg</font>
<font color="red">2154.                     result.append(tup)</font>
<font color="black">2155. </font>
<font color="black">2156.         # shouldn't ever get here</font>
<font color="black">2157.         else:</font>
<font color="red">2158.             self.error(_('unexpected option string: %s') % option_string)</font>
<font color="black">2159. </font>
<font color="black">2160.         # return the collected option tuples</font>
<font color="red">2161.         return result</font>
<font color="black">2162. </font>
<font color="green">2163.     def _get_nargs_pattern(self, action):</font>
<font color="black">2164.         # in all examples below, we have to allow for '--' args</font>
<font color="black">2165.         # which are represented as '-' in the pattern</font>
<font color="green">2166.         nargs = action.nargs</font>
<font color="black">2167. </font>
<font color="black">2168.         # the default (None) is assumed to be a single argument</font>
<font color="green">2169.         if nargs is None:</font>
<font color="green">2170.             nargs_pattern = '(-*A-*)'</font>
<font color="black">2171. </font>
<font color="black">2172.         # allow zero or one arguments</font>
<font color="green">2173.         elif nargs == OPTIONAL:</font>
<font color="red">2174.             nargs_pattern = '(-*A?-*)'</font>
<font color="black">2175. </font>
<font color="black">2176.         # allow zero or more arguments</font>
<font color="green">2177.         elif nargs == ZERO_OR_MORE:</font>
<font color="red">2178.             nargs_pattern = '(-*[A-]*)'</font>
<font color="black">2179. </font>
<font color="black">2180.         # allow one or more arguments</font>
<font color="green">2181.         elif nargs == ONE_OR_MORE:</font>
<font color="green">2182.             nargs_pattern = '(-*A[A-]*)'</font>
<font color="black">2183. </font>
<font color="black">2184.         # allow any number of options or arguments</font>
<font color="red">2185.         elif nargs == REMAINDER:</font>
<font color="red">2186.             nargs_pattern = '([-AO]*)'</font>
<font color="black">2187. </font>
<font color="black">2188.         # allow one argument followed by any number of options or arguments</font>
<font color="red">2189.         elif nargs == PARSER:</font>
<font color="red">2190.             nargs_pattern = '(-*A[-AO]*)'</font>
<font color="black">2191. </font>
<font color="black">2192.         # all others should be integers</font>
<font color="black">2193.         else:</font>
<font color="red">2194.             nargs_pattern = '(-*%s-*)' % '-*'.join('A' * nargs)</font>
<font color="black">2195. </font>
<font color="black">2196.         # if this is an optional action, -- is not allowed</font>
<font color="green">2197.         if action.option_strings:</font>
<font color="green">2198.             nargs_pattern = nargs_pattern.replace('-*', '')</font>
<font color="green">2199.             nargs_pattern = nargs_pattern.replace('-', '')</font>
<font color="black">2200. </font>
<font color="black">2201.         # return the pattern</font>
<font color="green">2202.         return nargs_pattern</font>
<font color="black">2203. </font>
<font color="black">2204.     # ========================</font>
<font color="black">2205.     # Value conversion methods</font>
<font color="black">2206.     # ========================</font>
<font color="green">2207.     def _get_values(self, action, arg_strings):</font>
<font color="black">2208.         # for everything but PARSER args, strip out '--'</font>
<font color="green">2209.         if action.nargs not in [PARSER, REMAINDER]:</font>
<font color="green">2210.             arg_strings = [s for s in arg_strings if s != '--']</font>
<font color="black">2211. </font>
<font color="black">2212.         # optional argument produces a default when not present</font>
<font color="green">2213.         if not arg_strings and action.nargs == OPTIONAL:</font>
<font color="red">2214.             if action.option_strings:</font>
<font color="red">2215.                 value = action.const</font>
<font color="black">2216.             else:</font>
<font color="red">2217.                 value = action.default</font>
<font color="red">2218.             if isinstance(value, basestring):</font>
<font color="red">2219.                 value = self._get_value(action, value)</font>
<font color="red">2220.                 self._check_value(action, value)</font>
<font color="black">2221. </font>
<font color="black">2222.         # when nargs='*' on a positional, if there were no command-line</font>
<font color="black">2223.         # args, use the default if it is anything other than None</font>
<font color="green">2224.         elif (not arg_strings and action.nargs == ZERO_OR_MORE and</font>
<font color="red">2225.               not action.option_strings):</font>
<font color="red">2226.             if action.default is not None:</font>
<font color="red">2227.                 value = action.default</font>
<font color="black">2228.             else:</font>
<font color="red">2229.                 value = arg_strings</font>
<font color="red">2230.             self._check_value(action, value)</font>
<font color="black">2231. </font>
<font color="black">2232.         # single argument or optional argument produces a single value</font>
<font color="green">2233.         elif len(arg_strings) == 1 and action.nargs in [None, OPTIONAL]:</font>
<font color="green">2234.             arg_string, = arg_strings</font>
<font color="green">2235.             value = self._get_value(action, arg_string)</font>
<font color="green">2236.             self._check_value(action, value)</font>
<font color="black">2237. </font>
<font color="black">2238.         # REMAINDER arguments convert all values, checking none</font>
<font color="green">2239.         elif action.nargs == REMAINDER:</font>
<font color="red">2240.             value = [self._get_value(action, v) for v in arg_strings]</font>
<font color="black">2241. </font>
<font color="black">2242.         # PARSER arguments convert all values, but check only the first</font>
<font color="green">2243.         elif action.nargs == PARSER:</font>
<font color="red">2244.             value = [self._get_value(action, v) for v in arg_strings]</font>
<font color="red">2245.             self._check_value(action, value[0])</font>
<font color="black">2246. </font>
<font color="black">2247.         # all other types of nargs produce a list</font>
<font color="black">2248.         else:</font>
<font color="green">2249.             value = [self._get_value(action, v) for v in arg_strings]</font>
<font color="green">2250.             for v in value:</font>
<font color="green">2251.                 self._check_value(action, v)</font>
<font color="black">2252. </font>
<font color="black">2253.         # return the converted value</font>
<font color="green">2254.         return value</font>
<font color="black">2255. </font>
<font color="green">2256.     def _get_value(self, action, arg_string):</font>
<font color="green">2257.         type_func = self._registry_get('type', action.type, action.type)</font>
<font color="green">2258.         if not _callable(type_func):</font>
<font color="red">2259.             msg = _('%r is not callable')</font>
<font color="red">2260.             raise ArgumentError(action, msg % type_func)</font>
<font color="black">2261. </font>
<font color="black">2262.         # convert the value to the appropriate type</font>
<font color="green">2263.         try:</font>
<font color="green">2264.             result = type_func(arg_string)</font>
<font color="black">2265. </font>
<font color="black">2266.         # ArgumentTypeErrors indicate errors</font>
<font color="red">2267.         except ArgumentTypeError:</font>
<font color="red">2268.             name = getattr(action.type, '__name__', repr(action.type))</font>
<font color="red">2269.             msg = str(_sys.exc_info()[1])</font>
<font color="red">2270.             raise ArgumentError(action, msg)</font>
<font color="black">2271. </font>
<font color="black">2272.         # TypeErrors or ValueErrors also indicate errors</font>
<font color="red">2273.         except (TypeError, ValueError):</font>
<font color="red">2274.             name = getattr(action.type, '__name__', repr(action.type))</font>
<font color="red">2275.             msg = _('invalid %s value: %r')</font>
<font color="red">2276.             raise ArgumentError(action, msg % (name, arg_string))</font>
<font color="black">2277. </font>
<font color="black">2278.         # return the converted value</font>
<font color="green">2279.         return result</font>
<font color="black">2280. </font>
<font color="green">2281.     def _check_value(self, action, value):</font>
<font color="black">2282.         # converted value must be one of the choices (if specified)</font>
<font color="green">2283.         if action.choices is not None and value not in action.choices:</font>
<font color="red">2284.             tup = value, ', '.join(map(repr, action.choices))</font>
<font color="red">2285.             msg = _('invalid choice: %r (choose from %s)') % tup</font>
<font color="red">2286.             raise ArgumentError(action, msg)</font>
<font color="black">2287. </font>
<font color="black">2288.     # =======================</font>
<font color="black">2289.     # Help-formatting methods</font>
<font color="black">2290.     # =======================</font>
<font color="green">2291.     def format_usage(self):</font>
<font color="red">2292.         formatter = self._get_formatter()</font>
<font color="red">2293.         formatter.add_usage(self.usage, self._actions,</font>
<font color="red">2294.                             self._mutually_exclusive_groups)</font>
<font color="red">2295.         return formatter.format_help()</font>
<font color="black">2296. </font>
<font color="green">2297.     def format_help(self):</font>
<font color="red">2298.         formatter = self._get_formatter()</font>
<font color="black">2299. </font>
<font color="black">2300.         # usage</font>
<font color="red">2301.         formatter.add_usage(self.usage, self._actions,</font>
<font color="red">2302.                             self._mutually_exclusive_groups)</font>
<font color="black">2303. </font>
<font color="black">2304.         # description</font>
<font color="red">2305.         formatter.add_text(self.description)</font>
<font color="black">2306. </font>
<font color="black">2307.         # positionals, optionals and user-defined groups</font>
<font color="red">2308.         for action_group in self._action_groups:</font>
<font color="red">2309.             formatter.start_section(action_group.title)</font>
<font color="red">2310.             formatter.add_text(action_group.description)</font>
<font color="red">2311.             formatter.add_arguments(action_group._group_actions)</font>
<font color="red">2312.             formatter.end_section()</font>
<font color="black">2313. </font>
<font color="black">2314.         # epilog</font>
<font color="red">2315.         formatter.add_text(self.epilog)</font>
<font color="black">2316. </font>
<font color="black">2317.         # determine help from format above</font>
<font color="red">2318.         return formatter.format_help()</font>
<font color="black">2319. </font>
<font color="green">2320.     def format_version(self):</font>
<font color="red">2321.         import warnings</font>
<font color="red">2322.         warnings.warn(</font>
<font color="red">2323.             'The format_version method is deprecated -- the &quot;version&quot; '</font>
<font color="black">2324.             'argument to ArgumentParser is no longer supported.',</font>
<font color="red">2325.             DeprecationWarning)</font>
<font color="red">2326.         formatter = self._get_formatter()</font>
<font color="red">2327.         formatter.add_text(self.version)</font>
<font color="red">2328.         return formatter.format_help()</font>
<font color="black">2329. </font>
<font color="green">2330.     def _get_formatter(self):</font>
<font color="red">2331.         return self.formatter_class(prog=self.prog)</font>
<font color="black">2332. </font>
<font color="black">2333.     # =====================</font>
<font color="black">2334.     # Help-printing methods</font>
<font color="black">2335.     # =====================</font>
<font color="green">2336.     def print_usage(self, file=None):</font>
<font color="red">2337.         if file is None:</font>
<font color="red">2338.             file = _sys.stdout</font>
<font color="red">2339.         self._print_message(self.format_usage(), file)</font>
<font color="black">2340. </font>
<font color="green">2341.     def print_help(self, file=None):</font>
<font color="red">2342.         if file is None:</font>
<font color="red">2343.             file = _sys.stdout</font>
<font color="red">2344.         self._print_message(self.format_help(), file)</font>
<font color="black">2345. </font>
<font color="green">2346.     def print_version(self, file=None):</font>
<font color="red">2347.         import warnings</font>
<font color="red">2348.         warnings.warn(</font>
<font color="red">2349.             'The print_version method is deprecated -- the &quot;version&quot; '</font>
<font color="black">2350.             'argument to ArgumentParser is no longer supported.',</font>
<font color="red">2351.             DeprecationWarning)</font>
<font color="red">2352.         self._print_message(self.format_version(), file)</font>
<font color="black">2353. </font>
<font color="green">2354.     def _print_message(self, message, file=None):</font>
<font color="red">2355.         if message:</font>
<font color="red">2356.             if file is None:</font>
<font color="red">2357.                 file = _sys.stderr</font>
<font color="red">2358.             file.write(message)</font>
<font color="black">2359. </font>
<font color="black">2360.     # ===============</font>
<font color="black">2361.     # Exiting methods</font>
<font color="black">2362.     # ===============</font>
<font color="green">2363.     def exit(self, status=0, message=None):</font>
<font color="red">2364.         if message:</font>
<font color="red">2365.             self._print_message(message, _sys.stderr)</font>
<font color="red">2366.         _sys.exit(status)</font>
<font color="black">2367. </font>
<font color="green">2368.     def error(self, message):</font>
<font color="black">2369.         &quot;&quot;&quot;error(message: string)</font>
<font color="black">2370. </font>
<font color="black">2371.         Prints a usage message incorporating the message to stderr and</font>
<font color="black">2372.         exits.</font>
<font color="black">2373. </font>
<font color="black">2374.         If you override this in a subclass, it should not return -- it</font>
<font color="black">2375.         should either exit or raise an exception.</font>
<font color="black">2376.         &quot;&quot;&quot;</font>
<font color="red">2377.         self.print_usage(_sys.stderr)</font>
<font color="red">2378.         self.exit(2, _('%s: error: %s\n') % (self.prog, message))</font>
</pre>

