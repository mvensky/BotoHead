source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/sessions.py</b><br>


file stats: <b>311 lines, 111 executed: 35.7% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. </font>
<font color="black">   3. &quot;&quot;&quot;</font>
<font color="black">   4. requests.session</font>
<font color="black">   5. ~~~~~~~~~~~~~~~~</font>
<font color="black">   6. </font>
<font color="black">   7. This module provides a Session object to manage and persist settings across</font>
<font color="black">   8. requests (cookies, auth, proxies).</font>
<font color="black">   9. </font>
<font color="green">  10. &quot;&quot;&quot;</font>
<font color="green">  11. import os</font>
<font color="green">  12. from collections import Mapping</font>
<font color="green">  13. from datetime import datetime</font>
<font color="black">  14. </font>
<font color="green">  15. from .auth import _basic_auth_str</font>
<font color="green">  16. from .compat import cookielib, OrderedDict, urljoin, urlparse</font>
<font color="green">  17. from .cookies import (</font>
<font color="black">  18.     cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)</font>
<font color="green">  19. from .models import Request, PreparedRequest, DEFAULT_REDIRECT_LIMIT</font>
<font color="green">  20. from .hooks import default_hooks, dispatch_hook</font>
<font color="green">  21. from .utils import to_key_val_list, default_headers, to_native_string</font>
<font color="green">  22. from .exceptions import (</font>
<font color="black">  23.     TooManyRedirects, InvalidSchema, ChunkedEncodingError, ContentDecodingError)</font>
<font color="green">  24. from .packages.urllib3._collections import RecentlyUsedContainer</font>
<font color="green">  25. from .structures import CaseInsensitiveDict</font>
<font color="black">  26. </font>
<font color="green">  27. from .adapters import HTTPAdapter</font>
<font color="black">  28. </font>
<font color="green">  29. from .utils import (</font>
<font color="black">  30.     requote_uri, get_environ_proxies, get_netrc_auth, should_bypass_proxies,</font>
<font color="black">  31.     get_auth_from_url</font>
<font color="black">  32. )</font>
<font color="black">  33. </font>
<font color="green">  34. from .status_codes import codes</font>
<font color="black">  35. </font>
<font color="black">  36. # formerly defined here, reexposed here for backward compatibility</font>
<font color="green">  37. from .models import REDIRECT_STATI</font>
<font color="black">  38. </font>
<font color="green">  39. REDIRECT_CACHE_SIZE = 1000</font>
<font color="black">  40. </font>
<font color="black">  41. </font>
<font color="green">  42. def merge_setting(request_setting, session_setting, dict_class=OrderedDict):</font>
<font color="black">  43.     &quot;&quot;&quot;</font>
<font color="black">  44.     Determines appropriate setting for a given request, taking into account the</font>
<font color="black">  45.     explicit setting on that request, and the setting in the session. If a</font>
<font color="black">  46.     setting is a dictionary, they will be merged together using `dict_class`</font>
<font color="black">  47.     &quot;&quot;&quot;</font>
<font color="black">  48. </font>
<font color="red">  49.     if session_setting is None:</font>
<font color="red">  50.         return request_setting</font>
<font color="black">  51. </font>
<font color="red">  52.     if request_setting is None:</font>
<font color="red">  53.         return session_setting</font>
<font color="black">  54. </font>
<font color="black">  55.     # Bypass if not a dictionary (e.g. verify)</font>
<font color="black">  56.     if not (</font>
<font color="red">  57.             isinstance(session_setting, Mapping) and</font>
<font color="red">  58.             isinstance(request_setting, Mapping)</font>
<font color="black">  59.     ):</font>
<font color="red">  60.         return request_setting</font>
<font color="black">  61. </font>
<font color="red">  62.     merged_setting = dict_class(to_key_val_list(session_setting))</font>
<font color="red">  63.     merged_setting.update(to_key_val_list(request_setting))</font>
<font color="black">  64. </font>
<font color="black">  65.     # Remove keys that are set to None.</font>
<font color="red">  66.     for (k, v) in request_setting.items():</font>
<font color="red">  67.         if v is None:</font>
<font color="red">  68.             del merged_setting[k]</font>
<font color="black">  69. </font>
<font color="red">  70.     merged_setting = dict((k, v) for (k, v) in merged_setting.items() if v is not None)</font>
<font color="black">  71. </font>
<font color="red">  72.     return merged_setting</font>
<font color="black">  73. </font>
<font color="black">  74. </font>
<font color="green">  75. def merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):</font>
<font color="black">  76.     &quot;&quot;&quot;</font>
<font color="black">  77.     Properly merges both requests and session hooks.</font>
<font color="black">  78. </font>
<font color="black">  79.     This is necessary because when request_hooks == {'response': []}, the</font>
<font color="black">  80.     merge breaks Session hooks entirely.</font>
<font color="black">  81.     &quot;&quot;&quot;</font>
<font color="red">  82.     if session_hooks is None or session_hooks.get('response') == []:</font>
<font color="red">  83.         return request_hooks</font>
<font color="black">  84. </font>
<font color="red">  85.     if request_hooks is None or request_hooks.get('response') == []:</font>
<font color="red">  86.         return session_hooks</font>
<font color="black">  87. </font>
<font color="red">  88.     return merge_setting(request_hooks, session_hooks, dict_class)</font>
<font color="black">  89. </font>
<font color="black">  90. </font>
<font color="green">  91. class SessionRedirectMixin(object):</font>
<font color="green">  92.     def resolve_redirects(self, resp, req, stream=False, timeout=None,</font>
<font color="green">  93.                           verify=True, cert=None, proxies=None, **adapter_kwargs):</font>
<font color="black">  94.         &quot;&quot;&quot;Receives a Response. Returns a generator of Responses.&quot;&quot;&quot;</font>
<font color="black">  95. </font>
<font color="green">  96.         i = 0</font>
<font color="green">  97.         hist = [] # keep track of history</font>
<font color="black">  98. </font>
<font color="green">  99.         while resp.is_redirect:</font>
<font color="red"> 100.             prepared_request = req.copy()</font>
<font color="black"> 101. </font>
<font color="red"> 102.             if i &gt; 0:</font>
<font color="black"> 103.                 # Update history and keep track of redirects.</font>
<font color="red"> 104.                 hist.append(resp)</font>
<font color="red"> 105.                 new_hist = list(hist)</font>
<font color="red"> 106.                 resp.history = new_hist</font>
<font color="black"> 107. </font>
<font color="red"> 108.             try:</font>
<font color="red"> 109.                 resp.content  # Consume socket so it can be released</font>
<font color="red"> 110.             except (ChunkedEncodingError, ContentDecodingError, RuntimeError):</font>
<font color="red"> 111.                 resp.raw.read(decode_content=False)</font>
<font color="black"> 112. </font>
<font color="red"> 113.             if i &gt;= self.max_redirects:</font>
<font color="red"> 114.                 raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)</font>
<font color="black"> 115. </font>
<font color="black"> 116.             # Release the connection back into the pool.</font>
<font color="red"> 117.             resp.close()</font>
<font color="black"> 118. </font>
<font color="red"> 119.             url = resp.headers['location']</font>
<font color="red"> 120.             method = req.method</font>
<font color="black"> 121. </font>
<font color="black"> 122.             # Handle redirection without scheme (see: RFC 1808 Section 4)</font>
<font color="red"> 123.             if url.startswith('//'):</font>
<font color="red"> 124.                 parsed_rurl = urlparse(resp.url)</font>
<font color="red"> 125.                 url = '%s:%s' % (parsed_rurl.scheme, url)</font>
<font color="black"> 126. </font>
<font color="black"> 127.             # The scheme should be lower case...</font>
<font color="red"> 128.             parsed = urlparse(url)</font>
<font color="red"> 129.             url = parsed.geturl()</font>
<font color="black"> 130. </font>
<font color="black"> 131.             # Facilitate relative 'location' headers, as allowed by RFC 7231.</font>
<font color="black"> 132.             # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')</font>
<font color="black"> 133.             # Compliant with RFC3986, we percent encode the url.</font>
<font color="red"> 134.             if not parsed.netloc:</font>
<font color="red"> 135.                 url = urljoin(resp.url, requote_uri(url))</font>
<font color="black"> 136.             else:</font>
<font color="red"> 137.                 url = requote_uri(url)</font>
<font color="black"> 138. </font>
<font color="red"> 139.             prepared_request.url = to_native_string(url)</font>
<font color="black"> 140.             # Cache the url, unless it redirects to itself.</font>
<font color="red"> 141.             if resp.is_permanent_redirect and req.url != prepared_request.url:</font>
<font color="red"> 142.                 self.redirect_cache[req.url] = prepared_request.url</font>
<font color="black"> 143. </font>
<font color="black"> 144.             # http://tools.ietf.org/html/rfc7231#section-6.4.4</font>
<font color="red"> 145.             if (resp.status_code == codes.see_other and</font>
<font color="red"> 146.                     method != 'HEAD'):</font>
<font color="red"> 147.                 method = 'GET'</font>
<font color="black"> 148. </font>
<font color="black"> 149.             # Do what the browsers do, despite standards...</font>
<font color="black"> 150.             # First, turn 302s into GETs.</font>
<font color="red"> 151.             if resp.status_code == codes.found and method != 'HEAD':</font>
<font color="red"> 152.                 method = 'GET'</font>
<font color="black"> 153. </font>
<font color="black"> 154.             # Second, if a POST is responded to with a 301, turn it into a GET.</font>
<font color="black"> 155.             # This bizarre behaviour is explained in Issue 1704.</font>
<font color="red"> 156.             if resp.status_code == codes.moved and method == 'POST':</font>
<font color="red"> 157.                 method = 'GET'</font>
<font color="black"> 158. </font>
<font color="red"> 159.             prepared_request.method = method</font>
<font color="black"> 160. </font>
<font color="black"> 161.             # https://github.com/kennethreitz/requests/issues/1084</font>
<font color="red"> 162.             if resp.status_code not in (codes.temporary_redirect, codes.permanent_redirect):</font>
<font color="red"> 163.                 if 'Content-Length' in prepared_request.headers:</font>
<font color="red"> 164.                     del prepared_request.headers['Content-Length']</font>
<font color="black"> 165. </font>
<font color="red"> 166.                 prepared_request.body = None</font>
<font color="black"> 167. </font>
<font color="red"> 168.             headers = prepared_request.headers</font>
<font color="red"> 169.             try:</font>
<font color="red"> 170.                 del headers['Cookie']</font>
<font color="red"> 171.             except KeyError:</font>
<font color="red"> 172.                 pass</font>
<font color="black"> 173. </font>
<font color="black"> 174.             # Extract any cookies sent on the response to the cookiejar</font>
<font color="black"> 175.             # in the new request. Because we've mutated our copied prepared</font>
<font color="black"> 176.             # request, use the old one that we haven't yet touched.</font>
<font color="red"> 177.             extract_cookies_to_jar(prepared_request._cookies, req, resp.raw)</font>
<font color="red"> 178.             prepared_request._cookies.update(self.cookies)</font>
<font color="red"> 179.             prepared_request.prepare_cookies(prepared_request._cookies)</font>
<font color="black"> 180. </font>
<font color="black"> 181.             # Rebuild auth and proxy information.</font>
<font color="red"> 182.             proxies = self.rebuild_proxies(prepared_request, proxies)</font>
<font color="red"> 183.             self.rebuild_auth(prepared_request, resp)</font>
<font color="black"> 184. </font>
<font color="black"> 185.             # Override the original request.</font>
<font color="red"> 186.             req = prepared_request</font>
<font color="black"> 187. </font>
<font color="red"> 188.             resp = self.send(</font>
<font color="red"> 189.                 req,</font>
<font color="red"> 190.                 stream=stream,</font>
<font color="red"> 191.                 timeout=timeout,</font>
<font color="red"> 192.                 verify=verify,</font>
<font color="red"> 193.                 cert=cert,</font>
<font color="red"> 194.                 proxies=proxies,</font>
<font color="red"> 195.                 allow_redirects=False,</font>
<font color="red"> 196.                 **adapter_kwargs</font>
<font color="black"> 197.             )</font>
<font color="black"> 198. </font>
<font color="red"> 199.             extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)</font>
<font color="black"> 200. </font>
<font color="red"> 201.             i += 1</font>
<font color="red"> 202.             yield resp</font>
<font color="black"> 203. </font>
<font color="green"> 204.     def rebuild_auth(self, prepared_request, response):</font>
<font color="black"> 205.         &quot;&quot;&quot;</font>
<font color="black"> 206.         When being redirected we may want to strip authentication from the</font>
<font color="black"> 207.         request to avoid leaking credentials. This method intelligently removes</font>
<font color="black"> 208.         and reapplies authentication where possible to avoid credential loss.</font>
<font color="black"> 209.         &quot;&quot;&quot;</font>
<font color="red"> 210.         headers = prepared_request.headers</font>
<font color="red"> 211.         url = prepared_request.url</font>
<font color="black"> 212. </font>
<font color="red"> 213.         if 'Authorization' in headers:</font>
<font color="black"> 214.             # If we get redirected to a new host, we should strip out any</font>
<font color="black"> 215.             # authentication headers.</font>
<font color="red"> 216.             original_parsed = urlparse(response.request.url)</font>
<font color="red"> 217.             redirect_parsed = urlparse(url)</font>
<font color="black"> 218. </font>
<font color="red"> 219.             if (original_parsed.hostname != redirect_parsed.hostname):</font>
<font color="red"> 220.                 del headers['Authorization']</font>
<font color="black"> 221. </font>
<font color="black"> 222.         # .netrc might have more auth for us on our new host.</font>
<font color="red"> 223.         new_auth = get_netrc_auth(url) if self.trust_env else None</font>
<font color="red"> 224.         if new_auth is not None:</font>
<font color="red"> 225.             prepared_request.prepare_auth(new_auth)</font>
<font color="black"> 226. </font>
<font color="red"> 227.         return</font>
<font color="black"> 228. </font>
<font color="green"> 229.     def rebuild_proxies(self, prepared_request, proxies):</font>
<font color="black"> 230.         &quot;&quot;&quot;</font>
<font color="black"> 231.         This method re-evaluates the proxy configuration by considering the</font>
<font color="black"> 232.         environment variables. If we are redirected to a URL covered by</font>
<font color="black"> 233.         NO_PROXY, we strip the proxy configuration. Otherwise, we set missing</font>
<font color="black"> 234.         proxy keys for this URL (in case they were stripped by a previous</font>
<font color="black"> 235.         redirect).</font>
<font color="black"> 236. </font>
<font color="black"> 237.         This method also replaces the Proxy-Authorization header where</font>
<font color="black"> 238.         necessary.</font>
<font color="black"> 239.         &quot;&quot;&quot;</font>
<font color="red"> 240.         headers = prepared_request.headers</font>
<font color="red"> 241.         url = prepared_request.url</font>
<font color="red"> 242.         scheme = urlparse(url).scheme</font>
<font color="red"> 243.         new_proxies = proxies.copy() if proxies is not None else {}</font>
<font color="black"> 244. </font>
<font color="red"> 245.         if self.trust_env and not should_bypass_proxies(url):</font>
<font color="red"> 246.             environ_proxies = get_environ_proxies(url)</font>
<font color="black"> 247. </font>
<font color="red"> 248.             proxy = environ_proxies.get(scheme)</font>
<font color="black"> 249. </font>
<font color="red"> 250.             if proxy:</font>
<font color="red"> 251.                 new_proxies.setdefault(scheme, environ_proxies[scheme])</font>
<font color="black"> 252. </font>
<font color="red"> 253.         if 'Proxy-Authorization' in headers:</font>
<font color="red"> 254.             del headers['Proxy-Authorization']</font>
<font color="black"> 255. </font>
<font color="red"> 256.         try:</font>
<font color="red"> 257.             username, password = get_auth_from_url(new_proxies[scheme])</font>
<font color="red"> 258.         except KeyError:</font>
<font color="red"> 259.             username, password = None, None</font>
<font color="black"> 260. </font>
<font color="red"> 261.         if username and password:</font>
<font color="red"> 262.             headers['Proxy-Authorization'] = _basic_auth_str(username, password)</font>
<font color="black"> 263. </font>
<font color="red"> 264.         return new_proxies</font>
<font color="black"> 265. </font>
<font color="black"> 266. </font>
<font color="green"> 267. class Session(SessionRedirectMixin):</font>
<font color="black"> 268.     &quot;&quot;&quot;A Requests session.</font>
<font color="black"> 269. </font>
<font color="black"> 270.     Provides cookie persistence, connection-pooling, and configuration.</font>
<font color="black"> 271. </font>
<font color="black"> 272.     Basic Usage::</font>
<font color="black"> 273. </font>
<font color="black"> 274.       &gt;&gt;&gt; import requests</font>
<font color="black"> 275.       &gt;&gt;&gt; s = requests.Session()</font>
<font color="black"> 276.       &gt;&gt;&gt; s.get('http://httpbin.org/get')</font>
<font color="black"> 277.       200</font>
<font color="green"> 278.     &quot;&quot;&quot;</font>
<font color="black"> 279. </font>
<font color="black"> 280.     __attrs__ = [</font>
<font color="green"> 281.         'headers', 'cookies', 'auth', 'proxies', 'hooks', 'params', 'verify',</font>
<font color="green"> 282.         'cert', 'prefetch', 'adapters', 'stream', 'trust_env',</font>
<font color="green"> 283.         'max_redirects',</font>
<font color="black"> 284.     ]</font>
<font color="black"> 285. </font>
<font color="green"> 286.     def __init__(self):</font>
<font color="black"> 287. </font>
<font color="black"> 288.         #: A case-insensitive dictionary of headers to be sent on each</font>
<font color="black"> 289.         #: :class:`Request &lt;Request&gt;` sent from this</font>
<font color="black"> 290.         #: :class:`Session &lt;Session&gt;`.</font>
<font color="green"> 291.         self.headers = default_headers()</font>
<font color="black"> 292. </font>
<font color="black"> 293.         #: Default Authentication tuple or object to attach to</font>
<font color="black"> 294.         #: :class:`Request &lt;Request&gt;`.</font>
<font color="green"> 295.         self.auth = None</font>
<font color="black"> 296. </font>
<font color="black"> 297.         #: Dictionary mapping protocol to the URL of the proxy (e.g.</font>
<font color="black"> 298.         #: {'http': 'foo.bar:3128'}) to be used on each</font>
<font color="black"> 299.         #: :class:`Request &lt;Request&gt;`.</font>
<font color="green"> 300.         self.proxies = {}</font>
<font color="black"> 301. </font>
<font color="black"> 302.         #: Event-handling hooks.</font>
<font color="green"> 303.         self.hooks = default_hooks()</font>
<font color="black"> 304. </font>
<font color="black"> 305.         #: Dictionary of querystring data to attach to each</font>
<font color="black"> 306.         #: :class:`Request &lt;Request&gt;`. The dictionary values may be lists for</font>
<font color="black"> 307.         #: representing multivalued query parameters.</font>
<font color="green"> 308.         self.params = {}</font>
<font color="black"> 309. </font>
<font color="black"> 310.         #: Stream response content default.</font>
<font color="green"> 311.         self.stream = False</font>
<font color="black"> 312. </font>
<font color="black"> 313.         #: SSL Verification default.</font>
<font color="green"> 314.         self.verify = True</font>
<font color="black"> 315. </font>
<font color="black"> 316.         #: SSL certificate default.</font>
<font color="green"> 317.         self.cert = None</font>
<font color="black"> 318. </font>
<font color="black"> 319.         #: Maximum number of redirects allowed. If the request exceeds this</font>
<font color="black"> 320.         #: limit, a :class:`TooManyRedirects` exception is raised.</font>
<font color="green"> 321.         self.max_redirects = DEFAULT_REDIRECT_LIMIT</font>
<font color="black"> 322. </font>
<font color="black"> 323.         #: Should we trust the environment?</font>
<font color="green"> 324.         self.trust_env = True</font>
<font color="black"> 325. </font>
<font color="black"> 326.         #: A CookieJar containing all currently outstanding cookies set on this</font>
<font color="black"> 327.         #: session. By default it is a</font>
<font color="black"> 328.         #: :class:`RequestsCookieJar &lt;requests.cookies.RequestsCookieJar&gt;`, but</font>
<font color="black"> 329.         #: may be any other ``cookielib.CookieJar`` compatible object.</font>
<font color="green"> 330.         self.cookies = cookiejar_from_dict({})</font>
<font color="black"> 331. </font>
<font color="black"> 332.         # Default connection adapters.</font>
<font color="green"> 333.         self.adapters = OrderedDict()</font>
<font color="green"> 334.         self.mount('https://', HTTPAdapter())</font>
<font color="green"> 335.         self.mount('http://', HTTPAdapter())</font>
<font color="black"> 336. </font>
<font color="black"> 337.         # Only store 1000 redirects to prevent using infinite memory</font>
<font color="green"> 338.         self.redirect_cache = RecentlyUsedContainer(REDIRECT_CACHE_SIZE)</font>
<font color="black"> 339. </font>
<font color="green"> 340.     def __enter__(self):</font>
<font color="red"> 341.         return self</font>
<font color="black"> 342. </font>
<font color="green"> 343.     def __exit__(self, *args):</font>
<font color="red"> 344.         self.close()</font>
<font color="black"> 345. </font>
<font color="green"> 346.     def prepare_request(self, request):</font>
<font color="black"> 347.         &quot;&quot;&quot;Constructs a :class:`PreparedRequest &lt;PreparedRequest&gt;` for</font>
<font color="black"> 348.         transmission and returns it. The :class:`PreparedRequest` has settings</font>
<font color="black"> 349.         merged from the :class:`Request &lt;Request&gt;` instance and those of the</font>
<font color="black"> 350.         :class:`Session`.</font>
<font color="black"> 351. </font>
<font color="black"> 352.         :param request: :class:`Request` instance to prepare with this</font>
<font color="black"> 353.             session's settings.</font>
<font color="black"> 354.         &quot;&quot;&quot;</font>
<font color="red"> 355.         cookies = request.cookies or {}</font>
<font color="black"> 356. </font>
<font color="black"> 357.         # Bootstrap CookieJar.</font>
<font color="red"> 358.         if not isinstance(cookies, cookielib.CookieJar):</font>
<font color="red"> 359.             cookies = cookiejar_from_dict(cookies)</font>
<font color="black"> 360. </font>
<font color="black"> 361.         # Merge with session cookies</font>
<font color="red"> 362.         merged_cookies = merge_cookies(</font>
<font color="red"> 363.             merge_cookies(RequestsCookieJar(), self.cookies), cookies)</font>
<font color="black"> 364. </font>
<font color="black"> 365. </font>
<font color="black"> 366.         # Set environment's basic authentication if not explicitly set.</font>
<font color="red"> 367.         auth = request.auth</font>
<font color="red"> 368.         if self.trust_env and not auth and not self.auth:</font>
<font color="red"> 369.             auth = get_netrc_auth(request.url)</font>
<font color="black"> 370. </font>
<font color="red"> 371.         p = PreparedRequest()</font>
<font color="red"> 372.         p.prepare(</font>
<font color="red"> 373.             method=request.method.upper(),</font>
<font color="red"> 374.             url=request.url,</font>
<font color="red"> 375.             files=request.files,</font>
<font color="red"> 376.             data=request.data,</font>
<font color="red"> 377.             json=request.json,</font>
<font color="red"> 378.             headers=merge_setting(request.headers, self.headers, dict_class=CaseInsensitiveDict),</font>
<font color="red"> 379.             params=merge_setting(request.params, self.params),</font>
<font color="red"> 380.             auth=merge_setting(auth, self.auth),</font>
<font color="red"> 381.             cookies=merged_cookies,</font>
<font color="red"> 382.             hooks=merge_hooks(request.hooks, self.hooks),</font>
<font color="black"> 383.         )</font>
<font color="red"> 384.         return p</font>
<font color="black"> 385. </font>
<font color="black"> 386.     def request(self, method, url,</font>
<font color="green"> 387.         params=None,</font>
<font color="green"> 388.         data=None,</font>
<font color="green"> 389.         headers=None,</font>
<font color="green"> 390.         cookies=None,</font>
<font color="green"> 391.         files=None,</font>
<font color="green"> 392.         auth=None,</font>
<font color="green"> 393.         timeout=None,</font>
<font color="green"> 394.         allow_redirects=True,</font>
<font color="green"> 395.         proxies=None,</font>
<font color="green"> 396.         hooks=None,</font>
<font color="green"> 397.         stream=None,</font>
<font color="green"> 398.         verify=None,</font>
<font color="green"> 399.         cert=None,</font>
<font color="green"> 400.         json=None):</font>
<font color="black"> 401.         &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.</font>
<font color="black"> 402.         Returns :class:`Response &lt;Response&gt;` object.</font>
<font color="black"> 403. </font>
<font color="black"> 404.         :param method: method for the new :class:`Request` object.</font>
<font color="black"> 405.         :param url: URL for the new :class:`Request` object.</font>
<font color="black"> 406.         :param params: (optional) Dictionary or bytes to be sent in the query</font>
<font color="black"> 407.             string for the :class:`Request`.</font>
<font color="black"> 408.         :param data: (optional) Dictionary or bytes to send in the body of the</font>
<font color="black"> 409.             :class:`Request`.</font>
<font color="black"> 410.         :param json: (optional) json to send in the body of the</font>
<font color="black"> 411.             :class:`Request`.</font>
<font color="black"> 412.         :param headers: (optional) Dictionary of HTTP Headers to send with the</font>
<font color="black"> 413.             :class:`Request`.</font>
<font color="black"> 414.         :param cookies: (optional) Dict or CookieJar object to send with the</font>
<font color="black"> 415.             :class:`Request`.</font>
<font color="black"> 416.         :param files: (optional) Dictionary of ``'filename': file-like-objects``</font>
<font color="black"> 417.             for multipart encoding upload.</font>
<font color="black"> 418.         :param auth: (optional) Auth tuple or callable to enable</font>
<font color="black"> 419.             Basic/Digest/Custom HTTP Auth.</font>
<font color="black"> 420.         :param timeout: (optional) How long to wait for the server to send</font>
<font color="black"> 421.             data before giving up, as a float, or a (`connect timeout, read</font>
<font color="black"> 422.             timeout &lt;user/advanced.html#timeouts&gt;`_) tuple.</font>
<font color="black"> 423.         :type timeout: float or tuple</font>
<font color="black"> 424.         :param allow_redirects: (optional) Set to True by default.</font>
<font color="black"> 425.         :type allow_redirects: bool</font>
<font color="black"> 426.         :param proxies: (optional) Dictionary mapping protocol to the URL of</font>
<font color="black"> 427.             the proxy.</font>
<font color="black"> 428.         :param stream: (optional) whether to immediately download the response</font>
<font color="black"> 429.             content. Defaults to ``False``.</font>
<font color="black"> 430.         :param verify: (optional) if ``True``, the SSL cert will be verified.</font>
<font color="black"> 431.             A CA_BUNDLE path can also be provided.</font>
<font color="black"> 432.         :param cert: (optional) if String, path to ssl client cert file (.pem).</font>
<font color="black"> 433.             If Tuple, ('cert', 'key') pair.</font>
<font color="black"> 434.         &quot;&quot;&quot;</font>
<font color="black"> 435. </font>
<font color="red"> 436.         method = to_native_string(method)</font>
<font color="black"> 437. </font>
<font color="black"> 438.         # Create the Request.</font>
<font color="red"> 439.         req = Request(</font>
<font color="red"> 440.             method = method.upper(),</font>
<font color="red"> 441.             url = url,</font>
<font color="red"> 442.             headers = headers,</font>
<font color="red"> 443.             files = files,</font>
<font color="red"> 444.             data = data or {},</font>
<font color="red"> 445.             json = json,</font>
<font color="red"> 446.             params = params or {},</font>
<font color="red"> 447.             auth = auth,</font>
<font color="red"> 448.             cookies = cookies,</font>
<font color="red"> 449.             hooks = hooks,</font>
<font color="black"> 450.         )</font>
<font color="red"> 451.         prep = self.prepare_request(req)</font>
<font color="black"> 452. </font>
<font color="red"> 453.         proxies = proxies or {}</font>
<font color="black"> 454. </font>
<font color="red"> 455.         settings = self.merge_environment_settings(</font>
<font color="red"> 456.             prep.url, proxies, stream, verify, cert</font>
<font color="black"> 457.         )</font>
<font color="black"> 458. </font>
<font color="black"> 459.         # Send the request.</font>
<font color="red"> 460.         send_kwargs = {</font>
<font color="red"> 461.             'timeout': timeout,</font>
<font color="red"> 462.             'allow_redirects': allow_redirects,</font>
<font color="black"> 463.         }</font>
<font color="red"> 464.         send_kwargs.update(settings)</font>
<font color="red"> 465.         resp = self.send(prep, **send_kwargs)</font>
<font color="black"> 466. </font>
<font color="red"> 467.         return resp</font>
<font color="black"> 468. </font>
<font color="green"> 469.     def get(self, url, **kwargs):</font>
<font color="black"> 470.         &quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object.</font>
<font color="black"> 471. </font>
<font color="black"> 472.         :param url: URL for the new :class:`Request` object.</font>
<font color="black"> 473.         :param \*\*kwargs: Optional arguments that ``request`` takes.</font>
<font color="black"> 474.         &quot;&quot;&quot;</font>
<font color="black"> 475. </font>
<font color="red"> 476.         kwargs.setdefault('allow_redirects', True)</font>
<font color="red"> 477.         return self.request('GET', url, **kwargs)</font>
<font color="black"> 478. </font>
<font color="green"> 479.     def options(self, url, **kwargs):</font>
<font color="black"> 480.         &quot;&quot;&quot;Sends a OPTIONS request. Returns :class:`Response` object.</font>
<font color="black"> 481. </font>
<font color="black"> 482.         :param url: URL for the new :class:`Request` object.</font>
<font color="black"> 483.         :param \*\*kwargs: Optional arguments that ``request`` takes.</font>
<font color="black"> 484.         &quot;&quot;&quot;</font>
<font color="black"> 485. </font>
<font color="red"> 486.         kwargs.setdefault('allow_redirects', True)</font>
<font color="red"> 487.         return self.request('OPTIONS', url, **kwargs)</font>
<font color="black"> 488. </font>
<font color="green"> 489.     def head(self, url, **kwargs):</font>
<font color="black"> 490.         &quot;&quot;&quot;Sends a HEAD request. Returns :class:`Response` object.</font>
<font color="black"> 491. </font>
<font color="black"> 492.         :param url: URL for the new :class:`Request` object.</font>
<font color="black"> 493.         :param \*\*kwargs: Optional arguments that ``request`` takes.</font>
<font color="black"> 494.         &quot;&quot;&quot;</font>
<font color="black"> 495. </font>
<font color="red"> 496.         kwargs.setdefault('allow_redirects', False)</font>
<font color="red"> 497.         return self.request('HEAD', url, **kwargs)</font>
<font color="black"> 498. </font>
<font color="green"> 499.     def post(self, url, data=None, json=None, **kwargs):</font>
<font color="black"> 500.         &quot;&quot;&quot;Sends a POST request. Returns :class:`Response` object.</font>
<font color="black"> 501. </font>
<font color="black"> 502.         :param url: URL for the new :class:`Request` object.</font>
<font color="black"> 503.         :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.</font>
<font color="black"> 504.         :param json: (optional) json to send in the body of the :class:`Request`.</font>
<font color="black"> 505.         :param \*\*kwargs: Optional arguments that ``request`` takes.</font>
<font color="black"> 506.         &quot;&quot;&quot;</font>
<font color="black"> 507. </font>
<font color="red"> 508.         return self.request('POST', url, data=data, json=json, **kwargs)</font>
<font color="black"> 509. </font>
<font color="green"> 510.     def put(self, url, data=None, **kwargs):</font>
<font color="black"> 511.         &quot;&quot;&quot;Sends a PUT request. Returns :class:`Response` object.</font>
<font color="black"> 512. </font>
<font color="black"> 513.         :param url: URL for the new :class:`Request` object.</font>
<font color="black"> 514.         :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.</font>
<font color="black"> 515.         :param \*\*kwargs: Optional arguments that ``request`` takes.</font>
<font color="black"> 516.         &quot;&quot;&quot;</font>
<font color="black"> 517. </font>
<font color="red"> 518.         return self.request('PUT', url, data=data, **kwargs)</font>
<font color="black"> 519. </font>
<font color="green"> 520.     def patch(self, url, data=None, **kwargs):</font>
<font color="black"> 521.         &quot;&quot;&quot;Sends a PATCH request. Returns :class:`Response` object.</font>
<font color="black"> 522. </font>
<font color="black"> 523.         :param url: URL for the new :class:`Request` object.</font>
<font color="black"> 524.         :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.</font>
<font color="black"> 525.         :param \*\*kwargs: Optional arguments that ``request`` takes.</font>
<font color="black"> 526.         &quot;&quot;&quot;</font>
<font color="black"> 527. </font>
<font color="red"> 528.         return self.request('PATCH', url,  data=data, **kwargs)</font>
<font color="black"> 529. </font>
<font color="green"> 530.     def delete(self, url, **kwargs):</font>
<font color="black"> 531.         &quot;&quot;&quot;Sends a DELETE request. Returns :class:`Response` object.</font>
<font color="black"> 532. </font>
<font color="black"> 533.         :param url: URL for the new :class:`Request` object.</font>
<font color="black"> 534.         :param \*\*kwargs: Optional arguments that ``request`` takes.</font>
<font color="black"> 535.         &quot;&quot;&quot;</font>
<font color="black"> 536. </font>
<font color="red"> 537.         return self.request('DELETE', url, **kwargs)</font>
<font color="black"> 538. </font>
<font color="green"> 539.     def send(self, request, **kwargs):</font>
<font color="black"> 540.         &quot;&quot;&quot;Send a given PreparedRequest.&quot;&quot;&quot;</font>
<font color="black"> 541.         # Set defaults that the hooks can utilize to ensure they always have</font>
<font color="black"> 542.         # the correct parameters to reproduce the previous request.</font>
<font color="green"> 543.         kwargs.setdefault('stream', self.stream)</font>
<font color="green"> 544.         kwargs.setdefault('verify', self.verify)</font>
<font color="green"> 545.         kwargs.setdefault('cert', self.cert)</font>
<font color="green"> 546.         kwargs.setdefault('proxies', self.proxies)</font>
<font color="black"> 547. </font>
<font color="black"> 548.         # It's possible that users might accidentally send a Request object.</font>
<font color="black"> 549.         # Guard against that specific failure case.</font>
<font color="green"> 550.         if not isinstance(request, PreparedRequest):</font>
<font color="red"> 551.             raise ValueError('You can only send PreparedRequests.')</font>
<font color="black"> 552. </font>
<font color="green"> 553.         checked_urls = set()</font>
<font color="green"> 554.         while request.url in self.redirect_cache:</font>
<font color="red"> 555.             checked_urls.add(request.url)</font>
<font color="red"> 556.             new_url = self.redirect_cache.get(request.url)</font>
<font color="red"> 557.             if new_url in checked_urls:</font>
<font color="red"> 558.                 break</font>
<font color="red"> 559.             request.url = new_url</font>
<font color="black"> 560. </font>
<font color="black"> 561.         # Set up variables needed for resolve_redirects and dispatching of hooks</font>
<font color="green"> 562.         allow_redirects = kwargs.pop('allow_redirects', True)</font>
<font color="green"> 563.         stream = kwargs.get('stream')</font>
<font color="green"> 564.         hooks = request.hooks</font>
<font color="black"> 565. </font>
<font color="black"> 566.         # Get the appropriate adapter to use</font>
<font color="green"> 567.         adapter = self.get_adapter(url=request.url)</font>
<font color="black"> 568. </font>
<font color="black"> 569.         # Start time (approximately) of the request</font>
<font color="green"> 570.         start = datetime.utcnow()</font>
<font color="black"> 571. </font>
<font color="black"> 572.         # Send the request</font>
<font color="green"> 573.         r = adapter.send(request, **kwargs)</font>
<font color="black"> 574. </font>
<font color="black"> 575.         # Total elapsed time of the request (approximately)</font>
<font color="green"> 576.         r.elapsed = datetime.utcnow() - start</font>
<font color="black"> 577. </font>
<font color="black"> 578.         # Response manipulation hooks</font>
<font color="green"> 579.         r = dispatch_hook('response', hooks, r, **kwargs)</font>
<font color="black"> 580. </font>
<font color="black"> 581.         # Persist cookies</font>
<font color="green"> 582.         if r.history:</font>
<font color="black"> 583. </font>
<font color="black"> 584.             # If the hooks create history then we want those cookies too</font>
<font color="red"> 585.             for resp in r.history:</font>
<font color="red"> 586.                 extract_cookies_to_jar(self.cookies, resp.request, resp.raw)</font>
<font color="black"> 587. </font>
<font color="green"> 588.         extract_cookies_to_jar(self.cookies, request, r.raw)</font>
<font color="black"> 589. </font>
<font color="black"> 590.         # Redirect resolving generator.</font>
<font color="green"> 591.         gen = self.resolve_redirects(r, request, **kwargs)</font>
<font color="black"> 592. </font>
<font color="black"> 593.         # Resolve redirects if allowed.</font>
<font color="green"> 594.         history = [resp for resp in gen] if allow_redirects else []</font>
<font color="black"> 595. </font>
<font color="black"> 596.         # Shuffle things around if there's history.</font>
<font color="green"> 597.         if history:</font>
<font color="black"> 598.             # Insert the first (original) request at the start</font>
<font color="red"> 599.             history.insert(0, r)</font>
<font color="black"> 600.             # Get the last request made</font>
<font color="red"> 601.             r = history.pop()</font>
<font color="red"> 602.             r.history = history</font>
<font color="black"> 603. </font>
<font color="green"> 604.         if not stream:</font>
<font color="green"> 605.             r.content</font>
<font color="black"> 606. </font>
<font color="green"> 607.         return r</font>
<font color="black"> 608. </font>
<font color="green"> 609.     def merge_environment_settings(self, url, proxies, stream, verify, cert):</font>
<font color="black"> 610.         &quot;&quot;&quot;Check the environment and merge it with some settings.&quot;&quot;&quot;</font>
<font color="black"> 611.         # Gather clues from the surrounding environment.</font>
<font color="red"> 612.         if self.trust_env:</font>
<font color="black"> 613.             # Set environment's proxies.</font>
<font color="red"> 614.             env_proxies = get_environ_proxies(url) or {}</font>
<font color="red"> 615.             for (k, v) in env_proxies.items():</font>
<font color="red"> 616.                 proxies.setdefault(k, v)</font>
<font color="black"> 617. </font>
<font color="black"> 618.             # Look for requests environment configuration and be compatible</font>
<font color="black"> 619.             # with cURL.</font>
<font color="red"> 620.             if verify is True or verify is None:</font>
<font color="red"> 621.                 verify = (os.environ.get('REQUESTS_CA_BUNDLE') or</font>
<font color="red"> 622.                           os.environ.get('CURL_CA_BUNDLE'))</font>
<font color="black"> 623. </font>
<font color="black"> 624.         # Merge all the kwargs.</font>
<font color="red"> 625.         proxies = merge_setting(proxies, self.proxies)</font>
<font color="red"> 626.         stream = merge_setting(stream, self.stream)</font>
<font color="red"> 627.         verify = merge_setting(verify, self.verify)</font>
<font color="red"> 628.         cert = merge_setting(cert, self.cert)</font>
<font color="black"> 629. </font>
<font color="red"> 630.         return {'verify': verify, 'proxies': proxies, 'stream': stream,</font>
<font color="red"> 631.                 'cert': cert}</font>
<font color="black"> 632. </font>
<font color="green"> 633.     def get_adapter(self, url):</font>
<font color="black"> 634.         &quot;&quot;&quot;Returns the appropriate connnection adapter for the given URL.&quot;&quot;&quot;</font>
<font color="green"> 635.         for (prefix, adapter) in self.adapters.items():</font>
<font color="black"> 636. </font>
<font color="green"> 637.             if url.lower().startswith(prefix):</font>
<font color="green"> 638.                 return adapter</font>
<font color="black"> 639. </font>
<font color="black"> 640.         # Nothing matches :-/</font>
<font color="red"> 641.         raise InvalidSchema(&quot;No connection adapters were found for '%s'&quot; % url)</font>
<font color="black"> 642. </font>
<font color="green"> 643.     def close(self):</font>
<font color="black"> 644.         &quot;&quot;&quot;Closes all adapters and as such the session&quot;&quot;&quot;</font>
<font color="red"> 645.         for v in self.adapters.values():</font>
<font color="red"> 646.             v.close()</font>
<font color="black"> 647. </font>
<font color="green"> 648.     def mount(self, prefix, adapter):</font>
<font color="black"> 649.         &quot;&quot;&quot;Registers a connection adapter to a prefix.</font>
<font color="black"> 650. </font>
<font color="black"> 651.         Adapters are sorted in descending order by key length.&quot;&quot;&quot;</font>
<font color="black"> 652. </font>
<font color="green"> 653.         self.adapters[prefix] = adapter</font>
<font color="green"> 654.         keys_to_move = [k for k in self.adapters if len(k) &lt; len(prefix)]</font>
<font color="black"> 655. </font>
<font color="green"> 656.         for key in keys_to_move:</font>
<font color="green"> 657.             self.adapters[key] = self.adapters.pop(key)</font>
<font color="black"> 658. </font>
<font color="green"> 659.     def __getstate__(self):</font>
<font color="red"> 660.         state = dict((attr, getattr(self, attr, None)) for attr in self.__attrs__)</font>
<font color="red"> 661.         state['redirect_cache'] = dict(self.redirect_cache)</font>
<font color="red"> 662.         return state</font>
<font color="black"> 663. </font>
<font color="green"> 664.     def __setstate__(self, state):</font>
<font color="red"> 665.         redirect_cache = state.pop('redirect_cache', {})</font>
<font color="red"> 666.         for attr, value in state.items():</font>
<font color="red"> 667.             setattr(self, attr, value)</font>
<font color="black"> 668. </font>
<font color="red"> 669.         self.redirect_cache = RecentlyUsedContainer(REDIRECT_CACHE_SIZE)</font>
<font color="red"> 670.         for redirect, to in redirect_cache.items():</font>
<font color="red"> 671.             self.redirect_cache[redirect] = to</font>
<font color="black"> 672. </font>
<font color="black"> 673. </font>
<font color="green"> 674. def session():</font>
<font color="black"> 675.     &quot;&quot;&quot;Returns a :class:`Session` for context-management.&quot;&quot;&quot;</font>
<font color="black"> 676. </font>
<font color="red"> 677.     return Session()</font>
</pre>

