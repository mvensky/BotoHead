source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/credentials.py</b><br>


file stats: <b>919 lines, 337 executed: 36.7% covered</b>
<pre>
<font color="black">   1. # Copyright (c) 2012-2013 Mitch Garnaat http://garnaat.org/</font>
<font color="black">   2. # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   3. #</font>
<font color="black">   4. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   5. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   6. # the License is located at</font>
<font color="black">   7. #</font>
<font color="black">   8. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   9. #</font>
<font color="black">  10. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  11. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  12. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  13. # language governing permissions and limitations under the License.</font>
<font color="green">  14. import time</font>
<font color="green">  15. import datetime</font>
<font color="green">  16. import logging</font>
<font color="green">  17. import os</font>
<font color="green">  18. import getpass</font>
<font color="green">  19. import threading</font>
<font color="green">  20. import json</font>
<font color="green">  21. import subprocess</font>
<font color="green">  22. from collections import namedtuple</font>
<font color="green">  23. from copy import deepcopy</font>
<font color="green">  24. from hashlib import sha1</font>
<font color="green">  25. import json</font>
<font color="black">  26. </font>
<font color="green">  27. from dateutil.parser import parse</font>
<font color="green">  28. from dateutil.tz import tzlocal</font>
<font color="black">  29. </font>
<font color="green">  30. import botocore.configloader</font>
<font color="green">  31. import botocore.compat</font>
<font color="green">  32. from botocore.compat import total_seconds</font>
<font color="green">  33. from botocore.compat import compat_shell_split</font>
<font color="green">  34. from botocore.exceptions import UnknownCredentialError</font>
<font color="green">  35. from botocore.exceptions import PartialCredentialsError</font>
<font color="green">  36. from botocore.exceptions import ConfigNotFound</font>
<font color="green">  37. from botocore.exceptions import InvalidConfigError</font>
<font color="green">  38. from botocore.exceptions import InfiniteLoopConfigError</font>
<font color="green">  39. from botocore.exceptions import RefreshWithMFAUnsupportedError</font>
<font color="green">  40. from botocore.exceptions import MetadataRetrievalError</font>
<font color="green">  41. from botocore.exceptions import CredentialRetrievalError</font>
<font color="green">  42. from botocore.utils import InstanceMetadataFetcher, parse_key_val_file</font>
<font color="green">  43. from botocore.utils import ContainerMetadataFetcher</font>
<font color="black">  44. </font>
<font color="black">  45. </font>
<font color="green">  46. logger = logging.getLogger(__name__)</font>
<font color="green">  47. ReadOnlyCredentials = namedtuple('ReadOnlyCredentials',</font>
<font color="green">  48.                                  ['access_key', 'secret_key', 'token'])</font>
<font color="black">  49. </font>
<font color="black">  50. </font>
<font color="green">  51. def create_credential_resolver(session, cache=None):</font>
<font color="black">  52.     &quot;&quot;&quot;Create a default credential resolver.</font>
<font color="black">  53. </font>
<font color="black">  54.     This creates a pre-configured credential resolver</font>
<font color="black">  55.     that includes the default lookup chain for</font>
<font color="black">  56.     credentials.</font>
<font color="black">  57. </font>
<font color="black">  58.     &quot;&quot;&quot;</font>
<font color="green">  59.     profile_name = session.get_config_variable('profile') or 'default'</font>
<font color="green">  60.     credential_file = session.get_config_variable('credentials_file')</font>
<font color="green">  61.     config_file = session.get_config_variable('config_file')</font>
<font color="green">  62.     metadata_timeout = session.get_config_variable('metadata_service_timeout')</font>
<font color="green">  63.     num_attempts = session.get_config_variable('metadata_service_num_attempts')</font>
<font color="green">  64.     if cache is None:</font>
<font color="green">  65.         cache = {}</font>
<font color="black">  66. </font>
<font color="green">  67.     env_provider = EnvProvider()</font>
<font color="green">  68.     container_provider = ContainerProvider()</font>
<font color="green">  69.     instance_metadata_provider = InstanceMetadataProvider(</font>
<font color="green">  70.         iam_role_fetcher=InstanceMetadataFetcher(</font>
<font color="green">  71.             timeout=metadata_timeout,</font>
<font color="green">  72.             num_attempts=num_attempts)</font>
<font color="black">  73.     )</font>
<font color="green">  74.     assume_role_provider = AssumeRoleProvider(</font>
<font color="green">  75.         load_config=lambda: session.full_config,</font>
<font color="green">  76.         client_creator=session.create_client,</font>
<font color="green">  77.         cache=cache,</font>
<font color="green">  78.         profile_name=profile_name,</font>
<font color="green">  79.         credential_sourcer=CanonicalNameCredentialSourcer([</font>
<font color="green">  80.             env_provider, container_provider, instance_metadata_provider</font>
<font color="black">  81.         ])</font>
<font color="black">  82.     )</font>
<font color="black">  83.     providers = [</font>
<font color="green">  84.         env_provider,</font>
<font color="green">  85.         assume_role_provider,</font>
<font color="green">  86.         SharedCredentialProvider(</font>
<font color="green">  87.             creds_filename=credential_file,</font>
<font color="green">  88.             profile_name=profile_name</font>
<font color="black">  89.         ),</font>
<font color="green">  90.         ProcessProvider(profile_name=profile_name,</font>
<font color="green">  91.                         load_config=lambda: session.full_config),</font>
<font color="black">  92.         # The new config file has precedence over the legacy</font>
<font color="black">  93.         # config file.</font>
<font color="green">  94.         ConfigProvider(config_filename=config_file, profile_name=profile_name),</font>
<font color="green">  95.         OriginalEC2Provider(),</font>
<font color="green">  96.         BotoProvider(),</font>
<font color="green">  97.         container_provider,</font>
<font color="green">  98.         instance_metadata_provider</font>
<font color="black">  99.     ]</font>
<font color="black"> 100. </font>
<font color="green"> 101.     explicit_profile = session.get_config_variable('profile',</font>
<font color="green"> 102.                                                    methods=('instance',))</font>
<font color="green"> 103.     if explicit_profile is not None:</font>
<font color="black"> 104.         # An explicitly provided profile will negate an EnvProvider.</font>
<font color="black"> 105.         # We will defer to providers that understand the &quot;profile&quot;</font>
<font color="black"> 106.         # concept to retrieve credentials.</font>
<font color="black"> 107.         # The one edge case if is all three values are provided via</font>
<font color="black"> 108.         # env vars:</font>
<font color="black"> 109.         # export AWS_ACCESS_KEY_ID=foo</font>
<font color="black"> 110.         # export AWS_SECRET_ACCESS_KEY=bar</font>
<font color="black"> 111.         # export AWS_PROFILE=baz</font>
<font color="black"> 112.         # Then, just like our client() calls, the explicit credentials</font>
<font color="black"> 113.         # will take precedence.</font>
<font color="black"> 114.         #</font>
<font color="black"> 115.         # This precedence is enforced by leaving the EnvProvider in the chain.</font>
<font color="black"> 116.         # This means that the only way a &quot;profile&quot; would win is if the</font>
<font color="black"> 117.         # EnvProvider does not return credentials, which is what we want</font>
<font color="black"> 118.         # in this scenario.</font>
<font color="red"> 119.         providers.remove(env_provider)</font>
<font color="red"> 120.         logger.debug('Skipping environment variable credential check'</font>
<font color="black"> 121.                      ' because profile name was explicitly set.')</font>
<font color="black"> 122. </font>
<font color="green"> 123.     resolver = CredentialResolver(providers=providers)</font>
<font color="green"> 124.     return resolver</font>
<font color="black"> 125. </font>
<font color="black"> 126. </font>
<font color="green"> 127. def get_credentials(session):</font>
<font color="red"> 128.     resolver = create_credential_resolver(session)</font>
<font color="red"> 129.     return resolver.load_credentials()</font>
<font color="black"> 130. </font>
<font color="black"> 131. </font>
<font color="green"> 132. def _local_now():</font>
<font color="red"> 133.     return datetime.datetime.now(tzlocal())</font>
<font color="black"> 134. </font>
<font color="black"> 135. </font>
<font color="green"> 136. def _parse_if_needed(value):</font>
<font color="red"> 137.     if isinstance(value, datetime.datetime):</font>
<font color="red"> 138.         return value</font>
<font color="red"> 139.     return parse(value)</font>
<font color="black"> 140. </font>
<font color="black"> 141. </font>
<font color="green"> 142. def _serialize_if_needed(value, iso=False):</font>
<font color="red"> 143.     if isinstance(value, datetime.datetime):</font>
<font color="red"> 144.         if iso:</font>
<font color="red"> 145.             return value.isoformat()</font>
<font color="red"> 146.         return value.strftime('%Y-%m-%dT%H:%M:%S%Z')</font>
<font color="red"> 147.     return value</font>
<font color="black"> 148. </font>
<font color="black"> 149. </font>
<font color="green"> 150. def create_assume_role_refresher(client, params):</font>
<font color="red"> 151.     def refresh():</font>
<font color="red"> 152.         response = client.assume_role(**params)</font>
<font color="red"> 153.         credentials = response['Credentials']</font>
<font color="black"> 154.         # We need to normalize the credential names to</font>
<font color="black"> 155.         # the values expected by the refresh creds.</font>
<font color="red"> 156.         return {</font>
<font color="red"> 157.             'access_key': credentials['AccessKeyId'],</font>
<font color="red"> 158.             'secret_key': credentials['SecretAccessKey'],</font>
<font color="red"> 159.             'token': credentials['SessionToken'],</font>
<font color="red"> 160.             'expiry_time': _serialize_if_needed(credentials['Expiration']),</font>
<font color="black"> 161.         }</font>
<font color="red"> 162.     return refresh</font>
<font color="black"> 163. </font>
<font color="black"> 164. </font>
<font color="green"> 165. def create_mfa_serial_refresher(actual_refresh):</font>
<font color="black"> 166. </font>
<font color="red"> 167.     class _Refresher(object):</font>
<font color="red"> 168.         def __init__(self, refresh):</font>
<font color="red"> 169.             self._refresh = refresh</font>
<font color="red"> 170.             self._has_been_called = False</font>
<font color="black"> 171. </font>
<font color="red"> 172.         def __call__(self):</font>
<font color="red"> 173.             if self._has_been_called:</font>
<font color="black"> 174.                 # We can explore an option in the future to support</font>
<font color="black"> 175.                 # reprompting for MFA, but for now we just error out</font>
<font color="black"> 176.                 # when the temp creds expire.</font>
<font color="red"> 177.                 raise RefreshWithMFAUnsupportedError()</font>
<font color="red"> 178.             self._has_been_called = True</font>
<font color="red"> 179.             return self._refresh()</font>
<font color="black"> 180. </font>
<font color="red"> 181.     return _Refresher(actual_refresh)</font>
<font color="black"> 182. </font>
<font color="black"> 183. </font>
<font color="green"> 184. class JSONFileCache(object):</font>
<font color="black"> 185.     &quot;&quot;&quot;JSON file cache.</font>
<font color="black"> 186.     This provides a dict like interface that stores JSON serializable</font>
<font color="black"> 187.     objects.</font>
<font color="black"> 188.     The objects are serialized to JSON and stored in a file.  These</font>
<font color="black"> 189.     values can be retrieved at a later time.</font>
<font color="green"> 190.     &quot;&quot;&quot;</font>
<font color="black"> 191. </font>
<font color="green"> 192.     CACHE_DIR = os.path.expanduser(os.path.join('~', '.aws', 'boto', 'cache'))</font>
<font color="black"> 193. </font>
<font color="green"> 194.     def __init__(self, working_dir=CACHE_DIR):</font>
<font color="red"> 195.         self._working_dir = working_dir</font>
<font color="black"> 196. </font>
<font color="green"> 197.     def __contains__(self, cache_key):</font>
<font color="red"> 198.         actual_key = self._convert_cache_key(cache_key)</font>
<font color="red"> 199.         return os.path.isfile(actual_key)</font>
<font color="black"> 200. </font>
<font color="green"> 201.     def __getitem__(self, cache_key):</font>
<font color="black"> 202.         &quot;&quot;&quot;Retrieve value from a cache key.&quot;&quot;&quot;</font>
<font color="red"> 203.         actual_key = self._convert_cache_key(cache_key)</font>
<font color="red"> 204.         try:</font>
<font color="red"> 205.             with open(actual_key) as f:</font>
<font color="red"> 206.                 return json.load(f)</font>
<font color="red"> 207.         except (OSError, ValueError, IOError):</font>
<font color="red"> 208.             raise KeyError(cache_key)</font>
<font color="black"> 209. </font>
<font color="green"> 210.     def __setitem__(self, cache_key, value):</font>
<font color="red"> 211.         full_key = self._convert_cache_key(cache_key)</font>
<font color="red"> 212.         try:</font>
<font color="red"> 213.             file_content = json.dumps(value, default=_serialize_if_needed)</font>
<font color="red"> 214.         except (TypeError, ValueError):</font>
<font color="red"> 215.             raise ValueError(&quot;Value cannot be cached, must be &quot;</font>
<font color="red"> 216.                              &quot;JSON serializable: %s&quot; % value)</font>
<font color="red"> 217.         if not os.path.isdir(self._working_dir):</font>
<font color="red"> 218.             os.makedirs(self._working_dir)</font>
<font color="red"> 219.         with os.fdopen(os.open(full_key,</font>
<font color="red"> 220.                                os.O_WRONLY | os.O_CREAT, 0o600), 'w') as f:</font>
<font color="red"> 221.             f.truncate()</font>
<font color="red"> 222.             f.write(file_content)</font>
<font color="black"> 223. </font>
<font color="green"> 224.     def _convert_cache_key(self, cache_key):</font>
<font color="red"> 225.         full_path = os.path.join(self._working_dir, cache_key + '.json')</font>
<font color="red"> 226.         return full_path</font>
<font color="black"> 227. </font>
<font color="black"> 228. </font>
<font color="green"> 229. class Credentials(object):</font>
<font color="black"> 230.     &quot;&quot;&quot;</font>
<font color="black"> 231.     Holds the credentials needed to authenticate requests.</font>
<font color="black"> 232. </font>
<font color="black"> 233.     :ivar access_key: The access key part of the credentials.</font>
<font color="black"> 234.     :ivar secret_key: The secret key part of the credentials.</font>
<font color="black"> 235.     :ivar token: The security token, valid only for session credentials.</font>
<font color="black"> 236.     :ivar method: A string which identifies where the credentials</font>
<font color="black"> 237.         were found.</font>
<font color="green"> 238.     &quot;&quot;&quot;</font>
<font color="black"> 239. </font>
<font color="green"> 240.     def __init__(self, access_key, secret_key, token=None,</font>
<font color="green"> 241.                  method=None):</font>
<font color="green"> 242.         self.access_key = access_key</font>
<font color="green"> 243.         self.secret_key = secret_key</font>
<font color="green"> 244.         self.token = token</font>
<font color="black"> 245. </font>
<font color="green"> 246.         if method is None:</font>
<font color="red"> 247.             method = 'explicit'</font>
<font color="green"> 248.         self.method = method</font>
<font color="black"> 249. </font>
<font color="green"> 250.         self._normalize()</font>
<font color="black"> 251. </font>
<font color="green"> 252.     def _normalize(self):</font>
<font color="black"> 253.         # Keys would sometimes (accidentally) contain non-ascii characters.</font>
<font color="black"> 254.         # It would cause a confusing UnicodeDecodeError in Python 2.</font>
<font color="black"> 255.         # We explicitly convert them into unicode to avoid such error.</font>
<font color="black"> 256.         #</font>
<font color="black"> 257.         # Eventually the service will decide whether to accept the credential.</font>
<font color="black"> 258.         # This also complies with the behavior in Python 3.</font>
<font color="green"> 259.         self.access_key = botocore.compat.ensure_unicode(self.access_key)</font>
<font color="green"> 260.         self.secret_key = botocore.compat.ensure_unicode(self.secret_key)</font>
<font color="black"> 261. </font>
<font color="green"> 262.     def get_frozen_credentials(self):</font>
<font color="green"> 263.         return ReadOnlyCredentials(self.access_key,</font>
<font color="green"> 264.                                    self.secret_key,</font>
<font color="green"> 265.                                    self.token)</font>
<font color="black"> 266. </font>
<font color="black"> 267. </font>
<font color="green"> 268. class RefreshableCredentials(Credentials):</font>
<font color="black"> 269.     &quot;&quot;&quot;</font>
<font color="black"> 270.     Holds the credentials needed to authenticate requests. In addition, it</font>
<font color="black"> 271.     knows how to refresh itself.</font>
<font color="black"> 272. </font>
<font color="black"> 273.     :ivar access_key: The access key part of the credentials.</font>
<font color="black"> 274.     :ivar secret_key: The secret key part of the credentials.</font>
<font color="black"> 275.     :ivar token: The security token, valid only for session credentials.</font>
<font color="black"> 276.     :ivar method: A string which identifies where the credentials</font>
<font color="black"> 277.         were found.</font>
<font color="green"> 278.     &quot;&quot;&quot;</font>
<font color="black"> 279.     # The time at which we'll attempt to refresh, but not</font>
<font color="black"> 280.     # block if someone else is refreshing.</font>
<font color="green"> 281.     _advisory_refresh_timeout = 15 * 60</font>
<font color="black"> 282.     # The time at which all threads will block waiting for</font>
<font color="black"> 283.     # refreshed credentials.</font>
<font color="green"> 284.     _mandatory_refresh_timeout = 10 * 60</font>
<font color="black"> 285. </font>
<font color="black"> 286.     def __init__(self, access_key, secret_key, token,</font>
<font color="black"> 287.                  expiry_time, refresh_using, method,</font>
<font color="green"> 288.                  time_fetcher=_local_now):</font>
<font color="red"> 289.         self._refresh_using = refresh_using</font>
<font color="red"> 290.         self._access_key = access_key</font>
<font color="red"> 291.         self._secret_key = secret_key</font>
<font color="red"> 292.         self._token = token</font>
<font color="red"> 293.         self._expiry_time = expiry_time</font>
<font color="red"> 294.         self._time_fetcher = time_fetcher</font>
<font color="red"> 295.         self._refresh_lock = threading.Lock()</font>
<font color="red"> 296.         self.method = method</font>
<font color="red"> 297.         self._frozen_credentials = ReadOnlyCredentials(</font>
<font color="red"> 298.             access_key, secret_key, token)</font>
<font color="red"> 299.         self._normalize()</font>
<font color="black"> 300. </font>
<font color="green"> 301.     def _normalize(self):</font>
<font color="red"> 302.         self._access_key = botocore.compat.ensure_unicode(self._access_key)</font>
<font color="red"> 303.         self._secret_key = botocore.compat.ensure_unicode(self._secret_key)</font>
<font color="black"> 304. </font>
<font color="green"> 305.     @classmethod</font>
<font color="black"> 306.     def create_from_metadata(cls, metadata, refresh_using, method):</font>
<font color="red"> 307.         instance = cls(</font>
<font color="red"> 308.             access_key=metadata['access_key'],</font>
<font color="red"> 309.             secret_key=metadata['secret_key'],</font>
<font color="red"> 310.             token=metadata['token'],</font>
<font color="red"> 311.             expiry_time=cls._expiry_datetime(metadata['expiry_time']),</font>
<font color="red"> 312.             method=method,</font>
<font color="red"> 313.             refresh_using=refresh_using</font>
<font color="black"> 314.         )</font>
<font color="red"> 315.         return instance</font>
<font color="black"> 316. </font>
<font color="green"> 317.     @property</font>
<font color="black"> 318.     def access_key(self):</font>
<font color="black"> 319.         &quot;&quot;&quot;Warning: Using this property can lead to race conditions if you</font>
<font color="black"> 320.         access another property subsequently along the refresh boundary.</font>
<font color="black"> 321.         Please use get_frozen_credentials instead.</font>
<font color="black"> 322.         &quot;&quot;&quot;</font>
<font color="red"> 323.         self._refresh()</font>
<font color="red"> 324.         return self._access_key</font>
<font color="black"> 325. </font>
<font color="green"> 326.     @access_key.setter</font>
<font color="black"> 327.     def access_key(self, value):</font>
<font color="red"> 328.         self._access_key = value</font>
<font color="black"> 329. </font>
<font color="green"> 330.     @property</font>
<font color="black"> 331.     def secret_key(self):</font>
<font color="black"> 332.         &quot;&quot;&quot;Warning: Using this property can lead to race conditions if you</font>
<font color="black"> 333.         access another property subsequently along the refresh boundary.</font>
<font color="black"> 334.         Please use get_frozen_credentials instead.</font>
<font color="black"> 335.         &quot;&quot;&quot;</font>
<font color="red"> 336.         self._refresh()</font>
<font color="red"> 337.         return self._secret_key</font>
<font color="black"> 338. </font>
<font color="green"> 339.     @secret_key.setter</font>
<font color="black"> 340.     def secret_key(self, value):</font>
<font color="red"> 341.         self._secret_key = value</font>
<font color="black"> 342. </font>
<font color="green"> 343.     @property</font>
<font color="black"> 344.     def token(self):</font>
<font color="black"> 345.         &quot;&quot;&quot;Warning: Using this property can lead to race conditions if you</font>
<font color="black"> 346.         access another property subsequently along the refresh boundary.</font>
<font color="black"> 347.         Please use get_frozen_credentials instead.</font>
<font color="black"> 348.         &quot;&quot;&quot;</font>
<font color="red"> 349.         self._refresh()</font>
<font color="red"> 350.         return self._token</font>
<font color="black"> 351. </font>
<font color="green"> 352.     @token.setter</font>
<font color="black"> 353.     def token(self, value):</font>
<font color="red"> 354.         self._token = value</font>
<font color="black"> 355. </font>
<font color="green"> 356.     def _seconds_remaining(self):</font>
<font color="red"> 357.         delta = self._expiry_time - self._time_fetcher()</font>
<font color="red"> 358.         return total_seconds(delta)</font>
<font color="black"> 359. </font>
<font color="green"> 360.     def refresh_needed(self, refresh_in=None):</font>
<font color="black"> 361.         &quot;&quot;&quot;Check if a refresh is needed.</font>
<font color="black"> 362. </font>
<font color="black"> 363.         A refresh is needed if the expiry time associated</font>
<font color="black"> 364.         with the temporary credentials is less than the</font>
<font color="black"> 365.         provided ``refresh_in``.  If ``time_delta`` is not</font>
<font color="black"> 366.         provided, ``self.advisory_refresh_needed`` will be used.</font>
<font color="black"> 367. </font>
<font color="black"> 368.         For example, if your temporary credentials expire</font>
<font color="black"> 369.         in 10 minutes and the provided ``refresh_in`` is</font>
<font color="black"> 370.         ``15 * 60``, then this function will return ``True``.</font>
<font color="black"> 371. </font>
<font color="black"> 372.         :type refresh_in: int</font>
<font color="black"> 373.         :param refresh_in: The number of seconds before the</font>
<font color="black"> 374.             credentials expire in which refresh attempts should</font>
<font color="black"> 375.             be made.</font>
<font color="black"> 376. </font>
<font color="black"> 377.         :return: True if refresh neeeded, False otherwise.</font>
<font color="black"> 378. </font>
<font color="black"> 379.         &quot;&quot;&quot;</font>
<font color="red"> 380.         if self._expiry_time is None:</font>
<font color="black"> 381.             # No expiration, so assume we don't need to refresh.</font>
<font color="red"> 382.             return False</font>
<font color="black"> 383. </font>
<font color="red"> 384.         if refresh_in is None:</font>
<font color="red"> 385.             refresh_in = self._advisory_refresh_timeout</font>
<font color="black"> 386.         # The credentials should be refreshed if they're going to expire</font>
<font color="black"> 387.         # in less than 5 minutes.</font>
<font color="red"> 388.         if self._seconds_remaining() &gt;= refresh_in:</font>
<font color="black"> 389.             # There's enough time left. Don't refresh.</font>
<font color="red"> 390.             return False</font>
<font color="red"> 391.         logger.debug(&quot;Credentials need to be refreshed.&quot;)</font>
<font color="red"> 392.         return True</font>
<font color="black"> 393. </font>
<font color="green"> 394.     def _is_expired(self):</font>
<font color="black"> 395.         # Checks if the current credentials are expired.</font>
<font color="red"> 396.         return self.refresh_needed(refresh_in=0)</font>
<font color="black"> 397. </font>
<font color="green"> 398.     def _refresh(self):</font>
<font color="black"> 399.         # In the common case where we don't need a refresh, we</font>
<font color="black"> 400.         # can immediately exit and not require acquiring the</font>
<font color="black"> 401.         # refresh lock.</font>
<font color="red"> 402.         if not self.refresh_needed(self._advisory_refresh_timeout):</font>
<font color="red"> 403.             return</font>
<font color="black"> 404. </font>
<font color="black"> 405.         # acquire() doesn't accept kwargs, but False is indicating</font>
<font color="black"> 406.         # that we should not block if we can't acquire the lock.</font>
<font color="black"> 407.         # If we aren't able to acquire the lock, we'll trigger</font>
<font color="black"> 408.         # the else clause.</font>
<font color="red"> 409.         if self._refresh_lock.acquire(False):</font>
<font color="red"> 410.             try:</font>
<font color="red"> 411.                 if not self.refresh_needed(self._advisory_refresh_timeout):</font>
<font color="red"> 412.                     return</font>
<font color="red"> 413.                 is_mandatory_refresh = self.refresh_needed(</font>
<font color="red"> 414.                     self._mandatory_refresh_timeout)</font>
<font color="red"> 415.                 self._protected_refresh(is_mandatory=is_mandatory_refresh)</font>
<font color="red"> 416.                 return</font>
<font color="black"> 417.             finally:</font>
<font color="red"> 418.                 self._refresh_lock.release()</font>
<font color="red"> 419.         elif self.refresh_needed(self._mandatory_refresh_timeout):</font>
<font color="black"> 420.             # If we're within the mandatory refresh window,</font>
<font color="black"> 421.             # we must block until we get refreshed credentials.</font>
<font color="red"> 422.             with self._refresh_lock:</font>
<font color="red"> 423.                 if not self.refresh_needed(self._mandatory_refresh_timeout):</font>
<font color="red"> 424.                     return</font>
<font color="red"> 425.                 self._protected_refresh(is_mandatory=True)</font>
<font color="black"> 426. </font>
<font color="green"> 427.     def _protected_refresh(self, is_mandatory):</font>
<font color="black"> 428.         # precondition: this method should only be called if you've acquired</font>
<font color="black"> 429.         # the self._refresh_lock.</font>
<font color="red"> 430.         try:</font>
<font color="red"> 431.             metadata = self._refresh_using()</font>
<font color="red"> 432.         except Exception as e:</font>
<font color="red"> 433.             period_name = 'mandatory' if is_mandatory else 'advisory'</font>
<font color="red"> 434.             logger.warning(&quot;Refreshing temporary credentials failed &quot;</font>
<font color="black"> 435.                            &quot;during %s refresh period.&quot;,</font>
<font color="red"> 436.                            period_name, exc_info=True)</font>
<font color="red"> 437.             if is_mandatory:</font>
<font color="black"> 438.                 # If this is a mandatory refresh, then</font>
<font color="black"> 439.                 # all errors that occur when we attempt to refresh</font>
<font color="black"> 440.                 # credentials are propagated back to the user.</font>
<font color="red"> 441.                 raise</font>
<font color="black"> 442.             # Otherwise we'll just return.</font>
<font color="black"> 443.             # The end result will be that we'll use the current</font>
<font color="black"> 444.             # set of temporary credentials we have.</font>
<font color="red"> 445.             return</font>
<font color="red"> 446.         self._set_from_data(metadata)</font>
<font color="red"> 447.         self._frozen_credentials = ReadOnlyCredentials(</font>
<font color="red"> 448.             self._access_key, self._secret_key, self._token)</font>
<font color="red"> 449.         if self._is_expired():</font>
<font color="black"> 450.             # We successfully refreshed credentials but for whatever</font>
<font color="black"> 451.             # reason, our refreshing function returned credentials</font>
<font color="black"> 452.             # that are still expired.  In this scenario, the only</font>
<font color="black"> 453.             # thing we can do is let the user know and raise</font>
<font color="black"> 454.             # an exception.</font>
<font color="red"> 455.             msg = (&quot;Credentials were refreshed, but the &quot;</font>
<font color="black"> 456.                    &quot;refreshed credentials are still expired.&quot;)</font>
<font color="red"> 457.             logger.warning(msg)</font>
<font color="red"> 458.             raise RuntimeError(msg)</font>
<font color="black"> 459. </font>
<font color="green"> 460.     @staticmethod</font>
<font color="black"> 461.     def _expiry_datetime(time_str):</font>
<font color="red"> 462.         return parse(time_str)</font>
<font color="black"> 463. </font>
<font color="green"> 464.     def _set_from_data(self, data):</font>
<font color="red"> 465.         self.access_key = data['access_key']</font>
<font color="red"> 466.         self.secret_key = data['secret_key']</font>
<font color="red"> 467.         self.token = data['token']</font>
<font color="red"> 468.         self._expiry_time = parse(data['expiry_time'])</font>
<font color="red"> 469.         logger.debug(&quot;Retrieved credentials will expire at: %s&quot;,</font>
<font color="red"> 470.                      self._expiry_time)</font>
<font color="red"> 471.         self._normalize()</font>
<font color="black"> 472. </font>
<font color="green"> 473.     def get_frozen_credentials(self):</font>
<font color="black"> 474.         &quot;&quot;&quot;Return immutable credentials.</font>
<font color="black"> 475. </font>
<font color="black"> 476.         The ``access_key``, ``secret_key``, and ``token`` properties</font>
<font color="black"> 477.         on this class will always check and refresh credentials if</font>
<font color="black"> 478.         needed before returning the particular credentials.</font>
<font color="black"> 479. </font>
<font color="black"> 480.         This has an edge case where you can get inconsistent</font>
<font color="black"> 481.         credentials.  Imagine this:</font>
<font color="black"> 482. </font>
<font color="black"> 483.             # Current creds are &quot;t1&quot;</font>
<font color="black"> 484.             tmp.access_key  ---&gt; expired? no, so return t1.access_key</font>
<font color="black"> 485.             # ---- time is now expired, creds need refreshing to &quot;t2&quot; ----</font>
<font color="black"> 486.             tmp.secret_key  ---&gt; expired? yes, refresh and return t2.secret_key</font>
<font color="black"> 487. </font>
<font color="black"> 488.         This means we're using the access key from t1 with the secret key</font>
<font color="black"> 489.         from t2.  To fix this issue, you can request a frozen credential object</font>
<font color="black"> 490.         which is guaranteed not to change.</font>
<font color="black"> 491. </font>
<font color="black"> 492.         The frozen credentials returned from this method should be used</font>
<font color="black"> 493.         immediately and then discarded.  The typical usage pattern would</font>
<font color="black"> 494.         be::</font>
<font color="black"> 495. </font>
<font color="black"> 496.             creds = RefreshableCredentials(...)</font>
<font color="black"> 497.             some_code = SomeSignerObject()</font>
<font color="black"> 498.             # I'm about to sign the request.</font>
<font color="black"> 499.             # The frozen credentials are only used for the</font>
<font color="black"> 500.             # duration of generate_presigned_url and will be</font>
<font color="black"> 501.             # immediately thrown away.</font>
<font color="black"> 502.             request = some_code.sign_some_request(</font>
<font color="black"> 503.                 with_credentials=creds.get_frozen_credentials())</font>
<font color="black"> 504.             print(&quot;Signed request:&quot;, request)</font>
<font color="black"> 505. </font>
<font color="black"> 506.         &quot;&quot;&quot;</font>
<font color="red"> 507.         self._refresh()</font>
<font color="red"> 508.         return self._frozen_credentials</font>
<font color="black"> 509. </font>
<font color="black"> 510. </font>
<font color="green"> 511. class DeferredRefreshableCredentials(RefreshableCredentials):</font>
<font color="black"> 512.     &quot;&quot;&quot;Refreshable credentials that don't require initial credentials.</font>
<font color="black"> 513. </font>
<font color="black"> 514.     refresh_using will be called upon first access.</font>
<font color="green"> 515.     &quot;&quot;&quot;</font>
<font color="green"> 516.     def __init__(self, refresh_using, method, time_fetcher=_local_now):</font>
<font color="red"> 517.         self._refresh_using = refresh_using</font>
<font color="red"> 518.         self._access_key = None</font>
<font color="red"> 519.         self._secret_key = None</font>
<font color="red"> 520.         self._token = None</font>
<font color="red"> 521.         self._expiry_time = None</font>
<font color="red"> 522.         self._time_fetcher = time_fetcher</font>
<font color="red"> 523.         self._refresh_lock = threading.Lock()</font>
<font color="red"> 524.         self.method = method</font>
<font color="red"> 525.         self._frozen_credentials = None</font>
<font color="black"> 526. </font>
<font color="green"> 527.     def refresh_needed(self, refresh_in=None):</font>
<font color="red"> 528.         if self._frozen_credentials is None:</font>
<font color="red"> 529.             return True</font>
<font color="red"> 530.         return super(DeferredRefreshableCredentials, self).refresh_needed(</font>
<font color="red"> 531.             refresh_in</font>
<font color="black"> 532.         )</font>
<font color="black"> 533. </font>
<font color="black"> 534. </font>
<font color="green"> 535. class CachedCredentialFetcher(object):</font>
<font color="green"> 536.     def __init__(self, cache=None, expiry_window_seconds=60 * 15):</font>
<font color="red"> 537.         if cache is None:</font>
<font color="red"> 538.             cache = {}</font>
<font color="red"> 539.         self._cache = cache</font>
<font color="red"> 540.         self._cache_key = self._create_cache_key()</font>
<font color="red"> 541.         self._expiry_window_seconds = expiry_window_seconds</font>
<font color="black"> 542. </font>
<font color="green"> 543.     def _create_cache_key(self):</font>
<font color="red"> 544.         raise NotImplementedError('_create_cache_key()')</font>
<font color="black"> 545. </font>
<font color="green"> 546.     def _make_file_safe(self, filename):</font>
<font color="black"> 547.         # Replace :, path sep, and / to make it the string filename safe.</font>
<font color="red"> 548.         filename = filename.replace(':', '_').replace(os.path.sep, '_')</font>
<font color="red"> 549.         return filename.replace('/', '_')</font>
<font color="black"> 550. </font>
<font color="green"> 551.     def _get_credentials(self):</font>
<font color="red"> 552.         raise NotImplementedError('_get_credentials()')</font>
<font color="black"> 553. </font>
<font color="green"> 554.     def fetch_credentials(self):</font>
<font color="red"> 555.         return self._get_cached_credentials()</font>
<font color="black"> 556. </font>
<font color="green"> 557.     def _get_cached_credentials(self):</font>
<font color="black"> 558.         &quot;&quot;&quot;Get up-to-date credentials.</font>
<font color="black"> 559. </font>
<font color="black"> 560.         This will check the cache for up-to-date credentials, calling assume</font>
<font color="black"> 561.         role if none are available.</font>
<font color="black"> 562.         &quot;&quot;&quot;</font>
<font color="red"> 563.         response = self._load_from_cache()</font>
<font color="red"> 564.         if response is None:</font>
<font color="red"> 565.             response = self._get_credentials()</font>
<font color="red"> 566.             self._write_to_cache(response)</font>
<font color="black"> 567.         else:</font>
<font color="red"> 568.             logger.debug(&quot;Credentials for role retrieved from cache.&quot;)</font>
<font color="black"> 569. </font>
<font color="red"> 570.         creds = response['Credentials']</font>
<font color="red"> 571.         expiration = _serialize_if_needed(creds['Expiration'], iso=True)</font>
<font color="red"> 572.         return {</font>
<font color="red"> 573.             'access_key': creds['AccessKeyId'],</font>
<font color="red"> 574.             'secret_key': creds['SecretAccessKey'],</font>
<font color="red"> 575.             'token': creds['SessionToken'],</font>
<font color="red"> 576.             'expiry_time': expiration,</font>
<font color="black"> 577.         }</font>
<font color="black"> 578. </font>
<font color="green"> 579.     def _load_from_cache(self):</font>
<font color="red"> 580.         if self._cache_key in self._cache:</font>
<font color="red"> 581.             creds = deepcopy(self._cache[self._cache_key])</font>
<font color="red"> 582.             if not self._is_expired(creds):</font>
<font color="red"> 583.                 return creds</font>
<font color="black"> 584.             else:</font>
<font color="red"> 585.                 logger.debug(</font>
<font color="red"> 586.                     &quot;Credentials were found in cache, but they are expired.&quot;</font>
<font color="black"> 587.                 )</font>
<font color="red"> 588.         return None</font>
<font color="black"> 589. </font>
<font color="green"> 590.     def _write_to_cache(self, response):</font>
<font color="red"> 591.         self._cache[self._cache_key] = deepcopy(response)</font>
<font color="black"> 592. </font>
<font color="green"> 593.     def _is_expired(self, credentials):</font>
<font color="black"> 594.         &quot;&quot;&quot;Check if credentials are expired.&quot;&quot;&quot;</font>
<font color="red"> 595.         end_time = _parse_if_needed(credentials['Credentials']['Expiration'])</font>
<font color="red"> 596.         seconds = total_seconds(end_time - _local_now())</font>
<font color="red"> 597.         return seconds &lt; self._expiry_window_seconds</font>
<font color="black"> 598. </font>
<font color="black"> 599. </font>
<font color="green"> 600. class AssumeRoleCredentialFetcher(CachedCredentialFetcher):</font>
<font color="black"> 601.     def __init__(self, client_creator, source_credentials, role_arn,</font>
<font color="green"> 602.                  extra_args=None, mfa_prompter=None, cache=None,</font>
<font color="green"> 603.                  expiry_window_seconds=60 * 15):</font>
<font color="black"> 604.         &quot;&quot;&quot;</font>
<font color="black"> 605.         :type client_creator: callable</font>
<font color="black"> 606.         :param client_creator: A callable that creates a client taking</font>
<font color="black"> 607.             arguments like ``Session.create_client``.</font>
<font color="black"> 608. </font>
<font color="black"> 609.         :type source_credentials: Credentials</font>
<font color="black"> 610.         :param source_credentials: The credentials to use to create the</font>
<font color="black"> 611.             client for the call to AssumeRole.</font>
<font color="black"> 612. </font>
<font color="black"> 613.         :type role_arn: str</font>
<font color="black"> 614.         :param role_arn: The ARN of the role to be assumed.</font>
<font color="black"> 615. </font>
<font color="black"> 616.         :type extra_args: dict</font>
<font color="black"> 617.         :param extra_args: Any additional arguments to add to the assume</font>
<font color="black"> 618.             role request using the format of the botocore operation.</font>
<font color="black"> 619.             Possible keys include, but may not be limited to,</font>
<font color="black"> 620.             DurationSeconds, Policy, SerialNumber, ExternalId and</font>
<font color="black"> 621.             RoleSessionName.</font>
<font color="black"> 622. </font>
<font color="black"> 623.         :type mfa_prompter: callable</font>
<font color="black"> 624.         :param mfa_prompter: A callable that returns input provided by the</font>
<font color="black"> 625.             user (i.e raw_input, getpass.getpass, etc.).</font>
<font color="black"> 626. </font>
<font color="black"> 627.         :type cache: dict</font>
<font color="black"> 628.         :param cache: An object that supports ``__getitem__``,</font>
<font color="black"> 629.             ``__setitem__``, and ``__contains__``.  An example of this is</font>
<font color="black"> 630.             the ``JSONFileCache`` class in aws-cli.</font>
<font color="black"> 631. </font>
<font color="black"> 632.         :type expiry_window_seconds: int</font>
<font color="black"> 633.         :param expiry_window_seconds: The amount of time, in seconds,</font>
<font color="black"> 634.         &quot;&quot;&quot;</font>
<font color="red"> 635.         self._client_creator = client_creator</font>
<font color="red"> 636.         self._source_credentials = source_credentials</font>
<font color="red"> 637.         self._role_arn = role_arn</font>
<font color="black"> 638. </font>
<font color="red"> 639.         if extra_args is None:</font>
<font color="red"> 640.             self._assume_kwargs = {}</font>
<font color="black"> 641.         else:</font>
<font color="red"> 642.             self._assume_kwargs = deepcopy(extra_args)</font>
<font color="red"> 643.         self._assume_kwargs['RoleArn'] = self._role_arn</font>
<font color="black"> 644. </font>
<font color="red"> 645.         self._role_session_name = self._assume_kwargs.get('RoleSessionName')</font>
<font color="red"> 646.         self._using_default_session_name = False</font>
<font color="red"> 647.         if not self._role_session_name:</font>
<font color="red"> 648.             self._role_session_name = 'botocore-session-%s' % (</font>
<font color="red"> 649.                 int(time.time()))</font>
<font color="red"> 650.             self._assume_kwargs['RoleSessionName'] = self._role_session_name</font>
<font color="red"> 651.             self._using_default_session_name = True</font>
<font color="black"> 652. </font>
<font color="red"> 653.         self._mfa_prompter = mfa_prompter</font>
<font color="red"> 654.         if self._mfa_prompter is None:</font>
<font color="red"> 655.             self._mfa_prompter = getpass.getpass</font>
<font color="black"> 656. </font>
<font color="red"> 657.         super(AssumeRoleCredentialFetcher, self).__init__(</font>
<font color="red"> 658.             cache, expiry_window_seconds</font>
<font color="black"> 659.         )</font>
<font color="black"> 660. </font>
<font color="green"> 661.     def _create_cache_key(self):</font>
<font color="black"> 662.         &quot;&quot;&quot;Create a predictable cache key for the current configuration.</font>
<font color="black"> 663. </font>
<font color="black"> 664.         The cache key is intended to be compatible with file names.</font>
<font color="black"> 665.         &quot;&quot;&quot;</font>
<font color="red"> 666.         args = deepcopy(self._assume_kwargs)</font>
<font color="black"> 667. </font>
<font color="black"> 668.         # The role session name gets randomly generated, so we don't want it</font>
<font color="black"> 669.         # in the hash.</font>
<font color="red"> 670.         if self._using_default_session_name:</font>
<font color="red"> 671.             del args['RoleSessionName']</font>
<font color="black"> 672. </font>
<font color="red"> 673.         if 'Policy' in args:</font>
<font color="black"> 674.             # To have a predictable hash, the keys of the policy must be</font>
<font color="black"> 675.             # sorted, so we have to load it here to make sure it gets sorted</font>
<font color="black"> 676.             # later on.</font>
<font color="red"> 677.             args['Policy'] = json.loads(args['Policy'])</font>
<font color="black"> 678. </font>
<font color="red"> 679.         args = json.dumps(args, sort_keys=True)</font>
<font color="red"> 680.         argument_hash = sha1(args.encode('utf-8')).hexdigest()</font>
<font color="red"> 681.         return self._make_file_safe(argument_hash)</font>
<font color="black"> 682. </font>
<font color="green"> 683.     def _get_credentials(self):</font>
<font color="black"> 684.         &quot;&quot;&quot;Get credentials by calling assume role.&quot;&quot;&quot;</font>
<font color="red"> 685.         kwargs = self._assume_role_kwargs()</font>
<font color="red"> 686.         client = self._create_client()</font>
<font color="red"> 687.         return client.assume_role(**kwargs)</font>
<font color="black"> 688. </font>
<font color="green"> 689.     def _assume_role_kwargs(self):</font>
<font color="black"> 690.         &quot;&quot;&quot;Get the arguments for assume role based on current configuration.&quot;&quot;&quot;</font>
<font color="red"> 691.         assume_role_kwargs = self._assume_kwargs</font>
<font color="red"> 692.         mfa_serial = assume_role_kwargs.get('SerialNumber')</font>
<font color="black"> 693. </font>
<font color="red"> 694.         if mfa_serial is not None:</font>
<font color="red"> 695.             prompt = 'Enter MFA code for %s: ' % mfa_serial</font>
<font color="red"> 696.             token_code = self._mfa_prompter(prompt)</font>
<font color="black"> 697. </font>
<font color="red"> 698.             assume_role_kwargs = deepcopy(assume_role_kwargs)</font>
<font color="red"> 699.             assume_role_kwargs['TokenCode'] = token_code</font>
<font color="black"> 700. </font>
<font color="red"> 701.         return assume_role_kwargs</font>
<font color="black"> 702. </font>
<font color="green"> 703.     def _create_client(self):</font>
<font color="black"> 704.         &quot;&quot;&quot;Create an STS client using the source credentials.&quot;&quot;&quot;</font>
<font color="red"> 705.         frozen_credentials = self._source_credentials.get_frozen_credentials()</font>
<font color="red"> 706.         return self._client_creator(</font>
<font color="red"> 707.             'sts',</font>
<font color="red"> 708.             aws_access_key_id=frozen_credentials.access_key,</font>
<font color="red"> 709.             aws_secret_access_key=frozen_credentials.secret_key,</font>
<font color="red"> 710.             aws_session_token=frozen_credentials.token,</font>
<font color="black"> 711.         )</font>
<font color="black"> 712. </font>
<font color="black"> 713. </font>
<font color="green"> 714. class CredentialProvider(object):</font>
<font color="black"> 715.     # A short name to identify the provider within botocore.</font>
<font color="green"> 716.     METHOD = None</font>
<font color="black"> 717. </font>
<font color="black"> 718.     # A name to identify the provider for use in cross-sdk features like</font>
<font color="black"> 719.     # assume role's `credential_source` configuration option. These names</font>
<font color="black"> 720.     # are to be treated in a case-insensitive way. NOTE: any providers not</font>
<font color="black"> 721.     # implemented in botocore MUST prefix their canonical names with</font>
<font color="black"> 722.     # 'custom' or we DO NOT guarantee that it will work with any features</font>
<font color="black"> 723.     # that this provides.</font>
<font color="green"> 724.     CANONICAL_NAME = None</font>
<font color="black"> 725. </font>
<font color="green"> 726.     def __init__(self, session=None):</font>
<font color="red"> 727.         self.session = session</font>
<font color="black"> 728. </font>
<font color="green"> 729.     def load(self):</font>
<font color="black"> 730.         &quot;&quot;&quot;</font>
<font color="black"> 731.         Loads the credentials from their source &amp; sets them on the object.</font>
<font color="black"> 732. </font>
<font color="black"> 733.         Subclasses should implement this method (by reading from disk, the</font>
<font color="black"> 734.         environment, the network or wherever), returning ``True`` if they were</font>
<font color="black"> 735.         found &amp; loaded.</font>
<font color="black"> 736. </font>
<font color="black"> 737.         If not found, this method should return ``False``, indictating that the</font>
<font color="black"> 738.         ``CredentialResolver`` should fall back to the next available method.</font>
<font color="black"> 739. </font>
<font color="black"> 740.         The default implementation does nothing, assuming the user has set the</font>
<font color="black"> 741.         ``access_key/secret_key/token`` themselves.</font>
<font color="black"> 742. </font>
<font color="black"> 743.         :returns: Whether credentials were found &amp; set</font>
<font color="black"> 744.         :rtype: Credentials</font>
<font color="black"> 745.         &quot;&quot;&quot;</font>
<font color="red"> 746.         return True</font>
<font color="black"> 747. </font>
<font color="green"> 748.     def _extract_creds_from_mapping(self, mapping, *key_names):</font>
<font color="green"> 749.         found = []</font>
<font color="green"> 750.         for key_name in key_names:</font>
<font color="green"> 751.             try:</font>
<font color="green"> 752.                 found.append(mapping[key_name])</font>
<font color="red"> 753.             except KeyError:</font>
<font color="red"> 754.                 raise PartialCredentialsError(provider=self.METHOD,</font>
<font color="red"> 755.                                               cred_var=key_name)</font>
<font color="green"> 756.         return found</font>
<font color="black"> 757. </font>
<font color="black"> 758. </font>
<font color="green"> 759. class ProcessProvider(CredentialProvider):</font>
<font color="black"> 760. </font>
<font color="green"> 761.     METHOD = 'custom-process'</font>
<font color="black"> 762. </font>
<font color="green"> 763.     def __init__(self, profile_name, load_config, popen=subprocess.Popen):</font>
<font color="green"> 764.         self._profile_name = profile_name</font>
<font color="green"> 765.         self._load_config = load_config</font>
<font color="green"> 766.         self._loaded_config = None</font>
<font color="green"> 767.         self._popen = popen</font>
<font color="black"> 768. </font>
<font color="green"> 769.     def load(self):</font>
<font color="red"> 770.         credential_process = self._credential_process</font>
<font color="red"> 771.         if credential_process is None:</font>
<font color="red"> 772.             return</font>
<font color="black"> 773. </font>
<font color="red"> 774.         creds_dict = self._retrieve_credentials_using(credential_process)</font>
<font color="red"> 775.         if creds_dict.get('expiry_time') is not None:</font>
<font color="red"> 776.             return RefreshableCredentials.create_from_metadata(</font>
<font color="red"> 777.                 creds_dict,</font>
<font color="red"> 778.                 lambda: self._retrieve_credentials_using(credential_process),</font>
<font color="red"> 779.                 self.METHOD</font>
<font color="black"> 780.             )</font>
<font color="black"> 781. </font>
<font color="red"> 782.         return Credentials(</font>
<font color="red"> 783.             access_key=creds_dict['access_key'],</font>
<font color="red"> 784.             secret_key=creds_dict['secret_key'],</font>
<font color="red"> 785.             token=creds_dict.get('token'),</font>
<font color="red"> 786.             method=self.METHOD</font>
<font color="black"> 787.         )</font>
<font color="black"> 788. </font>
<font color="green"> 789.     def _retrieve_credentials_using(self, credential_process):</font>
<font color="black"> 790.         # We're not using shell=True, so we need to pass the</font>
<font color="black"> 791.         # command and all arguments as a list.</font>
<font color="red"> 792.         process_list = compat_shell_split(credential_process)</font>
<font color="red"> 793.         p = self._popen(process_list,</font>
<font color="red"> 794.                         stdout=subprocess.PIPE,</font>
<font color="red"> 795.                         stderr=subprocess.PIPE)</font>
<font color="red"> 796.         stdout, stderr = p.communicate()</font>
<font color="red"> 797.         if p.returncode != 0:</font>
<font color="red"> 798.             raise CredentialRetrievalError(</font>
<font color="red"> 799.                 provider=self.METHOD, error_msg=stderr.decode('utf-8'))</font>
<font color="red"> 800.         parsed = botocore.compat.json.loads(stdout.decode('utf-8'))</font>
<font color="red"> 801.         version = parsed.get('Version', '&lt;Version key not provided&gt;')</font>
<font color="red"> 802.         if version != 1:</font>
<font color="red"> 803.             raise CredentialRetrievalError(</font>
<font color="red"> 804.                 provider=self.METHOD,</font>
<font color="red"> 805.                 error_msg=(&quot;Unsupported version '%s' for credential process &quot;</font>
<font color="red"> 806.                            &quot;provider, supported versions: 1&quot; % version))</font>
<font color="red"> 807.         try:</font>
<font color="red"> 808.             return {</font>
<font color="red"> 809.                 'access_key': parsed['AccessKeyId'],</font>
<font color="red"> 810.                 'secret_key': parsed['SecretAccessKey'],</font>
<font color="red"> 811.                 'token': parsed.get('SessionToken'),</font>
<font color="red"> 812.                 'expiry_time': parsed.get('Expiration'),</font>
<font color="black"> 813.             }</font>
<font color="red"> 814.         except KeyError as e:</font>
<font color="red"> 815.             raise CredentialRetrievalError(</font>
<font color="red"> 816.                 provider=self.METHOD,</font>
<font color="red"> 817.                 error_msg=&quot;Missing required key in response: %s&quot; % e</font>
<font color="black"> 818.             )</font>
<font color="black"> 819. </font>
<font color="green"> 820.     @property</font>
<font color="black"> 821.     def _credential_process(self):</font>
<font color="red"> 822.         if self._loaded_config is None:</font>
<font color="red"> 823.             self._loaded_config = self._load_config()</font>
<font color="red"> 824.         profile_config = self._loaded_config.get(</font>
<font color="red"> 825.             'profiles', {}).get(self._profile_name, {})</font>
<font color="red"> 826.         return profile_config.get('credential_process')</font>
<font color="black"> 827. </font>
<font color="black"> 828. </font>
<font color="green"> 829. class InstanceMetadataProvider(CredentialProvider):</font>
<font color="green"> 830.     METHOD = 'iam-role'</font>
<font color="green"> 831.     CANONICAL_NAME = 'Ec2InstanceMetadata'</font>
<font color="black"> 832. </font>
<font color="green"> 833.     def __init__(self, iam_role_fetcher):</font>
<font color="green"> 834.         self._role_fetcher = iam_role_fetcher</font>
<font color="black"> 835. </font>
<font color="green"> 836.     def load(self):</font>
<font color="red"> 837.         fetcher = self._role_fetcher</font>
<font color="black"> 838.         # We do the first request, to see if we get useful data back.</font>
<font color="black"> 839.         # If not, we'll pass &amp; move on to whatever's next in the credential</font>
<font color="black"> 840.         # chain.</font>
<font color="red"> 841.         metadata = fetcher.retrieve_iam_role_credentials()</font>
<font color="red"> 842.         if not metadata:</font>
<font color="red"> 843.             return None</font>
<font color="red"> 844.         logger.debug('Found credentials from IAM Role: %s',</font>
<font color="red"> 845.                      metadata['role_name'])</font>
<font color="black"> 846.         # We manually set the data here, since we already made the request &amp;</font>
<font color="black"> 847.         # have it. When the expiry is hit, the credentials will auto-refresh</font>
<font color="black"> 848.         # themselves.</font>
<font color="red"> 849.         creds = RefreshableCredentials.create_from_metadata(</font>
<font color="red"> 850.             metadata,</font>
<font color="red"> 851.             method=self.METHOD,</font>
<font color="red"> 852.             refresh_using=fetcher.retrieve_iam_role_credentials,</font>
<font color="black"> 853.         )</font>
<font color="red"> 854.         return creds</font>
<font color="black"> 855. </font>
<font color="black"> 856. </font>
<font color="green"> 857. class EnvProvider(CredentialProvider):</font>
<font color="green"> 858.     METHOD = 'env'</font>
<font color="green"> 859.     CANONICAL_NAME = 'Environment'</font>
<font color="green"> 860.     ACCESS_KEY = 'AWS_ACCESS_KEY_ID'</font>
<font color="green"> 861.     SECRET_KEY = 'AWS_SECRET_ACCESS_KEY'</font>
<font color="black"> 862.     # The token can come from either of these env var.</font>
<font color="black"> 863.     # AWS_SESSION_TOKEN is what other AWS SDKs have standardized on.</font>
<font color="green"> 864.     TOKENS = ['AWS_SECURITY_TOKEN', 'AWS_SESSION_TOKEN']</font>
<font color="green"> 865.     EXPIRY_TIME = 'AWS_CREDENTIAL_EXPIRATION'</font>
<font color="black"> 866. </font>
<font color="green"> 867.     def __init__(self, environ=None, mapping=None):</font>
<font color="black"> 868.         &quot;&quot;&quot;</font>
<font color="black"> 869. </font>
<font color="black"> 870.         :param environ: The environment variables (defaults to</font>
<font color="black"> 871.             ``os.environ`` if no value is provided).</font>
<font color="black"> 872.         :param mapping: An optional mapping of variable names to</font>
<font color="black"> 873.             environment variable names.  Use this if you want to</font>
<font color="black"> 874.             change the mapping of access_key-&gt;AWS_ACCESS_KEY_ID, etc.</font>
<font color="black"> 875.             The dict can have up to 3 keys: ``access_key``, ``secret_key``,</font>
<font color="black"> 876.             ``session_token``.</font>
<font color="black"> 877.         &quot;&quot;&quot;</font>
<font color="green"> 878.         if environ is None:</font>
<font color="green"> 879.             environ = os.environ</font>
<font color="green"> 880.         self.environ = environ</font>
<font color="green"> 881.         self._mapping = self._build_mapping(mapping)</font>
<font color="black"> 882. </font>
<font color="green"> 883.     def _build_mapping(self, mapping):</font>
<font color="black"> 884.         # Mapping of variable name to env var name.</font>
<font color="green"> 885.         var_mapping = {}</font>
<font color="green"> 886.         if mapping is None:</font>
<font color="black"> 887.             # Use the class var default.</font>
<font color="green"> 888.             var_mapping['access_key'] = self.ACCESS_KEY</font>
<font color="green"> 889.             var_mapping['secret_key'] = self.SECRET_KEY</font>
<font color="green"> 890.             var_mapping['token'] = self.TOKENS</font>
<font color="green"> 891.             var_mapping['expiry_time'] = self.EXPIRY_TIME</font>
<font color="black"> 892.         else:</font>
<font color="red"> 893.             var_mapping['access_key'] = mapping.get(</font>
<font color="red"> 894.                 'access_key', self.ACCESS_KEY)</font>
<font color="red"> 895.             var_mapping['secret_key'] = mapping.get(</font>
<font color="red"> 896.                 'secret_key', self.SECRET_KEY)</font>
<font color="red"> 897.             var_mapping['token'] = mapping.get(</font>
<font color="red"> 898.                 'token', self.TOKENS)</font>
<font color="red"> 899.             if not isinstance(var_mapping['token'], list):</font>
<font color="red"> 900.                 var_mapping['token'] = [var_mapping['token']]</font>
<font color="red"> 901.             var_mapping['expiry_time'] = mapping.get(</font>
<font color="red"> 902.                 'expiry_time', self.EXPIRY_TIME)</font>
<font color="green"> 903.         return var_mapping</font>
<font color="black"> 904. </font>
<font color="green"> 905.     def load(self):</font>
<font color="black"> 906.         &quot;&quot;&quot;</font>
<font color="black"> 907.         Search for credentials in explicit environment variables.</font>
<font color="black"> 908.         &quot;&quot;&quot;</font>
<font color="green"> 909.         if self._mapping['access_key'] in self.environ:</font>
<font color="red"> 910.             logger.info('Found credentials in environment variables.')</font>
<font color="red"> 911.             fetcher = self._create_credentials_fetcher()</font>
<font color="red"> 912.             credentials = fetcher(require_expiry=False)</font>
<font color="black"> 913. </font>
<font color="red"> 914.             expiry_time = credentials['expiry_time']</font>
<font color="red"> 915.             if expiry_time is not None:</font>
<font color="red"> 916.                 expiry_time = parse(expiry_time)</font>
<font color="red"> 917.                 return RefreshableCredentials(</font>
<font color="red"> 918.                     credentials['access_key'], credentials['secret_key'],</font>
<font color="red"> 919.                     credentials['token'], expiry_time,</font>
<font color="red"> 920.                     refresh_using=fetcher, method=self.METHOD</font>
<font color="black"> 921.                 )</font>
<font color="black"> 922. </font>
<font color="red"> 923.             return Credentials(</font>
<font color="red"> 924.                 credentials['access_key'], credentials['secret_key'],</font>
<font color="red"> 925.                 credentials['token'], method=self.METHOD</font>
<font color="black"> 926.             )</font>
<font color="black"> 927.         else:</font>
<font color="green"> 928.             return None</font>
<font color="black"> 929. </font>
<font color="green"> 930.     def _create_credentials_fetcher(self):</font>
<font color="red"> 931.         mapping = self._mapping</font>
<font color="red"> 932.         method = self.METHOD</font>
<font color="red"> 933.         environ = self.environ</font>
<font color="black"> 934. </font>
<font color="red"> 935.         def fetch_credentials(require_expiry=True):</font>
<font color="red"> 936.             credentials = {}</font>
<font color="black"> 937. </font>
<font color="red"> 938.             access_key = environ.get(mapping['access_key'])</font>
<font color="red"> 939.             if access_key is None:</font>
<font color="red"> 940.                 raise PartialCredentialsError(</font>
<font color="red"> 941.                     provider=method, cred_var=mapping['access_key'])</font>
<font color="red"> 942.             credentials['access_key'] = access_key</font>
<font color="black"> 943. </font>
<font color="red"> 944.             secret_key = environ.get(mapping['secret_key'])</font>
<font color="red"> 945.             if secret_key is None:</font>
<font color="red"> 946.                 raise PartialCredentialsError(</font>
<font color="red"> 947.                     provider=method, cred_var=mapping['secret_key'])</font>
<font color="red"> 948.             credentials['secret_key'] = secret_key</font>
<font color="black"> 949. </font>
<font color="red"> 950.             token = None</font>
<font color="red"> 951.             for token_env_var in mapping['token']:</font>
<font color="red"> 952.                 if token_env_var in environ:</font>
<font color="red"> 953.                     token = environ[token_env_var]</font>
<font color="red"> 954.                     break</font>
<font color="red"> 955.             credentials['token'] = token</font>
<font color="black"> 956. </font>
<font color="red"> 957.             expiry_time = environ.get(mapping['expiry_time'])</font>
<font color="red"> 958.             if require_expiry and expiry_time is None:</font>
<font color="red"> 959.                 raise PartialCredentialsError(</font>
<font color="red"> 960.                     provider=method, cred_var=mapping['expiry_time'])</font>
<font color="red"> 961.             credentials['expiry_time'] = expiry_time</font>
<font color="black"> 962. </font>
<font color="red"> 963.             return credentials</font>
<font color="black"> 964. </font>
<font color="red"> 965.         return fetch_credentials</font>
<font color="black"> 966. </font>
<font color="black"> 967. </font>
<font color="green"> 968. class OriginalEC2Provider(CredentialProvider):</font>
<font color="green"> 969.     METHOD = 'ec2-credentials-file'</font>
<font color="green"> 970.     CANONICAL_NAME = 'Ec2Config'</font>
<font color="black"> 971. </font>
<font color="green"> 972.     CRED_FILE_ENV = 'AWS_CREDENTIAL_FILE'</font>
<font color="green"> 973.     ACCESS_KEY = 'AWSAccessKeyId'</font>
<font color="green"> 974.     SECRET_KEY = 'AWSSecretKey'</font>
<font color="black"> 975. </font>
<font color="green"> 976.     def __init__(self, environ=None, parser=None):</font>
<font color="green"> 977.         if environ is None:</font>
<font color="green"> 978.             environ = os.environ</font>
<font color="green"> 979.         if parser is None:</font>
<font color="green"> 980.             parser = parse_key_val_file</font>
<font color="green"> 981.         self._environ = environ</font>
<font color="green"> 982.         self._parser = parser</font>
<font color="black"> 983. </font>
<font color="green"> 984.     def load(self):</font>
<font color="black"> 985.         &quot;&quot;&quot;</font>
<font color="black"> 986.         Search for a credential file used by original EC2 CLI tools.</font>
<font color="black"> 987.         &quot;&quot;&quot;</font>
<font color="red"> 988.         if 'AWS_CREDENTIAL_FILE' in self._environ:</font>
<font color="red"> 989.             full_path = os.path.expanduser(</font>
<font color="red"> 990.                 self._environ['AWS_CREDENTIAL_FILE'])</font>
<font color="red"> 991.             creds = self._parser(full_path)</font>
<font color="red"> 992.             if self.ACCESS_KEY in creds:</font>
<font color="red"> 993.                 logger.info('Found credentials in AWS_CREDENTIAL_FILE.')</font>
<font color="red"> 994.                 access_key = creds[self.ACCESS_KEY]</font>
<font color="red"> 995.                 secret_key = creds[self.SECRET_KEY]</font>
<font color="black"> 996.                 # EC2 creds file doesn't support session tokens.</font>
<font color="red"> 997.                 return Credentials(access_key, secret_key, method=self.METHOD)</font>
<font color="black"> 998.         else:</font>
<font color="red"> 999.             return None</font>
<font color="black">1000. </font>
<font color="black">1001. </font>
<font color="green">1002. class SharedCredentialProvider(CredentialProvider):</font>
<font color="green">1003.     METHOD = 'shared-credentials-file'</font>
<font color="green">1004.     CANONICAL_NAME = 'SharedCredentials'</font>
<font color="black">1005. </font>
<font color="green">1006.     ACCESS_KEY = 'aws_access_key_id'</font>
<font color="green">1007.     SECRET_KEY = 'aws_secret_access_key'</font>
<font color="black">1008.     # Same deal as the EnvProvider above.  Botocore originally supported</font>
<font color="black">1009.     # aws_security_token, but the SDKs are standardizing on aws_session_token</font>
<font color="black">1010.     # so we support both.</font>
<font color="green">1011.     TOKENS = ['aws_security_token', 'aws_session_token']</font>
<font color="black">1012. </font>
<font color="green">1013.     def __init__(self, creds_filename, profile_name=None, ini_parser=None):</font>
<font color="green">1014.         self._creds_filename = creds_filename</font>
<font color="green">1015.         if profile_name is None:</font>
<font color="red">1016.             profile_name = 'default'</font>
<font color="green">1017.         self._profile_name = profile_name</font>
<font color="green">1018.         if ini_parser is None:</font>
<font color="green">1019.             ini_parser = botocore.configloader.raw_config_parse</font>
<font color="green">1020.         self._ini_parser = ini_parser</font>
<font color="black">1021. </font>
<font color="green">1022.     def load(self):</font>
<font color="green">1023.         try:</font>
<font color="green">1024.             available_creds = self._ini_parser(self._creds_filename)</font>
<font color="red">1025.         except ConfigNotFound:</font>
<font color="red">1026.             return None</font>
<font color="green">1027.         if self._profile_name in available_creds:</font>
<font color="green">1028.             config = available_creds[self._profile_name]</font>
<font color="green">1029.             if self.ACCESS_KEY in config:</font>
<font color="green">1030.                 logger.info(&quot;Found credentials in shared credentials file: %s&quot;,</font>
<font color="green">1031.                             self._creds_filename)</font>
<font color="green">1032.                 access_key, secret_key = self._extract_creds_from_mapping(</font>
<font color="green">1033.                     config, self.ACCESS_KEY, self.SECRET_KEY)</font>
<font color="green">1034.                 token = self._get_session_token(config)</font>
<font color="green">1035.                 return Credentials(access_key, secret_key, token,</font>
<font color="green">1036.                                    method=self.METHOD)</font>
<font color="black">1037. </font>
<font color="green">1038.     def _get_session_token(self, config):</font>
<font color="green">1039.         for token_envvar in self.TOKENS:</font>
<font color="green">1040.             if token_envvar in config:</font>
<font color="red">1041.                 return config[token_envvar]</font>
<font color="black">1042. </font>
<font color="black">1043. </font>
<font color="green">1044. class ConfigProvider(CredentialProvider):</font>
<font color="green">1045.     &quot;&quot;&quot;INI based config provider with profile sections.&quot;&quot;&quot;</font>
<font color="green">1046.     METHOD = 'config-file'</font>
<font color="green">1047.     CANONICAL_NAME = 'SharedConfig'</font>
<font color="black">1048. </font>
<font color="green">1049.     ACCESS_KEY = 'aws_access_key_id'</font>
<font color="green">1050.     SECRET_KEY = 'aws_secret_access_key'</font>
<font color="black">1051.     # Same deal as the EnvProvider above.  Botocore originally supported</font>
<font color="black">1052.     # aws_security_token, but the SDKs are standardizing on aws_session_token</font>
<font color="black">1053.     # so we support both.</font>
<font color="green">1054.     TOKENS = ['aws_security_token', 'aws_session_token']</font>
<font color="black">1055. </font>
<font color="green">1056.     def __init__(self, config_filename, profile_name, config_parser=None):</font>
<font color="black">1057.         &quot;&quot;&quot;</font>
<font color="black">1058. </font>
<font color="black">1059.         :param config_filename: The session configuration scoped to the current</font>
<font color="black">1060.             profile.  This is available via ``session.config``.</font>
<font color="black">1061.         :param profile_name: The name of the current profile.</font>
<font color="black">1062.         :param config_parser: A config parser callable.</font>
<font color="black">1063. </font>
<font color="black">1064.         &quot;&quot;&quot;</font>
<font color="green">1065.         self._config_filename = config_filename</font>
<font color="green">1066.         self._profile_name = profile_name</font>
<font color="green">1067.         if config_parser is None:</font>
<font color="green">1068.             config_parser = botocore.configloader.load_config</font>
<font color="green">1069.         self._config_parser = config_parser</font>
<font color="black">1070. </font>
<font color="green">1071.     def load(self):</font>
<font color="black">1072.         &quot;&quot;&quot;</font>
<font color="black">1073.         If there is are credentials in the configuration associated with</font>
<font color="black">1074.         the session, use those.</font>
<font color="black">1075.         &quot;&quot;&quot;</font>
<font color="red">1076.         try:</font>
<font color="red">1077.             full_config = self._config_parser(self._config_filename)</font>
<font color="red">1078.         except ConfigNotFound:</font>
<font color="red">1079.             return None</font>
<font color="red">1080.         if self._profile_name in full_config['profiles']:</font>
<font color="red">1081.             profile_config = full_config['profiles'][self._profile_name]</font>
<font color="red">1082.             if self.ACCESS_KEY in profile_config:</font>
<font color="red">1083.                 logger.info(&quot;Credentials found in config file: %s&quot;,</font>
<font color="red">1084.                             self._config_filename)</font>
<font color="red">1085.                 access_key, secret_key = self._extract_creds_from_mapping(</font>
<font color="red">1086.                     profile_config, self.ACCESS_KEY, self.SECRET_KEY)</font>
<font color="red">1087.                 token = self._get_session_token(profile_config)</font>
<font color="red">1088.                 return Credentials(access_key, secret_key, token,</font>
<font color="red">1089.                                    method=self.METHOD)</font>
<font color="black">1090.         else:</font>
<font color="red">1091.             return None</font>
<font color="black">1092. </font>
<font color="green">1093.     def _get_session_token(self, profile_config):</font>
<font color="red">1094.         for token_name in self.TOKENS:</font>
<font color="red">1095.             if token_name in profile_config:</font>
<font color="red">1096.                 return profile_config[token_name]</font>
<font color="black">1097. </font>
<font color="black">1098. </font>
<font color="green">1099. class BotoProvider(CredentialProvider):</font>
<font color="green">1100.     METHOD = 'boto-config'</font>
<font color="green">1101.     CANONICAL_NAME = 'Boto2Config'</font>
<font color="black">1102. </font>
<font color="green">1103.     BOTO_CONFIG_ENV = 'BOTO_CONFIG'</font>
<font color="green">1104.     DEFAULT_CONFIG_FILENAMES = ['/etc/boto.cfg', '~/.boto']</font>
<font color="green">1105.     ACCESS_KEY = 'aws_access_key_id'</font>
<font color="green">1106.     SECRET_KEY = 'aws_secret_access_key'</font>
<font color="black">1107. </font>
<font color="green">1108.     def __init__(self, environ=None, ini_parser=None):</font>
<font color="green">1109.         if environ is None:</font>
<font color="green">1110.             environ = os.environ</font>
<font color="green">1111.         if ini_parser is None:</font>
<font color="green">1112.             ini_parser = botocore.configloader.raw_config_parse</font>
<font color="green">1113.         self._environ = environ</font>
<font color="green">1114.         self._ini_parser = ini_parser</font>
<font color="black">1115. </font>
<font color="green">1116.     def load(self):</font>
<font color="black">1117.         &quot;&quot;&quot;</font>
<font color="black">1118.         Look for credentials in boto config file.</font>
<font color="black">1119.         &quot;&quot;&quot;</font>
<font color="red">1120.         if self.BOTO_CONFIG_ENV in self._environ:</font>
<font color="red">1121.             potential_locations = [self._environ[self.BOTO_CONFIG_ENV]]</font>
<font color="black">1122.         else:</font>
<font color="red">1123.             potential_locations = self.DEFAULT_CONFIG_FILENAMES</font>
<font color="red">1124.         for filename in potential_locations:</font>
<font color="red">1125.             try:</font>
<font color="red">1126.                 config = self._ini_parser(filename)</font>
<font color="red">1127.             except ConfigNotFound:</font>
<font color="black">1128.                 # Move on to the next potential config file name.</font>
<font color="red">1129.                 continue</font>
<font color="red">1130.             if 'Credentials' in config:</font>
<font color="red">1131.                 credentials = config['Credentials']</font>
<font color="red">1132.                 if self.ACCESS_KEY in credentials:</font>
<font color="red">1133.                     logger.info(&quot;Found credentials in boto config file: %s&quot;,</font>
<font color="red">1134.                                 filename)</font>
<font color="red">1135.                     access_key, secret_key = self._extract_creds_from_mapping(</font>
<font color="red">1136.                         credentials, self.ACCESS_KEY, self.SECRET_KEY)</font>
<font color="red">1137.                     return Credentials(access_key, secret_key,</font>
<font color="red">1138.                                        method=self.METHOD)</font>
<font color="black">1139. </font>
<font color="black">1140. </font>
<font color="green">1141. class AssumeRoleProvider(CredentialProvider):</font>
<font color="green">1142.     METHOD = 'assume-role'</font>
<font color="black">1143.     # The AssumeRole provider is logically part of the SharedConfig and</font>
<font color="black">1144.     # SharedCredentials providers. Since the purpose of the canonical name</font>
<font color="black">1145.     # is to provide cross-sdk compatibility, calling code will need to be</font>
<font color="black">1146.     # aware that either of those providers should be tied to the AssumeRole</font>
<font color="black">1147.     # provider as much as possible.</font>
<font color="green">1148.     CANONICAL_NAME = None</font>
<font color="green">1149.     ROLE_CONFIG_VAR = 'role_arn'</font>
<font color="black">1150.     # Credentials are considered expired (and will be refreshed) once the total</font>
<font color="black">1151.     # remaining time left until the credentials expires is less than the</font>
<font color="black">1152.     # EXPIRY_WINDOW.</font>
<font color="green">1153.     EXPIRY_WINDOW_SECONDS = 60 * 15</font>
<font color="black">1154. </font>
<font color="black">1155.     def __init__(self, load_config, client_creator, cache, profile_name,</font>
<font color="green">1156.                  prompter=getpass.getpass, credential_sourcer=None):</font>
<font color="black">1157.         &quot;&quot;&quot;</font>
<font color="black">1158.         :type load_config: callable</font>
<font color="black">1159.         :param load_config: A function that accepts no arguments, and</font>
<font color="black">1160.             when called, will return the full configuration dictionary</font>
<font color="black">1161.             for the session (``session.full_config``).</font>
<font color="black">1162. </font>
<font color="black">1163.         :type client_creator: callable</font>
<font color="black">1164.         :param client_creator: A factory function that will create</font>
<font color="black">1165.             a client when called.  Has the same interface as</font>
<font color="black">1166.             ``botocore.session.Session.create_client``.</font>
<font color="black">1167. </font>
<font color="black">1168.         :type cache: dict</font>
<font color="black">1169.         :param cache: An object that supports ``__getitem__``,</font>
<font color="black">1170.             ``__setitem__``, and ``__contains__``.  An example</font>
<font color="black">1171.             of this is the ``JSONFileCache`` class in the CLI.</font>
<font color="black">1172. </font>
<font color="black">1173.         :type profile_name: str</font>
<font color="black">1174.         :param profile_name: The name of the profile.</font>
<font color="black">1175. </font>
<font color="black">1176.         :type prompter: callable</font>
<font color="black">1177.         :param prompter: A callable that returns input provided</font>
<font color="black">1178.             by the user (i.e raw_input, getpass.getpass, etc.).</font>
<font color="black">1179. </font>
<font color="black">1180.         :type credential_sourcer: CanonicalNameCredentialSourcer</font>
<font color="black">1181.         :param credential_sourcer: A credential provider that takes a</font>
<font color="black">1182.             configuration, which is used to provide the source credentials</font>
<font color="black">1183.             for the STS call.</font>
<font color="black">1184.         &quot;&quot;&quot;</font>
<font color="black">1185.         #: The cache used to first check for assumed credentials.</font>
<font color="black">1186.         #: This is checked before making the AssumeRole API</font>
<font color="black">1187.         #: calls and can be useful if you have short lived</font>
<font color="black">1188.         #: scripts and you'd like to avoid calling AssumeRole</font>
<font color="black">1189.         #: until the credentials are expired.</font>
<font color="green">1190.         self.cache = cache</font>
<font color="green">1191.         self._load_config = load_config</font>
<font color="black">1192.         # client_creator is a callable that creates function.</font>
<font color="black">1193.         # It's basically session.create_client</font>
<font color="green">1194.         self._client_creator = client_creator</font>
<font color="green">1195.         self._profile_name = profile_name</font>
<font color="green">1196.         self._prompter = prompter</font>
<font color="black">1197.         # The _loaded_config attribute will be populated from the</font>
<font color="black">1198.         # load_config() function once the configuration is actually</font>
<font color="black">1199.         # loaded.  The reason we go through all this instead of just</font>
<font color="black">1200.         # requiring that the loaded_config be passed to us is to that</font>
<font color="black">1201.         # we can defer configuration loaded until we actually try</font>
<font color="black">1202.         # to load credentials (as opposed to when the object is</font>
<font color="black">1203.         # instantiated).</font>
<font color="green">1204.         self._loaded_config = {}</font>
<font color="green">1205.         self._credential_sourcer = credential_sourcer</font>
<font color="green">1206.         self._visited_profiles = [self._profile_name]</font>
<font color="black">1207. </font>
<font color="green">1208.     def load(self):</font>
<font color="green">1209.         self._loaded_config = self._load_config()</font>
<font color="green">1210.         profiles = self._loaded_config.get('profiles', {})</font>
<font color="green">1211.         profile = profiles.get(self._profile_name, {})</font>
<font color="green">1212.         if self._has_assume_role_config_vars(profile):</font>
<font color="red">1213.             return self._load_creds_via_assume_role(self._profile_name)</font>
<font color="black">1214. </font>
<font color="green">1215.     def _has_assume_role_config_vars(self, profile):</font>
<font color="green">1216.         return self.ROLE_CONFIG_VAR in profile</font>
<font color="black">1217. </font>
<font color="green">1218.     def _load_creds_via_assume_role(self, profile_name):</font>
<font color="red">1219.         role_config = self._get_role_config(profile_name)</font>
<font color="red">1220.         source_credentials = self._resolve_source_credentials(</font>
<font color="red">1221.             role_config, profile_name</font>
<font color="black">1222.         )</font>
<font color="black">1223. </font>
<font color="red">1224.         extra_args = {}</font>
<font color="red">1225.         role_session_name = role_config.get('role_session_name')</font>
<font color="red">1226.         if role_session_name is not None:</font>
<font color="red">1227.             extra_args['RoleSessionName'] = role_session_name</font>
<font color="black">1228. </font>
<font color="red">1229.         external_id = role_config.get('external_id')</font>
<font color="red">1230.         if external_id is not None:</font>
<font color="red">1231.             extra_args['ExternalId'] = external_id</font>
<font color="black">1232. </font>
<font color="red">1233.         mfa_serial = role_config.get('mfa_serial')</font>
<font color="red">1234.         if mfa_serial is not None:</font>
<font color="red">1235.             extra_args['SerialNumber'] = mfa_serial</font>
<font color="black">1236. </font>
<font color="red">1237.         fetcher = AssumeRoleCredentialFetcher(</font>
<font color="red">1238.             client_creator=self._client_creator,</font>
<font color="red">1239.             source_credentials=source_credentials,</font>
<font color="red">1240.             role_arn=role_config['role_arn'],</font>
<font color="red">1241.             extra_args=extra_args,</font>
<font color="red">1242.             mfa_prompter=self._prompter,</font>
<font color="red">1243.             cache=self.cache,</font>
<font color="black">1244.         )</font>
<font color="red">1245.         refresher = fetcher.fetch_credentials</font>
<font color="red">1246.         if mfa_serial is not None:</font>
<font color="red">1247.             refresher = create_mfa_serial_refresher(refresher)</font>
<font color="black">1248. </font>
<font color="black">1249.         # The initial credentials are empty and the expiration time is set</font>
<font color="black">1250.         # to now so that we can delay the call to assume role until it is</font>
<font color="black">1251.         # strictly needed.</font>
<font color="red">1252.         return DeferredRefreshableCredentials(</font>
<font color="red">1253.             method=self.METHOD,</font>
<font color="red">1254.             refresh_using=refresher,</font>
<font color="red">1255.             time_fetcher=_local_now</font>
<font color="black">1256.         )</font>
<font color="black">1257. </font>
<font color="green">1258.     def _get_role_config(self, profile_name):</font>
<font color="black">1259.         &quot;&quot;&quot;Retrieves and validates the role configuration for the profile.&quot;&quot;&quot;</font>
<font color="red">1260.         profiles = self._loaded_config.get('profiles', {})</font>
<font color="black">1261. </font>
<font color="red">1262.         profile = profiles[profile_name]</font>
<font color="red">1263.         source_profile = profile.get('source_profile')</font>
<font color="red">1264.         role_arn = profile['role_arn']</font>
<font color="red">1265.         credential_source = profile.get('credential_source')</font>
<font color="red">1266.         mfa_serial = profile.get('mfa_serial')</font>
<font color="red">1267.         external_id = profile.get('external_id')</font>
<font color="red">1268.         role_session_name = profile.get('role_session_name')</font>
<font color="black">1269. </font>
<font color="red">1270.         role_config = {</font>
<font color="red">1271.             'role_arn': role_arn,</font>
<font color="red">1272.             'external_id': external_id,</font>
<font color="red">1273.             'mfa_serial': mfa_serial,</font>
<font color="red">1274.             'role_session_name': role_session_name,</font>
<font color="red">1275.             'source_profile': source_profile,</font>
<font color="red">1276.             'credential_source': credential_source</font>
<font color="black">1277.         }</font>
<font color="black">1278. </font>
<font color="black">1279.         # Either the credential source or the source profile must be</font>
<font color="black">1280.         # specified, but not both.</font>
<font color="red">1281.         if credential_source is not None and source_profile is not None:</font>
<font color="red">1282.             raise InvalidConfigError(</font>
<font color="black">1283.                 error_msg=(</font>
<font color="red">1284.                     'The profile &quot;%s&quot; contains both source_profile and '</font>
<font color="red">1285.                     'credential_source.' % profile_name</font>
<font color="black">1286.                 )</font>
<font color="black">1287.             )</font>
<font color="red">1288.         elif credential_source is None and source_profile is None:</font>
<font color="red">1289.             raise PartialCredentialsError(</font>
<font color="red">1290.                 provider=self.METHOD,</font>
<font color="red">1291.                 cred_var='source_profile or credential_source'</font>
<font color="black">1292.             )</font>
<font color="red">1293.         elif credential_source is not None:</font>
<font color="red">1294.             self._validate_credential_source(</font>
<font color="red">1295.                 profile_name, credential_source)</font>
<font color="black">1296.         else:</font>
<font color="red">1297.             self._validate_source_profile(profile_name, source_profile)</font>
<font color="black">1298. </font>
<font color="red">1299.         return role_config</font>
<font color="black">1300. </font>
<font color="green">1301.     def _validate_credential_source(self, parent_profile, credential_source):</font>
<font color="red">1302.         if self._credential_sourcer is None:</font>
<font color="red">1303.             raise InvalidConfigError(error_msg=(</font>
<font color="red">1304.                 'The credential_source &quot;%s&quot; is specified in profile &quot;%s&quot;, '</font>
<font color="black">1305.                 'but no source provider was configured.' % (</font>
<font color="red">1306.                     credential_source, parent_profile)</font>
<font color="black">1307.             ))</font>
<font color="red">1308.         if not self._credential_sourcer.is_supported(credential_source):</font>
<font color="red">1309.             raise InvalidConfigError(error_msg=(</font>
<font color="red">1310.                 'The credential source &quot;%s&quot; referenced in profile &quot;%s&quot; is not '</font>
<font color="red">1311.                 'valid.' % (credential_source, parent_profile)</font>
<font color="black">1312.             ))</font>
<font color="black">1313. </font>
<font color="green">1314.     def _source_profile_has_credentials(self, profile):</font>
<font color="red">1315.         return any([</font>
<font color="red">1316.             self._has_static_credentials(profile),</font>
<font color="red">1317.             self._has_assume_role_config_vars(profile),</font>
<font color="black">1318.         ])</font>
<font color="black">1319. </font>
<font color="green">1320.     def _validate_source_profile(self, parent_profile_name,</font>
<font color="black">1321.                                  source_profile_name):</font>
<font color="red">1322.         profiles = self._loaded_config.get('profiles', {})</font>
<font color="red">1323.         if source_profile_name not in profiles:</font>
<font color="red">1324.             raise InvalidConfigError(</font>
<font color="black">1325.                 error_msg=(</font>
<font color="red">1326.                     'The source_profile &quot;%s&quot; referenced in '</font>
<font color="black">1327.                     'the profile &quot;%s&quot; does not exist.' % (</font>
<font color="red">1328.                         source_profile_name, parent_profile_name)</font>
<font color="black">1329.                 )</font>
<font color="black">1330.             )</font>
<font color="black">1331. </font>
<font color="red">1332.         source_profile = profiles[source_profile_name]</font>
<font color="black">1333. </font>
<font color="black">1334.         # Ensure the profile has valid credential type</font>
<font color="red">1335.         if not self._source_profile_has_credentials(source_profile):</font>
<font color="red">1336.             raise InvalidConfigError(</font>
<font color="black">1337.                 error_msg=(</font>
<font color="red">1338.                     'The source_profile &quot;%s&quot; must specify either static '</font>
<font color="black">1339.                     'credentials or an assume role configuration' % (</font>
<font color="red">1340.                         source_profile_name)</font>
<font color="black">1341.                 )</font>
<font color="black">1342.             )</font>
<font color="black">1343. </font>
<font color="black">1344.         # Make sure we aren't going into an infinite loop. If we haven't</font>
<font color="black">1345.         # visited the profile yet, we're good.</font>
<font color="red">1346.         if source_profile_name not in self._visited_profiles:</font>
<font color="red">1347.             return</font>
<font color="black">1348. </font>
<font color="black">1349.         # If we have visited the profile and the profile isn't simply</font>
<font color="black">1350.         # referencing itself, that's an infinite loop.</font>
<font color="red">1351.         if source_profile_name != parent_profile_name:</font>
<font color="red">1352.             raise InfiniteLoopConfigError(</font>
<font color="red">1353.                 source_profile=source_profile_name,</font>
<font color="red">1354.                 visited_profiles=self._visited_profiles</font>
<font color="black">1355.             )</font>
<font color="black">1356. </font>
<font color="black">1357.         # A profile is allowed to reference itself so that it can source</font>
<font color="black">1358.         # static credentials and have configuration all in the same</font>
<font color="black">1359.         # profile. This will only ever work for the top level assume</font>
<font color="black">1360.         # role because the static credentials will otherwise take</font>
<font color="black">1361.         # precedence.</font>
<font color="red">1362.         if not self._has_static_credentials(source_profile):</font>
<font color="red">1363.             raise InfiniteLoopConfigError(</font>
<font color="red">1364.                 source_profile=source_profile_name,</font>
<font color="red">1365.                 visited_profiles=self._visited_profiles</font>
<font color="black">1366.             )</font>
<font color="black">1367. </font>
<font color="green">1368.     def _has_static_credentials(self, profile):</font>
<font color="red">1369.         static_keys = ['aws_secret_access_key', 'aws_access_key_id']</font>
<font color="red">1370.         return any(static_key in profile for static_key in static_keys)</font>
<font color="black">1371. </font>
<font color="green">1372.     def _resolve_source_credentials(self, role_config, profile_name):</font>
<font color="red">1373.         credential_source = role_config.get('credential_source')</font>
<font color="red">1374.         if credential_source is not None:</font>
<font color="red">1375.             return self._resolve_credentials_from_source(</font>
<font color="red">1376.                 credential_source, profile_name</font>
<font color="black">1377.             )</font>
<font color="black">1378. </font>
<font color="red">1379.         source_profile = role_config['source_profile']</font>
<font color="red">1380.         self._visited_profiles.append(source_profile)</font>
<font color="red">1381.         return self._resolve_credentials_from_profile(source_profile)</font>
<font color="black">1382. </font>
<font color="green">1383.     def _resolve_credentials_from_profile(self, profile_name):</font>
<font color="red">1384.         profiles = self._loaded_config.get('profiles', {})</font>
<font color="red">1385.         profile = profiles[profile_name]</font>
<font color="black">1386. </font>
<font color="red">1387.         if self._has_static_credentials(profile):</font>
<font color="red">1388.             return self._resolve_static_credentials_from_profile(profile)</font>
<font color="black">1389. </font>
<font color="red">1390.         return self._load_creds_via_assume_role(profile_name)</font>
<font color="black">1391. </font>
<font color="green">1392.     def _resolve_static_credentials_from_profile(self, profile):</font>
<font color="red">1393.         try:</font>
<font color="red">1394.             return Credentials(</font>
<font color="red">1395.                 access_key=profile['aws_access_key_id'],</font>
<font color="red">1396.                 secret_key=profile['aws_secret_access_key'],</font>
<font color="red">1397.                 token=profile.get('aws_session_token')</font>
<font color="black">1398.             )</font>
<font color="red">1399.         except KeyError as e:</font>
<font color="red">1400.             raise PartialCredentialsError(</font>
<font color="red">1401.                 provider=self.METHOD, cred_var=str(e))</font>
<font color="black">1402. </font>
<font color="green">1403.     def _resolve_credentials_from_source(self, credential_source,</font>
<font color="black">1404.                                          profile_name):</font>
<font color="red">1405.         credentials = self._credential_sourcer.source_credentials(</font>
<font color="red">1406.             credential_source)</font>
<font color="red">1407.         if credentials is None:</font>
<font color="red">1408.             raise CredentialRetrievalError(</font>
<font color="red">1409.                 provider=credential_source,</font>
<font color="black">1410.                 error_msg=(</font>
<font color="red">1411.                     'No credentials found in credential_source referenced '</font>
<font color="red">1412.                     'in profile %s' % profile_name</font>
<font color="black">1413.                 )</font>
<font color="black">1414.             )</font>
<font color="red">1415.         return credentials</font>
<font color="black">1416. </font>
<font color="black">1417. </font>
<font color="green">1418. class CanonicalNameCredentialSourcer(object):</font>
<font color="green">1419.     def __init__(self, providers):</font>
<font color="green">1420.         self._providers = providers</font>
<font color="black">1421. </font>
<font color="green">1422.     def is_supported(self, source_name):</font>
<font color="black">1423.         &quot;&quot;&quot;Validates a given source name.</font>
<font color="black">1424. </font>
<font color="black">1425.         :type source_name: str</font>
<font color="black">1426.         :param source_name: The value of credential_source in the config</font>
<font color="black">1427.             file. This is the canonical name of the credential provider.</font>
<font color="black">1428. </font>
<font color="black">1429.         :rtype: bool</font>
<font color="black">1430.         :returns: True if the credential provider is supported,</font>
<font color="black">1431.             False otherwise.</font>
<font color="black">1432.         &quot;&quot;&quot;</font>
<font color="red">1433.         return source_name in [p.CANONICAL_NAME for p in self._providers]</font>
<font color="black">1434. </font>
<font color="green">1435.     def source_credentials(self, source_name):</font>
<font color="black">1436.         &quot;&quot;&quot;Loads source credentials based on the provided configuration.</font>
<font color="black">1437. </font>
<font color="black">1438.         :type source_name: str</font>
<font color="black">1439.         :param source_name: The value of credential_source in the config</font>
<font color="black">1440.             file. This is the canonical name of the credential provider.</font>
<font color="black">1441. </font>
<font color="black">1442.         :rtype: Credentials</font>
<font color="black">1443.         &quot;&quot;&quot;</font>
<font color="red">1444.         source = self._get_provider(source_name)</font>
<font color="red">1445.         if isinstance(source, CredentialResolver):</font>
<font color="red">1446.             return source.load_credentials()</font>
<font color="red">1447.         return source.load()</font>
<font color="black">1448. </font>
<font color="green">1449.     def _get_provider(self, canonical_name):</font>
<font color="black">1450.         &quot;&quot;&quot;Return a credential provider by its canonical name.</font>
<font color="black">1451. </font>
<font color="black">1452.         :type canonical_name: str</font>
<font color="black">1453.         :param canonical_name: The canonical name of the provider.</font>
<font color="black">1454. </font>
<font color="black">1455.         :raises UnknownCredentialError: Raised if no</font>
<font color="black">1456.             credential provider by the provided name</font>
<font color="black">1457.             is found.</font>
<font color="black">1458.         &quot;&quot;&quot;</font>
<font color="red">1459.         provider = self._get_provider_by_canonical_name(canonical_name)</font>
<font color="black">1460. </font>
<font color="black">1461.         # The AssumeRole provider should really be part of the SharedConfig</font>
<font color="black">1462.         # provider rather than being its own thing, but it is not. It is</font>
<font color="black">1463.         # effectively part of both the SharedConfig provider and the</font>
<font color="black">1464.         # SharedCredentials provider now due to the way it behaves.</font>
<font color="black">1465.         # Therefore if we want either of those providers we should return</font>
<font color="black">1466.         # the AssumeRole provider with it.</font>
<font color="red">1467.         if canonical_name.lower() in ['sharedconfig', 'sharedcredentials']:</font>
<font color="red">1468.             assume_role_provider = self._get_provider_by_method('assume-role')</font>
<font color="red">1469.             if assume_role_provider is not None:</font>
<font color="black">1470.                 # The SharedConfig or SharedCredentials provider may not be</font>
<font color="black">1471.                 # present if it was removed for some reason, but the</font>
<font color="black">1472.                 # AssumeRole provider could still be present. In that case,</font>
<font color="black">1473.                 # return the assume role provider by itself.</font>
<font color="red">1474.                 if provider is None:</font>
<font color="red">1475.                     return assume_role_provider</font>
<font color="black">1476. </font>
<font color="black">1477.                 # If both are present, return them both as a</font>
<font color="black">1478.                 # CredentialResolver so that calling code can treat them as</font>
<font color="black">1479.                 # a single entity.</font>
<font color="red">1480.                 return CredentialResolver([assume_role_provider, provider])</font>
<font color="black">1481. </font>
<font color="red">1482.         if provider is None:</font>
<font color="red">1483.             raise UnknownCredentialError(name=canonical_name)</font>
<font color="black">1484. </font>
<font color="red">1485.         return provider</font>
<font color="black">1486. </font>
<font color="green">1487.     def _get_provider_by_canonical_name(self, canonical_name):</font>
<font color="black">1488.         &quot;&quot;&quot;Return a credential provider by its canonical name.</font>
<font color="black">1489. </font>
<font color="black">1490.         This function is strict, it does not attempt to address</font>
<font color="black">1491.         compatibility issues.</font>
<font color="black">1492.         &quot;&quot;&quot;</font>
<font color="red">1493.         for provider in self._providers:</font>
<font color="red">1494.             name = provider.CANONICAL_NAME</font>
<font color="black">1495.             # Canonical names are case-insensitive</font>
<font color="red">1496.             if name and name.lower() == canonical_name.lower():</font>
<font color="red">1497.                 return provider</font>
<font color="black">1498. </font>
<font color="green">1499.     def _get_provider_by_method(self, method):</font>
<font color="black">1500.         &quot;&quot;&quot;Return a credential provider by its METHOD name.&quot;&quot;&quot;</font>
<font color="red">1501.         for provider in self._providers:</font>
<font color="red">1502.             if provider.METHOD == method:</font>
<font color="red">1503.                 return provider</font>
<font color="black">1504. </font>
<font color="black">1505. </font>
<font color="green">1506. class ContainerProvider(CredentialProvider):</font>
<font color="green">1507.     METHOD = 'container-role'</font>
<font color="green">1508.     CANONICAL_NAME = 'EcsContainer'</font>
<font color="green">1509.     ENV_VAR = 'AWS_CONTAINER_CREDENTIALS_RELATIVE_URI'</font>
<font color="green">1510.     ENV_VAR_FULL = 'AWS_CONTAINER_CREDENTIALS_FULL_URI'</font>
<font color="green">1511.     ENV_VAR_AUTH_TOKEN = 'AWS_CONTAINER_AUTHORIZATION_TOKEN'</font>
<font color="black">1512. </font>
<font color="green">1513.     def __init__(self, environ=None, fetcher=None):</font>
<font color="green">1514.         if environ is None:</font>
<font color="green">1515.             environ = os.environ</font>
<font color="green">1516.         if fetcher is None:</font>
<font color="green">1517.             fetcher = ContainerMetadataFetcher()</font>
<font color="green">1518.         self._environ = environ</font>
<font color="green">1519.         self._fetcher = fetcher</font>
<font color="black">1520. </font>
<font color="green">1521.     def load(self):</font>
<font color="black">1522.         # This cred provider is only triggered if the self.ENV_VAR is set,</font>
<font color="black">1523.         # which only happens if you opt into this feature.</font>
<font color="red">1524.         if self.ENV_VAR in self._environ or self.ENV_VAR_FULL in self._environ:</font>
<font color="red">1525.             return self._retrieve_or_fail()</font>
<font color="black">1526. </font>
<font color="green">1527.     def _retrieve_or_fail(self):</font>
<font color="red">1528.         if self._provided_relative_uri():</font>
<font color="red">1529.             full_uri = self._fetcher.full_url(self._environ[self.ENV_VAR])</font>
<font color="black">1530.         else:</font>
<font color="red">1531.             full_uri = self._environ[self.ENV_VAR_FULL]</font>
<font color="red">1532.         headers = self._build_headers()</font>
<font color="red">1533.         fetcher = self._create_fetcher(full_uri, headers)</font>
<font color="red">1534.         creds = fetcher()</font>
<font color="red">1535.         return RefreshableCredentials(</font>
<font color="red">1536.             access_key=creds['access_key'],</font>
<font color="red">1537.             secret_key=creds['secret_key'],</font>
<font color="red">1538.             token=creds['token'],</font>
<font color="red">1539.             method=self.METHOD,</font>
<font color="red">1540.             expiry_time=_parse_if_needed(creds['expiry_time']),</font>
<font color="red">1541.             refresh_using=fetcher,</font>
<font color="black">1542.         )</font>
<font color="black">1543. </font>
<font color="green">1544.     def _build_headers(self):</font>
<font color="red">1545.         headers = {}</font>
<font color="red">1546.         auth_token = self._environ.get(self.ENV_VAR_AUTH_TOKEN)</font>
<font color="red">1547.         if auth_token is not None:</font>
<font color="red">1548.             return {</font>
<font color="red">1549.                 'Authorization': auth_token</font>
<font color="black">1550.             }</font>
<font color="black">1551. </font>
<font color="green">1552.     def _create_fetcher(self, full_uri, headers):</font>
<font color="red">1553.         def fetch_creds():</font>
<font color="red">1554.             try:</font>
<font color="red">1555.                 response = self._fetcher.retrieve_full_uri(</font>
<font color="red">1556.                     full_uri, headers=headers)</font>
<font color="red">1557.             except MetadataRetrievalError as e:</font>
<font color="red">1558.                 logger.debug(&quot;Error retrieving container metadata: %s&quot;, e,</font>
<font color="red">1559.                              exc_info=True)</font>
<font color="red">1560.                 raise CredentialRetrievalError(provider=self.METHOD,</font>
<font color="red">1561.                                                error_msg=str(e))</font>
<font color="red">1562.             return {</font>
<font color="red">1563.                 'access_key': response['AccessKeyId'],</font>
<font color="red">1564.                 'secret_key': response['SecretAccessKey'],</font>
<font color="red">1565.                 'token': response['Token'],</font>
<font color="red">1566.                 'expiry_time': response['Expiration'],</font>
<font color="black">1567.             }</font>
<font color="black">1568. </font>
<font color="red">1569.         return fetch_creds</font>
<font color="black">1570. </font>
<font color="green">1571.     def _provided_relative_uri(self):</font>
<font color="red">1572.         return self.ENV_VAR in self._environ</font>
<font color="black">1573. </font>
<font color="black">1574. </font>
<font color="green">1575. class CredentialResolver(object):</font>
<font color="green">1576.     def __init__(self, providers):</font>
<font color="black">1577.         &quot;&quot;&quot;</font>
<font color="black">1578. </font>
<font color="black">1579.         :param providers: A list of ``CredentialProvider`` instances.</font>
<font color="black">1580. </font>
<font color="black">1581.         &quot;&quot;&quot;</font>
<font color="green">1582.         self.providers = providers</font>
<font color="black">1583. </font>
<font color="green">1584.     def insert_before(self, name, credential_provider):</font>
<font color="black">1585.         &quot;&quot;&quot;</font>
<font color="black">1586.         Inserts a new instance of ``CredentialProvider`` into the chain that</font>
<font color="black">1587.         will be tried before an existing one.</font>
<font color="black">1588. </font>
<font color="black">1589.         :param name: The short name of the credentials you'd like to insert the</font>
<font color="black">1590.             new credentials before. (ex. ``env`` or ``config``). Existing names</font>
<font color="black">1591.             &amp; ordering can be discovered via ``self.available_methods``.</font>
<font color="black">1592.         :type name: string</font>
<font color="black">1593. </font>
<font color="black">1594.         :param cred_instance: An instance of the new ``Credentials`` object</font>
<font color="black">1595.             you'd like to add to the chain.</font>
<font color="black">1596.         :type cred_instance: A subclass of ``Credentials``</font>
<font color="black">1597.         &quot;&quot;&quot;</font>
<font color="red">1598.         try:</font>
<font color="red">1599.             offset = [p.METHOD for p in self.providers].index(name)</font>
<font color="red">1600.         except ValueError:</font>
<font color="red">1601.             raise UnknownCredentialError(name=name)</font>
<font color="red">1602.         self.providers.insert(offset, credential_provider)</font>
<font color="black">1603. </font>
<font color="green">1604.     def insert_after(self, name, credential_provider):</font>
<font color="black">1605.         &quot;&quot;&quot;</font>
<font color="black">1606.         Inserts a new type of ``Credentials`` instance into the chain that will</font>
<font color="black">1607.         be tried after an existing one.</font>
<font color="black">1608. </font>
<font color="black">1609.         :param name: The short name of the credentials you'd like to insert the</font>
<font color="black">1610.             new credentials after. (ex. ``env`` or ``config``). Existing names</font>
<font color="black">1611.             &amp; ordering can be discovered via ``self.available_methods``.</font>
<font color="black">1612.         :type name: string</font>
<font color="black">1613. </font>
<font color="black">1614.         :param cred_instance: An instance of the new ``Credentials`` object</font>
<font color="black">1615.             you'd like to add to the chain.</font>
<font color="black">1616.         :type cred_instance: A subclass of ``Credentials``</font>
<font color="black">1617.         &quot;&quot;&quot;</font>
<font color="red">1618.         offset = self._get_provider_offset(name)</font>
<font color="red">1619.         self.providers.insert(offset + 1, credential_provider)</font>
<font color="black">1620. </font>
<font color="green">1621.     def remove(self, name):</font>
<font color="black">1622.         &quot;&quot;&quot;</font>
<font color="black">1623.         Removes a given ``Credentials`` instance from the chain.</font>
<font color="black">1624. </font>
<font color="black">1625.         :param name: The short name of the credentials instance to remove.</font>
<font color="black">1626.         :type name: string</font>
<font color="black">1627.         &quot;&quot;&quot;</font>
<font color="red">1628.         available_methods = [p.METHOD for p in self.providers]</font>
<font color="red">1629.         if name not in available_methods:</font>
<font color="black">1630.             # It's not present. Fail silently.</font>
<font color="red">1631.             return</font>
<font color="black">1632. </font>
<font color="red">1633.         offset = available_methods.index(name)</font>
<font color="red">1634.         self.providers.pop(offset)</font>
<font color="black">1635. </font>
<font color="green">1636.     def get_provider(self, name):</font>
<font color="black">1637.         &quot;&quot;&quot;Return a credential provider by name.</font>
<font color="black">1638. </font>
<font color="black">1639.         :type name: str</font>
<font color="black">1640.         :param name: The name of the provider.</font>
<font color="black">1641. </font>
<font color="black">1642.         :raises UnknownCredentialError: Raised if no</font>
<font color="black">1643.             credential provider by the provided name</font>
<font color="black">1644.             is found.</font>
<font color="black">1645.         &quot;&quot;&quot;</font>
<font color="red">1646.         return self.providers[self._get_provider_offset(name)]</font>
<font color="black">1647. </font>
<font color="green">1648.     def _get_provider_offset(self, name):</font>
<font color="red">1649.         try:</font>
<font color="red">1650.             return [p.METHOD for p in self.providers].index(name)</font>
<font color="red">1651.         except ValueError:</font>
<font color="red">1652.             raise UnknownCredentialError(name=name)</font>
<font color="black">1653. </font>
<font color="green">1654.     def load_credentials(self):</font>
<font color="black">1655.         &quot;&quot;&quot;</font>
<font color="black">1656.         Goes through the credentials chain, returning the first ``Credentials``</font>
<font color="black">1657.         that could be loaded.</font>
<font color="black">1658.         &quot;&quot;&quot;</font>
<font color="black">1659.         # First provider to return a non-None response wins.</font>
<font color="green">1660.         for provider in self.providers:</font>
<font color="green">1661.             logger.debug(&quot;Looking for credentials via: %s&quot;, provider.METHOD)</font>
<font color="green">1662.             creds = provider.load()</font>
<font color="green">1663.             if creds is not None:</font>
<font color="green">1664.                 return creds</font>
<font color="black">1665. </font>
<font color="black">1666.         # If we got here, no credentials could be found.</font>
<font color="black">1667.         # This feels like it should be an exception, but historically, ``None``</font>
<font color="black">1668.         # is returned.</font>
<font color="black">1669.         #</font>
<font color="black">1670.         # +1</font>
<font color="black">1671.         # -js</font>
<font color="red">1672.         return None</font>
</pre>

