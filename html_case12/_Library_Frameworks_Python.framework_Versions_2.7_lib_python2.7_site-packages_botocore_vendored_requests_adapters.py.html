source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/adapters.py</b><br>


file stats: <b>210 lines, 121 executed: 57.6% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. </font>
<font color="black">   3. &quot;&quot;&quot;</font>
<font color="black">   4. requests.adapters</font>
<font color="black">   5. ~~~~~~~~~~~~~~~~~</font>
<font color="black">   6. </font>
<font color="black">   7. This module contains the transport adapters that Requests uses to define</font>
<font color="black">   8. and maintain connections.</font>
<font color="green">   9. &quot;&quot;&quot;</font>
<font color="black">  10. </font>
<font color="green">  11. import socket</font>
<font color="black">  12. </font>
<font color="green">  13. from .models import Response</font>
<font color="green">  14. from .packages.urllib3.poolmanager import PoolManager, proxy_from_url</font>
<font color="green">  15. from .packages.urllib3.response import HTTPResponse</font>
<font color="green">  16. from .packages.urllib3.util import Timeout as TimeoutSauce</font>
<font color="green">  17. from .packages.urllib3.util.retry import Retry</font>
<font color="green">  18. from .compat import urlparse, basestring</font>
<font color="green">  19. from .utils import (DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers,</font>
<font color="black">  20.                     prepend_scheme_if_needed, get_auth_from_url, urldefragauth)</font>
<font color="green">  21. from .structures import CaseInsensitiveDict</font>
<font color="green">  22. from .packages.urllib3.exceptions import ConnectTimeoutError</font>
<font color="green">  23. from .packages.urllib3.exceptions import HTTPError as _HTTPError</font>
<font color="green">  24. from .packages.urllib3.exceptions import MaxRetryError</font>
<font color="green">  25. from .packages.urllib3.exceptions import ProxyError as _ProxyError</font>
<font color="green">  26. from .packages.urllib3.exceptions import ProtocolError</font>
<font color="green">  27. from .packages.urllib3.exceptions import ReadTimeoutError</font>
<font color="green">  28. from .packages.urllib3.exceptions import SSLError as _SSLError</font>
<font color="green">  29. from .packages.urllib3.exceptions import ResponseError</font>
<font color="green">  30. from .cookies import extract_cookies_to_jar</font>
<font color="green">  31. from .exceptions import (ConnectionError, ConnectTimeout, ReadTimeout, SSLError,</font>
<font color="black">  32.                          ProxyError, RetryError)</font>
<font color="green">  33. from .auth import _basic_auth_str</font>
<font color="black">  34. </font>
<font color="green">  35. DEFAULT_POOLBLOCK = False</font>
<font color="green">  36. DEFAULT_POOLSIZE = 10</font>
<font color="green">  37. DEFAULT_RETRIES = 0</font>
<font color="black">  38. </font>
<font color="black">  39. </font>
<font color="green">  40. class BaseAdapter(object):</font>
<font color="green">  41.     &quot;&quot;&quot;The Base Transport Adapter&quot;&quot;&quot;</font>
<font color="black">  42. </font>
<font color="green">  43.     def __init__(self):</font>
<font color="green">  44.         super(BaseAdapter, self).__init__()</font>
<font color="black">  45. </font>
<font color="green">  46.     def send(self):</font>
<font color="red">  47.         raise NotImplementedError</font>
<font color="black">  48. </font>
<font color="green">  49.     def close(self):</font>
<font color="red">  50.         raise NotImplementedError</font>
<font color="black">  51. </font>
<font color="black">  52. </font>
<font color="green">  53. class HTTPAdapter(BaseAdapter):</font>
<font color="black">  54.     &quot;&quot;&quot;The built-in HTTP Adapter for urllib3.</font>
<font color="black">  55. </font>
<font color="black">  56.     Provides a general-case interface for Requests sessions to contact HTTP and</font>
<font color="black">  57.     HTTPS urls by implementing the Transport Adapter interface. This class will</font>
<font color="black">  58.     usually be created by the :class:`Session &lt;Session&gt;` class under the</font>
<font color="black">  59.     covers.</font>
<font color="black">  60. </font>
<font color="black">  61.     :param pool_connections: The number of urllib3 connection pools to cache.</font>
<font color="black">  62.     :param pool_maxsize: The maximum number of connections to save in the pool.</font>
<font color="black">  63.     :param int max_retries: The maximum number of retries each connection</font>
<font color="black">  64.         should attempt. Note, this applies only to failed DNS lookups, socket</font>
<font color="black">  65.         connections and connection timeouts, never to requests where data has</font>
<font color="black">  66.         made it to the server. By default, Requests does not retry failed</font>
<font color="black">  67.         connections. If you need granular control over the conditions under</font>
<font color="black">  68.         which we retry a request, import urllib3's ``Retry`` class and pass</font>
<font color="black">  69.         that instead.</font>
<font color="black">  70.     :param pool_block: Whether the connection pool should block for connections.</font>
<font color="black">  71. </font>
<font color="black">  72.     Usage::</font>
<font color="black">  73. </font>
<font color="black">  74.       &gt;&gt;&gt; import requests</font>
<font color="black">  75.       &gt;&gt;&gt; s = requests.Session()</font>
<font color="black">  76.       &gt;&gt;&gt; a = requests.adapters.HTTPAdapter(max_retries=3)</font>
<font color="black">  77.       &gt;&gt;&gt; s.mount('http://', a)</font>
<font color="green">  78.     &quot;&quot;&quot;</font>
<font color="green">  79.     __attrs__ = ['max_retries', 'config', '_pool_connections', '_pool_maxsize',</font>
<font color="green">  80.                  '_pool_block']</font>
<font color="black">  81. </font>
<font color="green">  82.     def __init__(self, pool_connections=DEFAULT_POOLSIZE,</font>
<font color="green">  83.                  pool_maxsize=DEFAULT_POOLSIZE, max_retries=DEFAULT_RETRIES,</font>
<font color="green">  84.                  pool_block=DEFAULT_POOLBLOCK):</font>
<font color="green">  85.         if max_retries == DEFAULT_RETRIES:</font>
<font color="green">  86.             self.max_retries = Retry(0, read=False)</font>
<font color="black">  87.         else:</font>
<font color="red">  88.             self.max_retries = Retry.from_int(max_retries)</font>
<font color="green">  89.         self.config = {}</font>
<font color="green">  90.         self.proxy_manager = {}</font>
<font color="black">  91. </font>
<font color="green">  92.         super(HTTPAdapter, self).__init__()</font>
<font color="black">  93. </font>
<font color="green">  94.         self._pool_connections = pool_connections</font>
<font color="green">  95.         self._pool_maxsize = pool_maxsize</font>
<font color="green">  96.         self._pool_block = pool_block</font>
<font color="black">  97. </font>
<font color="green">  98.         self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)</font>
<font color="black">  99. </font>
<font color="green"> 100.     def __getstate__(self):</font>
<font color="red"> 101.         return dict((attr, getattr(self, attr, None)) for attr in</font>
<font color="red"> 102.                     self.__attrs__)</font>
<font color="black"> 103. </font>
<font color="green"> 104.     def __setstate__(self, state):</font>
<font color="black"> 105.         # Can't handle by adding 'proxy_manager' to self.__attrs__ because</font>
<font color="black"> 106.         # because self.poolmanager uses a lambda function, which isn't pickleable.</font>
<font color="red"> 107.         self.proxy_manager = {}</font>
<font color="red"> 108.         self.config = {}</font>
<font color="black"> 109. </font>
<font color="red"> 110.         for attr, value in state.items():</font>
<font color="red"> 111.             setattr(self, attr, value)</font>
<font color="black"> 112. </font>
<font color="red"> 113.         self.init_poolmanager(self._pool_connections, self._pool_maxsize,</font>
<font color="red"> 114.                               block=self._pool_block)</font>
<font color="black"> 115. </font>
<font color="green"> 116.     def init_poolmanager(self, connections, maxsize, block=DEFAULT_POOLBLOCK, **pool_kwargs):</font>
<font color="black"> 117.         &quot;&quot;&quot;Initializes a urllib3 PoolManager.</font>
<font color="black"> 118. </font>
<font color="black"> 119.         This method should not be called from user code, and is only</font>
<font color="black"> 120.         exposed for use when subclassing the</font>
<font color="black"> 121.         :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.</font>
<font color="black"> 122. </font>
<font color="black"> 123.         :param connections: The number of urllib3 connection pools to cache.</font>
<font color="black"> 124.         :param maxsize: The maximum number of connections to save in the pool.</font>
<font color="black"> 125.         :param block: Block when no free connections are available.</font>
<font color="black"> 126.         :param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.</font>
<font color="black"> 127.         &quot;&quot;&quot;</font>
<font color="black"> 128.         # save these values for pickling</font>
<font color="green"> 129.         self._pool_connections = connections</font>
<font color="green"> 130.         self._pool_maxsize = maxsize</font>
<font color="green"> 131.         self._pool_block = block</font>
<font color="black"> 132. </font>
<font color="green"> 133.         self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize,</font>
<font color="green"> 134.                                        block=block, strict=True, **pool_kwargs)</font>
<font color="black"> 135. </font>
<font color="green"> 136.     def proxy_manager_for(self, proxy, **proxy_kwargs):</font>
<font color="black"> 137.         &quot;&quot;&quot;Return urllib3 ProxyManager for the given proxy.</font>
<font color="black"> 138. </font>
<font color="black"> 139.         This method should not be called from user code, and is only</font>
<font color="black"> 140.         exposed for use when subclassing the</font>
<font color="black"> 141.         :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.</font>
<font color="black"> 142. </font>
<font color="black"> 143.         :param proxy: The proxy to return a urllib3 ProxyManager for.</font>
<font color="black"> 144.         :param proxy_kwargs: Extra keyword arguments used to configure the Proxy Manager.</font>
<font color="black"> 145.         :returns: ProxyManager</font>
<font color="black"> 146.         &quot;&quot;&quot;</font>
<font color="red"> 147.         if not proxy in self.proxy_manager:</font>
<font color="red"> 148.             proxy_headers = self.proxy_headers(proxy)</font>
<font color="red"> 149.             self.proxy_manager[proxy] = proxy_from_url(</font>
<font color="red"> 150.                 proxy,</font>
<font color="red"> 151.                 proxy_headers=proxy_headers,</font>
<font color="red"> 152.                 num_pools=self._pool_connections,</font>
<font color="red"> 153.                 maxsize=self._pool_maxsize,</font>
<font color="red"> 154.                 block=self._pool_block,</font>
<font color="red"> 155.                 **proxy_kwargs)</font>
<font color="black"> 156. </font>
<font color="red"> 157.         return self.proxy_manager[proxy]</font>
<font color="black"> 158. </font>
<font color="green"> 159.     def cert_verify(self, conn, url, verify, cert):</font>
<font color="black"> 160.         &quot;&quot;&quot;Verify a SSL certificate. This method should not be called from user</font>
<font color="black"> 161.         code, and is only exposed for use when subclassing the</font>
<font color="black"> 162.         :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.</font>
<font color="black"> 163. </font>
<font color="black"> 164.         :param conn: The urllib3 connection object associated with the cert.</font>
<font color="black"> 165.         :param url: The requested URL.</font>
<font color="black"> 166.         :param verify: Whether we should actually verify the certificate.</font>
<font color="black"> 167.         :param cert: The SSL certificate to verify.</font>
<font color="black"> 168.         &quot;&quot;&quot;</font>
<font color="green"> 169.         if url.lower().startswith('https') and verify:</font>
<font color="black"> 170. </font>
<font color="green"> 171.             cert_loc = None</font>
<font color="black"> 172. </font>
<font color="black"> 173.             # Allow self-specified cert location.</font>
<font color="green"> 174.             if verify is not True:</font>
<font color="red"> 175.                 cert_loc = verify</font>
<font color="black"> 176. </font>
<font color="green"> 177.             if not cert_loc:</font>
<font color="green"> 178.                 cert_loc = DEFAULT_CA_BUNDLE_PATH</font>
<font color="black"> 179. </font>
<font color="green"> 180.             if not cert_loc:</font>
<font color="red"> 181.                 raise Exception(&quot;Could not find a suitable SSL CA certificate bundle.&quot;)</font>
<font color="black"> 182. </font>
<font color="green"> 183.             conn.cert_reqs = 'CERT_REQUIRED'</font>
<font color="green"> 184.             conn.ca_certs = cert_loc</font>
<font color="black"> 185.         else:</font>
<font color="red"> 186.             conn.cert_reqs = 'CERT_NONE'</font>
<font color="red"> 187.             conn.ca_certs = None</font>
<font color="black"> 188. </font>
<font color="green"> 189.         if cert:</font>
<font color="red"> 190.             if not isinstance(cert, basestring):</font>
<font color="red"> 191.                 conn.cert_file = cert[0]</font>
<font color="red"> 192.                 conn.key_file = cert[1]</font>
<font color="black"> 193.             else:</font>
<font color="red"> 194.                 conn.cert_file = cert</font>
<font color="black"> 195. </font>
<font color="green"> 196.     def build_response(self, req, resp):</font>
<font color="black"> 197.         &quot;&quot;&quot;Builds a :class:`Response &lt;requests.Response&gt;` object from a urllib3</font>
<font color="black"> 198.         response. This should not be called from user code, and is only exposed</font>
<font color="black"> 199.         for use when subclassing the</font>
<font color="black"> 200.         :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`</font>
<font color="black"> 201. </font>
<font color="black"> 202.         :param req: The :class:`PreparedRequest &lt;PreparedRequest&gt;` used to generate the response.</font>
<font color="black"> 203.         :param resp: The urllib3 response object.</font>
<font color="black"> 204.         &quot;&quot;&quot;</font>
<font color="green"> 205.         response = Response()</font>
<font color="black"> 206. </font>
<font color="black"> 207.         # Fallback to None if there's no status_code, for whatever reason.</font>
<font color="green"> 208.         response.status_code = getattr(resp, 'status', None)</font>
<font color="black"> 209. </font>
<font color="black"> 210.         # Make headers case-insensitive.</font>
<font color="green"> 211.         response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))</font>
<font color="black"> 212. </font>
<font color="black"> 213.         # Set encoding.</font>
<font color="green"> 214.         response.encoding = get_encoding_from_headers(response.headers)</font>
<font color="green"> 215.         response.raw = resp</font>
<font color="green"> 216.         response.reason = response.raw.reason</font>
<font color="black"> 217. </font>
<font color="green"> 218.         if isinstance(req.url, bytes):</font>
<font color="green"> 219.             response.url = req.url.decode('utf-8')</font>
<font color="black"> 220.         else:</font>
<font color="red"> 221.             response.url = req.url</font>
<font color="black"> 222. </font>
<font color="black"> 223.         # Add new cookies from the server.</font>
<font color="green"> 224.         extract_cookies_to_jar(response.cookies, req, resp)</font>
<font color="black"> 225. </font>
<font color="black"> 226.         # Give the Response some context.</font>
<font color="green"> 227.         response.request = req</font>
<font color="green"> 228.         response.connection = self</font>
<font color="black"> 229. </font>
<font color="green"> 230.         return response</font>
<font color="black"> 231. </font>
<font color="green"> 232.     def get_connection(self, url, proxies=None):</font>
<font color="black"> 233.         &quot;&quot;&quot;Returns a urllib3 connection for the given URL. This should not be</font>
<font color="black"> 234.         called from user code, and is only exposed for use when subclassing the</font>
<font color="black"> 235.         :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.</font>
<font color="black"> 236. </font>
<font color="black"> 237.         :param url: The URL to connect to.</font>
<font color="black"> 238.         :param proxies: (optional) A Requests-style dictionary of proxies used on this request.</font>
<font color="black"> 239.         &quot;&quot;&quot;</font>
<font color="green"> 240.         proxies = proxies or {}</font>
<font color="green"> 241.         proxy = proxies.get(urlparse(url.lower()).scheme)</font>
<font color="black"> 242. </font>
<font color="green"> 243.         if proxy:</font>
<font color="red"> 244.             proxy = prepend_scheme_if_needed(proxy, 'http')</font>
<font color="red"> 245.             proxy_manager = self.proxy_manager_for(proxy)</font>
<font color="red"> 246.             conn = proxy_manager.connection_from_url(url)</font>
<font color="black"> 247.         else:</font>
<font color="black"> 248.             # Only scheme should be lower case</font>
<font color="green"> 249.             parsed = urlparse(url)</font>
<font color="green"> 250.             url = parsed.geturl()</font>
<font color="green"> 251.             conn = self.poolmanager.connection_from_url(url)</font>
<font color="black"> 252. </font>
<font color="green"> 253.         return conn</font>
<font color="black"> 254. </font>
<font color="green"> 255.     def close(self):</font>
<font color="black"> 256.         &quot;&quot;&quot;Disposes of any internal state.</font>
<font color="black"> 257. </font>
<font color="black"> 258.         Currently, this just closes the PoolManager, which closes pooled</font>
<font color="black"> 259.         connections.</font>
<font color="black"> 260.         &quot;&quot;&quot;</font>
<font color="red"> 261.         self.poolmanager.clear()</font>
<font color="black"> 262. </font>
<font color="green"> 263.     def request_url(self, request, proxies):</font>
<font color="black"> 264.         &quot;&quot;&quot;Obtain the url to use when making the final request.</font>
<font color="black"> 265. </font>
<font color="black"> 266.         If the message is being sent through a HTTP proxy, the full URL has to</font>
<font color="black"> 267.         be used. Otherwise, we should only use the path portion of the URL.</font>
<font color="black"> 268. </font>
<font color="black"> 269.         This should not be called from user code, and is only exposed for use</font>
<font color="black"> 270.         when subclassing the</font>
<font color="black"> 271.         :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.</font>
<font color="black"> 272. </font>
<font color="black"> 273.         :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.</font>
<font color="black"> 274.         :param proxies: A dictionary of schemes to proxy URLs.</font>
<font color="black"> 275.         &quot;&quot;&quot;</font>
<font color="green"> 276.         proxies = proxies or {}</font>
<font color="green"> 277.         scheme = urlparse(request.url).scheme</font>
<font color="green"> 278.         proxy = proxies.get(scheme)</font>
<font color="black"> 279. </font>
<font color="green"> 280.         if proxy and scheme != 'https':</font>
<font color="red"> 281.             url = urldefragauth(request.url)</font>
<font color="black"> 282.         else:</font>
<font color="green"> 283.             url = request.path_url</font>
<font color="black"> 284. </font>
<font color="green"> 285.         return url</font>
<font color="black"> 286. </font>
<font color="green"> 287.     def add_headers(self, request, **kwargs):</font>
<font color="black"> 288.         &quot;&quot;&quot;Add any headers needed by the connection. As of v2.0 this does</font>
<font color="black"> 289.         nothing by default, but is left for overriding by users that subclass</font>
<font color="black"> 290.         the :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.</font>
<font color="black"> 291. </font>
<font color="black"> 292.         This should not be called from user code, and is only exposed for use</font>
<font color="black"> 293.         when subclassing the</font>
<font color="black"> 294.         :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.</font>
<font color="black"> 295. </font>
<font color="black"> 296.         :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` to add headers to.</font>
<font color="black"> 297.         :param kwargs: The keyword arguments from the call to send().</font>
<font color="black"> 298.         &quot;&quot;&quot;</font>
<font color="green"> 299.         pass</font>
<font color="black"> 300. </font>
<font color="green"> 301.     def proxy_headers(self, proxy):</font>
<font color="black"> 302.         &quot;&quot;&quot;Returns a dictionary of the headers to add to any request sent</font>
<font color="black"> 303.         through a proxy. This works with urllib3 magic to ensure that they are</font>
<font color="black"> 304.         correctly sent to the proxy, rather than in a tunnelled request if</font>
<font color="black"> 305.         CONNECT is being used.</font>
<font color="black"> 306. </font>
<font color="black"> 307.         This should not be called from user code, and is only exposed for use</font>
<font color="black"> 308.         when subclassing the</font>
<font color="black"> 309.         :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.</font>
<font color="black"> 310. </font>
<font color="black"> 311.         :param proxies: The url of the proxy being used for this request.</font>
<font color="black"> 312.         :param kwargs: Optional additional keyword arguments.</font>
<font color="black"> 313.         &quot;&quot;&quot;</font>
<font color="red"> 314.         headers = {}</font>
<font color="red"> 315.         username, password = get_auth_from_url(proxy)</font>
<font color="black"> 316. </font>
<font color="red"> 317.         if username and password:</font>
<font color="red"> 318.             headers['Proxy-Authorization'] = _basic_auth_str(username,</font>
<font color="red"> 319.                                                              password)</font>
<font color="black"> 320. </font>
<font color="red"> 321.         return headers</font>
<font color="black"> 322. </font>
<font color="green"> 323.     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):</font>
<font color="black"> 324.         &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.</font>
<font color="black"> 325. </font>
<font color="black"> 326.         :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.</font>
<font color="black"> 327.         :param stream: (optional) Whether to stream the request content.</font>
<font color="black"> 328.         :param timeout: (optional) How long to wait for the server to send</font>
<font color="black"> 329.             data before giving up, as a float, or a (`connect timeout, read</font>
<font color="black"> 330.             timeout &lt;user/advanced.html#timeouts&gt;`_) tuple.</font>
<font color="black"> 331.         :type timeout: float or tuple</font>
<font color="black"> 332.         :param verify: (optional) Whether to verify SSL certificates.</font>
<font color="black"> 333.         :param cert: (optional) Any user-provided SSL certificate to be trusted.</font>
<font color="black"> 334.         :param proxies: (optional) The proxies dictionary to apply to the request.</font>
<font color="black"> 335.         &quot;&quot;&quot;</font>
<font color="black"> 336. </font>
<font color="green"> 337.         conn = self.get_connection(request.url, proxies)</font>
<font color="black"> 338. </font>
<font color="green"> 339.         self.cert_verify(conn, request.url, verify, cert)</font>
<font color="green"> 340.         url = self.request_url(request, proxies)</font>
<font color="green"> 341.         self.add_headers(request)</font>
<font color="black"> 342. </font>
<font color="green"> 343.         chunked = not (request.body is None or 'Content-Length' in request.headers)</font>
<font color="black"> 344. </font>
<font color="green"> 345.         if isinstance(timeout, tuple):</font>
<font color="green"> 346.             try:</font>
<font color="green"> 347.                 connect, read = timeout</font>
<font color="green"> 348.                 timeout = TimeoutSauce(connect=connect, read=read)</font>
<font color="red"> 349.             except ValueError as e:</font>
<font color="black"> 350.                 # this may raise a string formatting error.</font>
<font color="red"> 351.                 err = (&quot;Invalid timeout {0}. Pass a (connect, read) &quot;</font>
<font color="black"> 352.                        &quot;timeout tuple, or a single float to set &quot;</font>
<font color="red"> 353.                        &quot;both timeouts to the same value&quot;.format(timeout))</font>
<font color="red"> 354.                 raise ValueError(err)</font>
<font color="black"> 355.         else:</font>
<font color="red"> 356.             timeout = TimeoutSauce(connect=timeout, read=timeout)</font>
<font color="black"> 357. </font>
<font color="green"> 358.         try:</font>
<font color="green"> 359.             if not chunked:</font>
<font color="green"> 360.                 resp = conn.urlopen(</font>
<font color="green"> 361.                     method=request.method,</font>
<font color="green"> 362.                     url=url,</font>
<font color="green"> 363.                     body=request.body,</font>
<font color="green"> 364.                     headers=request.headers,</font>
<font color="green"> 365.                     redirect=False,</font>
<font color="green"> 366.                     assert_same_host=False,</font>
<font color="green"> 367.                     preload_content=False,</font>
<font color="green"> 368.                     decode_content=False,</font>
<font color="green"> 369.                     retries=self.max_retries,</font>
<font color="green"> 370.                     timeout=timeout</font>
<font color="black"> 371.                 )</font>
<font color="black"> 372. </font>
<font color="black"> 373.             # Send the request.</font>
<font color="black"> 374.             else:</font>
<font color="red"> 375.                 if hasattr(conn, 'proxy_pool'):</font>
<font color="red"> 376.                     conn = conn.proxy_pool</font>
<font color="black"> 377. </font>
<font color="red"> 378.                 low_conn = conn._get_conn(timeout=timeout)</font>
<font color="black"> 379. </font>
<font color="red"> 380.                 try:</font>
<font color="red"> 381.                     low_conn.putrequest(request.method,</font>
<font color="red"> 382.                                         url,</font>
<font color="red"> 383.                                         skip_accept_encoding=True)</font>
<font color="black"> 384. </font>
<font color="red"> 385.                     for header, value in request.headers.items():</font>
<font color="red"> 386.                         low_conn.putheader(header, value)</font>
<font color="black"> 387. </font>
<font color="red"> 388.                     low_conn.endheaders()</font>
<font color="black"> 389. </font>
<font color="red"> 390.                     for i in request.body:</font>
<font color="red"> 391.                         low_conn.send(hex(len(i))[2:].encode('utf-8'))</font>
<font color="red"> 392.                         low_conn.send(b'\r\n')</font>
<font color="red"> 393.                         low_conn.send(i)</font>
<font color="red"> 394.                         low_conn.send(b'\r\n')</font>
<font color="red"> 395.                     low_conn.send(b'0\r\n\r\n')</font>
<font color="black"> 396. </font>
<font color="red"> 397.                     r = low_conn.getresponse()</font>
<font color="red"> 398.                     resp = HTTPResponse.from_httplib(</font>
<font color="red"> 399.                         r,</font>
<font color="red"> 400.                         pool=conn,</font>
<font color="red"> 401.                         connection=low_conn,</font>
<font color="red"> 402.                         preload_content=False,</font>
<font color="red"> 403.                         decode_content=False</font>
<font color="black"> 404.                     )</font>
<font color="red"> 405.                 except:</font>
<font color="black"> 406.                     # If we hit any problems here, clean up the connection.</font>
<font color="black"> 407.                     # Then, reraise so that we can handle the actual exception.</font>
<font color="red"> 408.                     low_conn.close()</font>
<font color="red"> 409.                     raise</font>
<font color="black"> 410.                 else:</font>
<font color="black"> 411.                     # All is well, return the connection to the pool.</font>
<font color="red"> 412.                     conn._put_conn(low_conn)</font>
<font color="black"> 413. </font>
<font color="red"> 414.         except (ProtocolError, socket.error) as err:</font>
<font color="red"> 415.             raise ConnectionError(err, request=request)</font>
<font color="black"> 416. </font>
<font color="red"> 417.         except MaxRetryError as e:</font>
<font color="red"> 418.             if isinstance(e.reason, ConnectTimeoutError):</font>
<font color="red"> 419.                 raise ConnectTimeout(e, request=request)</font>
<font color="black"> 420. </font>
<font color="red"> 421.             if isinstance(e.reason, ResponseError):</font>
<font color="red"> 422.                 raise RetryError(e, request=request)</font>
<font color="black"> 423. </font>
<font color="red"> 424.             raise ConnectionError(e, request=request)</font>
<font color="black"> 425. </font>
<font color="red"> 426.         except _ProxyError as e:</font>
<font color="red"> 427.             raise ProxyError(e)</font>
<font color="black"> 428. </font>
<font color="red"> 429.         except (_SSLError, _HTTPError) as e:</font>
<font color="red"> 430.             if isinstance(e, _SSLError):</font>
<font color="red"> 431.                 raise SSLError(e, request=request)</font>
<font color="red"> 432.             elif isinstance(e, ReadTimeoutError):</font>
<font color="red"> 433.                 raise ReadTimeout(e, request=request)</font>
<font color="black"> 434.             else:</font>
<font color="red"> 435.                 raise</font>
<font color="black"> 436. </font>
<font color="green"> 437.         return self.build_response(request, resp)</font>
</pre>

