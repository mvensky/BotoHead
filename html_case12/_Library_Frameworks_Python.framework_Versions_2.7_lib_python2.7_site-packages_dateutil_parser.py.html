source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/dateutil/parser.py</b><br>


file stats: <b>753 lines, 349 executed: 46.3% covered</b>
<pre>
<font color="black">   1. # -*- coding:iso-8859-1 -*-</font>
<font color="black">   2. &quot;&quot;&quot;</font>
<font color="black">   3. This module offers a generic date/time string parser which is able to parse</font>
<font color="black">   4. most known formats to represent a date and/or time.</font>
<font color="black">   5. </font>
<font color="black">   6. This module attempts to be forgiving with regards to unlikely input formats,</font>
<font color="black">   7. returning a datetime object even for dates which are ambiguous. If an element</font>
<font color="black">   8. of a date/time stamp is omitted, the following rules are applied:</font>
<font color="black">   9. - If AM or PM is left unspecified, a 24-hour clock is assumed, however, an hour</font>
<font color="black">  10.   on a 12-hour clock (``0 &lt;= hour &lt;= 12``) *must* be specified if AM or PM is</font>
<font color="black">  11.   specified.</font>
<font color="black">  12. - If a time zone is omitted, a timezone-naive datetime is returned.</font>
<font color="black">  13. </font>
<font color="black">  14. If any other elements are missing, they are taken from the</font>
<font color="black">  15. :class:`datetime.datetime` object passed to the parameter ``default``. If this</font>
<font color="black">  16. results in a day number exceeding the valid number of days per month, the</font>
<font color="black">  17. value falls back to the end of the month.</font>
<font color="black">  18. </font>
<font color="black">  19. Additional resources about date/time string formats can be found below:</font>
<font color="black">  20. </font>
<font color="black">  21. - `A summary of the international standard date and time notation</font>
<font color="black">  22.   &lt;http://www.cl.cam.ac.uk/~mgk25/iso-time.html&gt;`_</font>
<font color="black">  23. - `W3C Date and Time Formats &lt;http://www.w3.org/TR/NOTE-datetime&gt;`_</font>
<font color="black">  24. - `Time Formats (Planetary Rings Node) &lt;http://pds-rings.seti.org/tools/time_formats.html&gt;`_</font>
<font color="black">  25. - `CPAN ParseDate module</font>
<font color="black">  26.   &lt;http://search.cpan.org/~muir/Time-modules-2013.0912/lib/Time/ParseDate.pm&gt;`_</font>
<font color="black">  27. - `Java SimpleDateFormat Class</font>
<font color="black">  28.   &lt;https://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html&gt;`_</font>
<font color="green">  29. &quot;&quot;&quot;</font>
<font color="green">  30. from __future__ import unicode_literals</font>
<font color="black">  31. </font>
<font color="green">  32. import datetime</font>
<font color="green">  33. import string</font>
<font color="green">  34. import time</font>
<font color="green">  35. import collections</font>
<font color="green">  36. import re</font>
<font color="green">  37. from io import StringIO</font>
<font color="green">  38. from calendar import monthrange, isleap</font>
<font color="black">  39. </font>
<font color="green">  40. from six import text_type, binary_type, integer_types</font>
<font color="black">  41. </font>
<font color="green">  42. from . import relativedelta</font>
<font color="green">  43. from . import tz</font>
<font color="black">  44. </font>
<font color="green">  45. __all__ = [&quot;parse&quot;, &quot;parserinfo&quot;]</font>
<font color="black">  46. </font>
<font color="black">  47. </font>
<font color="green">  48. class _timelex(object):</font>
<font color="black">  49.     # Fractional seconds are sometimes split by a comma</font>
<font color="green">  50.     _split_decimal = re.compile(&quot;([\.,])&quot;)</font>
<font color="black">  51. </font>
<font color="green">  52.     def __init__(self, instream):</font>
<font color="green">  53.         if isinstance(instream, binary_type):</font>
<font color="green">  54.             instream = instream.decode()</font>
<font color="black">  55. </font>
<font color="green">  56.         if isinstance(instream, text_type):</font>
<font color="green">  57.             instream = StringIO(instream)</font>
<font color="black">  58. </font>
<font color="green">  59.         self.instream = instream</font>
<font color="green">  60.         self.charstack = []</font>
<font color="green">  61.         self.tokenstack = []</font>
<font color="green">  62.         self.eof = False</font>
<font color="black">  63. </font>
<font color="green">  64.     def get_token(self):</font>
<font color="black">  65.         &quot;&quot;&quot;</font>
<font color="black">  66.         This function breaks the time string into lexical units (tokens), which</font>
<font color="black">  67.         can be parsed by the parser. Lexical units are demarcated by changes in</font>
<font color="black">  68.         the character set, so any continuous string of letters is considered</font>
<font color="black">  69.         one unit, any continuous string of numbers is considered one unit.</font>
<font color="black">  70. </font>
<font color="black">  71.         The main complication arises from the fact that dots ('.') can be used</font>
<font color="black">  72.         both as separators (e.g. &quot;Sep.20.2009&quot;) or decimal points (e.g.</font>
<font color="black">  73.         &quot;4:30:21.447&quot;). As such, it is necessary to read the full context of</font>
<font color="black">  74.         any dot-separated strings before breaking it into tokens; as such, this</font>
<font color="black">  75.         function maintains a &quot;token stack&quot;, for when the ambiguous context</font>
<font color="black">  76.         demands that multiple tokens be parsed at once.</font>
<font color="black">  77.         &quot;&quot;&quot;</font>
<font color="green">  78.         if self.tokenstack:</font>
<font color="red">  79.             return self.tokenstack.pop(0)</font>
<font color="black">  80. </font>
<font color="green">  81.         seenletters = False</font>
<font color="green">  82.         token = None</font>
<font color="green">  83.         state = None</font>
<font color="black">  84. </font>
<font color="green">  85.         while not self.eof:</font>
<font color="black">  86.             # We only realize that we've reached the end of a token when we</font>
<font color="black">  87.             # find a character that's not part of the current token - since</font>
<font color="black">  88.             # that character may be part of the next token, it's stored in the</font>
<font color="black">  89.             # charstack.</font>
<font color="green">  90.             if self.charstack:</font>
<font color="green">  91.                 nextchar = self.charstack.pop(0)</font>
<font color="black">  92.             else:</font>
<font color="green">  93.                 nextchar = self.instream.read(1)</font>
<font color="green">  94.                 while nextchar == '\x00':</font>
<font color="red">  95.                     nextchar = self.instream.read(1)</font>
<font color="black">  96. </font>
<font color="green">  97.             if not nextchar:</font>
<font color="green">  98.                 self.eof = True</font>
<font color="green">  99.                 break</font>
<font color="green"> 100.             elif not state:</font>
<font color="black"> 101.                 # First character of the token - determines if we're starting</font>
<font color="black"> 102.                 # to parse a word, a number or something else.</font>
<font color="green"> 103.                 token = nextchar</font>
<font color="green"> 104.                 if self.isword(nextchar):</font>
<font color="green"> 105.                     state = 'a'</font>
<font color="green"> 106.                 elif self.isnum(nextchar):</font>
<font color="green"> 107.                     state = '0'</font>
<font color="green"> 108.                 elif self.isspace(nextchar):</font>
<font color="red"> 109.                     token = ' '</font>
<font color="red"> 110.                     break  # emit token</font>
<font color="black"> 111.                 else:</font>
<font color="green"> 112.                     break  # emit token</font>
<font color="green"> 113.             elif state == 'a':</font>
<font color="black"> 114.                 # If we've already started reading a word, we keep reading</font>
<font color="black"> 115.                 # letters until we find something that's not part of a word.</font>
<font color="green"> 116.                 seenletters = True</font>
<font color="green"> 117.                 if self.isword(nextchar):</font>
<font color="red"> 118.                     token += nextchar</font>
<font color="green"> 119.                 elif nextchar == '.':</font>
<font color="red"> 120.                     token += nextchar</font>
<font color="red"> 121.                     state = 'a.'</font>
<font color="black"> 122.                 else:</font>
<font color="green"> 123.                     self.charstack.append(nextchar)</font>
<font color="green"> 124.                     break  # emit token</font>
<font color="green"> 125.             elif state == '0':</font>
<font color="black"> 126.                 # If we've already started reading a number, we keep reading</font>
<font color="black"> 127.                 # numbers until we find something that doesn't fit.</font>
<font color="green"> 128.                 if self.isnum(nextchar):</font>
<font color="green"> 129.                     token += nextchar</font>
<font color="green"> 130.                 elif nextchar == '.' or (nextchar == ',' and len(token) &gt;= 2):</font>
<font color="green"> 131.                     token += nextchar</font>
<font color="green"> 132.                     state = '0.'</font>
<font color="black"> 133.                 else:</font>
<font color="green"> 134.                     self.charstack.append(nextchar)</font>
<font color="green"> 135.                     break  # emit token</font>
<font color="green"> 136.             elif state == 'a.':</font>
<font color="black"> 137.                 # If we've seen some letters and a dot separator, continue</font>
<font color="black"> 138.                 # parsing, and the tokens will be broken up later.</font>
<font color="red"> 139.                 seenletters = True</font>
<font color="red"> 140.                 if nextchar == '.' or self.isword(nextchar):</font>
<font color="red"> 141.                     token += nextchar</font>
<font color="red"> 142.                 elif self.isnum(nextchar) and token[-1] == '.':</font>
<font color="red"> 143.                     token += nextchar</font>
<font color="red"> 144.                     state = '0.'</font>
<font color="black"> 145.                 else:</font>
<font color="red"> 146.                     self.charstack.append(nextchar)</font>
<font color="red"> 147.                     break  # emit token</font>
<font color="green"> 148.             elif state == '0.':</font>
<font color="black"> 149.                 # If we've seen at least one dot separator, keep going, we'll</font>
<font color="black"> 150.                 # break up the tokens later.</font>
<font color="green"> 151.                 if nextchar == '.' or self.isnum(nextchar):</font>
<font color="green"> 152.                     token += nextchar</font>
<font color="green"> 153.                 elif self.isword(nextchar) and token[-1] == '.':</font>
<font color="red"> 154.                     token += nextchar</font>
<font color="red"> 155.                     state = 'a.'</font>
<font color="black"> 156.                 else:</font>
<font color="green"> 157.                     self.charstack.append(nextchar)</font>
<font color="green"> 158.                     break  # emit token</font>
<font color="black"> 159. </font>
<font color="green"> 160.         if (state in ('a.', '0.') and (seenletters or token.count('.') &gt; 1 or</font>
<font color="green"> 161.                                        token[-1] in '.,')):</font>
<font color="red"> 162.             l = self._split_decimal.split(token)</font>
<font color="red"> 163.             token = l[0]</font>
<font color="red"> 164.             for tok in l[1:]:</font>
<font color="red"> 165.                 if tok:</font>
<font color="red"> 166.                     self.tokenstack.append(tok)</font>
<font color="black"> 167. </font>
<font color="green"> 168.         if state == '0.' and token.count('.') == 0:</font>
<font color="red"> 169.             token = token.replace(',', '.')</font>
<font color="black"> 170. </font>
<font color="green"> 171.         return token</font>
<font color="black"> 172. </font>
<font color="green"> 173.     def __iter__(self):</font>
<font color="green"> 174.         return self</font>
<font color="black"> 175. </font>
<font color="green"> 176.     def __next__(self):</font>
<font color="green"> 177.         token = self.get_token()</font>
<font color="green"> 178.         if token is None:</font>
<font color="green"> 179.             raise StopIteration</font>
<font color="black"> 180. </font>
<font color="green"> 181.         return token</font>
<font color="black"> 182. </font>
<font color="green"> 183.     def next(self):</font>
<font color="green"> 184.         return self.__next__()  # Python 2.x support</font>
<font color="black"> 185. </font>
<font color="green"> 186.     @classmethod</font>
<font color="black"> 187.     def split(cls, s):</font>
<font color="green"> 188.         return list(cls(s))</font>
<font color="black"> 189. </font>
<font color="green"> 190.     @classmethod</font>
<font color="black"> 191.     def isword(cls, nextchar):</font>
<font color="black"> 192.         &quot;&quot;&quot; Whether or not the next character is part of a word &quot;&quot;&quot;</font>
<font color="green"> 193.         return nextchar.isalpha()</font>
<font color="black"> 194. </font>
<font color="green"> 195.     @classmethod</font>
<font color="black"> 196.     def isnum(cls, nextchar):</font>
<font color="black"> 197.         &quot;&quot;&quot; Whether the next character is part of a number &quot;&quot;&quot;</font>
<font color="green"> 198.         return nextchar.isdigit()</font>
<font color="black"> 199. </font>
<font color="green"> 200.     @classmethod</font>
<font color="black"> 201.     def isspace(cls, nextchar):</font>
<font color="black"> 202.         &quot;&quot;&quot; Whether the next character is whitespace &quot;&quot;&quot;</font>
<font color="green"> 203.         return nextchar.isspace()</font>
<font color="black"> 204. </font>
<font color="black"> 205. </font>
<font color="green"> 206. class _resultbase(object):</font>
<font color="black"> 207. </font>
<font color="green"> 208.     def __init__(self):</font>
<font color="green"> 209.         for attr in self.__slots__:</font>
<font color="green"> 210.             setattr(self, attr, None)</font>
<font color="black"> 211. </font>
<font color="green"> 212.     def _repr(self, classname):</font>
<font color="red"> 213.         l = []</font>
<font color="red"> 214.         for attr in self.__slots__:</font>
<font color="red"> 215.             value = getattr(self, attr)</font>
<font color="red"> 216.             if value is not None:</font>
<font color="red"> 217.                 l.append(&quot;%s=%s&quot; % (attr, repr(value)))</font>
<font color="red"> 218.         return &quot;%s(%s)&quot; % (classname, &quot;, &quot;.join(l))</font>
<font color="black"> 219. </font>
<font color="green"> 220.     def __len__(self):</font>
<font color="green"> 221.         return (sum(getattr(self, attr) is not None</font>
<font color="green"> 222.                     for attr in self.__slots__))</font>
<font color="black"> 223. </font>
<font color="green"> 224.     def __repr__(self):</font>
<font color="red"> 225.         return self._repr(self.__class__.__name__)</font>
<font color="black"> 226. </font>
<font color="black"> 227. </font>
<font color="green"> 228. class parserinfo(object):</font>
<font color="black"> 229.     &quot;&quot;&quot;</font>
<font color="black"> 230.     Class which handles what inputs are accepted. Subclass this to customize</font>
<font color="black"> 231.     the language and acceptable values for each parameter.</font>
<font color="black"> 232. </font>
<font color="black"> 233.     :param dayfirst:</font>
<font color="black"> 234.             Whether to interpret the first value in an ambiguous 3-integer date</font>
<font color="black"> 235.             (e.g. 01/05/09) as the day (``True``) or month (``False``). If</font>
<font color="black"> 236.             ``yearfirst`` is set to ``True``, this distinguishes between YDM</font>
<font color="black"> 237.             and YMD. Default is ``False``.</font>
<font color="black"> 238. </font>
<font color="black"> 239.     :param yearfirst:</font>
<font color="black"> 240.             Whether to interpret the first value in an ambiguous 3-integer date</font>
<font color="black"> 241.             (e.g. 01/05/09) as the year. If ``True``, the first number is taken</font>
<font color="black"> 242.             to be the year, otherwise the last number is taken to be the year.</font>
<font color="black"> 243.             Default is ``False``.</font>
<font color="green"> 244.     &quot;&quot;&quot;</font>
<font color="black"> 245. </font>
<font color="black"> 246.     # m from a.m/p.m, t from ISO T separator</font>
<font color="green"> 247.     JUMP = [&quot; &quot;, &quot;.&quot;, &quot;,&quot;, &quot;;&quot;, &quot;-&quot;, &quot;/&quot;, &quot;'&quot;,</font>
<font color="green"> 248.             &quot;at&quot;, &quot;on&quot;, &quot;and&quot;, &quot;ad&quot;, &quot;m&quot;, &quot;t&quot;, &quot;of&quot;,</font>
<font color="green"> 249.             &quot;st&quot;, &quot;nd&quot;, &quot;rd&quot;, &quot;th&quot;]</font>
<font color="black"> 250. </font>
<font color="green"> 251.     WEEKDAYS = [(&quot;Mon&quot;, &quot;Monday&quot;),</font>
<font color="green"> 252.                 (&quot;Tue&quot;, &quot;Tuesday&quot;),</font>
<font color="green"> 253.                 (&quot;Wed&quot;, &quot;Wednesday&quot;),</font>
<font color="green"> 254.                 (&quot;Thu&quot;, &quot;Thursday&quot;),</font>
<font color="green"> 255.                 (&quot;Fri&quot;, &quot;Friday&quot;),</font>
<font color="green"> 256.                 (&quot;Sat&quot;, &quot;Saturday&quot;),</font>
<font color="green"> 257.                 (&quot;Sun&quot;, &quot;Sunday&quot;)]</font>
<font color="green"> 258.     MONTHS = [(&quot;Jan&quot;, &quot;January&quot;),</font>
<font color="green"> 259.               (&quot;Feb&quot;, &quot;February&quot;),</font>
<font color="green"> 260.               (&quot;Mar&quot;, &quot;March&quot;),</font>
<font color="green"> 261.               (&quot;Apr&quot;, &quot;April&quot;),</font>
<font color="green"> 262.               (&quot;May&quot;, &quot;May&quot;),</font>
<font color="green"> 263.               (&quot;Jun&quot;, &quot;June&quot;),</font>
<font color="green"> 264.               (&quot;Jul&quot;, &quot;July&quot;),</font>
<font color="green"> 265.               (&quot;Aug&quot;, &quot;August&quot;),</font>
<font color="green"> 266.               (&quot;Sep&quot;, &quot;Sept&quot;, &quot;September&quot;),</font>
<font color="green"> 267.               (&quot;Oct&quot;, &quot;October&quot;),</font>
<font color="green"> 268.               (&quot;Nov&quot;, &quot;November&quot;),</font>
<font color="green"> 269.               (&quot;Dec&quot;, &quot;December&quot;)]</font>
<font color="green"> 270.     HMS = [(&quot;h&quot;, &quot;hour&quot;, &quot;hours&quot;),</font>
<font color="green"> 271.            (&quot;m&quot;, &quot;minute&quot;, &quot;minutes&quot;),</font>
<font color="green"> 272.            (&quot;s&quot;, &quot;second&quot;, &quot;seconds&quot;)]</font>
<font color="green"> 273.     AMPM = [(&quot;am&quot;, &quot;a&quot;),</font>
<font color="green"> 274.             (&quot;pm&quot;, &quot;p&quot;)]</font>
<font color="green"> 275.     UTCZONE = [&quot;UTC&quot;, &quot;GMT&quot;, &quot;Z&quot;]</font>
<font color="green"> 276.     PERTAIN = [&quot;of&quot;]</font>
<font color="green"> 277.     TZOFFSET = {}</font>
<font color="black"> 278. </font>
<font color="green"> 279.     def __init__(self, dayfirst=False, yearfirst=False):</font>
<font color="green"> 280.         self._jump = self._convert(self.JUMP)</font>
<font color="green"> 281.         self._weekdays = self._convert(self.WEEKDAYS)</font>
<font color="green"> 282.         self._months = self._convert(self.MONTHS)</font>
<font color="green"> 283.         self._hms = self._convert(self.HMS)</font>
<font color="green"> 284.         self._ampm = self._convert(self.AMPM)</font>
<font color="green"> 285.         self._utczone = self._convert(self.UTCZONE)</font>
<font color="green"> 286.         self._pertain = self._convert(self.PERTAIN)</font>
<font color="black"> 287. </font>
<font color="green"> 288.         self.dayfirst = dayfirst</font>
<font color="green"> 289.         self.yearfirst = yearfirst</font>
<font color="black"> 290. </font>
<font color="green"> 291.         self._year = time.localtime().tm_year</font>
<font color="green"> 292.         self._century = self._year // 100 * 100</font>
<font color="black"> 293. </font>
<font color="green"> 294.     def _convert(self, lst):</font>
<font color="green"> 295.         dct = {}</font>
<font color="green"> 296.         for i, v in enumerate(lst):</font>
<font color="green"> 297.             if isinstance(v, tuple):</font>
<font color="green"> 298.                 for v in v:</font>
<font color="green"> 299.                     dct[v.lower()] = i</font>
<font color="black"> 300.             else:</font>
<font color="green"> 301.                 dct[v.lower()] = i</font>
<font color="green"> 302.         return dct</font>
<font color="black"> 303. </font>
<font color="green"> 304.     def jump(self, name):</font>
<font color="green"> 305.         return name.lower() in self._jump</font>
<font color="black"> 306. </font>
<font color="green"> 307.     def weekday(self, name):</font>
<font color="green"> 308.         if len(name) &gt;= 3:</font>
<font color="red"> 309.             try:</font>
<font color="red"> 310.                 return self._weekdays[name.lower()]</font>
<font color="red"> 311.             except KeyError:</font>
<font color="red"> 312.                 pass</font>
<font color="green"> 313.         return None</font>
<font color="black"> 314. </font>
<font color="green"> 315.     def month(self, name):</font>
<font color="green"> 316.         if len(name) &gt;= 3:</font>
<font color="red"> 317.             try:</font>
<font color="red"> 318.                 return self._months[name.lower()] + 1</font>
<font color="red"> 319.             except KeyError:</font>
<font color="red"> 320.                 pass</font>
<font color="green"> 321.         return None</font>
<font color="black"> 322. </font>
<font color="green"> 323.     def hms(self, name):</font>
<font color="green"> 324.         try:</font>
<font color="green"> 325.             return self._hms[name.lower()]</font>
<font color="green"> 326.         except KeyError:</font>
<font color="green"> 327.             return None</font>
<font color="black"> 328. </font>
<font color="green"> 329.     def ampm(self, name):</font>
<font color="green"> 330.         try:</font>
<font color="green"> 331.             return self._ampm[name.lower()]</font>
<font color="green"> 332.         except KeyError:</font>
<font color="green"> 333.             return None</font>
<font color="black"> 334. </font>
<font color="green"> 335.     def pertain(self, name):</font>
<font color="red"> 336.         return name.lower() in self._pertain</font>
<font color="black"> 337. </font>
<font color="green"> 338.     def utczone(self, name):</font>
<font color="red"> 339.         return name.lower() in self._utczone</font>
<font color="black"> 340. </font>
<font color="green"> 341.     def tzoffset(self, name):</font>
<font color="green"> 342.         if name in self._utczone:</font>
<font color="red"> 343.             return 0</font>
<font color="black"> 344. </font>
<font color="green"> 345.         return self.TZOFFSET.get(name)</font>
<font color="black"> 346. </font>
<font color="green"> 347.     def convertyear(self, year, century_specified=False):</font>
<font color="green"> 348.         if year &lt; 100 and not century_specified:</font>
<font color="red"> 349.             year += self._century</font>
<font color="red"> 350.             if abs(year - self._year) &gt;= 50:</font>
<font color="red"> 351.                 if year &lt; self._year:</font>
<font color="red"> 352.                     year += 100</font>
<font color="black"> 353.                 else:</font>
<font color="red"> 354.                     year -= 100</font>
<font color="green"> 355.         return year</font>
<font color="black"> 356. </font>
<font color="green"> 357.     def validate(self, res):</font>
<font color="black"> 358.         # move to info</font>
<font color="green"> 359.         if res.year is not None:</font>
<font color="green"> 360.             res.year = self.convertyear(res.year, res.century_specified)</font>
<font color="black"> 361. </font>
<font color="green"> 362.         if res.tzoffset == 0 and not res.tzname or res.tzname == 'Z':</font>
<font color="green"> 363.             res.tzname = &quot;UTC&quot;</font>
<font color="green"> 364.             res.tzoffset = 0</font>
<font color="red"> 365.         elif res.tzoffset != 0 and res.tzname and self.utczone(res.tzname):</font>
<font color="red"> 366.             res.tzoffset = 0</font>
<font color="green"> 367.         return True</font>
<font color="black"> 368. </font>
<font color="black"> 369. </font>
<font color="green"> 370. class _ymd(list):</font>
<font color="green"> 371.     def __init__(self, tzstr, *args, **kwargs):</font>
<font color="green"> 372.         super(self.__class__, self).__init__(*args, **kwargs)</font>
<font color="green"> 373.         self.century_specified = False</font>
<font color="green"> 374.         self.tzstr = tzstr</font>
<font color="black"> 375. </font>
<font color="green"> 376.     @staticmethod</font>
<font color="black"> 377.     def token_could_be_year(token, year):</font>
<font color="red"> 378.         try:</font>
<font color="red"> 379.             return int(token) == year</font>
<font color="red"> 380.         except ValueError:</font>
<font color="red"> 381.             return False</font>
<font color="black"> 382. </font>
<font color="green"> 383.     @staticmethod</font>
<font color="black"> 384.     def find_potential_year_tokens(year, tokens):</font>
<font color="red"> 385.         return [token for token in tokens if _ymd.token_could_be_year(token, year)]</font>
<font color="black"> 386. </font>
<font color="green"> 387.     def find_probable_year_index(self, tokens):</font>
<font color="black"> 388.         &quot;&quot;&quot;</font>
<font color="black"> 389.         attempt to deduce if a pre 100 year was lost</font>
<font color="black"> 390.          due to padded zeros being taken off</font>
<font color="black"> 391.         &quot;&quot;&quot;</font>
<font color="red"> 392.         for index, token in enumerate(self):</font>
<font color="red"> 393.             potential_year_tokens = _ymd.find_potential_year_tokens(token, tokens)</font>
<font color="red"> 394.             if len(potential_year_tokens) == 1 and len(potential_year_tokens[0]) &gt; 2:</font>
<font color="red"> 395.                 return index</font>
<font color="black"> 396. </font>
<font color="green"> 397.     def append(self, val):</font>
<font color="green"> 398.         if hasattr(val, '__len__'):</font>
<font color="green"> 399.             if val.isdigit() and len(val) &gt; 2:</font>
<font color="green"> 400.                 self.century_specified = True</font>
<font color="red"> 401.         elif val &gt; 100:</font>
<font color="red"> 402.             self.century_specified = True</font>
<font color="black"> 403. </font>
<font color="green"> 404.         super(self.__class__, self).append(int(val))</font>
<font color="black"> 405. </font>
<font color="green"> 406.     def resolve_ymd(self, mstridx, yearfirst, dayfirst):</font>
<font color="green"> 407.         len_ymd = len(self)</font>
<font color="green"> 408.         year, month, day = (None, None, None)</font>
<font color="black"> 409. </font>
<font color="green"> 410.         if len_ymd &gt; 3:</font>
<font color="red"> 411.             raise ValueError(&quot;More than three YMD values&quot;)</font>
<font color="green"> 412.         elif len_ymd == 1 or (mstridx != -1 and len_ymd == 2):</font>
<font color="black"> 413.             # One member, or two members with a month string</font>
<font color="red"> 414.             if mstridx != -1:</font>
<font color="red"> 415.                 month = self[mstridx]</font>
<font color="red"> 416.                 del self[mstridx]</font>
<font color="black"> 417. </font>
<font color="red"> 418.             if len_ymd &gt; 1 or mstridx == -1:</font>
<font color="red"> 419.                 if self[0] &gt; 31:</font>
<font color="red"> 420.                     year = self[0]</font>
<font color="black"> 421.                 else:</font>
<font color="red"> 422.                     day = self[0]</font>
<font color="black"> 423. </font>
<font color="green"> 424.         elif len_ymd == 2:</font>
<font color="black"> 425.             # Two members with numbers</font>
<font color="red"> 426.             if self[0] &gt; 31:</font>
<font color="black"> 427.                 # 99-01</font>
<font color="red"> 428.                 year, month = self</font>
<font color="red"> 429.             elif self[1] &gt; 31:</font>
<font color="black"> 430.                 # 01-99</font>
<font color="red"> 431.                 month, year = self</font>
<font color="red"> 432.             elif dayfirst and self[1] &lt;= 12:</font>
<font color="black"> 433.                 # 13-01</font>
<font color="red"> 434.                 day, month = self</font>
<font color="black"> 435.             else:</font>
<font color="black"> 436.                 # 01-13</font>
<font color="red"> 437.                 month, day = self</font>
<font color="black"> 438. </font>
<font color="green"> 439.         elif len_ymd == 3:</font>
<font color="black"> 440.             # Three members</font>
<font color="green"> 441.             if mstridx == 0:</font>
<font color="red"> 442.                 month, day, year = self</font>
<font color="green"> 443.             elif mstridx == 1:</font>
<font color="red"> 444.                 if self[0] &gt; 31 or (yearfirst and self[2] &lt;= 31):</font>
<font color="black"> 445.                     # 99-Jan-01</font>
<font color="red"> 446.                     year, month, day = self</font>
<font color="black"> 447.                 else:</font>
<font color="black"> 448.                     # 01-Jan-01</font>
<font color="black"> 449.                     # Give precendence to day-first, since</font>
<font color="black"> 450.                     # two-digit years is usually hand-written.</font>
<font color="red"> 451.                     day, month, year = self</font>
<font color="black"> 452. </font>
<font color="green"> 453.             elif mstridx == 2:</font>
<font color="black"> 454.                 # WTF!?</font>
<font color="red"> 455.                 if self[1] &gt; 31:</font>
<font color="black"> 456.                     # 01-99-Jan</font>
<font color="red"> 457.                     day, year, month = self</font>
<font color="black"> 458.                 else:</font>
<font color="black"> 459.                     # 99-01-Jan</font>
<font color="red"> 460.                     year, day, month = self</font>
<font color="black"> 461. </font>
<font color="black"> 462.             else:</font>
<font color="green"> 463.                 if self[0] &gt; 31 or \</font>
<font color="red"> 464.                     self.find_probable_year_index(_timelex.split(self.tzstr)) == 0 or \</font>
<font color="red"> 465.                    (yearfirst and self[1] &lt;= 12 and self[2] &lt;= 31):</font>
<font color="black"> 466.                     # 99-01-01</font>
<font color="green"> 467.                     if dayfirst and self[2] &lt;= 12:</font>
<font color="red"> 468.                         year, day, month = self</font>
<font color="black"> 469.                     else:</font>
<font color="green"> 470.                         year, month, day = self</font>
<font color="red"> 471.                 elif self[0] &gt; 12 or (dayfirst and self[1] &lt;= 12):</font>
<font color="black"> 472.                     # 13-01-01</font>
<font color="red"> 473.                     day, month, year = self</font>
<font color="black"> 474.                 else:</font>
<font color="black"> 475.                     # 01-13-01</font>
<font color="red"> 476.                     month, day, year = self</font>
<font color="black"> 477. </font>
<font color="green"> 478.         return year, month, day</font>
<font color="black"> 479. </font>
<font color="black"> 480. </font>
<font color="green"> 481. class parser(object):</font>
<font color="green"> 482.     def __init__(self, info=None):</font>
<font color="green"> 483.         self.info = info or parserinfo()</font>
<font color="black"> 484. </font>
<font color="green"> 485.     def parse(self, timestr, default=None, ignoretz=False, tzinfos=None, **kwargs):</font>
<font color="black"> 486.         &quot;&quot;&quot;</font>
<font color="black"> 487.         Parse the date/time string into a :class:`datetime.datetime` object.</font>
<font color="black"> 488. </font>
<font color="black"> 489.         :param timestr:</font>
<font color="black"> 490.             Any date/time string using the supported formats.</font>
<font color="black"> 491. </font>
<font color="black"> 492.         :param default:</font>
<font color="black"> 493.             The default datetime object, if this is a datetime object and not</font>
<font color="black"> 494.             ``None``, elements specified in ``timestr`` replace elements in the</font>
<font color="black"> 495.             default object.</font>
<font color="black"> 496. </font>
<font color="black"> 497.         :param ignoretz:</font>
<font color="black"> 498.             If set ``True``, time zones in parsed strings are ignored and a</font>
<font color="black"> 499.             naive :class:`datetime.datetime` object is returned.</font>
<font color="black"> 500. </font>
<font color="black"> 501.         :param tzinfos:</font>
<font color="black"> 502.             Additional time zone names / aliases which may be present in the</font>
<font color="black"> 503.             string. This argument maps time zone names (and optionally offsets</font>
<font color="black"> 504.             from those time zones) to time zones. This parameter can be a</font>
<font color="black"> 505.             dictionary with timezone aliases mapping time zone names to time</font>
<font color="black"> 506.             zones or a function taking two parameters (``tzname`` and</font>
<font color="black"> 507.             ``tzoffset``) and returning a time zone.</font>
<font color="black"> 508. </font>
<font color="black"> 509.             The timezones to which the names are mapped can be an integer</font>
<font color="black"> 510.             offset from UTC in minutes or a :class:`tzinfo` object.</font>
<font color="black"> 511. </font>
<font color="black"> 512.             .. doctest::</font>
<font color="black"> 513.                :options: +NORMALIZE_WHITESPACE</font>
<font color="black"> 514. </font>
<font color="black"> 515.                 &gt;&gt;&gt; from dateutil.parser import parse</font>
<font color="black"> 516.                 &gt;&gt;&gt; from dateutil.tz import gettz</font>
<font color="black"> 517.                 &gt;&gt;&gt; tzinfos = {&quot;BRST&quot;: -10800, &quot;CST&quot;: gettz(&quot;America/Chicago&quot;)}</font>
<font color="black"> 518.                 &gt;&gt;&gt; parse(&quot;2012-01-19 17:21:00 BRST&quot;, tzinfos=tzinfos)</font>
<font color="black"> 519.                 datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -10800))</font>
<font color="black"> 520.                 &gt;&gt;&gt; parse(&quot;2012-01-19 17:21:00 CST&quot;, tzinfos=tzinfos)</font>
<font color="black"> 521.                 datetime.datetime(2012, 1, 19, 17, 21,</font>
<font color="black"> 522.                                   tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))</font>
<font color="black"> 523. </font>
<font color="black"> 524.             This parameter is ignored if ``ignoretz`` is set.</font>
<font color="black"> 525. </font>
<font color="black"> 526.         :param **kwargs:</font>
<font color="black"> 527.             Keyword arguments as passed to ``_parse()``.</font>
<font color="black"> 528. </font>
<font color="black"> 529.         :return:</font>
<font color="black"> 530.             Returns a :class:`datetime.datetime` object or, if the</font>
<font color="black"> 531.             ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the</font>
<font color="black"> 532.             first element being a :class:`datetime.datetime` object, the second</font>
<font color="black"> 533.             a tuple containing the fuzzy tokens.</font>
<font color="black"> 534. </font>
<font color="black"> 535.         :raises ValueError:</font>
<font color="black"> 536.             Raised for invalid or unknown string format, if the provided</font>
<font color="black"> 537.             :class:`tzinfo` is not in a valid format, or if an invalid date</font>
<font color="black"> 538.             would be created.</font>
<font color="black"> 539. </font>
<font color="black"> 540.         :raises OverflowError:</font>
<font color="black"> 541.             Raised if the parsed date exceeds the largest valid C integer on</font>
<font color="black"> 542.             your system.</font>
<font color="black"> 543.         &quot;&quot;&quot;</font>
<font color="black"> 544. </font>
<font color="green"> 545.         if default is None:</font>
<font color="green"> 546.             effective_dt = datetime.datetime.now()</font>
<font color="green"> 547.             default = datetime.datetime.now().replace(hour=0, minute=0,</font>
<font color="green"> 548.                                                       second=0, microsecond=0)</font>
<font color="black"> 549.         else:</font>
<font color="red"> 550.             effective_dt = default</font>
<font color="black"> 551. </font>
<font color="green"> 552.         res, skipped_tokens = self._parse(timestr, **kwargs)</font>
<font color="black"> 553. </font>
<font color="green"> 554.         if res is None:</font>
<font color="red"> 555.             raise ValueError(&quot;Unknown string format&quot;)</font>
<font color="black"> 556. </font>
<font color="green"> 557.         if len(res) == 0:</font>
<font color="red"> 558.             raise ValueError(&quot;String does not contain a date.&quot;)</font>
<font color="black"> 559. </font>
<font color="green"> 560.         repl = {}</font>
<font color="green"> 561.         for attr in (&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;,</font>
<font color="green"> 562.                      &quot;minute&quot;, &quot;second&quot;, &quot;microsecond&quot;):</font>
<font color="green"> 563.             value = getattr(res, attr)</font>
<font color="green"> 564.             if value is not None:</font>
<font color="green"> 565.                 repl[attr] = value</font>
<font color="black"> 566. </font>
<font color="green"> 567.         if 'day' not in repl:</font>
<font color="black"> 568.             # If the default day exceeds the last day of the month, fall back to</font>
<font color="black"> 569.             # the end of the month.</font>
<font color="red"> 570.             cyear = default.year if res.year is None else res.year</font>
<font color="red"> 571.             cmonth = default.month if res.month is None else res.month</font>
<font color="red"> 572.             cday = default.day if res.day is None else res.day</font>
<font color="black"> 573. </font>
<font color="red"> 574.             if cday &gt; monthrange(cyear, cmonth)[1]:</font>
<font color="red"> 575.                 repl['day'] = monthrange(cyear, cmonth)[1]</font>
<font color="black"> 576. </font>
<font color="green"> 577.         ret = default.replace(**repl)</font>
<font color="black"> 578. </font>
<font color="green"> 579.         if res.weekday is not None and not res.day:</font>
<font color="red"> 580.             ret = ret+relativedelta.relativedelta(weekday=res.weekday)</font>
<font color="black"> 581. </font>
<font color="green"> 582.         if not ignoretz:</font>
<font color="green"> 583.             if (isinstance(tzinfos, collections.Callable) or</font>
<font color="green"> 584.                     tzinfos and res.tzname in tzinfos):</font>
<font color="black"> 585. </font>
<font color="red"> 586.                 if isinstance(tzinfos, collections.Callable):</font>
<font color="red"> 587.                     tzdata = tzinfos(res.tzname, res.tzoffset)</font>
<font color="black"> 588.                 else:</font>
<font color="red"> 589.                     tzdata = tzinfos.get(res.tzname)</font>
<font color="black"> 590. </font>
<font color="red"> 591.                 if isinstance(tzdata, datetime.tzinfo):</font>
<font color="red"> 592.                     tzinfo = tzdata</font>
<font color="red"> 593.                 elif isinstance(tzdata, text_type):</font>
<font color="red"> 594.                     tzinfo = tz.tzstr(tzdata)</font>
<font color="red"> 595.                 elif isinstance(tzdata, integer_types):</font>
<font color="red"> 596.                     tzinfo = tz.tzoffset(res.tzname, tzdata)</font>
<font color="black"> 597.                 else:</font>
<font color="red"> 598.                     raise ValueError(&quot;Offset must be tzinfo subclass, &quot;</font>
<font color="black"> 599.                                      &quot;tz string, or int offset.&quot;)</font>
<font color="red"> 600.                 ret = ret.replace(tzinfo=tzinfo)</font>
<font color="green"> 601.             elif res.tzname and res.tzname in time.tzname:</font>
<font color="red"> 602.                 ret = ret.replace(tzinfo=tz.tzlocal())</font>
<font color="green"> 603.             elif res.tzoffset == 0:</font>
<font color="green"> 604.                 ret = ret.replace(tzinfo=tz.tzutc())</font>
<font color="red"> 605.             elif res.tzoffset:</font>
<font color="red"> 606.                 ret = ret.replace(tzinfo=tz.tzoffset(res.tzname, res.tzoffset))</font>
<font color="black"> 607. </font>
<font color="green"> 608.         if kwargs.get('fuzzy_with_tokens', False):</font>
<font color="red"> 609.             return ret, skipped_tokens</font>
<font color="black"> 610.         else:</font>
<font color="green"> 611.             return ret</font>
<font color="black"> 612. </font>
<font color="green"> 613.     class _result(_resultbase):</font>
<font color="green"> 614.         __slots__ = [&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;weekday&quot;,</font>
<font color="green"> 615.                      &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;, &quot;microsecond&quot;,</font>
<font color="green"> 616.                      &quot;tzname&quot;, &quot;tzoffset&quot;, &quot;ampm&quot;]</font>
<font color="black"> 617. </font>
<font color="green"> 618.     def _parse(self, timestr, dayfirst=None, yearfirst=None, fuzzy=False,</font>
<font color="green"> 619.                fuzzy_with_tokens=False):</font>
<font color="black"> 620.         &quot;&quot;&quot;</font>
<font color="black"> 621.         Private method which performs the heavy lifting of parsing, called from</font>
<font color="black"> 622.         ``parse()``, which passes on its ``kwargs`` to this function.</font>
<font color="black"> 623. </font>
<font color="black"> 624.         :param timestr:</font>
<font color="black"> 625.             The string to parse.</font>
<font color="black"> 626. </font>
<font color="black"> 627.         :param dayfirst:</font>
<font color="black"> 628.             Whether to interpret the first value in an ambiguous 3-integer date</font>
<font color="black"> 629.             (e.g. 01/05/09) as the day (``True``) or month (``False``). If</font>
<font color="black"> 630.             ``yearfirst`` is set to ``True``, this distinguishes between YDM</font>
<font color="black"> 631.             and YMD. If set to ``None``, this value is retrieved from the</font>
<font color="black"> 632.             current :class:`parserinfo` object (which itself defaults to</font>
<font color="black"> 633.             ``False``).</font>
<font color="black"> 634. </font>
<font color="black"> 635.         :param yearfirst:</font>
<font color="black"> 636.             Whether to interpret the first value in an ambiguous 3-integer date</font>
<font color="black"> 637.             (e.g. 01/05/09) as the year. If ``True``, the first number is taken</font>
<font color="black"> 638.             to be the year, otherwise the last number is taken to be the year.</font>
<font color="black"> 639.             If this is set to ``None``, the value is retrieved from the current</font>
<font color="black"> 640.             :class:`parserinfo` object (which itself defaults to ``False``).</font>
<font color="black"> 641. </font>
<font color="black"> 642.         :param fuzzy:</font>
<font color="black"> 643.             Whether to allow fuzzy parsing, allowing for string like &quot;Today is</font>
<font color="black"> 644.             January 1, 2047 at 8:21:00AM&quot;.</font>
<font color="black"> 645. </font>
<font color="black"> 646.         :param fuzzy_with_tokens:</font>
<font color="black"> 647.             If ``True``, ``fuzzy`` is automatically set to True, and the parser</font>
<font color="black"> 648.             will return a tuple where the first element is the parsed</font>
<font color="black"> 649.             :class:`datetime.datetime` datetimestamp and the second element is</font>
<font color="black"> 650.             a tuple containing the portions of the string which were ignored:</font>
<font color="black"> 651. </font>
<font color="black"> 652.             .. doctest::</font>
<font color="black"> 653. </font>
<font color="black"> 654.                 &gt;&gt;&gt; from dateutil.parser import parse</font>
<font color="black"> 655.                 &gt;&gt;&gt; parse(&quot;Today is January 1, 2047 at 8:21:00AM&quot;, fuzzy_with_tokens=True)</font>
<font color="black"> 656.                 (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))</font>
<font color="black"> 657. </font>
<font color="black"> 658.         &quot;&quot;&quot;</font>
<font color="green"> 659.         if fuzzy_with_tokens:</font>
<font color="red"> 660.             fuzzy = True</font>
<font color="black"> 661. </font>
<font color="green"> 662.         info = self.info</font>
<font color="black"> 663. </font>
<font color="green"> 664.         if dayfirst is None:</font>
<font color="green"> 665.             dayfirst = info.dayfirst</font>
<font color="black"> 666. </font>
<font color="green"> 667.         if yearfirst is None:</font>
<font color="green"> 668.             yearfirst = info.yearfirst</font>
<font color="black"> 669. </font>
<font color="green"> 670.         res = self._result()</font>
<font color="green"> 671.         l = _timelex.split(timestr)         # Splits the timestr into tokens</font>
<font color="black"> 672. </font>
<font color="black"> 673.         # keep up with the last token skipped so we can recombine</font>
<font color="black"> 674.         # consecutively skipped tokens (-2 for when i begins at 0).</font>
<font color="green"> 675.         last_skipped_token_i = -2</font>
<font color="green"> 676.         skipped_tokens = list()</font>
<font color="black"> 677. </font>
<font color="green"> 678.         try:</font>
<font color="black"> 679.             # year/month/day list</font>
<font color="green"> 680.             ymd = _ymd(timestr)</font>
<font color="black"> 681. </font>
<font color="black"> 682.             # Index of the month string in ymd</font>
<font color="green"> 683.             mstridx = -1</font>
<font color="black"> 684. </font>
<font color="green"> 685.             len_l = len(l)</font>
<font color="green"> 686.             i = 0</font>
<font color="green"> 687.             while i &lt; len_l:</font>
<font color="black"> 688. </font>
<font color="black"> 689.                 # Check if it's a number</font>
<font color="green"> 690.                 try:</font>
<font color="green"> 691.                     value_repr = l[i]</font>
<font color="green"> 692.                     value = float(value_repr)</font>
<font color="green"> 693.                 except ValueError:</font>
<font color="green"> 694.                     value = None</font>
<font color="black"> 695. </font>
<font color="green"> 696.                 if value is not None:</font>
<font color="black"> 697.                     # Token is a number</font>
<font color="green"> 698.                     len_li = len(l[i])</font>
<font color="green"> 699.                     i += 1</font>
<font color="black"> 700. </font>
<font color="green"> 701.                     if (len(ymd) == 3 and len_li in (2, 4)</font>
<font color="green"> 702.                         and res.hour is None and (i &gt;= len_l or (l[i] != ':' and</font>
<font color="red"> 703.                                                   info.hms(l[i]) is None))):</font>
<font color="black"> 704.                         # 19990101T23[59]</font>
<font color="red"> 705.                         s = l[i-1]</font>
<font color="red"> 706.                         res.hour = int(s[:2])</font>
<font color="black"> 707. </font>
<font color="red"> 708.                         if len_li == 4:</font>
<font color="red"> 709.                             res.minute = int(s[2:])</font>
<font color="black"> 710. </font>
<font color="green"> 711.                     elif len_li == 6 or (len_li &gt; 6 and l[i-1].find('.') == 6):</font>
<font color="black"> 712.                         # YYMMDD or HHMMSS[.ss]</font>
<font color="red"> 713.                         s = l[i-1]</font>
<font color="black"> 714. </font>
<font color="red"> 715.                         if not ymd and l[i-1].find('.') == -1:</font>
<font color="black"> 716.                             #ymd.append(info.convertyear(int(s[:2])))</font>
<font color="black"> 717. </font>
<font color="red"> 718.                             ymd.append(s[:2])</font>
<font color="red"> 719.                             ymd.append(s[2:4])</font>
<font color="red"> 720.                             ymd.append(s[4:])</font>
<font color="black"> 721.                         else:</font>
<font color="black"> 722.                             # 19990101T235959[.59]</font>
<font color="red"> 723.                             res.hour = int(s[:2])</font>
<font color="red"> 724.                             res.minute = int(s[2:4])</font>
<font color="red"> 725.                             res.second, res.microsecond = _parsems(s[4:])</font>
<font color="black"> 726. </font>
<font color="green"> 727.                     elif len_li in (8, 12, 14):</font>
<font color="black"> 728.                         # YYYYMMDD</font>
<font color="red"> 729.                         s = l[i-1]</font>
<font color="red"> 730.                         ymd.append(s[:4])</font>
<font color="red"> 731.                         ymd.append(s[4:6])</font>
<font color="red"> 732.                         ymd.append(s[6:8])</font>
<font color="black"> 733. </font>
<font color="red"> 734.                         if len_li &gt; 8:</font>
<font color="red"> 735.                             res.hour = int(s[8:10])</font>
<font color="red"> 736.                             res.minute = int(s[10:12])</font>
<font color="black"> 737. </font>
<font color="red"> 738.                             if len_li &gt; 12:</font>
<font color="red"> 739.                                 res.second = int(s[12:])</font>
<font color="black"> 740. </font>
<font color="green"> 741.                     elif ((i &lt; len_l and info.hms(l[i]) is not None) or</font>
<font color="green"> 742.                           (i+1 &lt; len_l and l[i] == ' ' and</font>
<font color="red"> 743.                            info.hms(l[i+1]) is not None)):</font>
<font color="black"> 744. </font>
<font color="black"> 745.                         # HH[ ]h or MM[ ]m or SS[.ss][ ]s</font>
<font color="red"> 746.                         if l[i] == ' ':</font>
<font color="red"> 747.                             i += 1</font>
<font color="black"> 748. </font>
<font color="red"> 749.                         idx = info.hms(l[i])</font>
<font color="black"> 750. </font>
<font color="red"> 751.                         while True:</font>
<font color="red"> 752.                             if idx == 0:</font>
<font color="red"> 753.                                 res.hour = int(value)</font>
<font color="black"> 754. </font>
<font color="red"> 755.                                 if value % 1:</font>
<font color="red"> 756.                                     res.minute = int(60*(value % 1))</font>
<font color="black"> 757. </font>
<font color="red"> 758.                             elif idx == 1:</font>
<font color="red"> 759.                                 res.minute = int(value)</font>
<font color="black"> 760. </font>
<font color="red"> 761.                                 if value % 1:</font>
<font color="red"> 762.                                     res.second = int(60*(value % 1))</font>
<font color="black"> 763. </font>
<font color="red"> 764.                             elif idx == 2:</font>
<font color="black"> 765.                                 res.second, res.microsecond = \</font>
<font color="red"> 766.                                     _parsems(value_repr)</font>
<font color="black"> 767. </font>
<font color="red"> 768.                             i += 1</font>
<font color="black"> 769. </font>
<font color="red"> 770.                             if i &gt;= len_l or idx == 2:</font>
<font color="red"> 771.                                 break</font>
<font color="black"> 772. </font>
<font color="black"> 773.                             # 12h00</font>
<font color="red"> 774.                             try:</font>
<font color="red"> 775.                                 value_repr = l[i]</font>
<font color="red"> 776.                                 value = float(value_repr)</font>
<font color="red"> 777.                             except ValueError:</font>
<font color="red"> 778.                                 break</font>
<font color="black"> 779.                             else:</font>
<font color="red"> 780.                                 i += 1</font>
<font color="red"> 781.                                 idx += 1</font>
<font color="black"> 782. </font>
<font color="red"> 783.                                 if i &lt; len_l:</font>
<font color="red"> 784.                                     newidx = info.hms(l[i])</font>
<font color="black"> 785. </font>
<font color="red"> 786.                                     if newidx is not None:</font>
<font color="red"> 787.                                         idx = newidx</font>
<font color="black"> 788. </font>
<font color="green"> 789.                     elif (i == len_l and l[i-2] == ' ' and</font>
<font color="red"> 790.                           info.hms(l[i-3]) is not None):</font>
<font color="black"> 791.                         # X h MM or X m SS</font>
<font color="red"> 792.                         idx = info.hms(l[i-3]) + 1</font>
<font color="black"> 793. </font>
<font color="red"> 794.                         if idx == 1:</font>
<font color="red"> 795.                             res.minute = int(value)</font>
<font color="black"> 796. </font>
<font color="red"> 797.                             if value % 1:</font>
<font color="red"> 798.                                 res.second = int(60*(value % 1))</font>
<font color="red"> 799.                             elif idx == 2:</font>
<font color="black"> 800.                                 res.second, res.microsecond = \</font>
<font color="red"> 801.                                     _parsems(value_repr)</font>
<font color="red"> 802.                                 i += 1</font>
<font color="black"> 803. </font>
<font color="green"> 804.                     elif i+1 &lt; len_l and l[i] == ':':</font>
<font color="black"> 805.                         # HH:MM[:SS[.ss]]</font>
<font color="green"> 806.                         res.hour = int(value)</font>
<font color="green"> 807.                         i += 1</font>
<font color="green"> 808.                         value = float(l[i])</font>
<font color="green"> 809.                         res.minute = int(value)</font>
<font color="black"> 810. </font>
<font color="green"> 811.                         if value % 1:</font>
<font color="red"> 812.                             res.second = int(60*(value % 1))</font>
<font color="black"> 813. </font>
<font color="green"> 814.                         i += 1</font>
<font color="black"> 815. </font>
<font color="green"> 816.                         if i &lt; len_l and l[i] == ':':</font>
<font color="green"> 817.                             res.second, res.microsecond = _parsems(l[i+1])</font>
<font color="green"> 818.                             i += 2</font>
<font color="black"> 819. </font>
<font color="green"> 820.                     elif i &lt; len_l and l[i] in ('-', '/', '.'):</font>
<font color="green"> 821.                         sep = l[i]</font>
<font color="green"> 822.                         ymd.append(value_repr)</font>
<font color="green"> 823.                         i += 1</font>
<font color="black"> 824. </font>
<font color="green"> 825.                         if i &lt; len_l and not info.jump(l[i]):</font>
<font color="green"> 826.                             try:</font>
<font color="black"> 827.                                 # 01-01[-01]</font>
<font color="green"> 828.                                 ymd.append(l[i])</font>
<font color="red"> 829.                             except ValueError:</font>
<font color="black"> 830.                                 # 01-Jan[-01]</font>
<font color="red"> 831.                                 value = info.month(l[i])</font>
<font color="black"> 832. </font>
<font color="red"> 833.                                 if value is not None:</font>
<font color="red"> 834.                                     ymd.append(value)</font>
<font color="red"> 835.                                     assert mstridx == -1</font>
<font color="red"> 836.                                     mstridx = len(ymd)-1</font>
<font color="black"> 837.                                 else:</font>
<font color="red"> 838.                                     return None, None</font>
<font color="black"> 839. </font>
<font color="green"> 840.                             i += 1</font>
<font color="black"> 841. </font>
<font color="green"> 842.                             if i &lt; len_l and l[i] == sep:</font>
<font color="black"> 843.                                 # We have three members</font>
<font color="green"> 844.                                 i += 1</font>
<font color="green"> 845.                                 value = info.month(l[i])</font>
<font color="black"> 846. </font>
<font color="green"> 847.                                 if value is not None:</font>
<font color="red"> 848.                                     ymd.append(value)</font>
<font color="red"> 849.                                     mstridx = len(ymd)-1</font>
<font color="red"> 850.                                     assert mstridx == -1</font>
<font color="black"> 851.                                 else:</font>
<font color="green"> 852.                                     ymd.append(l[i])</font>
<font color="black"> 853. </font>
<font color="green"> 854.                                 i += 1</font>
<font color="red"> 855.                     elif i &gt;= len_l or info.jump(l[i]):</font>
<font color="red"> 856.                         if i+1 &lt; len_l and info.ampm(l[i+1]) is not None:</font>
<font color="black"> 857.                             # 12 am</font>
<font color="red"> 858.                             res.hour = int(value)</font>
<font color="black"> 859. </font>
<font color="red"> 860.                             if res.hour &lt; 12 and info.ampm(l[i+1]) == 1:</font>
<font color="red"> 861.                                 res.hour += 12</font>
<font color="red"> 862.                             elif res.hour == 12 and info.ampm(l[i+1]) == 0:</font>
<font color="red"> 863.                                 res.hour = 0</font>
<font color="black"> 864. </font>
<font color="red"> 865.                             i += 1</font>
<font color="black"> 866.                         else:</font>
<font color="black"> 867.                             # Year, month or day</font>
<font color="red"> 868.                             ymd.append(value)</font>
<font color="red"> 869.                         i += 1</font>
<font color="red"> 870.                     elif info.ampm(l[i]) is not None:</font>
<font color="black"> 871. </font>
<font color="black"> 872.                         # 12am</font>
<font color="red"> 873.                         res.hour = int(value)</font>
<font color="black"> 874. </font>
<font color="red"> 875.                         if res.hour &lt; 12 and info.ampm(l[i]) == 1:</font>
<font color="red"> 876.                             res.hour += 12</font>
<font color="red"> 877.                         elif res.hour == 12 and info.ampm(l[i]) == 0:</font>
<font color="red"> 878.                             res.hour = 0</font>
<font color="red"> 879.                         i += 1</font>
<font color="black"> 880. </font>
<font color="red"> 881.                     elif not fuzzy:</font>
<font color="red"> 882.                         return None, None</font>
<font color="black"> 883.                     else:</font>
<font color="red"> 884.                         i += 1</font>
<font color="green"> 885.                     continue</font>
<font color="black"> 886. </font>
<font color="black"> 887.                 # Check weekday</font>
<font color="green"> 888.                 value = info.weekday(l[i])</font>
<font color="green"> 889.                 if value is not None:</font>
<font color="red"> 890.                     res.weekday = value</font>
<font color="red"> 891.                     i += 1</font>
<font color="red"> 892.                     continue</font>
<font color="black"> 893. </font>
<font color="black"> 894.                 # Check month name</font>
<font color="green"> 895.                 value = info.month(l[i])</font>
<font color="green"> 896.                 if value is not None:</font>
<font color="red"> 897.                     ymd.append(value)</font>
<font color="red"> 898.                     assert mstridx == -1</font>
<font color="red"> 899.                     mstridx = len(ymd)-1</font>
<font color="black"> 900. </font>
<font color="red"> 901.                     i += 1</font>
<font color="red"> 902.                     if i &lt; len_l:</font>
<font color="red"> 903.                         if l[i] in ('-', '/'):</font>
<font color="black"> 904.                             # Jan-01[-99]</font>
<font color="red"> 905.                             sep = l[i]</font>
<font color="red"> 906.                             i += 1</font>
<font color="red"> 907.                             ymd.append(l[i])</font>
<font color="red"> 908.                             i += 1</font>
<font color="black"> 909. </font>
<font color="red"> 910.                             if i &lt; len_l and l[i] == sep:</font>
<font color="black"> 911.                                 # Jan-01-99</font>
<font color="red"> 912.                                 i += 1</font>
<font color="red"> 913.                                 ymd.append(l[i])</font>
<font color="red"> 914.                                 i += 1</font>
<font color="black"> 915. </font>
<font color="red"> 916.                         elif (i+3 &lt; len_l and l[i] == l[i+2] == ' '</font>
<font color="red"> 917.                               and info.pertain(l[i+1])):</font>
<font color="black"> 918.                             # Jan of 01</font>
<font color="black"> 919.                             # In this case, 01 is clearly year</font>
<font color="red"> 920.                             try:</font>
<font color="red"> 921.                                 value = int(l[i+3])</font>
<font color="red"> 922.                             except ValueError:</font>
<font color="black"> 923.                                 # Wrong guess</font>
<font color="red"> 924.                                 pass</font>
<font color="black"> 925.                             else:</font>
<font color="black"> 926.                                 # Convert it here to become unambiguous</font>
<font color="red"> 927.                                 ymd.append(str(info.convertyear(value)))</font>
<font color="red"> 928.                             i += 4</font>
<font color="red"> 929.                     continue</font>
<font color="black"> 930. </font>
<font color="black"> 931.                 # Check am/pm</font>
<font color="green"> 932.                 value = info.ampm(l[i])</font>
<font color="green"> 933.                 if value is not None:</font>
<font color="black"> 934.                     # For fuzzy parsing, 'a' or 'am' (both valid English words)</font>
<font color="black"> 935.                     # may erroneously trigger the AM/PM flag. Deal with that</font>
<font color="black"> 936.                     # here.</font>
<font color="red"> 937.                     val_is_ampm = True</font>
<font color="black"> 938. </font>
<font color="black"> 939.                     # If there's already an AM/PM flag, this one isn't one.</font>
<font color="red"> 940.                     if fuzzy and res.ampm is not None:</font>
<font color="red"> 941.                         val_is_ampm = False</font>
<font color="black"> 942. </font>
<font color="black"> 943.                     # If AM/PM is found and hour is not, raise a ValueError</font>
<font color="red"> 944.                     if res.hour is None:</font>
<font color="red"> 945.                         if fuzzy:</font>
<font color="red"> 946.                             val_is_ampm = False</font>
<font color="black"> 947.                         else:</font>
<font color="red"> 948.                             raise ValueError('No hour specified with ' +</font>
<font color="red"> 949.                                              'AM or PM flag.')</font>
<font color="red"> 950.                     elif not 0 &lt;= res.hour &lt;= 12:</font>
<font color="black"> 951.                         # If AM/PM is found, it's a 12 hour clock, so raise</font>
<font color="black"> 952.                         # an error for invalid range</font>
<font color="red"> 953.                         if fuzzy:</font>
<font color="red"> 954.                             val_is_ampm = False</font>
<font color="black"> 955.                         else:</font>
<font color="red"> 956.                             raise ValueError('Invalid hour specified for ' +</font>
<font color="red"> 957.                                              '12-hour clock.')</font>
<font color="black"> 958. </font>
<font color="red"> 959.                     if val_is_ampm:</font>
<font color="red"> 960.                         if value == 1 and res.hour &lt; 12:</font>
<font color="red"> 961.                             res.hour += 12</font>
<font color="red"> 962.                         elif value == 0 and res.hour == 12:</font>
<font color="red"> 963.                             res.hour = 0</font>
<font color="black"> 964. </font>
<font color="red"> 965.                         res.ampm = value</font>
<font color="black"> 966. </font>
<font color="red"> 967.                     i += 1</font>
<font color="red"> 968.                     continue</font>
<font color="black"> 969. </font>
<font color="black"> 970.                 # Check for a timezone name</font>
<font color="green"> 971.                 if (res.hour is not None and len(l[i]) &lt;= 5 and</font>
<font color="green"> 972.                         res.tzname is None and res.tzoffset is None and</font>
<font color="green"> 973.                         not [x for x in l[i] if x not in</font>
<font color="green"> 974.                              string.ascii_uppercase]):</font>
<font color="green"> 975.                     res.tzname = l[i]</font>
<font color="green"> 976.                     res.tzoffset = info.tzoffset(res.tzname)</font>
<font color="green"> 977.                     i += 1</font>
<font color="black"> 978. </font>
<font color="black"> 979.                     # Check for something like GMT+3, or BRST+3. Notice</font>
<font color="black"> 980.                     # that it doesn't mean &quot;I am 3 hours after GMT&quot;, but</font>
<font color="black"> 981.                     # &quot;my time +3 is GMT&quot;. If found, we reverse the</font>
<font color="black"> 982.                     # logic so that timezone parsing code will get it</font>
<font color="black"> 983.                     # right.</font>
<font color="green"> 984.                     if i &lt; len_l and l[i] in ('+', '-'):</font>
<font color="red"> 985.                         l[i] = ('+', '-')[l[i] == '+']</font>
<font color="red"> 986.                         res.tzoffset = None</font>
<font color="red"> 987.                         if info.utczone(res.tzname):</font>
<font color="black"> 988.                             # With something like GMT+3, the timezone</font>
<font color="black"> 989.                             # is *not* GMT.</font>
<font color="red"> 990.                             res.tzname = None</font>
<font color="black"> 991. </font>
<font color="red"> 992.                     continue</font>
<font color="black"> 993. </font>
<font color="black"> 994.                 # Check for a numbered timezone</font>
<font color="green"> 995.                 if res.hour is not None and l[i] in ('+', '-'):</font>
<font color="red"> 996.                     signal = (-1, 1)[l[i] == '+']</font>
<font color="red"> 997.                     i += 1</font>
<font color="red"> 998.                     len_li = len(l[i])</font>
<font color="black"> 999. </font>
<font color="red">1000.                     if len_li == 4:</font>
<font color="black">1001.                         # -0300</font>
<font color="red">1002.                         res.tzoffset = int(l[i][:2])*3600+int(l[i][2:])*60</font>
<font color="red">1003.                     elif i+1 &lt; len_l and l[i+1] == ':':</font>
<font color="black">1004.                         # -03:00</font>
<font color="red">1005.                         res.tzoffset = int(l[i])*3600+int(l[i+2])*60</font>
<font color="red">1006.                         i += 2</font>
<font color="red">1007.                     elif len_li &lt;= 2:</font>
<font color="black">1008.                         # -[0]3</font>
<font color="red">1009.                         res.tzoffset = int(l[i][:2])*3600</font>
<font color="black">1010.                     else:</font>
<font color="red">1011.                         return None, None</font>
<font color="red">1012.                     i += 1</font>
<font color="black">1013. </font>
<font color="red">1014.                     res.tzoffset *= signal</font>
<font color="black">1015. </font>
<font color="black">1016.                     # Look for a timezone name between parenthesis</font>
<font color="red">1017.                     if (i+3 &lt; len_l and</font>
<font color="red">1018.                         info.jump(l[i]) and l[i+1] == '(' and l[i+3] == ')' and</font>
<font color="red">1019.                         3 &lt;= len(l[i+2]) &lt;= 5 and</font>
<font color="red">1020.                         not [x for x in l[i+2]</font>
<font color="red">1021.                              if x not in string.ascii_uppercase]):</font>
<font color="black">1022.                         # -0300 (BRST)</font>
<font color="red">1023.                         res.tzname = l[i+2]</font>
<font color="red">1024.                         i += 4</font>
<font color="red">1025.                     continue</font>
<font color="black">1026. </font>
<font color="black">1027.                 # Check jumps</font>
<font color="green">1028.                 if not (info.jump(l[i]) or fuzzy):</font>
<font color="red">1029.                     return None, None</font>
<font color="black">1030. </font>
<font color="green">1031.                 if last_skipped_token_i == i - 1:</font>
<font color="black">1032.                     # recombine the tokens</font>
<font color="red">1033.                     skipped_tokens[-1] += l[i]</font>
<font color="black">1034.                 else:</font>
<font color="black">1035.                     # just append</font>
<font color="green">1036.                     skipped_tokens.append(l[i])</font>
<font color="green">1037.                 last_skipped_token_i = i</font>
<font color="green">1038.                 i += 1</font>
<font color="black">1039. </font>
<font color="black">1040.             # Process year/month/day</font>
<font color="green">1041.             year, month, day = ymd.resolve_ymd(mstridx, yearfirst, dayfirst)</font>
<font color="green">1042.             if year is not None:</font>
<font color="green">1043.                 res.year = year</font>
<font color="green">1044.                 res.century_specified = ymd.century_specified</font>
<font color="black">1045. </font>
<font color="green">1046.             if month is not None:</font>
<font color="green">1047.                 res.month = month</font>
<font color="black">1048. </font>
<font color="green">1049.             if day is not None:</font>
<font color="green">1050.                 res.day = day</font>
<font color="black">1051. </font>
<font color="red">1052.         except (IndexError, ValueError, AssertionError):</font>
<font color="red">1053.             return None, None</font>
<font color="black">1054. </font>
<font color="green">1055.         if not info.validate(res):</font>
<font color="red">1056.             return None, None</font>
<font color="black">1057. </font>
<font color="green">1058.         if fuzzy_with_tokens:</font>
<font color="red">1059.             return res, tuple(skipped_tokens)</font>
<font color="black">1060.         else:</font>
<font color="green">1061.             return res, None</font>
<font color="black">1062. </font>
<font color="green">1063. DEFAULTPARSER = parser()</font>
<font color="black">1064. </font>
<font color="black">1065. </font>
<font color="green">1066. def parse(timestr, parserinfo=None, **kwargs):</font>
<font color="black">1067.     &quot;&quot;&quot;</font>
<font color="black">1068. </font>
<font color="black">1069.     Parse a string in one of the supported formats, using the</font>
<font color="black">1070.     ``parserinfo`` parameters.</font>
<font color="black">1071. </font>
<font color="black">1072.     :param timestr:</font>
<font color="black">1073.         A string containing a date/time stamp.</font>
<font color="black">1074. </font>
<font color="black">1075.     :param parserinfo:</font>
<font color="black">1076.         A :class:`parserinfo` object containing parameters for the parser.</font>
<font color="black">1077.         If ``None``, the default arguments to the :class:`parserinfo`</font>
<font color="black">1078.         constructor are used.</font>
<font color="black">1079. </font>
<font color="black">1080.     The ``**kwargs`` parameter takes the following keyword arguments:</font>
<font color="black">1081. </font>
<font color="black">1082.     :param default:</font>
<font color="black">1083.         The default datetime object, if this is a datetime object and not</font>
<font color="black">1084.         ``None``, elements specified in ``timestr`` replace elements in the</font>
<font color="black">1085.         default object.</font>
<font color="black">1086. </font>
<font color="black">1087.     :param ignoretz:</font>
<font color="black">1088.         If set ``True``, time zones in parsed strings are ignored and a naive</font>
<font color="black">1089.         :class:`datetime` object is returned.</font>
<font color="black">1090. </font>
<font color="black">1091.     :param tzinfos:</font>
<font color="black">1092.             Additional time zone names / aliases which may be present in the</font>
<font color="black">1093.             string. This argument maps time zone names (and optionally offsets</font>
<font color="black">1094.             from those time zones) to time zones. This parameter can be a</font>
<font color="black">1095.             dictionary with timezone aliases mapping time zone names to time</font>
<font color="black">1096.             zones or a function taking two parameters (``tzname`` and</font>
<font color="black">1097.             ``tzoffset``) and returning a time zone.</font>
<font color="black">1098. </font>
<font color="black">1099.             The timezones to which the names are mapped can be an integer</font>
<font color="black">1100.             offset from UTC in minutes or a :class:`tzinfo` object.</font>
<font color="black">1101. </font>
<font color="black">1102.             .. doctest::</font>
<font color="black">1103.                :options: +NORMALIZE_WHITESPACE</font>
<font color="black">1104. </font>
<font color="black">1105.                 &gt;&gt;&gt; from dateutil.parser import parse</font>
<font color="black">1106.                 &gt;&gt;&gt; from dateutil.tz import gettz</font>
<font color="black">1107.                 &gt;&gt;&gt; tzinfos = {&quot;BRST&quot;: -10800, &quot;CST&quot;: gettz(&quot;America/Chicago&quot;)}</font>
<font color="black">1108.                 &gt;&gt;&gt; parse(&quot;2012-01-19 17:21:00 BRST&quot;, tzinfos=tzinfos)</font>
<font color="black">1109.                 datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -10800))</font>
<font color="black">1110.                 &gt;&gt;&gt; parse(&quot;2012-01-19 17:21:00 CST&quot;, tzinfos=tzinfos)</font>
<font color="black">1111.                 datetime.datetime(2012, 1, 19, 17, 21,</font>
<font color="black">1112.                                   tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))</font>
<font color="black">1113. </font>
<font color="black">1114.             This parameter is ignored if ``ignoretz`` is set.</font>
<font color="black">1115. </font>
<font color="black">1116.     :param dayfirst:</font>
<font color="black">1117.         Whether to interpret the first value in an ambiguous 3-integer date</font>
<font color="black">1118.         (e.g. 01/05/09) as the day (``True``) or month (``False``). If</font>
<font color="black">1119.         ``yearfirst`` is set to ``True``, this distinguishes between YDM and</font>
<font color="black">1120.         YMD. If set to ``None``, this value is retrieved from the current</font>
<font color="black">1121.         :class:`parserinfo` object (which itself defaults to ``False``).</font>
<font color="black">1122. </font>
<font color="black">1123.     :param yearfirst:</font>
<font color="black">1124.         Whether to interpret the first value in an ambiguous 3-integer date</font>
<font color="black">1125.         (e.g. 01/05/09) as the year. If ``True``, the first number is taken to</font>
<font color="black">1126.         be the year, otherwise the last number is taken to be the year. If</font>
<font color="black">1127.         this is set to ``None``, the value is retrieved from the current</font>
<font color="black">1128.         :class:`parserinfo` object (which itself defaults to ``False``).</font>
<font color="black">1129. </font>
<font color="black">1130.     :param fuzzy:</font>
<font color="black">1131.         Whether to allow fuzzy parsing, allowing for string like &quot;Today is</font>
<font color="black">1132.         January 1, 2047 at 8:21:00AM&quot;.</font>
<font color="black">1133. </font>
<font color="black">1134.     :param fuzzy_with_tokens:</font>
<font color="black">1135.         If ``True``, ``fuzzy`` is automatically set to True, and the parser</font>
<font color="black">1136.         will return a tuple where the first element is the parsed</font>
<font color="black">1137.         :class:`datetime.datetime` datetimestamp and the second element is</font>
<font color="black">1138.         a tuple containing the portions of the string which were ignored:</font>
<font color="black">1139. </font>
<font color="black">1140.         .. doctest::</font>
<font color="black">1141. </font>
<font color="black">1142.             &gt;&gt;&gt; from dateutil.parser import parse</font>
<font color="black">1143.             &gt;&gt;&gt; parse(&quot;Today is January 1, 2047 at 8:21:00AM&quot;, fuzzy_with_tokens=True)</font>
<font color="black">1144.             (datetime.datetime(2011, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))</font>
<font color="black">1145. </font>
<font color="black">1146.     :return:</font>
<font color="black">1147.         Returns a :class:`datetime.datetime` object or, if the</font>
<font color="black">1148.         ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the</font>
<font color="black">1149.         first element being a :class:`datetime.datetime` object, the second</font>
<font color="black">1150.         a tuple containing the fuzzy tokens.</font>
<font color="black">1151. </font>
<font color="black">1152.     :raises ValueError:</font>
<font color="black">1153.         Raised for invalid or unknown string format, if the provided</font>
<font color="black">1154.         :class:`tzinfo` is not in a valid format, or if an invalid date</font>
<font color="black">1155.         would be created.</font>
<font color="black">1156. </font>
<font color="black">1157.     :raises OverflowError:</font>
<font color="black">1158.         Raised if the parsed date exceeds the largest valid C integer on</font>
<font color="black">1159.         your system.</font>
<font color="black">1160.     &quot;&quot;&quot;</font>
<font color="green">1161.     if parserinfo:</font>
<font color="red">1162.         return parser(parserinfo).parse(timestr, **kwargs)</font>
<font color="black">1163.     else:</font>
<font color="green">1164.         return DEFAULTPARSER.parse(timestr, **kwargs)</font>
<font color="black">1165. </font>
<font color="black">1166. </font>
<font color="green">1167. class _tzparser(object):</font>
<font color="black">1168. </font>
<font color="green">1169.     class _result(_resultbase):</font>
<font color="black">1170. </font>
<font color="green">1171.         __slots__ = [&quot;stdabbr&quot;, &quot;stdoffset&quot;, &quot;dstabbr&quot;, &quot;dstoffset&quot;,</font>
<font color="green">1172.                      &quot;start&quot;, &quot;end&quot;]</font>
<font color="black">1173. </font>
<font color="green">1174.         class _attr(_resultbase):</font>
<font color="green">1175.             __slots__ = [&quot;month&quot;, &quot;week&quot;, &quot;weekday&quot;,</font>
<font color="green">1176.                          &quot;yday&quot;, &quot;jyday&quot;, &quot;day&quot;, &quot;time&quot;]</font>
<font color="black">1177. </font>
<font color="green">1178.         def __repr__(self):</font>
<font color="red">1179.             return self._repr(&quot;&quot;)</font>
<font color="black">1180. </font>
<font color="green">1181.         def __init__(self):</font>
<font color="red">1182.             _resultbase.__init__(self)</font>
<font color="red">1183.             self.start = self._attr()</font>
<font color="red">1184.             self.end = self._attr()</font>
<font color="black">1185. </font>
<font color="green">1186.     def parse(self, tzstr):</font>
<font color="red">1187.         res = self._result()</font>
<font color="red">1188.         l = _timelex.split(tzstr)</font>
<font color="red">1189.         try:</font>
<font color="black">1190. </font>
<font color="red">1191.             len_l = len(l)</font>
<font color="black">1192. </font>
<font color="red">1193.             i = 0</font>
<font color="red">1194.             while i &lt; len_l:</font>
<font color="black">1195.                 # BRST+3[BRDT[+2]]</font>
<font color="red">1196.                 j = i</font>
<font color="red">1197.                 while j &lt; len_l and not [x for x in l[j]</font>
<font color="red">1198.                                          if x in &quot;0123456789:,-+&quot;]:</font>
<font color="red">1199.                     j += 1</font>
<font color="red">1200.                 if j != i:</font>
<font color="red">1201.                     if not res.stdabbr:</font>
<font color="red">1202.                         offattr = &quot;stdoffset&quot;</font>
<font color="red">1203.                         res.stdabbr = &quot;&quot;.join(l[i:j])</font>
<font color="black">1204.                     else:</font>
<font color="red">1205.                         offattr = &quot;dstoffset&quot;</font>
<font color="red">1206.                         res.dstabbr = &quot;&quot;.join(l[i:j])</font>
<font color="red">1207.                     i = j</font>
<font color="red">1208.                     if (i &lt; len_l and (l[i] in ('+', '-') or l[i][0] in</font>
<font color="red">1209.                                        &quot;0123456789&quot;)):</font>
<font color="red">1210.                         if l[i] in ('+', '-'):</font>
<font color="black">1211.                             # Yes, that's right.  See the TZ variable</font>
<font color="black">1212.                             # documentation.</font>
<font color="red">1213.                             signal = (1, -1)[l[i] == '+']</font>
<font color="red">1214.                             i += 1</font>
<font color="black">1215.                         else:</font>
<font color="red">1216.                             signal = -1</font>
<font color="red">1217.                         len_li = len(l[i])</font>
<font color="red">1218.                         if len_li == 4:</font>
<font color="black">1219.                             # -0300</font>
<font color="red">1220.                             setattr(res, offattr, (int(l[i][:2])*3600 +</font>
<font color="red">1221.                                                    int(l[i][2:])*60)*signal)</font>
<font color="red">1222.                         elif i+1 &lt; len_l and l[i+1] == ':':</font>
<font color="black">1223.                             # -03:00</font>
<font color="red">1224.                             setattr(res, offattr,</font>
<font color="red">1225.                                     (int(l[i])*3600+int(l[i+2])*60)*signal)</font>
<font color="red">1226.                             i += 2</font>
<font color="red">1227.                         elif len_li &lt;= 2:</font>
<font color="black">1228.                             # -[0]3</font>
<font color="red">1229.                             setattr(res, offattr,</font>
<font color="red">1230.                                     int(l[i][:2])*3600*signal)</font>
<font color="black">1231.                         else:</font>
<font color="red">1232.                             return None</font>
<font color="red">1233.                         i += 1</font>
<font color="red">1234.                     if res.dstabbr:</font>
<font color="red">1235.                         break</font>
<font color="black">1236.                 else:</font>
<font color="red">1237.                     break</font>
<font color="black">1238. </font>
<font color="red">1239.             if i &lt; len_l:</font>
<font color="red">1240.                 for j in range(i, len_l):</font>
<font color="red">1241.                     if l[j] == ';':</font>
<font color="red">1242.                         l[j] = ','</font>
<font color="black">1243. </font>
<font color="red">1244.                 assert l[i] == ','</font>
<font color="black">1245. </font>
<font color="red">1246.                 i += 1</font>
<font color="black">1247. </font>
<font color="red">1248.             if i &gt;= len_l:</font>
<font color="red">1249.                 pass</font>
<font color="red">1250.             elif (8 &lt;= l.count(',') &lt;= 9 and</font>
<font color="red">1251.                   not [y for x in l[i:] if x != ','</font>
<font color="red">1252.                        for y in x if y not in &quot;0123456789&quot;]):</font>
<font color="black">1253.                 # GMT0BST,3,0,30,3600,10,0,26,7200[,3600]</font>
<font color="red">1254.                 for x in (res.start, res.end):</font>
<font color="red">1255.                     x.month = int(l[i])</font>
<font color="red">1256.                     i += 2</font>
<font color="red">1257.                     if l[i] == '-':</font>
<font color="red">1258.                         value = int(l[i+1])*-1</font>
<font color="red">1259.                         i += 1</font>
<font color="black">1260.                     else:</font>
<font color="red">1261.                         value = int(l[i])</font>
<font color="red">1262.                     i += 2</font>
<font color="red">1263.                     if value:</font>
<font color="red">1264.                         x.week = value</font>
<font color="red">1265.                         x.weekday = (int(l[i])-1) % 7</font>
<font color="black">1266.                     else:</font>
<font color="red">1267.                         x.day = int(l[i])</font>
<font color="red">1268.                     i += 2</font>
<font color="red">1269.                     x.time = int(l[i])</font>
<font color="red">1270.                     i += 2</font>
<font color="red">1271.                 if i &lt; len_l:</font>
<font color="red">1272.                     if l[i] in ('-', '+'):</font>
<font color="red">1273.                         signal = (-1, 1)[l[i] == &quot;+&quot;]</font>
<font color="red">1274.                         i += 1</font>
<font color="black">1275.                     else:</font>
<font color="red">1276.                         signal = 1</font>
<font color="red">1277.                     res.dstoffset = (res.stdoffset+int(l[i]))*signal</font>
<font color="red">1278.             elif (l.count(',') == 2 and l[i:].count('/') &lt;= 2 and</font>
<font color="red">1279.                   not [y for x in l[i:] if x not in (',', '/', 'J', 'M',</font>
<font color="red">1280.                                                      '.', '-', ':')</font>
<font color="red">1281.                        for y in x if y not in &quot;0123456789&quot;]):</font>
<font color="red">1282.                 for x in (res.start, res.end):</font>
<font color="red">1283.                     if l[i] == 'J':</font>
<font color="black">1284.                         # non-leap year day (1 based)</font>
<font color="red">1285.                         i += 1</font>
<font color="red">1286.                         x.jyday = int(l[i])</font>
<font color="red">1287.                     elif l[i] == 'M':</font>
<font color="black">1288.                         # month[-.]week[-.]weekday</font>
<font color="red">1289.                         i += 1</font>
<font color="red">1290.                         x.month = int(l[i])</font>
<font color="red">1291.                         i += 1</font>
<font color="red">1292.                         assert l[i] in ('-', '.')</font>
<font color="red">1293.                         i += 1</font>
<font color="red">1294.                         x.week = int(l[i])</font>
<font color="red">1295.                         if x.week == 5:</font>
<font color="red">1296.                             x.week = -1</font>
<font color="red">1297.                         i += 1</font>
<font color="red">1298.                         assert l[i] in ('-', '.')</font>
<font color="red">1299.                         i += 1</font>
<font color="red">1300.                         x.weekday = (int(l[i])-1) % 7</font>
<font color="black">1301.                     else:</font>
<font color="black">1302.                         # year day (zero based)</font>
<font color="red">1303.                         x.yday = int(l[i])+1</font>
<font color="black">1304. </font>
<font color="red">1305.                     i += 1</font>
<font color="black">1306. </font>
<font color="red">1307.                     if i &lt; len_l and l[i] == '/':</font>
<font color="red">1308.                         i += 1</font>
<font color="black">1309.                         # start time</font>
<font color="red">1310.                         len_li = len(l[i])</font>
<font color="red">1311.                         if len_li == 4:</font>
<font color="black">1312.                             # -0300</font>
<font color="red">1313.                             x.time = (int(l[i][:2])*3600+int(l[i][2:])*60)</font>
<font color="red">1314.                         elif i+1 &lt; len_l and l[i+1] == ':':</font>
<font color="black">1315.                             # -03:00</font>
<font color="red">1316.                             x.time = int(l[i])*3600+int(l[i+2])*60</font>
<font color="red">1317.                             i += 2</font>
<font color="red">1318.                             if i+1 &lt; len_l and l[i+1] == ':':</font>
<font color="red">1319.                                 i += 2</font>
<font color="red">1320.                                 x.time += int(l[i])</font>
<font color="red">1321.                         elif len_li &lt;= 2:</font>
<font color="black">1322.                             # -[0]3</font>
<font color="red">1323.                             x.time = (int(l[i][:2])*3600)</font>
<font color="black">1324.                         else:</font>
<font color="red">1325.                             return None</font>
<font color="red">1326.                         i += 1</font>
<font color="black">1327. </font>
<font color="red">1328.                     assert i == len_l or l[i] == ','</font>
<font color="black">1329. </font>
<font color="red">1330.                     i += 1</font>
<font color="black">1331. </font>
<font color="red">1332.                 assert i &gt;= len_l</font>
<font color="black">1333. </font>
<font color="red">1334.         except (IndexError, ValueError, AssertionError):</font>
<font color="red">1335.             return None</font>
<font color="black">1336. </font>
<font color="red">1337.         return res</font>
<font color="black">1338. </font>
<font color="black">1339. </font>
<font color="green">1340. DEFAULTTZPARSER = _tzparser()</font>
<font color="black">1341. </font>
<font color="black">1342. </font>
<font color="green">1343. def _parsetz(tzstr):</font>
<font color="red">1344.     return DEFAULTTZPARSER.parse(tzstr)</font>
<font color="black">1345. </font>
<font color="black">1346. </font>
<font color="green">1347. def _parsems(value):</font>
<font color="black">1348.     &quot;&quot;&quot;Parse a I[.F] seconds value into (seconds, microseconds).&quot;&quot;&quot;</font>
<font color="green">1349.     if &quot;.&quot; not in value:</font>
<font color="red">1350.         return int(value), 0</font>
<font color="black">1351.     else:</font>
<font color="green">1352.         i, f = value.split(&quot;.&quot;)</font>
<font color="green">1353.         return int(i), int(f.ljust(6, &quot;0&quot;)[:6])</font>
<font color="black">1354. </font>
<font color="black">1355. </font>
<font color="black">1356. # vim:ts=4:sw=4:et</font>
</pre>

