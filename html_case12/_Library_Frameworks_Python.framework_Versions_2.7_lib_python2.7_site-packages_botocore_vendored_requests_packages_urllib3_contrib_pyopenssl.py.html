source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/packages/urllib3/contrib/pyopenssl.py</b><br>


file stats: <b>168 lines, 57 executed: 33.9% covered</b>
<pre>
<font color="black">   1. '''SSL with SNI_-support for Python 2. Follow these instructions if you would</font>
<font color="black">   2. like to verify SSL certificates in Python 2. Note, the default libraries do</font>
<font color="black">   3. *not* do certificate checking; you need to do additional work to validate</font>
<font color="black">   4. certificates yourself.</font>
<font color="black">   5. </font>
<font color="black">   6. This needs the following packages installed:</font>
<font color="black">   7. </font>
<font color="black">   8. * pyOpenSSL (tested with 0.13)</font>
<font color="black">   9. * ndg-httpsclient (tested with 0.3.2)</font>
<font color="black">  10. * pyasn1 (tested with 0.1.6)</font>
<font color="black">  11. </font>
<font color="black">  12. You can install them with the following command:</font>
<font color="black">  13. </font>
<font color="black">  14.     pip install pyopenssl ndg-httpsclient pyasn1</font>
<font color="black">  15. </font>
<font color="black">  16. To activate certificate checking, call</font>
<font color="black">  17. :func:`~urllib3.contrib.pyopenssl.inject_into_urllib3` from your Python code</font>
<font color="black">  18. before you begin making HTTP requests. This can be done in a ``sitecustomize``</font>
<font color="black">  19. module, or at any other time before your application begins using ``urllib3``,</font>
<font color="black">  20. like this::</font>
<font color="black">  21. </font>
<font color="black">  22.     try:</font>
<font color="black">  23.         import urllib3.contrib.pyopenssl</font>
<font color="black">  24.         urllib3.contrib.pyopenssl.inject_into_urllib3()</font>
<font color="black">  25.     except ImportError:</font>
<font color="black">  26.         pass</font>
<font color="black">  27. </font>
<font color="black">  28. Now you can use :mod:`urllib3` as you normally would, and it will support SNI</font>
<font color="black">  29. when the required modules are installed.</font>
<font color="black">  30. </font>
<font color="black">  31. Activating this module also has the positive side effect of disabling SSL/TLS</font>
<font color="black">  32. compression in Python 2 (see `CRIME attack`_).</font>
<font color="black">  33. </font>
<font color="black">  34. If you want to configure the default list of supported cipher suites, you can</font>
<font color="black">  35. set the ``urllib3.contrib.pyopenssl.DEFAULT_SSL_CIPHER_LIST`` variable.</font>
<font color="black">  36. </font>
<font color="black">  37. Module Variables</font>
<font color="black">  38. ----------------</font>
<font color="black">  39. </font>
<font color="black">  40. :var DEFAULT_SSL_CIPHER_LIST: The list of supported SSL/TLS cipher suites.</font>
<font color="black">  41. </font>
<font color="black">  42. .. _sni: https://en.wikipedia.org/wiki/Server_Name_Indication</font>
<font color="black">  43. .. _crime attack: https://en.wikipedia.org/wiki/CRIME_(security_exploit)</font>
<font color="black">  44. </font>
<font color="green">  45. '''</font>
<font color="black">  46. </font>
<font color="green">  47. try:</font>
<font color="green">  48.     from ndg.httpsclient.ssl_peer_verification import SUBJ_ALT_NAME_SUPPORT</font>
<font color="green">  49.     from ndg.httpsclient.subj_alt_name import SubjectAltName as BaseSubjectAltName</font>
<font color="red">  50. except SyntaxError as e:</font>
<font color="red">  51.     raise ImportError(e)</font>
<font color="black">  52. </font>
<font color="green">  53. import OpenSSL.SSL</font>
<font color="green">  54. from pyasn1.codec.der import decoder as der_decoder</font>
<font color="green">  55. from pyasn1.type import univ, constraint</font>
<font color="green">  56. from socket import _fileobject, timeout</font>
<font color="green">  57. import ssl</font>
<font color="green">  58. import select</font>
<font color="black">  59. </font>
<font color="green">  60. from .. import connection</font>
<font color="green">  61. from .. import util</font>
<font color="black">  62. </font>
<font color="green">  63. __all__ = ['inject_into_urllib3', 'extract_from_urllib3']</font>
<font color="black">  64. </font>
<font color="black">  65. # SNI only *really* works if we can read the subjectAltName of certificates.</font>
<font color="green">  66. HAS_SNI = SUBJ_ALT_NAME_SUPPORT</font>
<font color="black">  67. </font>
<font color="black">  68. # Map from urllib3 to PyOpenSSL compatible parameter-values.</font>
<font color="green">  69. _openssl_versions = {</font>
<font color="green">  70.     ssl.PROTOCOL_SSLv23: OpenSSL.SSL.SSLv23_METHOD,</font>
<font color="green">  71.     ssl.PROTOCOL_TLSv1: OpenSSL.SSL.TLSv1_METHOD,</font>
<font color="black">  72. }</font>
<font color="black">  73. </font>
<font color="green">  74. try:</font>
<font color="green">  75.     _openssl_versions.update({ssl.PROTOCOL_SSLv3: OpenSSL.SSL.SSLv3_METHOD})</font>
<font color="green">  76. except AttributeError:</font>
<font color="green">  77.     pass</font>
<font color="black">  78. </font>
<font color="green">  79. _openssl_verify = {</font>
<font color="green">  80.     ssl.CERT_NONE: OpenSSL.SSL.VERIFY_NONE,</font>
<font color="green">  81.     ssl.CERT_OPTIONAL: OpenSSL.SSL.VERIFY_PEER,</font>
<font color="green">  82.     ssl.CERT_REQUIRED: OpenSSL.SSL.VERIFY_PEER</font>
<font color="green">  83.                        + OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,</font>
<font color="black">  84. }</font>
<font color="black">  85. </font>
<font color="green">  86. DEFAULT_SSL_CIPHER_LIST = util.ssl_.DEFAULT_CIPHERS</font>
<font color="black">  87. </font>
<font color="black">  88. </font>
<font color="green">  89. orig_util_HAS_SNI = util.HAS_SNI</font>
<font color="green">  90. orig_connection_ssl_wrap_socket = connection.ssl_wrap_socket</font>
<font color="black">  91. </font>
<font color="black">  92. </font>
<font color="green">  93. def inject_into_urllib3():</font>
<font color="black">  94.     'Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.'</font>
<font color="black">  95. </font>
<font color="green">  96.     connection.ssl_wrap_socket = ssl_wrap_socket</font>
<font color="green">  97.     util.HAS_SNI = HAS_SNI</font>
<font color="black">  98. </font>
<font color="black">  99. </font>
<font color="green"> 100. def extract_from_urllib3():</font>
<font color="black"> 101.     'Undo monkey-patching by :func:`inject_into_urllib3`.'</font>
<font color="black"> 102. </font>
<font color="green"> 103.     connection.ssl_wrap_socket = orig_connection_ssl_wrap_socket</font>
<font color="green"> 104.     util.HAS_SNI = orig_util_HAS_SNI</font>
<font color="black"> 105. </font>
<font color="black"> 106. </font>
<font color="black"> 107. ### Note: This is a slightly bug-fixed version of same from ndg-httpsclient.</font>
<font color="green"> 108. class SubjectAltName(BaseSubjectAltName):</font>
<font color="green"> 109.     '''ASN.1 implementation for subjectAltNames support'''</font>
<font color="black"> 110. </font>
<font color="black"> 111.     # There is no limit to how many SAN certificates a certificate may have,</font>
<font color="black"> 112.     #   however this needs to have some limit so we'll set an arbitrarily high</font>
<font color="black"> 113.     #   limit.</font>
<font color="green"> 114.     sizeSpec = univ.SequenceOf.sizeSpec + \</font>
<font color="green"> 115.         constraint.ValueSizeConstraint(1, 1024)</font>
<font color="black"> 116. </font>
<font color="black"> 117. </font>
<font color="black"> 118. ### Note: This is a slightly bug-fixed version of same from ndg-httpsclient.</font>
<font color="green"> 119. def get_subj_alt_name(peer_cert):</font>
<font color="black"> 120.     # Search through extensions</font>
<font color="red"> 121.     dns_name = []</font>
<font color="red"> 122.     if not SUBJ_ALT_NAME_SUPPORT:</font>
<font color="red"> 123.         return dns_name</font>
<font color="black"> 124. </font>
<font color="red"> 125.     general_names = SubjectAltName()</font>
<font color="red"> 126.     for i in range(peer_cert.get_extension_count()):</font>
<font color="red"> 127.         ext = peer_cert.get_extension(i)</font>
<font color="red"> 128.         ext_name = ext.get_short_name()</font>
<font color="red"> 129.         if ext_name != 'subjectAltName':</font>
<font color="red"> 130.             continue</font>
<font color="black"> 131. </font>
<font color="black"> 132.         # PyOpenSSL returns extension data in ASN.1 encoded form</font>
<font color="red"> 133.         ext_dat = ext.get_data()</font>
<font color="red"> 134.         decoded_dat = der_decoder.decode(ext_dat,</font>
<font color="red"> 135.                                          asn1Spec=general_names)</font>
<font color="black"> 136. </font>
<font color="red"> 137.         for name in decoded_dat:</font>
<font color="red"> 138.             if not isinstance(name, SubjectAltName):</font>
<font color="red"> 139.                 continue</font>
<font color="red"> 140.             for entry in range(len(name)):</font>
<font color="red"> 141.                 component = name.getComponentByPosition(entry)</font>
<font color="red"> 142.                 if component.getName() != 'dNSName':</font>
<font color="red"> 143.                     continue</font>
<font color="red"> 144.                 dns_name.append(str(component.getComponent()))</font>
<font color="black"> 145. </font>
<font color="red"> 146.     return dns_name</font>
<font color="black"> 147. </font>
<font color="black"> 148. </font>
<font color="green"> 149. class WrappedSocket(object):</font>
<font color="black"> 150.     '''API-compatibility wrapper for Python OpenSSL's Connection-class.</font>
<font color="black"> 151. </font>
<font color="black"> 152.     Note: _makefile_refs, _drop() and _reuse() are needed for the garbage</font>
<font color="black"> 153.     collector of pypy.</font>
<font color="green"> 154.     '''</font>
<font color="black"> 155. </font>
<font color="green"> 156.     def __init__(self, connection, socket, suppress_ragged_eofs=True):</font>
<font color="red"> 157.         self.connection = connection</font>
<font color="red"> 158.         self.socket = socket</font>
<font color="red"> 159.         self.suppress_ragged_eofs = suppress_ragged_eofs</font>
<font color="red"> 160.         self._makefile_refs = 0</font>
<font color="black"> 161. </font>
<font color="green"> 162.     def fileno(self):</font>
<font color="red"> 163.         return self.socket.fileno()</font>
<font color="black"> 164. </font>
<font color="green"> 165.     def makefile(self, mode, bufsize=-1):</font>
<font color="red"> 166.         self._makefile_refs += 1</font>
<font color="red"> 167.         return _fileobject(self, mode, bufsize, close=True)</font>
<font color="black"> 168. </font>
<font color="green"> 169.     def recv(self, *args, **kwargs):</font>
<font color="red"> 170.         try:</font>
<font color="red"> 171.             data = self.connection.recv(*args, **kwargs)</font>
<font color="red"> 172.         except OpenSSL.SSL.SysCallError as e:</font>
<font color="red"> 173.             if self.suppress_ragged_eofs and e.args == (-1, 'Unexpected EOF'):</font>
<font color="red"> 174.                 return b''</font>
<font color="black"> 175.             else:</font>
<font color="red"> 176.                 raise</font>
<font color="red"> 177.         except OpenSSL.SSL.ZeroReturnError as e:</font>
<font color="red"> 178.             if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:</font>
<font color="red"> 179.                 return b''</font>
<font color="black"> 180.             else:</font>
<font color="red"> 181.                 raise</font>
<font color="red"> 182.         except OpenSSL.SSL.WantReadError:</font>
<font color="red"> 183.             rd, wd, ed = select.select(</font>
<font color="red"> 184.                 [self.socket], [], [], self.socket.gettimeout())</font>
<font color="red"> 185.             if not rd:</font>
<font color="red"> 186.                 raise timeout('The read operation timed out')</font>
<font color="black"> 187.             else:</font>
<font color="red"> 188.                 return self.recv(*args, **kwargs)</font>
<font color="black"> 189.         else:</font>
<font color="red"> 190.             return data</font>
<font color="black"> 191. </font>
<font color="green"> 192.     def settimeout(self, timeout):</font>
<font color="red"> 193.         return self.socket.settimeout(timeout)</font>
<font color="black"> 194. </font>
<font color="green"> 195.     def _send_until_done(self, data):</font>
<font color="red"> 196.         while True:</font>
<font color="red"> 197.             try:</font>
<font color="red"> 198.                 return self.connection.send(data)</font>
<font color="red"> 199.             except OpenSSL.SSL.WantWriteError:</font>
<font color="red"> 200.                 _, wlist, _ = select.select([], [self.socket], [],</font>
<font color="red"> 201.                                             self.socket.gettimeout())</font>
<font color="red"> 202.                 if not wlist:</font>
<font color="red"> 203.                     raise timeout()</font>
<font color="red"> 204.                 continue</font>
<font color="black"> 205. </font>
<font color="green"> 206.     def sendall(self, data):</font>
<font color="red"> 207.         while len(data):</font>
<font color="red"> 208.             sent = self._send_until_done(data)</font>
<font color="red"> 209.             data = data[sent:]</font>
<font color="black"> 210. </font>
<font color="green"> 211.     def close(self):</font>
<font color="red"> 212.         if self._makefile_refs &lt; 1:</font>
<font color="red"> 213.             return self.connection.shutdown()</font>
<font color="black"> 214.         else:</font>
<font color="red"> 215.             self._makefile_refs -= 1</font>
<font color="black"> 216. </font>
<font color="green"> 217.     def getpeercert(self, binary_form=False):</font>
<font color="red"> 218.         x509 = self.connection.get_peer_certificate()</font>
<font color="black"> 219. </font>
<font color="red"> 220.         if not x509:</font>
<font color="red"> 221.             return x509</font>
<font color="black"> 222. </font>
<font color="red"> 223.         if binary_form:</font>
<font color="red"> 224.             return OpenSSL.crypto.dump_certificate(</font>
<font color="red"> 225.                 OpenSSL.crypto.FILETYPE_ASN1,</font>
<font color="red"> 226.                 x509)</font>
<font color="black"> 227. </font>
<font color="red"> 228.         return {</font>
<font color="black"> 229.             'subject': (</font>
<font color="red"> 230.                 (('commonName', x509.get_subject().CN),),</font>
<font color="black"> 231.             ),</font>
<font color="black"> 232.             'subjectAltName': [</font>
<font color="red"> 233.                 ('DNS', value)</font>
<font color="red"> 234.                 for value in get_subj_alt_name(x509)</font>
<font color="black"> 235.             ]</font>
<font color="black"> 236.         }</font>
<font color="black"> 237. </font>
<font color="green"> 238.     def _reuse(self):</font>
<font color="red"> 239.         self._makefile_refs += 1</font>
<font color="black"> 240. </font>
<font color="green"> 241.     def _drop(self):</font>
<font color="red"> 242.         if self._makefile_refs &lt; 1:</font>
<font color="red"> 243.             self.close()</font>
<font color="black"> 244.         else:</font>
<font color="red"> 245.             self._makefile_refs -= 1</font>
<font color="black"> 246. </font>
<font color="black"> 247. </font>
<font color="green"> 248. def _verify_callback(cnx, x509, err_no, err_depth, return_code):</font>
<font color="red"> 249.     return err_no == 0</font>
<font color="black"> 250. </font>
<font color="black"> 251. </font>
<font color="green"> 252. def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,</font>
<font color="green"> 253.                     ca_certs=None, server_hostname=None,</font>
<font color="green"> 254.                     ssl_version=None):</font>
<font color="red"> 255.     ctx = OpenSSL.SSL.Context(_openssl_versions[ssl_version])</font>
<font color="red"> 256.     if certfile:</font>
<font color="red"> 257.         keyfile = keyfile or certfile  # Match behaviour of the normal python ssl library</font>
<font color="red"> 258.         ctx.use_certificate_file(certfile)</font>
<font color="red"> 259.     if keyfile:</font>
<font color="red"> 260.         ctx.use_privatekey_file(keyfile)</font>
<font color="red"> 261.     if cert_reqs != ssl.CERT_NONE:</font>
<font color="red"> 262.         ctx.set_verify(_openssl_verify[cert_reqs], _verify_callback)</font>
<font color="red"> 263.     if ca_certs:</font>
<font color="red"> 264.         try:</font>
<font color="red"> 265.             ctx.load_verify_locations(ca_certs, None)</font>
<font color="red"> 266.         except OpenSSL.SSL.Error as e:</font>
<font color="red"> 267.             raise ssl.SSLError('bad ca_certs: %r' % ca_certs, e)</font>
<font color="black"> 268.     else:</font>
<font color="red"> 269.         ctx.set_default_verify_paths()</font>
<font color="black"> 270. </font>
<font color="black"> 271.     # Disable TLS compression to migitate CRIME attack (issue #309)</font>
<font color="red"> 272.     OP_NO_COMPRESSION = 0x20000</font>
<font color="red"> 273.     ctx.set_options(OP_NO_COMPRESSION)</font>
<font color="black"> 274. </font>
<font color="black"> 275.     # Set list of supported ciphersuites.</font>
<font color="red"> 276.     ctx.set_cipher_list(DEFAULT_SSL_CIPHER_LIST)</font>
<font color="black"> 277. </font>
<font color="red"> 278.     cnx = OpenSSL.SSL.Connection(ctx, sock)</font>
<font color="red"> 279.     cnx.set_tlsext_host_name(server_hostname)</font>
<font color="red"> 280.     cnx.set_connect_state()</font>
<font color="red"> 281.     while True:</font>
<font color="red"> 282.         try:</font>
<font color="red"> 283.             cnx.do_handshake()</font>
<font color="red"> 284.         except OpenSSL.SSL.WantReadError:</font>
<font color="red"> 285.             rd, _, _ = select.select([sock], [], [], sock.gettimeout())</font>
<font color="red"> 286.             if not rd:</font>
<font color="red"> 287.                 raise timeout('select timed out')</font>
<font color="red"> 288.             continue</font>
<font color="red"> 289.         except OpenSSL.SSL.Error as e:</font>
<font color="red"> 290.             raise ssl.SSLError('bad handshake', e)</font>
<font color="red"> 291.         break</font>
<font color="black"> 292. </font>
<font color="red"> 293.     return WrappedSocket(cnx, sock)</font>
</pre>

