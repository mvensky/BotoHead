source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/simplejson/__init__.py</b><br>


file stats: <b>178 lines, 59 executed: 33.1% covered</b>
<pre>
<font color="black">   1. r&quot;&quot;&quot;JSON (JavaScript Object Notation) &lt;http://json.org&gt; is a subset of</font>
<font color="black">   2. JavaScript syntax (ECMA-262 3rd edition) used as a lightweight data</font>
<font color="black">   3. interchange format.</font>
<font color="black">   4. </font>
<font color="black">   5. :mod:`simplejson` exposes an API familiar to users of the standard library</font>
<font color="black">   6. :mod:`marshal` and :mod:`pickle` modules. It is the externally maintained</font>
<font color="black">   7. version of the :mod:`json` library contained in Python 2.6, but maintains</font>
<font color="black">   8. compatibility back to Python 2.5 and (currently) has significant performance</font>
<font color="black">   9. advantages, even without using the optional C extension for speedups.</font>
<font color="black">  10. </font>
<font color="black">  11. Encoding basic Python object hierarchies::</font>
<font color="black">  12. </font>
<font color="black">  13.     &gt;&gt;&gt; import simplejson as json</font>
<font color="black">  14.     &gt;&gt;&gt; json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])</font>
<font color="black">  15.     '[&quot;foo&quot;, {&quot;bar&quot;: [&quot;baz&quot;, null, 1.0, 2]}]'</font>
<font color="black">  16.     &gt;&gt;&gt; print(json.dumps(&quot;\&quot;foo\bar&quot;))</font>
<font color="black">  17.     &quot;\&quot;foo\bar&quot;</font>
<font color="black">  18.     &gt;&gt;&gt; print(json.dumps(u'\u1234'))</font>
<font color="black">  19.     &quot;\u1234&quot;</font>
<font color="black">  20.     &gt;&gt;&gt; print(json.dumps('\\'))</font>
<font color="black">  21.     &quot;\\&quot;</font>
<font color="black">  22.     &gt;&gt;&gt; print(json.dumps({&quot;c&quot;: 0, &quot;b&quot;: 0, &quot;a&quot;: 0}, sort_keys=True))</font>
<font color="black">  23.     {&quot;a&quot;: 0, &quot;b&quot;: 0, &quot;c&quot;: 0}</font>
<font color="black">  24.     &gt;&gt;&gt; from simplejson.compat import StringIO</font>
<font color="black">  25.     &gt;&gt;&gt; io = StringIO()</font>
<font color="black">  26.     &gt;&gt;&gt; json.dump(['streaming API'], io)</font>
<font color="black">  27.     &gt;&gt;&gt; io.getvalue()</font>
<font color="black">  28.     '[&quot;streaming API&quot;]'</font>
<font color="black">  29. </font>
<font color="black">  30. Compact encoding::</font>
<font color="black">  31. </font>
<font color="black">  32.     &gt;&gt;&gt; import simplejson as json</font>
<font color="black">  33.     &gt;&gt;&gt; obj = [1,2,3,{'4': 5, '6': 7}]</font>
<font color="black">  34.     &gt;&gt;&gt; json.dumps(obj, separators=(',',':'), sort_keys=True)</font>
<font color="black">  35.     '[1,2,3,{&quot;4&quot;:5,&quot;6&quot;:7}]'</font>
<font color="black">  36. </font>
<font color="black">  37. Pretty printing::</font>
<font color="black">  38. </font>
<font color="black">  39.     &gt;&gt;&gt; import simplejson as json</font>
<font color="black">  40.     &gt;&gt;&gt; print(json.dumps({'4': 5, '6': 7}, sort_keys=True, indent='    '))</font>
<font color="black">  41.     {</font>
<font color="black">  42.         &quot;4&quot;: 5,</font>
<font color="black">  43.         &quot;6&quot;: 7</font>
<font color="black">  44.     }</font>
<font color="black">  45. </font>
<font color="black">  46. Decoding JSON::</font>
<font color="black">  47. </font>
<font color="black">  48.     &gt;&gt;&gt; import simplejson as json</font>
<font color="black">  49.     &gt;&gt;&gt; obj = [u'foo', {u'bar': [u'baz', None, 1.0, 2]}]</font>
<font color="black">  50.     &gt;&gt;&gt; json.loads('[&quot;foo&quot;, {&quot;bar&quot;:[&quot;baz&quot;, null, 1.0, 2]}]') == obj</font>
<font color="black">  51.     True</font>
<font color="black">  52.     &gt;&gt;&gt; json.loads('&quot;\\&quot;foo\\bar&quot;') == u'&quot;foo\x08ar'</font>
<font color="black">  53.     True</font>
<font color="black">  54.     &gt;&gt;&gt; from simplejson.compat import StringIO</font>
<font color="black">  55.     &gt;&gt;&gt; io = StringIO('[&quot;streaming API&quot;]')</font>
<font color="black">  56.     &gt;&gt;&gt; json.load(io)[0] == 'streaming API'</font>
<font color="black">  57.     True</font>
<font color="black">  58. </font>
<font color="black">  59. Specializing JSON object decoding::</font>
<font color="black">  60. </font>
<font color="black">  61.     &gt;&gt;&gt; import simplejson as json</font>
<font color="black">  62.     &gt;&gt;&gt; def as_complex(dct):</font>
<font color="black">  63.     ...     if '__complex__' in dct:</font>
<font color="black">  64.     ...         return complex(dct['real'], dct['imag'])</font>
<font color="black">  65.     ...     return dct</font>
<font color="black">  66.     ...</font>
<font color="black">  67.     &gt;&gt;&gt; json.loads('{&quot;__complex__&quot;: true, &quot;real&quot;: 1, &quot;imag&quot;: 2}',</font>
<font color="black">  68.     ...     object_hook=as_complex)</font>
<font color="black">  69.     (1+2j)</font>
<font color="black">  70.     &gt;&gt;&gt; from decimal import Decimal</font>
<font color="black">  71.     &gt;&gt;&gt; json.loads('1.1', parse_float=Decimal) == Decimal('1.1')</font>
<font color="black">  72.     True</font>
<font color="black">  73. </font>
<font color="black">  74. Specializing JSON object encoding::</font>
<font color="black">  75. </font>
<font color="black">  76.     &gt;&gt;&gt; import simplejson as json</font>
<font color="black">  77.     &gt;&gt;&gt; def encode_complex(obj):</font>
<font color="black">  78.     ...     if isinstance(obj, complex):</font>
<font color="black">  79.     ...         return [obj.real, obj.imag]</font>
<font color="black">  80.     ...     raise TypeError(repr(o) + &quot; is not JSON serializable&quot;)</font>
<font color="black">  81.     ...</font>
<font color="black">  82.     &gt;&gt;&gt; json.dumps(2 + 1j, default=encode_complex)</font>
<font color="black">  83.     '[2.0, 1.0]'</font>
<font color="black">  84.     &gt;&gt;&gt; json.JSONEncoder(default=encode_complex).encode(2 + 1j)</font>
<font color="black">  85.     '[2.0, 1.0]'</font>
<font color="black">  86.     &gt;&gt;&gt; ''.join(json.JSONEncoder(default=encode_complex).iterencode(2 + 1j))</font>
<font color="black">  87.     '[2.0, 1.0]'</font>
<font color="black">  88. </font>
<font color="black">  89. </font>
<font color="black">  90. Using simplejson.tool from the shell to validate and pretty-print::</font>
<font color="black">  91. </font>
<font color="black">  92.     $ echo '{&quot;json&quot;:&quot;obj&quot;}' | python -m simplejson.tool</font>
<font color="black">  93.     {</font>
<font color="black">  94.         &quot;json&quot;: &quot;obj&quot;</font>
<font color="black">  95.     }</font>
<font color="black">  96.     $ echo '{ 1.2:3.4}' | python -m simplejson.tool</font>
<font color="black">  97.     Expecting property name: line 1 column 3 (char 2)</font>
<font color="green">  98. &quot;&quot;&quot;</font>
<font color="green">  99. from __future__ import absolute_import</font>
<font color="green"> 100. __version__ = '3.10.0'</font>
<font color="black"> 101. __all__ = [</font>
<font color="green"> 102.     'dump', 'dumps', 'load', 'loads',</font>
<font color="green"> 103.     'JSONDecoder', 'JSONDecodeError', 'JSONEncoder',</font>
<font color="green"> 104.     'OrderedDict', 'simple_first',</font>
<font color="black"> 105. ]</font>
<font color="black"> 106. </font>
<font color="green"> 107. __author__ = 'Bob Ippolito &lt;bob@redivi.com&gt;'</font>
<font color="black"> 108. </font>
<font color="green"> 109. from decimal import Decimal</font>
<font color="black"> 110. </font>
<font color="green"> 111. from .scanner import JSONDecodeError</font>
<font color="green"> 112. from .decoder import JSONDecoder</font>
<font color="green"> 113. from .encoder import JSONEncoder, JSONEncoderForHTML, RawJSON</font>
<font color="green"> 114. def _import_OrderedDict():</font>
<font color="green"> 115.     import collections</font>
<font color="green"> 116.     try:</font>
<font color="green"> 117.         return collections.OrderedDict</font>
<font color="red"> 118.     except AttributeError:</font>
<font color="red"> 119.         from . import ordered_dict</font>
<font color="red"> 120.         return ordered_dict.OrderedDict</font>
<font color="green"> 121. OrderedDict = _import_OrderedDict()</font>
<font color="black"> 122. </font>
<font color="green"> 123. def _import_c_make_encoder():</font>
<font color="red"> 124.     try:</font>
<font color="red"> 125.         from ._speedups import make_encoder</font>
<font color="red"> 126.         return make_encoder</font>
<font color="red"> 127.     except ImportError:</font>
<font color="red"> 128.         return None</font>
<font color="black"> 129. </font>
<font color="green"> 130. _default_encoder = JSONEncoder(</font>
<font color="green"> 131.     skipkeys=False,</font>
<font color="green"> 132.     ensure_ascii=True,</font>
<font color="green"> 133.     check_circular=True,</font>
<font color="green"> 134.     allow_nan=True,</font>
<font color="green"> 135.     indent=None,</font>
<font color="green"> 136.     separators=None,</font>
<font color="green"> 137.     encoding='utf-8',</font>
<font color="green"> 138.     default=None,</font>
<font color="green"> 139.     use_decimal=True,</font>
<font color="green"> 140.     namedtuple_as_object=True,</font>
<font color="green"> 141.     tuple_as_array=True,</font>
<font color="green"> 142.     iterable_as_array=False,</font>
<font color="green"> 143.     bigint_as_string=False,</font>
<font color="green"> 144.     item_sort_key=None,</font>
<font color="green"> 145.     for_json=False,</font>
<font color="green"> 146.     ignore_nan=False,</font>
<font color="green"> 147.     int_as_string_bitcount=None,</font>
<font color="black"> 148. )</font>
<font color="black"> 149. </font>
<font color="green"> 150. def dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True,</font>
<font color="green"> 151.          allow_nan=True, cls=None, indent=None, separators=None,</font>
<font color="green"> 152.          encoding='utf-8', default=None, use_decimal=True,</font>
<font color="green"> 153.          namedtuple_as_object=True, tuple_as_array=True,</font>
<font color="green"> 154.          bigint_as_string=False, sort_keys=False, item_sort_key=None,</font>
<font color="green"> 155.          for_json=False, ignore_nan=False, int_as_string_bitcount=None,</font>
<font color="green"> 156.          iterable_as_array=False, **kw):</font>
<font color="black"> 157.     &quot;&quot;&quot;Serialize ``obj`` as a JSON formatted stream to ``fp`` (a</font>
<font color="black"> 158.     ``.write()``-supporting file-like object).</font>
<font color="black"> 159. </font>
<font color="black"> 160.     If *skipkeys* is true then ``dict`` keys that are not basic types</font>
<font color="black"> 161.     (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)</font>
<font color="black"> 162.     will be skipped instead of raising a ``TypeError``.</font>
<font color="black"> 163. </font>
<font color="black"> 164.     If *ensure_ascii* is false, then the some chunks written to ``fp``</font>
<font color="black"> 165.     may be ``unicode`` instances, subject to normal Python ``str`` to</font>
<font color="black"> 166.     ``unicode`` coercion rules. Unless ``fp.write()`` explicitly</font>
<font color="black"> 167.     understands ``unicode`` (as in ``codecs.getwriter()``) this is likely</font>
<font color="black"> 168.     to cause an error.</font>
<font color="black"> 169. </font>
<font color="black"> 170.     If *check_circular* is false, then the circular reference check</font>
<font color="black"> 171.     for container types will be skipped and a circular reference will</font>
<font color="black"> 172.     result in an ``OverflowError`` (or worse).</font>
<font color="black"> 173. </font>
<font color="black"> 174.     If *allow_nan* is false, then it will be a ``ValueError`` to</font>
<font color="black"> 175.     serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)</font>
<font color="black"> 176.     in strict compliance of the original JSON specification, instead of using</font>
<font color="black"> 177.     the JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``). See</font>
<font color="black"> 178.     *ignore_nan* for ECMA-262 compliant behavior.</font>
<font color="black"> 179. </font>
<font color="black"> 180.     If *indent* is a string, then JSON array elements and object members</font>
<font color="black"> 181.     will be pretty-printed with a newline followed by that string repeated</font>
<font color="black"> 182.     for each level of nesting. ``None`` (the default) selects the most compact</font>
<font color="black"> 183.     representation without any newlines. For backwards compatibility with</font>
<font color="black"> 184.     versions of simplejson earlier than 2.1.0, an integer is also accepted</font>
<font color="black"> 185.     and is converted to a string with that many spaces.</font>
<font color="black"> 186. </font>
<font color="black"> 187.     If specified, *separators* should be an</font>
<font color="black"> 188.     ``(item_separator, key_separator)`` tuple.  The default is ``(', ', ': ')``</font>
<font color="black"> 189.     if *indent* is ``None`` and ``(',', ': ')`` otherwise.  To get the most</font>
<font color="black"> 190.     compact JSON representation, you should specify ``(',', ':')`` to eliminate</font>
<font color="black"> 191.     whitespace.</font>
<font color="black"> 192. </font>
<font color="black"> 193.     *encoding* is the character encoding for str instances, default is UTF-8.</font>
<font color="black"> 194. </font>
<font color="black"> 195.     *default(obj)* is a function that should return a serializable version</font>
<font color="black"> 196.     of obj or raise ``TypeError``. The default simply raises ``TypeError``.</font>
<font color="black"> 197. </font>
<font color="black"> 198.     If *use_decimal* is true (default: ``True``) then decimal.Decimal</font>
<font color="black"> 199.     will be natively serialized to JSON with full precision.</font>
<font color="black"> 200. </font>
<font color="black"> 201.     If *namedtuple_as_object* is true (default: ``True``),</font>
<font color="black"> 202.     :class:`tuple` subclasses with ``_asdict()`` methods will be encoded</font>
<font color="black"> 203.     as JSON objects.</font>
<font color="black"> 204. </font>
<font color="black"> 205.     If *tuple_as_array* is true (default: ``True``),</font>
<font color="black"> 206.     :class:`tuple` (and subclasses) will be encoded as JSON arrays.</font>
<font color="black"> 207. </font>
<font color="black"> 208.     If *iterable_as_array* is true (default: ``False``),</font>
<font color="black"> 209.     any object not in the above table that implements ``__iter__()``</font>
<font color="black"> 210.     will be encoded as a JSON array.</font>
<font color="black"> 211. </font>
<font color="black"> 212.     If *bigint_as_string* is true (default: ``False``), ints 2**53 and higher</font>
<font color="black"> 213.     or lower than -2**53 will be encoded as strings. This is to avoid the</font>
<font color="black"> 214.     rounding that happens in Javascript otherwise. Note that this is still a</font>
<font color="black"> 215.     lossy operation that will not round-trip correctly and should be used</font>
<font color="black"> 216.     sparingly.</font>
<font color="black"> 217. </font>
<font color="black"> 218.     If *int_as_string_bitcount* is a positive number (n), then int of size</font>
<font color="black"> 219.     greater than or equal to 2**n or lower than or equal to -2**n will be</font>
<font color="black"> 220.     encoded as strings.</font>
<font color="black"> 221. </font>
<font color="black"> 222.     If specified, *item_sort_key* is a callable used to sort the items in</font>
<font color="black"> 223.     each dictionary. This is useful if you want to sort items other than</font>
<font color="black"> 224.     in alphabetical order by key. This option takes precedence over</font>
<font color="black"> 225.     *sort_keys*.</font>
<font color="black"> 226. </font>
<font color="black"> 227.     If *sort_keys* is true (default: ``False``), the output of dictionaries</font>
<font color="black"> 228.     will be sorted by item.</font>
<font color="black"> 229. </font>
<font color="black"> 230.     If *for_json* is true (default: ``False``), objects with a ``for_json()``</font>
<font color="black"> 231.     method will use the return value of that method for encoding as JSON</font>
<font color="black"> 232.     instead of the object.</font>
<font color="black"> 233. </font>
<font color="black"> 234.     If *ignore_nan* is true (default: ``False``), then out of range</font>
<font color="black"> 235.     :class:`float` values (``nan``, ``inf``, ``-inf``) will be serialized as</font>
<font color="black"> 236.     ``null`` in compliance with the ECMA-262 specification. If true, this will</font>
<font color="black"> 237.     override *allow_nan*.</font>
<font color="black"> 238. </font>
<font color="black"> 239.     To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the</font>
<font color="black"> 240.     ``.default()`` method to serialize additional types), specify it with</font>
<font color="black"> 241.     the ``cls`` kwarg. NOTE: You should use *default* or *for_json* instead</font>
<font color="black"> 242.     of subclassing whenever possible.</font>
<font color="black"> 243. </font>
<font color="black"> 244.     &quot;&quot;&quot;</font>
<font color="black"> 245.     # cached encoder</font>
<font color="red"> 246.     if (not skipkeys and ensure_ascii and</font>
<font color="red"> 247.         check_circular and allow_nan and</font>
<font color="red"> 248.         cls is None and indent is None and separators is None and</font>
<font color="red"> 249.         encoding == 'utf-8' and default is None and use_decimal</font>
<font color="red"> 250.         and namedtuple_as_object and tuple_as_array and not iterable_as_array</font>
<font color="red"> 251.         and not bigint_as_string and not sort_keys</font>
<font color="red"> 252.         and not item_sort_key and not for_json</font>
<font color="red"> 253.         and not ignore_nan and int_as_string_bitcount is None</font>
<font color="red"> 254.         and not kw</font>
<font color="black"> 255.     ):</font>
<font color="red"> 256.         iterable = _default_encoder.iterencode(obj)</font>
<font color="black"> 257.     else:</font>
<font color="red"> 258.         if cls is None:</font>
<font color="red"> 259.             cls = JSONEncoder</font>
<font color="red"> 260.         iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii,</font>
<font color="red"> 261.             check_circular=check_circular, allow_nan=allow_nan, indent=indent,</font>
<font color="red"> 262.             separators=separators, encoding=encoding,</font>
<font color="red"> 263.             default=default, use_decimal=use_decimal,</font>
<font color="red"> 264.             namedtuple_as_object=namedtuple_as_object,</font>
<font color="red"> 265.             tuple_as_array=tuple_as_array,</font>
<font color="red"> 266.             iterable_as_array=iterable_as_array,</font>
<font color="red"> 267.             bigint_as_string=bigint_as_string,</font>
<font color="red"> 268.             sort_keys=sort_keys,</font>
<font color="red"> 269.             item_sort_key=item_sort_key,</font>
<font color="red"> 270.             for_json=for_json,</font>
<font color="red"> 271.             ignore_nan=ignore_nan,</font>
<font color="red"> 272.             int_as_string_bitcount=int_as_string_bitcount,</font>
<font color="red"> 273.             **kw).iterencode(obj)</font>
<font color="black"> 274.     # could accelerate with writelines in some versions of Python, at</font>
<font color="black"> 275.     # a debuggability cost</font>
<font color="red"> 276.     for chunk in iterable:</font>
<font color="red"> 277.         fp.write(chunk)</font>
<font color="black"> 278. </font>
<font color="black"> 279. </font>
<font color="green"> 280. def dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True,</font>
<font color="green"> 281.           allow_nan=True, cls=None, indent=None, separators=None,</font>
<font color="green"> 282.           encoding='utf-8', default=None, use_decimal=True,</font>
<font color="green"> 283.           namedtuple_as_object=True, tuple_as_array=True,</font>
<font color="green"> 284.           bigint_as_string=False, sort_keys=False, item_sort_key=None,</font>
<font color="green"> 285.           for_json=False, ignore_nan=False, int_as_string_bitcount=None,</font>
<font color="green"> 286.           iterable_as_array=False, **kw):</font>
<font color="black"> 287.     &quot;&quot;&quot;Serialize ``obj`` to a JSON formatted ``str``.</font>
<font color="black"> 288. </font>
<font color="black"> 289.     If ``skipkeys`` is false then ``dict`` keys that are not basic types</font>
<font color="black"> 290.     (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)</font>
<font color="black"> 291.     will be skipped instead of raising a ``TypeError``.</font>
<font color="black"> 292. </font>
<font color="black"> 293.     If ``ensure_ascii`` is false, then the return value will be a</font>
<font color="black"> 294.     ``unicode`` instance subject to normal Python ``str`` to ``unicode``</font>
<font color="black"> 295.     coercion rules instead of being escaped to an ASCII ``str``.</font>
<font color="black"> 296. </font>
<font color="black"> 297.     If ``check_circular`` is false, then the circular reference check</font>
<font color="black"> 298.     for container types will be skipped and a circular reference will</font>
<font color="black"> 299.     result in an ``OverflowError`` (or worse).</font>
<font color="black"> 300. </font>
<font color="black"> 301.     If ``allow_nan`` is false, then it will be a ``ValueError`` to</font>
<font color="black"> 302.     serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in</font>
<font color="black"> 303.     strict compliance of the JSON specification, instead of using the</font>
<font color="black"> 304.     JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).</font>
<font color="black"> 305. </font>
<font color="black"> 306.     If ``indent`` is a string, then JSON array elements and object members</font>
<font color="black"> 307.     will be pretty-printed with a newline followed by that string repeated</font>
<font color="black"> 308.     for each level of nesting. ``None`` (the default) selects the most compact</font>
<font color="black"> 309.     representation without any newlines. For backwards compatibility with</font>
<font color="black"> 310.     versions of simplejson earlier than 2.1.0, an integer is also accepted</font>
<font color="black"> 311.     and is converted to a string with that many spaces.</font>
<font color="black"> 312. </font>
<font color="black"> 313.     If specified, ``separators`` should be an</font>
<font color="black"> 314.     ``(item_separator, key_separator)`` tuple.  The default is ``(', ', ': ')``</font>
<font color="black"> 315.     if *indent* is ``None`` and ``(',', ': ')`` otherwise.  To get the most</font>
<font color="black"> 316.     compact JSON representation, you should specify ``(',', ':')`` to eliminate</font>
<font color="black"> 317.     whitespace.</font>
<font color="black"> 318. </font>
<font color="black"> 319.     ``encoding`` is the character encoding for str instances, default is UTF-8.</font>
<font color="black"> 320. </font>
<font color="black"> 321.     ``default(obj)`` is a function that should return a serializable version</font>
<font color="black"> 322.     of obj or raise TypeError. The default simply raises TypeError.</font>
<font color="black"> 323. </font>
<font color="black"> 324.     If *use_decimal* is true (default: ``True``) then decimal.Decimal</font>
<font color="black"> 325.     will be natively serialized to JSON with full precision.</font>
<font color="black"> 326. </font>
<font color="black"> 327.     If *namedtuple_as_object* is true (default: ``True``),</font>
<font color="black"> 328.     :class:`tuple` subclasses with ``_asdict()`` methods will be encoded</font>
<font color="black"> 329.     as JSON objects.</font>
<font color="black"> 330. </font>
<font color="black"> 331.     If *tuple_as_array* is true (default: ``True``),</font>
<font color="black"> 332.     :class:`tuple` (and subclasses) will be encoded as JSON arrays.</font>
<font color="black"> 333. </font>
<font color="black"> 334.     If *iterable_as_array* is true (default: ``False``),</font>
<font color="black"> 335.     any object not in the above table that implements ``__iter__()``</font>
<font color="black"> 336.     will be encoded as a JSON array.</font>
<font color="black"> 337. </font>
<font color="black"> 338.     If *bigint_as_string* is true (not the default), ints 2**53 and higher</font>
<font color="black"> 339.     or lower than -2**53 will be encoded as strings. This is to avoid the</font>
<font color="black"> 340.     rounding that happens in Javascript otherwise.</font>
<font color="black"> 341. </font>
<font color="black"> 342.     If *int_as_string_bitcount* is a positive number (n), then int of size</font>
<font color="black"> 343.     greater than or equal to 2**n or lower than or equal to -2**n will be</font>
<font color="black"> 344.     encoded as strings.</font>
<font color="black"> 345. </font>
<font color="black"> 346.     If specified, *item_sort_key* is a callable used to sort the items in</font>
<font color="black"> 347.     each dictionary. This is useful if you want to sort items other than</font>
<font color="black"> 348.     in alphabetical order by key. This option takes precendence over</font>
<font color="black"> 349.     *sort_keys*.</font>
<font color="black"> 350. </font>
<font color="black"> 351.     If *sort_keys* is true (default: ``False``), the output of dictionaries</font>
<font color="black"> 352.     will be sorted by item.</font>
<font color="black"> 353. </font>
<font color="black"> 354.     If *for_json* is true (default: ``False``), objects with a ``for_json()``</font>
<font color="black"> 355.     method will use the return value of that method for encoding as JSON</font>
<font color="black"> 356.     instead of the object.</font>
<font color="black"> 357. </font>
<font color="black"> 358.     If *ignore_nan* is true (default: ``False``), then out of range</font>
<font color="black"> 359.     :class:`float` values (``nan``, ``inf``, ``-inf``) will be serialized as</font>
<font color="black"> 360.     ``null`` in compliance with the ECMA-262 specification. If true, this will</font>
<font color="black"> 361.     override *allow_nan*.</font>
<font color="black"> 362. </font>
<font color="black"> 363.     To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the</font>
<font color="black"> 364.     ``.default()`` method to serialize additional types), specify it with</font>
<font color="black"> 365.     the ``cls`` kwarg. NOTE: You should use *default* instead of subclassing</font>
<font color="black"> 366.     whenever possible.</font>
<font color="black"> 367. </font>
<font color="black"> 368.     &quot;&quot;&quot;</font>
<font color="black"> 369.     # cached encoder</font>
<font color="red"> 370.     if (not skipkeys and ensure_ascii and</font>
<font color="red"> 371.         check_circular and allow_nan and</font>
<font color="red"> 372.         cls is None and indent is None and separators is None and</font>
<font color="red"> 373.         encoding == 'utf-8' and default is None and use_decimal</font>
<font color="red"> 374.         and namedtuple_as_object and tuple_as_array and not iterable_as_array</font>
<font color="red"> 375.         and not bigint_as_string and not sort_keys</font>
<font color="red"> 376.         and not item_sort_key and not for_json</font>
<font color="red"> 377.         and not ignore_nan and int_as_string_bitcount is None</font>
<font color="red"> 378.         and not kw</font>
<font color="black"> 379.     ):</font>
<font color="red"> 380.         return _default_encoder.encode(obj)</font>
<font color="red"> 381.     if cls is None:</font>
<font color="red"> 382.         cls = JSONEncoder</font>
<font color="red"> 383.     return cls(</font>
<font color="red"> 384.         skipkeys=skipkeys, ensure_ascii=ensure_ascii,</font>
<font color="red"> 385.         check_circular=check_circular, allow_nan=allow_nan, indent=indent,</font>
<font color="red"> 386.         separators=separators, encoding=encoding, default=default,</font>
<font color="red"> 387.         use_decimal=use_decimal,</font>
<font color="red"> 388.         namedtuple_as_object=namedtuple_as_object,</font>
<font color="red"> 389.         tuple_as_array=tuple_as_array,</font>
<font color="red"> 390.         iterable_as_array=iterable_as_array,</font>
<font color="red"> 391.         bigint_as_string=bigint_as_string,</font>
<font color="red"> 392.         sort_keys=sort_keys,</font>
<font color="red"> 393.         item_sort_key=item_sort_key,</font>
<font color="red"> 394.         for_json=for_json,</font>
<font color="red"> 395.         ignore_nan=ignore_nan,</font>
<font color="red"> 396.         int_as_string_bitcount=int_as_string_bitcount,</font>
<font color="red"> 397.         **kw).encode(obj)</font>
<font color="black"> 398. </font>
<font color="black"> 399. </font>
<font color="green"> 400. _default_decoder = JSONDecoder(encoding=None, object_hook=None,</font>
<font color="green"> 401.                                object_pairs_hook=None)</font>
<font color="black"> 402. </font>
<font color="black"> 403. </font>
<font color="green"> 404. def load(fp, encoding=None, cls=None, object_hook=None, parse_float=None,</font>
<font color="green"> 405.         parse_int=None, parse_constant=None, object_pairs_hook=None,</font>
<font color="green"> 406.         use_decimal=False, namedtuple_as_object=True, tuple_as_array=True,</font>
<font color="black"> 407.         **kw):</font>
<font color="black"> 408.     &quot;&quot;&quot;Deserialize ``fp`` (a ``.read()``-supporting file-like object containing</font>
<font color="black"> 409.     a JSON document) to a Python object.</font>
<font color="black"> 410. </font>
<font color="black"> 411.     *encoding* determines the encoding used to interpret any</font>
<font color="black"> 412.     :class:`str` objects decoded by this instance (``'utf-8'`` by</font>
<font color="black"> 413.     default).  It has no effect when decoding :class:`unicode` objects.</font>
<font color="black"> 414. </font>
<font color="black"> 415.     Note that currently only encodings that are a superset of ASCII work,</font>
<font color="black"> 416.     strings of other encodings should be passed in as :class:`unicode`.</font>
<font color="black"> 417. </font>
<font color="black"> 418.     *object_hook*, if specified, will be called with the result of every</font>
<font color="black"> 419.     JSON object decoded and its return value will be used in place of the</font>
<font color="black"> 420.     given :class:`dict`.  This can be used to provide custom</font>
<font color="black"> 421.     deserializations (e.g. to support JSON-RPC class hinting).</font>
<font color="black"> 422. </font>
<font color="black"> 423.     *object_pairs_hook* is an optional function that will be called with</font>
<font color="black"> 424.     the result of any object literal decode with an ordered list of pairs.</font>
<font color="black"> 425.     The return value of *object_pairs_hook* will be used instead of the</font>
<font color="black"> 426.     :class:`dict`.  This feature can be used to implement custom decoders</font>
<font color="black"> 427.     that rely on the order that the key and value pairs are decoded (for</font>
<font color="black"> 428.     example, :func:`collections.OrderedDict` will remember the order of</font>
<font color="black"> 429.     insertion). If *object_hook* is also defined, the *object_pairs_hook*</font>
<font color="black"> 430.     takes priority.</font>
<font color="black"> 431. </font>
<font color="black"> 432.     *parse_float*, if specified, will be called with the string of every</font>
<font color="black"> 433.     JSON float to be decoded.  By default, this is equivalent to</font>
<font color="black"> 434.     ``float(num_str)``. This can be used to use another datatype or parser</font>
<font color="black"> 435.     for JSON floats (e.g. :class:`decimal.Decimal`).</font>
<font color="black"> 436. </font>
<font color="black"> 437.     *parse_int*, if specified, will be called with the string of every</font>
<font color="black"> 438.     JSON int to be decoded.  By default, this is equivalent to</font>
<font color="black"> 439.     ``int(num_str)``.  This can be used to use another datatype or parser</font>
<font color="black"> 440.     for JSON integers (e.g. :class:`float`).</font>
<font color="black"> 441. </font>
<font color="black"> 442.     *parse_constant*, if specified, will be called with one of the</font>
<font color="black"> 443.     following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This</font>
<font color="black"> 444.     can be used to raise an exception if invalid JSON numbers are</font>
<font color="black"> 445.     encountered.</font>
<font color="black"> 446. </font>
<font color="black"> 447.     If *use_decimal* is true (default: ``False``) then it implies</font>
<font color="black"> 448.     parse_float=decimal.Decimal for parity with ``dump``.</font>
<font color="black"> 449. </font>
<font color="black"> 450.     To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``</font>
<font color="black"> 451.     kwarg. NOTE: You should use *object_hook* or *object_pairs_hook* instead</font>
<font color="black"> 452.     of subclassing whenever possible.</font>
<font color="black"> 453. </font>
<font color="black"> 454.     &quot;&quot;&quot;</font>
<font color="red"> 455.     return loads(fp.read(),</font>
<font color="red"> 456.         encoding=encoding, cls=cls, object_hook=object_hook,</font>
<font color="red"> 457.         parse_float=parse_float, parse_int=parse_int,</font>
<font color="red"> 458.         parse_constant=parse_constant, object_pairs_hook=object_pairs_hook,</font>
<font color="red"> 459.         use_decimal=use_decimal, **kw)</font>
<font color="black"> 460. </font>
<font color="black"> 461. </font>
<font color="green"> 462. def loads(s, encoding=None, cls=None, object_hook=None, parse_float=None,</font>
<font color="green"> 463.         parse_int=None, parse_constant=None, object_pairs_hook=None,</font>
<font color="green"> 464.         use_decimal=False, **kw):</font>
<font color="black"> 465.     &quot;&quot;&quot;Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON</font>
<font color="black"> 466.     document) to a Python object.</font>
<font color="black"> 467. </font>
<font color="black"> 468.     *encoding* determines the encoding used to interpret any</font>
<font color="black"> 469.     :class:`str` objects decoded by this instance (``'utf-8'`` by</font>
<font color="black"> 470.     default).  It has no effect when decoding :class:`unicode` objects.</font>
<font color="black"> 471. </font>
<font color="black"> 472.     Note that currently only encodings that are a superset of ASCII work,</font>
<font color="black"> 473.     strings of other encodings should be passed in as :class:`unicode`.</font>
<font color="black"> 474. </font>
<font color="black"> 475.     *object_hook*, if specified, will be called with the result of every</font>
<font color="black"> 476.     JSON object decoded and its return value will be used in place of the</font>
<font color="black"> 477.     given :class:`dict`.  This can be used to provide custom</font>
<font color="black"> 478.     deserializations (e.g. to support JSON-RPC class hinting).</font>
<font color="black"> 479. </font>
<font color="black"> 480.     *object_pairs_hook* is an optional function that will be called with</font>
<font color="black"> 481.     the result of any object literal decode with an ordered list of pairs.</font>
<font color="black"> 482.     The return value of *object_pairs_hook* will be used instead of the</font>
<font color="black"> 483.     :class:`dict`.  This feature can be used to implement custom decoders</font>
<font color="black"> 484.     that rely on the order that the key and value pairs are decoded (for</font>
<font color="black"> 485.     example, :func:`collections.OrderedDict` will remember the order of</font>
<font color="black"> 486.     insertion). If *object_hook* is also defined, the *object_pairs_hook*</font>
<font color="black"> 487.     takes priority.</font>
<font color="black"> 488. </font>
<font color="black"> 489.     *parse_float*, if specified, will be called with the string of every</font>
<font color="black"> 490.     JSON float to be decoded.  By default, this is equivalent to</font>
<font color="black"> 491.     ``float(num_str)``. This can be used to use another datatype or parser</font>
<font color="black"> 492.     for JSON floats (e.g. :class:`decimal.Decimal`).</font>
<font color="black"> 493. </font>
<font color="black"> 494.     *parse_int*, if specified, will be called with the string of every</font>
<font color="black"> 495.     JSON int to be decoded.  By default, this is equivalent to</font>
<font color="black"> 496.     ``int(num_str)``.  This can be used to use another datatype or parser</font>
<font color="black"> 497.     for JSON integers (e.g. :class:`float`).</font>
<font color="black"> 498. </font>
<font color="black"> 499.     *parse_constant*, if specified, will be called with one of the</font>
<font color="black"> 500.     following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This</font>
<font color="black"> 501.     can be used to raise an exception if invalid JSON numbers are</font>
<font color="black"> 502.     encountered.</font>
<font color="black"> 503. </font>
<font color="black"> 504.     If *use_decimal* is true (default: ``False``) then it implies</font>
<font color="black"> 505.     parse_float=decimal.Decimal for parity with ``dump``.</font>
<font color="black"> 506. </font>
<font color="black"> 507.     To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``</font>
<font color="black"> 508.     kwarg. NOTE: You should use *object_hook* or *object_pairs_hook* instead</font>
<font color="black"> 509.     of subclassing whenever possible.</font>
<font color="black"> 510. </font>
<font color="black"> 511.     &quot;&quot;&quot;</font>
<font color="red"> 512.     if (cls is None and encoding is None and object_hook is None and</font>
<font color="red"> 513.             parse_int is None and parse_float is None and</font>
<font color="red"> 514.             parse_constant is None and object_pairs_hook is None</font>
<font color="red"> 515.             and not use_decimal and not kw):</font>
<font color="red"> 516.         return _default_decoder.decode(s)</font>
<font color="red"> 517.     if cls is None:</font>
<font color="red"> 518.         cls = JSONDecoder</font>
<font color="red"> 519.     if object_hook is not None:</font>
<font color="red"> 520.         kw['object_hook'] = object_hook</font>
<font color="red"> 521.     if object_pairs_hook is not None:</font>
<font color="red"> 522.         kw['object_pairs_hook'] = object_pairs_hook</font>
<font color="red"> 523.     if parse_float is not None:</font>
<font color="red"> 524.         kw['parse_float'] = parse_float</font>
<font color="red"> 525.     if parse_int is not None:</font>
<font color="red"> 526.         kw['parse_int'] = parse_int</font>
<font color="red"> 527.     if parse_constant is not None:</font>
<font color="red"> 528.         kw['parse_constant'] = parse_constant</font>
<font color="red"> 529.     if use_decimal:</font>
<font color="red"> 530.         if parse_float is not None:</font>
<font color="red"> 531.             raise TypeError(&quot;use_decimal=True implies parse_float=Decimal&quot;)</font>
<font color="red"> 532.         kw['parse_float'] = Decimal</font>
<font color="red"> 533.     return cls(encoding=encoding, **kw).decode(s)</font>
<font color="black"> 534. </font>
<font color="black"> 535. </font>
<font color="green"> 536. def _toggle_speedups(enabled):</font>
<font color="red"> 537.     from . import decoder as dec</font>
<font color="red"> 538.     from . import encoder as enc</font>
<font color="red"> 539.     from . import scanner as scan</font>
<font color="red"> 540.     c_make_encoder = _import_c_make_encoder()</font>
<font color="red"> 541.     if enabled:</font>
<font color="red"> 542.         dec.scanstring = dec.c_scanstring or dec.py_scanstring</font>
<font color="red"> 543.         enc.c_make_encoder = c_make_encoder</font>
<font color="red"> 544.         enc.encode_basestring_ascii = (enc.c_encode_basestring_ascii or</font>
<font color="red"> 545.             enc.py_encode_basestring_ascii)</font>
<font color="red"> 546.         scan.make_scanner = scan.c_make_scanner or scan.py_make_scanner</font>
<font color="black"> 547.     else:</font>
<font color="red"> 548.         dec.scanstring = dec.py_scanstring</font>
<font color="red"> 549.         enc.c_make_encoder = None</font>
<font color="red"> 550.         enc.encode_basestring_ascii = enc.py_encode_basestring_ascii</font>
<font color="red"> 551.         scan.make_scanner = scan.py_make_scanner</font>
<font color="red"> 552.     dec.make_scanner = scan.make_scanner</font>
<font color="black"> 553.     global _default_decoder</font>
<font color="red"> 554.     _default_decoder = JSONDecoder(</font>
<font color="red"> 555.         encoding=None,</font>
<font color="red"> 556.         object_hook=None,</font>
<font color="red"> 557.         object_pairs_hook=None,</font>
<font color="black"> 558.     )</font>
<font color="black"> 559.     global _default_encoder</font>
<font color="red"> 560.     _default_encoder = JSONEncoder(</font>
<font color="red"> 561.        skipkeys=False,</font>
<font color="red"> 562.        ensure_ascii=True,</font>
<font color="red"> 563.        check_circular=True,</font>
<font color="red"> 564.        allow_nan=True,</font>
<font color="red"> 565.        indent=None,</font>
<font color="red"> 566.        separators=None,</font>
<font color="red"> 567.        encoding='utf-8',</font>
<font color="red"> 568.        default=None,</font>
<font color="black"> 569.    )</font>
<font color="black"> 570. </font>
<font color="green"> 571. def simple_first(kv):</font>
<font color="black"> 572.     &quot;&quot;&quot;Helper function to pass to item_sort_key to sort simple</font>
<font color="black"> 573.     elements to the top, then container elements.</font>
<font color="black"> 574.     &quot;&quot;&quot;</font>
<font color="red"> 575.     return (isinstance(kv[1], (list, dict, tuple)), kv[0])</font>
</pre>

