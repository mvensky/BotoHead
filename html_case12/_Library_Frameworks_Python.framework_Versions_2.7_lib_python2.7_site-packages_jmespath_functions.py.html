source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/jmespath/functions.py</b><br>


file stats: <b>239 lines, 79 executed: 33.1% covered</b>
<pre>
<font color="green">   1. import math</font>
<font color="green">   2. import json</font>
<font color="green">   3. import weakref</font>
<font color="black">   4. </font>
<font color="green">   5. from jmespath import exceptions</font>
<font color="green">   6. from jmespath.compat import string_type as STRING_TYPE</font>
<font color="green">   7. from jmespath.compat import get_methods</font>
<font color="black">   8. </font>
<font color="black">   9. </font>
<font color="black">  10. # python types -&gt; jmespath types</font>
<font color="green">  11. TYPES_MAP = {</font>
<font color="green">  12.     'bool': 'boolean',</font>
<font color="green">  13.     'list': 'array',</font>
<font color="green">  14.     'dict': 'object',</font>
<font color="green">  15.     'NoneType': 'null',</font>
<font color="green">  16.     'unicode': 'string',</font>
<font color="green">  17.     'str': 'string',</font>
<font color="green">  18.     'float': 'number',</font>
<font color="green">  19.     'int': 'number',</font>
<font color="green">  20.     'OrderedDict': 'object',</font>
<font color="green">  21.     '_Projection': 'array',</font>
<font color="green">  22.     '_Expression': 'expref',</font>
<font color="black">  23. }</font>
<font color="black">  24. </font>
<font color="black">  25. </font>
<font color="black">  26. # jmespath types -&gt; python types</font>
<font color="green">  27. REVERSE_TYPES_MAP = {</font>
<font color="green">  28.     'boolean': ('bool',),</font>
<font color="green">  29.     'array': ('list', '_Projection'),</font>
<font color="green">  30.     'object': ('dict', 'OrderedDict',),</font>
<font color="green">  31.     'null': ('None',),</font>
<font color="green">  32.     'string': ('unicode', 'str'),</font>
<font color="green">  33.     'number': ('float', 'int'),</font>
<font color="green">  34.     'expref': ('_Expression',),</font>
<font color="black">  35. }</font>
<font color="black">  36. </font>
<font color="black">  37. </font>
<font color="green">  38. def populate_function_table(cls):</font>
<font color="green">  39.     func_table = cls.FUNCTION_TABLE</font>
<font color="green">  40.     for name, method in get_methods(cls):</font>
<font color="green">  41.         signature = getattr(method, 'signature', None)</font>
<font color="green">  42.         if signature is not None:</font>
<font color="green">  43.             func_table[name[6:]] = {&quot;function&quot;: method,</font>
<font color="green">  44.                                     &quot;signature&quot;: signature}</font>
<font color="green">  45.     return cls</font>
<font color="black">  46. </font>
<font color="black">  47. </font>
<font color="green">  48. def builtin_function(*arguments):</font>
<font color="green">  49.     def _record_arity(func):</font>
<font color="green">  50.         func.signature = arguments</font>
<font color="green">  51.         return func</font>
<font color="green">  52.     return _record_arity</font>
<font color="black">  53. </font>
<font color="black">  54. </font>
<font color="green">  55. @populate_function_table</font>
<font color="green">  56. class RuntimeFunctions(object):</font>
<font color="black">  57.     # The built in functions are automatically populated in the FUNCTION_TABLE</font>
<font color="black">  58.     # using the @builtin_function decorator on methods defined in this class.</font>
<font color="black">  59. </font>
<font color="green">  60.     FUNCTION_TABLE = {</font>
<font color="black">  61.     }</font>
<font color="black">  62. </font>
<font color="green">  63.     def __init__(self):</font>
<font color="red">  64.         self._interpreter = None</font>
<font color="black">  65. </font>
<font color="green">  66.     @property</font>
<font color="black">  67.     def interpreter(self):</font>
<font color="red">  68.         if self._interpreter is None:</font>
<font color="red">  69.             return None</font>
<font color="black">  70.         else:</font>
<font color="red">  71.             return self._interpreter()</font>
<font color="black">  72. </font>
<font color="green">  73.     @interpreter.setter</font>
<font color="black">  74.     def interpreter(self, value):</font>
<font color="black">  75.         # A weakref is used because we have</font>
<font color="black">  76.         # a cyclic reference and we want to allow</font>
<font color="black">  77.         # for the memory to be properly freed when</font>
<font color="black">  78.         # the objects are no longer needed.</font>
<font color="red">  79.         self._interpreter = weakref.ref(value)</font>
<font color="black">  80. </font>
<font color="green">  81.     def call_function(self, function_name, resolved_args):</font>
<font color="red">  82.         try:</font>
<font color="red">  83.             spec = self.FUNCTION_TABLE[function_name]</font>
<font color="red">  84.         except KeyError:</font>
<font color="red">  85.             raise exceptions.UnknownFunctionError(</font>
<font color="red">  86.                 &quot;Unknown function: %s()&quot; % function_name)</font>
<font color="red">  87.         function = spec['function']</font>
<font color="red">  88.         signature = spec['signature']</font>
<font color="red">  89.         self._validate_arguments(resolved_args, signature, function_name)</font>
<font color="red">  90.         return function(self, *resolved_args)</font>
<font color="black">  91. </font>
<font color="green">  92.     def _validate_arguments(self, args, signature, function_name):</font>
<font color="red">  93.         if signature and signature[-1].get('variadic'):</font>
<font color="red">  94.             if len(args) &lt; len(signature):</font>
<font color="red">  95.                 raise exceptions.VariadictArityError(</font>
<font color="red">  96.                     len(signature), len(args), function_name)</font>
<font color="red">  97.         elif len(args) != len(signature):</font>
<font color="red">  98.             raise exceptions.ArityError(</font>
<font color="red">  99.                 len(signature), len(args), function_name)</font>
<font color="red"> 100.         return self._type_check(args, signature, function_name)</font>
<font color="black"> 101. </font>
<font color="green"> 102.     def _type_check(self, actual, signature, function_name):</font>
<font color="red"> 103.         for i in range(len(signature)):</font>
<font color="red"> 104.             allowed_types = signature[i]['types']</font>
<font color="red"> 105.             if allowed_types:</font>
<font color="red"> 106.                 self._type_check_single(actual[i], allowed_types,</font>
<font color="red"> 107.                                         function_name)</font>
<font color="black"> 108. </font>
<font color="green"> 109.     def _type_check_single(self, current, types, function_name):</font>
<font color="black"> 110.         # Type checking involves checking the top level type,</font>
<font color="black"> 111.         # and in the case of arrays, potentially checking the types</font>
<font color="black"> 112.         # of each element.</font>
<font color="red"> 113.         allowed_types, allowed_subtypes = self._get_allowed_pytypes(types)</font>
<font color="black"> 114.         # We're not using isinstance() on purpose.</font>
<font color="black"> 115.         # The type model for jmespath does not map</font>
<font color="black"> 116.         # 1-1 with python types (booleans are considered</font>
<font color="black"> 117.         # integers in python for example).</font>
<font color="red"> 118.         actual_typename = type(current).__name__</font>
<font color="red"> 119.         if actual_typename not in allowed_types:</font>
<font color="red"> 120.             raise exceptions.JMESPathTypeError(</font>
<font color="red"> 121.                 function_name, current,</font>
<font color="red"> 122.                 self._convert_to_jmespath_type(actual_typename), types)</font>
<font color="black"> 123.         # If we're dealing with a list type, we can have</font>
<font color="black"> 124.         # additional restrictions on the type of the list</font>
<font color="black"> 125.         # elements (for example a function can require a</font>
<font color="black"> 126.         # list of numbers or a list of strings).</font>
<font color="black"> 127.         # Arrays are the only types that can have subtypes.</font>
<font color="red"> 128.         if allowed_subtypes:</font>
<font color="red"> 129.             self._subtype_check(current, allowed_subtypes,</font>
<font color="red"> 130.                                 types, function_name)</font>
<font color="black"> 131. </font>
<font color="green"> 132.     def _get_allowed_pytypes(self, types):</font>
<font color="red"> 133.         allowed_types = []</font>
<font color="red"> 134.         allowed_subtypes = []</font>
<font color="red"> 135.         for t in types:</font>
<font color="red"> 136.             type_ = t.split('-', 1)</font>
<font color="red"> 137.             if len(type_) == 2:</font>
<font color="red"> 138.                 type_, subtype = type_</font>
<font color="red"> 139.                 allowed_subtypes.append(REVERSE_TYPES_MAP[subtype])</font>
<font color="black"> 140.             else:</font>
<font color="red"> 141.                 type_ = type_[0]</font>
<font color="red"> 142.             allowed_types.extend(REVERSE_TYPES_MAP[type_])</font>
<font color="red"> 143.         return allowed_types, allowed_subtypes</font>
<font color="black"> 144. </font>
<font color="green"> 145.     def _subtype_check(self, current, allowed_subtypes, types, function_name):</font>
<font color="red"> 146.         if len(allowed_subtypes) == 1:</font>
<font color="black"> 147.             # The easy case, we know up front what type</font>
<font color="black"> 148.             # we need to validate.</font>
<font color="red"> 149.             allowed_subtypes = allowed_subtypes[0]</font>
<font color="red"> 150.             for element in current:</font>
<font color="red"> 151.                 actual_typename = type(element).__name__</font>
<font color="red"> 152.                 if actual_typename not in allowed_subtypes:</font>
<font color="red"> 153.                     raise exceptions.JMESPathTypeError(</font>
<font color="red"> 154.                         function_name, element, actual_typename, types)</font>
<font color="red"> 155.         elif len(allowed_subtypes) &gt; 1 and current:</font>
<font color="black"> 156.             # Dynamic type validation.  Based on the first</font>
<font color="black"> 157.             # type we see, we validate that the remaining types</font>
<font color="black"> 158.             # match.</font>
<font color="red"> 159.             first = type(current[0]).__name__</font>
<font color="red"> 160.             for subtypes in allowed_subtypes:</font>
<font color="red"> 161.                 if first in subtypes:</font>
<font color="red"> 162.                     allowed = subtypes</font>
<font color="red"> 163.                     break</font>
<font color="black"> 164.             else:</font>
<font color="red"> 165.                 raise exceptions.JMESPathTypeError(</font>
<font color="red"> 166.                     function_name, current[0], first, types)</font>
<font color="red"> 167.             for element in current:</font>
<font color="red"> 168.                 actual_typename = type(element).__name__</font>
<font color="red"> 169.                 if actual_typename not in allowed:</font>
<font color="red"> 170.                     raise exceptions.JMESPathTypeError(</font>
<font color="red"> 171.                         function_name, element, actual_typename, types)</font>
<font color="black"> 172. </font>
<font color="green"> 173.     @builtin_function({'types': ['number']})</font>
<font color="black"> 174.     def _func_abs(self, arg):</font>
<font color="red"> 175.         return abs(arg)</font>
<font color="black"> 176. </font>
<font color="green"> 177.     @builtin_function({'types': ['array-number']})</font>
<font color="black"> 178.     def _func_avg(self, arg):</font>
<font color="red"> 179.         return sum(arg) / float(len(arg))</font>
<font color="black"> 180. </font>
<font color="green"> 181.     @builtin_function({'types': [], 'variadic': True})</font>
<font color="black"> 182.     def _func_not_null(self, *arguments):</font>
<font color="red"> 183.         for argument in arguments:</font>
<font color="red"> 184.             if argument is not None:</font>
<font color="red"> 185.                 return argument</font>
<font color="black"> 186. </font>
<font color="green"> 187.     @builtin_function({'types': []})</font>
<font color="black"> 188.     def _func_to_array(self, arg):</font>
<font color="red"> 189.         if isinstance(arg, list):</font>
<font color="red"> 190.             return arg</font>
<font color="black"> 191.         else:</font>
<font color="red"> 192.             return [arg]</font>
<font color="black"> 193. </font>
<font color="green"> 194.     @builtin_function({'types': []})</font>
<font color="black"> 195.     def _func_to_string(self, arg):</font>
<font color="red"> 196.         if isinstance(arg, STRING_TYPE):</font>
<font color="red"> 197.             return arg</font>
<font color="black"> 198.         else:</font>
<font color="red"> 199.             return json.dumps(arg, separators=(',', ':'),</font>
<font color="red"> 200.                               default=str)</font>
<font color="black"> 201. </font>
<font color="green"> 202.     @builtin_function({'types': []})</font>
<font color="black"> 203.     def _func_to_number(self, arg):</font>
<font color="red"> 204.         if isinstance(arg, (list, dict, bool)):</font>
<font color="red"> 205.             return None</font>
<font color="red"> 206.         elif arg is None:</font>
<font color="red"> 207.             return None</font>
<font color="red"> 208.         elif isinstance(arg, (int, float)):</font>
<font color="red"> 209.             return arg</font>
<font color="black"> 210.         else:</font>
<font color="red"> 211.             try:</font>
<font color="red"> 212.                 if '.' in arg:</font>
<font color="red"> 213.                     return float(arg)</font>
<font color="black"> 214.                 else:</font>
<font color="red"> 215.                     return int(arg)</font>
<font color="red"> 216.             except ValueError:</font>
<font color="red"> 217.                 return None</font>
<font color="black"> 218. </font>
<font color="green"> 219.     @builtin_function({'types': ['array', 'string']}, {'types': []})</font>
<font color="black"> 220.     def _func_contains(self, subject, search):</font>
<font color="red"> 221.         return search in subject</font>
<font color="black"> 222. </font>
<font color="green"> 223.     @builtin_function({'types': ['string', 'array', 'object']})</font>
<font color="black"> 224.     def _func_length(self, arg):</font>
<font color="red"> 225.         return len(arg)</font>
<font color="black"> 226. </font>
<font color="green"> 227.     @builtin_function({'types': ['string']}, {'types': ['string']})</font>
<font color="black"> 228.     def _func_ends_with(self, search, suffix):</font>
<font color="red"> 229.         return search.endswith(suffix)</font>
<font color="black"> 230. </font>
<font color="green"> 231.     @builtin_function({'types': ['string']}, {'types': ['string']})</font>
<font color="black"> 232.     def _func_starts_with(self, search, suffix):</font>
<font color="red"> 233.         return search.startswith(suffix)</font>
<font color="black"> 234. </font>
<font color="green"> 235.     @builtin_function({'types': ['array', 'string']})</font>
<font color="black"> 236.     def _func_reverse(self, arg):</font>
<font color="red"> 237.         if isinstance(arg, STRING_TYPE):</font>
<font color="red"> 238.             return arg[::-1]</font>
<font color="black"> 239.         else:</font>
<font color="red"> 240.             return list(reversed(arg))</font>
<font color="black"> 241. </font>
<font color="green"> 242.     @builtin_function({&quot;types&quot;: ['number']})</font>
<font color="black"> 243.     def _func_ceil(self, arg):</font>
<font color="red"> 244.         return math.ceil(arg)</font>
<font color="black"> 245. </font>
<font color="green"> 246.     @builtin_function({&quot;types&quot;: ['number']})</font>
<font color="black"> 247.     def _func_floor(self, arg):</font>
<font color="red"> 248.         return math.floor(arg)</font>
<font color="black"> 249. </font>
<font color="green"> 250.     @builtin_function({&quot;types&quot;: ['string']}, {&quot;types&quot;: ['array-string']})</font>
<font color="black"> 251.     def _func_join(self, separator, array):</font>
<font color="red"> 252.         return separator.join(array)</font>
<font color="black"> 253. </font>
<font color="green"> 254.     @builtin_function({'types': ['expref']}, {'types': ['array']})</font>
<font color="black"> 255.     def _func_map(self, expref, arg):</font>
<font color="red"> 256.         result = []</font>
<font color="red"> 257.         for element in arg:</font>
<font color="red"> 258.             result.append(self.interpreter.visit(expref.expression, element))</font>
<font color="red"> 259.         return result</font>
<font color="black"> 260. </font>
<font color="green"> 261.     @builtin_function({&quot;types&quot;: ['array-number', 'array-string']})</font>
<font color="black"> 262.     def _func_max(self, arg):</font>
<font color="red"> 263.         if arg:</font>
<font color="red"> 264.             return max(arg)</font>
<font color="black"> 265.         else:</font>
<font color="red"> 266.             return None</font>
<font color="black"> 267. </font>
<font color="green"> 268.     @builtin_function({&quot;types&quot;: [&quot;object&quot;], &quot;variadic&quot;: True})</font>
<font color="black"> 269.     def _func_merge(self, *arguments):</font>
<font color="red"> 270.         merged = {}</font>
<font color="red"> 271.         for arg in arguments:</font>
<font color="red"> 272.             merged.update(arg)</font>
<font color="red"> 273.         return merged</font>
<font color="black"> 274. </font>
<font color="green"> 275.     @builtin_function({&quot;types&quot;: ['array-number', 'array-string']})</font>
<font color="black"> 276.     def _func_min(self, arg):</font>
<font color="red"> 277.         if arg:</font>
<font color="red"> 278.             return min(arg)</font>
<font color="black"> 279.         else:</font>
<font color="red"> 280.             return None</font>
<font color="black"> 281. </font>
<font color="green"> 282.     @builtin_function({&quot;types&quot;: ['array-string', 'array-number']})</font>
<font color="black"> 283.     def _func_sort(self, arg):</font>
<font color="red"> 284.         return list(sorted(arg))</font>
<font color="black"> 285. </font>
<font color="green"> 286.     @builtin_function({&quot;types&quot;: ['array-number']})</font>
<font color="black"> 287.     def _func_sum(self, arg):</font>
<font color="red"> 288.         return sum(arg)</font>
<font color="black"> 289. </font>
<font color="green"> 290.     @builtin_function({&quot;types&quot;: ['object']})</font>
<font color="black"> 291.     def _func_keys(self, arg):</font>
<font color="black"> 292.         # To be consistent with .values()</font>
<font color="black"> 293.         # should we also return the indices of a list?</font>
<font color="red"> 294.         return list(arg.keys())</font>
<font color="black"> 295. </font>
<font color="green"> 296.     @builtin_function({&quot;types&quot;: ['object']})</font>
<font color="black"> 297.     def _func_values(self, arg):</font>
<font color="red"> 298.         return list(arg.values())</font>
<font color="black"> 299. </font>
<font color="green"> 300.     @builtin_function({'types': []})</font>
<font color="black"> 301.     def _func_type(self, arg):</font>
<font color="red"> 302.         if isinstance(arg, STRING_TYPE):</font>
<font color="red"> 303.             return &quot;string&quot;</font>
<font color="red"> 304.         elif isinstance(arg, bool):</font>
<font color="red"> 305.             return &quot;boolean&quot;</font>
<font color="red"> 306.         elif isinstance(arg, list):</font>
<font color="red"> 307.             return &quot;array&quot;</font>
<font color="red"> 308.         elif isinstance(arg, dict):</font>
<font color="red"> 309.             return &quot;object&quot;</font>
<font color="red"> 310.         elif isinstance(arg, (float, int)):</font>
<font color="red"> 311.             return &quot;number&quot;</font>
<font color="red"> 312.         elif arg is None:</font>
<font color="red"> 313.             return &quot;null&quot;</font>
<font color="black"> 314. </font>
<font color="green"> 315.     @builtin_function({'types': ['array']}, {'types': ['expref']})</font>
<font color="black"> 316.     def _func_sort_by(self, array, expref):</font>
<font color="red"> 317.         if not array:</font>
<font color="red"> 318.             return array</font>
<font color="black"> 319.         # sort_by allows for the expref to be either a number of</font>
<font color="black"> 320.         # a string, so we have some special logic to handle this.</font>
<font color="black"> 321.         # We evaluate the first array element and verify that it's</font>
<font color="black"> 322.         # either a string of a number.  We then create a key function</font>
<font color="black"> 323.         # that validates that type, which requires that remaining array</font>
<font color="black"> 324.         # elements resolve to the same type as the first element.</font>
<font color="red"> 325.         required_type = self._convert_to_jmespath_type(</font>
<font color="red"> 326.             type(self.interpreter.visit(expref.expression, array[0])).__name__)</font>
<font color="red"> 327.         if required_type not in ['number', 'string']:</font>
<font color="red"> 328.             raise exceptions.JMESPathTypeError(</font>
<font color="red"> 329.                 'sort_by', array[0], required_type, ['string', 'number'])</font>
<font color="red"> 330.         keyfunc = self._create_key_func(expref.expression,</font>
<font color="red"> 331.                                         [required_type],</font>
<font color="red"> 332.                                         'sort_by')</font>
<font color="red"> 333.         return list(sorted(array, key=keyfunc))</font>
<font color="black"> 334. </font>
<font color="green"> 335.     @builtin_function({'types': ['array']}, {'types': ['expref']})</font>
<font color="black"> 336.     def _func_min_by(self, array, expref):</font>
<font color="red"> 337.         keyfunc = self._create_key_func(expref.expression,</font>
<font color="red"> 338.                                         ['number', 'string'],</font>
<font color="red"> 339.                                         'min_by')</font>
<font color="red"> 340.         return min(array, key=keyfunc)</font>
<font color="black"> 341. </font>
<font color="green"> 342.     @builtin_function({'types': ['array']}, {'types': ['expref']})</font>
<font color="black"> 343.     def _func_max_by(self, array, expref):</font>
<font color="red"> 344.         keyfunc = self._create_key_func(expref.expression,</font>
<font color="red"> 345.                                         ['number', 'string'],</font>
<font color="red"> 346.                                         'min_by')</font>
<font color="red"> 347.         return max(array, key=keyfunc)</font>
<font color="black"> 348. </font>
<font color="green"> 349.     def _create_key_func(self, expr_node, allowed_types, function_name):</font>
<font color="red"> 350.         interpreter = self.interpreter</font>
<font color="black"> 351. </font>
<font color="red"> 352.         def keyfunc(x):</font>
<font color="red"> 353.             result = interpreter.visit(expr_node, x)</font>
<font color="red"> 354.             actual_typename = type(result).__name__</font>
<font color="red"> 355.             jmespath_type = self._convert_to_jmespath_type(actual_typename)</font>
<font color="black"> 356.             # allowed_types is in term of jmespath types, not python types.</font>
<font color="red"> 357.             if jmespath_type not in allowed_types:</font>
<font color="red"> 358.                 raise exceptions.JMESPathTypeError(</font>
<font color="red"> 359.                     function_name, result, jmespath_type, allowed_types)</font>
<font color="red"> 360.             return result</font>
<font color="red"> 361.         return keyfunc</font>
<font color="black"> 362. </font>
<font color="green"> 363.     def _convert_to_jmespath_type(self, pyobject):</font>
<font color="red"> 364.         return TYPES_MAP.get(pyobject, 'unknown')</font>
</pre>

