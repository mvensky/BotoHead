source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/handlers.py</b><br>


file stats: <b>592 lines, 267 executed: 45.1% covered</b>
<pre>
<font color="black">   1. # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="black">  13. </font>
<font color="black">  14. &quot;&quot;&quot;Builtin event handlers.</font>
<font color="black">  15. </font>
<font color="black">  16. This module contains builtin handlers for events emitted by botocore.</font>
<font color="green">  17. &quot;&quot;&quot;</font>
<font color="black">  18. </font>
<font color="green">  19. import base64</font>
<font color="green">  20. import logging</font>
<font color="green">  21. import xml.etree.cElementTree</font>
<font color="green">  22. import copy</font>
<font color="green">  23. import re</font>
<font color="green">  24. import warnings</font>
<font color="green">  25. import uuid</font>
<font color="black">  26. </font>
<font color="green">  27. from botocore.compat import unquote, json, six, unquote_str, \</font>
<font color="black">  28.     ensure_bytes, get_md5, MD5_AVAILABLE, OrderedDict</font>
<font color="green">  29. from botocore.docs.utils import AutoPopulatedParam</font>
<font color="green">  30. from botocore.docs.utils import HideParamFromOperations</font>
<font color="green">  31. from botocore.docs.utils import AppendParamDocumentation</font>
<font color="green">  32. from botocore.signers import add_generate_presigned_url</font>
<font color="green">  33. from botocore.signers import add_generate_presigned_post</font>
<font color="green">  34. from botocore.signers import add_generate_db_auth_token</font>
<font color="green">  35. from botocore.exceptions import ParamValidationError</font>
<font color="green">  36. from botocore.exceptions import AliasConflictParameterError</font>
<font color="green">  37. from botocore.exceptions import UnsupportedTLSVersionWarning</font>
<font color="green">  38. from botocore.utils import percent_encode, SAFE_CHARS</font>
<font color="green">  39. from botocore.utils import switch_host_with_param</font>
<font color="black">  40. </font>
<font color="green">  41. from botocore import retryhandler</font>
<font color="green">  42. from botocore import utils</font>
<font color="green">  43. from botocore import translate</font>
<font color="green">  44. import botocore</font>
<font color="green">  45. import botocore.auth</font>
<font color="black">  46. </font>
<font color="black">  47. </font>
<font color="green">  48. logger = logging.getLogger(__name__)</font>
<font color="black">  49. </font>
<font color="green">  50. REGISTER_FIRST = object()</font>
<font color="green">  51. REGISTER_LAST = object()</font>
<font color="black">  52. # From the S3 docs:</font>
<font color="black">  53. # The rules for bucket names in the US Standard region allow bucket names</font>
<font color="black">  54. # to be as long as 255 characters, and bucket names can contain any</font>
<font color="black">  55. # combination of uppercase letters, lowercase letters, numbers, periods</font>
<font color="black">  56. # (.), hyphens (-), and underscores (_).</font>
<font color="green">  57. VALID_BUCKET = re.compile(r'^[a-zA-Z0-9.\-_]{1,255}$')</font>
<font color="green">  58. VERSION_ID_SUFFIX = re.compile(r'\?versionId=[^\s]+$')</font>
<font color="black">  59. </font>
<font color="green">  60. SERVICE_NAME_ALIASES = {</font>
<font color="green">  61.     'runtime.sagemaker': 'sagemaker-runtime'</font>
<font color="black">  62. }</font>
<font color="black">  63. </font>
<font color="black">  64. </font>
<font color="green">  65. def handle_service_name_alias(service_name, **kwargs):</font>
<font color="green">  66.     return SERVICE_NAME_ALIASES.get(service_name, service_name)</font>
<font color="black">  67. </font>
<font color="black">  68. </font>
<font color="green">  69. def check_for_200_error(response, **kwargs):</font>
<font color="black">  70.     # From: http://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectCOPY.html</font>
<font color="black">  71.     # There are two opportunities for a copy request to return an error. One</font>
<font color="black">  72.     # can occur when Amazon S3 receives the copy request and the other can</font>
<font color="black">  73.     # occur while Amazon S3 is copying the files. If the error occurs before</font>
<font color="black">  74.     # the copy operation starts, you receive a standard Amazon S3 error. If the</font>
<font color="black">  75.     # error occurs during the copy operation, the error response is embedded in</font>
<font color="black">  76.     # the 200 OK response. This means that a 200 OK response can contain either</font>
<font color="black">  77.     # a success or an error. Make sure to design your application to parse the</font>
<font color="black">  78.     # contents of the response and handle it appropriately.</font>
<font color="black">  79.     #</font>
<font color="black">  80.     # So this handler checks for this case.  Even though the server sends a</font>
<font color="black">  81.     # 200 response, conceptually this should be handled exactly like a</font>
<font color="black">  82.     # 500 response (with respect to raising exceptions, retries, etc.)</font>
<font color="black">  83.     # We're connected *before* all the other retry logic handlers, so as long</font>
<font color="black">  84.     # as we switch the error code to 500, we'll retry the error as expected.</font>
<font color="red">  85.     if response is None:</font>
<font color="black">  86.         # A None response can happen if an exception is raised while</font>
<font color="black">  87.         # trying to retrieve the response.  See Endpoint._get_response().</font>
<font color="red">  88.         return</font>
<font color="red">  89.     http_response, parsed = response</font>
<font color="red">  90.     if _looks_like_special_case_error(http_response):</font>
<font color="red">  91.         logger.debug(&quot;Error found for response with 200 status code, &quot;</font>
<font color="black">  92.                      &quot;errors: %s, changing status code to &quot;</font>
<font color="red">  93.                      &quot;500.&quot;, parsed)</font>
<font color="red">  94.         http_response.status_code = 500</font>
<font color="black">  95. </font>
<font color="black">  96. </font>
<font color="green">  97. def _looks_like_special_case_error(http_response):</font>
<font color="red">  98.     if http_response.status_code == 200:</font>
<font color="red">  99.         parser = xml.etree.cElementTree.XMLParser(</font>
<font color="red"> 100.             target=xml.etree.cElementTree.TreeBuilder(),</font>
<font color="red"> 101.             encoding='utf-8')</font>
<font color="red"> 102.         parser.feed(http_response.content)</font>
<font color="red"> 103.         root = parser.close()</font>
<font color="red"> 104.         if root.tag == 'Error':</font>
<font color="red"> 105.             return True</font>
<font color="red"> 106.     return False</font>
<font color="black"> 107. </font>
<font color="black"> 108. </font>
<font color="green"> 109. def set_operation_specific_signer(context, signing_name, **kwargs):</font>
<font color="black"> 110.     &quot;&quot;&quot; Choose the operation-specific signer.</font>
<font color="black"> 111. </font>
<font color="black"> 112.     Individual operations may have a different auth type than the service as a</font>
<font color="black"> 113.     whole. This will most often manifest as operations that should not be</font>
<font color="black"> 114.     authenticated at all, but can include other auth modes such as sigv4</font>
<font color="black"> 115.     without body signing.</font>
<font color="black"> 116.     &quot;&quot;&quot;</font>
<font color="green"> 117.     auth_type = context.get('auth_type')</font>
<font color="black"> 118. </font>
<font color="black"> 119.     # Auth type will be None if the operation doesn't have a configured auth</font>
<font color="black"> 120.     # type.</font>
<font color="green"> 121.     if not auth_type:</font>
<font color="green"> 122.         return</font>
<font color="black"> 123. </font>
<font color="black"> 124.     # Auth type will be the string value 'none' if the operation should not</font>
<font color="black"> 125.     # be signed at all.</font>
<font color="red"> 126.     if auth_type == 'none':</font>
<font color="red"> 127.         return botocore.UNSIGNED</font>
<font color="black"> 128. </font>
<font color="red"> 129.     if auth_type.startswith('v4'):</font>
<font color="red"> 130.         signature_version = 'v4'</font>
<font color="red"> 131.         if signing_name == 's3':</font>
<font color="red"> 132.             signature_version = 's3v4'</font>
<font color="black"> 133. </font>
<font color="black"> 134.         # If the operation needs an unsigned body, we set additional context</font>
<font color="black"> 135.         # allowing the signer to be aware of this.</font>
<font color="red"> 136.         if auth_type == 'v4-unsigned-body':</font>
<font color="red"> 137.             context['payload_signing_enabled'] = False</font>
<font color="black"> 138. </font>
<font color="red"> 139.         return signature_version</font>
<font color="black"> 140. </font>
<font color="black"> 141. </font>
<font color="green"> 142. def decode_console_output(parsed, **kwargs):</font>
<font color="red"> 143.     if 'Output' in parsed:</font>
<font color="red"> 144.         try:</font>
<font color="black"> 145.             # We're using 'replace' for errors because it is</font>
<font color="black"> 146.             # possible that console output contains non string</font>
<font color="black"> 147.             # chars we can't utf-8 decode.</font>
<font color="red"> 148.             value = base64.b64decode(six.b(parsed['Output'])).decode(</font>
<font color="red"> 149.                 'utf-8', 'replace')</font>
<font color="red"> 150.             parsed['Output'] = value</font>
<font color="red"> 151.         except (ValueError, TypeError, AttributeError):</font>
<font color="red"> 152.             logger.debug('Error decoding base64', exc_info=True)</font>
<font color="black"> 153. </font>
<font color="black"> 154. </font>
<font color="green"> 155. def generate_idempotent_uuid(params, model, **kwargs):</font>
<font color="green"> 156.     for name in model.idempotent_members:</font>
<font color="red"> 157.         if name not in params:</font>
<font color="red"> 158.             params[name] = str(uuid.uuid4())</font>
<font color="red"> 159.             logger.debug(&quot;injecting idempotency token (%s) into param '%s'.&quot; %</font>
<font color="red"> 160.                          (params[name], name))</font>
<font color="black"> 161. </font>
<font color="black"> 162. </font>
<font color="green"> 163. def decode_quoted_jsondoc(value):</font>
<font color="red"> 164.     try:</font>
<font color="red"> 165.         value = json.loads(unquote(value))</font>
<font color="red"> 166.     except (ValueError, TypeError):</font>
<font color="red"> 167.         logger.debug('Error loading quoted JSON', exc_info=True)</font>
<font color="red"> 168.     return value</font>
<font color="black"> 169. </font>
<font color="black"> 170. </font>
<font color="green"> 171. def json_decode_template_body(parsed, **kwargs):</font>
<font color="red"> 172.     if 'TemplateBody' in parsed:</font>
<font color="red"> 173.         try:</font>
<font color="red"> 174.             value = json.loads(</font>
<font color="red"> 175.                 parsed['TemplateBody'], object_pairs_hook=OrderedDict)</font>
<font color="red"> 176.             parsed['TemplateBody'] = value</font>
<font color="red"> 177.         except (ValueError, TypeError):</font>
<font color="red"> 178.             logger.debug('error loading JSON', exc_info=True)</font>
<font color="black"> 179. </font>
<font color="black"> 180. </font>
<font color="green"> 181. def calculate_md5(params, **kwargs):</font>
<font color="green"> 182.     request_dict = params</font>
<font color="green"> 183.     if request_dict['body'] and 'Content-MD5' not in params['headers']:</font>
<font color="green"> 184.         body = request_dict['body']</font>
<font color="green"> 185.         if isinstance(body, (bytes, bytearray)):</font>
<font color="green"> 186.             binary_md5 = _calculate_md5_from_bytes(body)</font>
<font color="black"> 187.         else:</font>
<font color="red"> 188.             binary_md5 = _calculate_md5_from_file(body)</font>
<font color="green"> 189.         base64_md5 = base64.b64encode(binary_md5).decode('ascii')</font>
<font color="green"> 190.         params['headers']['Content-MD5'] = base64_md5</font>
<font color="black"> 191. </font>
<font color="black"> 192. </font>
<font color="green"> 193. def _calculate_md5_from_bytes(body_bytes):</font>
<font color="green"> 194.     md5 = get_md5(body_bytes)</font>
<font color="green"> 195.     return md5.digest()</font>
<font color="black"> 196. </font>
<font color="black"> 197. </font>
<font color="green"> 198. def _calculate_md5_from_file(fileobj):</font>
<font color="red"> 199.     start_position = fileobj.tell()</font>
<font color="red"> 200.     md5 = get_md5()</font>
<font color="red"> 201.     for chunk in iter(lambda: fileobj.read(1024 * 1024), b''):</font>
<font color="red"> 202.         md5.update(chunk)</font>
<font color="red"> 203.     fileobj.seek(start_position)</font>
<font color="red"> 204.     return md5.digest()</font>
<font color="black"> 205. </font>
<font color="black"> 206. </font>
<font color="green"> 207. def conditionally_calculate_md5(params, context, request_signer, **kwargs):</font>
<font color="black"> 208.     &quot;&quot;&quot;Only add a Content-MD5 if the system supports it.&quot;&quot;&quot;</font>
<font color="red"> 209.     if MD5_AVAILABLE:</font>
<font color="red"> 210.         calculate_md5(params, **kwargs)</font>
<font color="black"> 211. </font>
<font color="black"> 212. </font>
<font color="green"> 213. def validate_bucket_name(params, **kwargs):</font>
<font color="green"> 214.     if 'Bucket' not in params:</font>
<font color="green"> 215.         return</font>
<font color="green"> 216.     bucket = params['Bucket']</font>
<font color="green"> 217.     if VALID_BUCKET.search(bucket) is None:</font>
<font color="black"> 218.         error_msg = (</font>
<font color="red"> 219.             'Invalid bucket name &quot;%s&quot;: Bucket name must match '</font>
<font color="red"> 220.             'the regex &quot;%s&quot;' % (bucket, VALID_BUCKET.pattern))</font>
<font color="red"> 221.         raise ParamValidationError(report=error_msg)</font>
<font color="black"> 222. </font>
<font color="black"> 223. </font>
<font color="green"> 224. def sse_md5(params, **kwargs):</font>
<font color="black"> 225.     &quot;&quot;&quot;</font>
<font color="black"> 226.     S3 server-side encryption requires the encryption key to be sent to the</font>
<font color="black"> 227.     server base64 encoded, as well as a base64-encoded MD5 hash of the</font>
<font color="black"> 228.     encryption key. This handler does both if the MD5 has not been set by</font>
<font color="black"> 229.     the caller.</font>
<font color="black"> 230.     &quot;&quot;&quot;</font>
<font color="red"> 231.     _sse_md5(params, 'SSECustomer')</font>
<font color="black"> 232. </font>
<font color="black"> 233. </font>
<font color="green"> 234. def copy_source_sse_md5(params, **kwargs):</font>
<font color="black"> 235.     &quot;&quot;&quot;</font>
<font color="black"> 236.     S3 server-side encryption requires the encryption key to be sent to the</font>
<font color="black"> 237.     server base64 encoded, as well as a base64-encoded MD5 hash of the</font>
<font color="black"> 238.     encryption key. This handler does both if the MD5 has not been set by</font>
<font color="black"> 239.     the caller specifically if the parameter is for the copy-source sse-c key.</font>
<font color="black"> 240.     &quot;&quot;&quot;</font>
<font color="red"> 241.     _sse_md5(params, 'CopySourceSSECustomer')</font>
<font color="black"> 242. </font>
<font color="black"> 243. </font>
<font color="green"> 244. def _sse_md5(params, sse_member_prefix='SSECustomer'):</font>
<font color="red"> 245.     if not _needs_s3_sse_customization(params, sse_member_prefix):</font>
<font color="red"> 246.         return</font>
<font color="black"> 247. </font>
<font color="red"> 248.     sse_key_member = sse_member_prefix + 'Key'</font>
<font color="red"> 249.     sse_md5_member = sse_member_prefix + 'KeyMD5'</font>
<font color="red"> 250.     key_as_bytes = params[sse_key_member]</font>
<font color="red"> 251.     if isinstance(key_as_bytes, six.text_type):</font>
<font color="red"> 252.         key_as_bytes = key_as_bytes.encode('utf-8')</font>
<font color="red"> 253.     key_md5_str = base64.b64encode(</font>
<font color="red"> 254.         get_md5(key_as_bytes).digest()).decode('utf-8')</font>
<font color="red"> 255.     key_b64_encoded = base64.b64encode(key_as_bytes).decode('utf-8')</font>
<font color="red"> 256.     params[sse_key_member] = key_b64_encoded</font>
<font color="red"> 257.     params[sse_md5_member] = key_md5_str</font>
<font color="black"> 258. </font>
<font color="black"> 259. </font>
<font color="green"> 260. def _needs_s3_sse_customization(params, sse_member_prefix):</font>
<font color="red"> 261.     return (params.get(sse_member_prefix + 'Key') is not None and</font>
<font color="red"> 262.             sse_member_prefix + 'KeyMD5' not in params)</font>
<font color="black"> 263. </font>
<font color="black"> 264. </font>
<font color="black"> 265. # NOTE: Retries get registered in two separate places in the botocore</font>
<font color="black"> 266. # code: once when creating the client and once when you load the service</font>
<font color="black"> 267. # model from the session. While at first this handler seems unneeded, it</font>
<font color="black"> 268. # would be a breaking change for the AWS CLI to have it removed. This is</font>
<font color="black"> 269. # because it relies on the service model from the session to create commands</font>
<font color="black"> 270. # and this handler respects operation granular retry logic while the client</font>
<font color="black"> 271. # one does not. If this is ever to be removed the handler, the client</font>
<font color="black"> 272. # will have to respect per-operation level retry configuration.</font>
<font color="green"> 273. def register_retries_for_service(service_data, session,</font>
<font color="black"> 274.                                  service_name, **kwargs):</font>
<font color="red"> 275.     loader = session.get_component('data_loader')</font>
<font color="red"> 276.     endpoint_prefix = service_data.get('metadata', {}).get('endpointPrefix')</font>
<font color="red"> 277.     if endpoint_prefix is None:</font>
<font color="red"> 278.         logger.debug(&quot;Not registering retry handlers, could not endpoint &quot;</font>
<font color="red"> 279.                      &quot;prefix from model for service %s&quot;, service_name)</font>
<font color="red"> 280.         return</font>
<font color="red"> 281.     config = _load_retry_config(loader, endpoint_prefix)</font>
<font color="red"> 282.     if not config:</font>
<font color="red"> 283.         return</font>
<font color="red"> 284.     logger.debug(&quot;Registering retry handlers for service: %s&quot;, service_name)</font>
<font color="red"> 285.     handler = retryhandler.create_retry_handler(</font>
<font color="red"> 286.         config, endpoint_prefix)</font>
<font color="red"> 287.     unique_id = 'retry-config-%s' % endpoint_prefix</font>
<font color="red"> 288.     session.register('needs-retry.%s' % endpoint_prefix,</font>
<font color="red"> 289.                      handler, unique_id=unique_id)</font>
<font color="red"> 290.     _register_for_operations(config, session,</font>
<font color="red"> 291.                              service_name=endpoint_prefix)</font>
<font color="black"> 292. </font>
<font color="black"> 293. </font>
<font color="green"> 294. def _load_retry_config(loader, endpoint_prefix):</font>
<font color="red"> 295.     original_config = loader.load_data('_retry')</font>
<font color="red"> 296.     retry_config = translate.build_retry_config(</font>
<font color="red"> 297.         endpoint_prefix, original_config['retry'],</font>
<font color="red"> 298.         original_config.get('definitions', {}))</font>
<font color="red"> 299.     return retry_config</font>
<font color="black"> 300. </font>
<font color="black"> 301. </font>
<font color="green"> 302. def _register_for_operations(config, session, service_name):</font>
<font color="black"> 303.     # There's certainly a tradeoff for registering the retry config</font>
<font color="black"> 304.     # for the operations when the service is created.  In practice,</font>
<font color="black"> 305.     # there aren't a whole lot of per operation retry configs so</font>
<font color="black"> 306.     # this is ok for now.</font>
<font color="red"> 307.     for key in config:</font>
<font color="red"> 308.         if key == '__default__':</font>
<font color="red"> 309.             continue</font>
<font color="red"> 310.         handler = retryhandler.create_retry_handler(config, key)</font>
<font color="red"> 311.         unique_id = 'retry-config-%s-%s' % (service_name, key)</font>
<font color="red"> 312.         session.register('needs-retry.%s.%s' % (service_name, key),</font>
<font color="red"> 313.                          handler, unique_id=unique_id)</font>
<font color="black"> 314. </font>
<font color="black"> 315. </font>
<font color="green"> 316. def disable_signing(**kwargs):</font>
<font color="black"> 317.     &quot;&quot;&quot;</font>
<font color="black"> 318.     This handler disables request signing by setting the signer</font>
<font color="black"> 319.     name to a special sentinel value.</font>
<font color="black"> 320.     &quot;&quot;&quot;</font>
<font color="red"> 321.     return botocore.UNSIGNED</font>
<font color="black"> 322. </font>
<font color="black"> 323. </font>
<font color="green"> 324. def add_expect_header(model, params, **kwargs):</font>
<font color="green"> 325.     if model.http.get('method', '') not in ['PUT', 'POST']:</font>
<font color="green"> 326.         return</font>
<font color="green"> 327.     if 'body' in params:</font>
<font color="green"> 328.         body = params['body']</font>
<font color="green"> 329.         if hasattr(body, 'read'):</font>
<font color="black"> 330.             # Any file like object will use an expect 100-continue</font>
<font color="black"> 331.             # header regardless of size.</font>
<font color="red"> 332.             logger.debug(&quot;Adding expect 100 continue header to request.&quot;)</font>
<font color="red"> 333.             params['headers']['Expect'] = '100-continue'</font>
<font color="black"> 334. </font>
<font color="black"> 335. </font>
<font color="green"> 336. def document_copy_source_form(section, event_name, **kwargs):</font>
<font color="red"> 337.     if 'request-example' in event_name:</font>
<font color="red"> 338.         parent = section.get_section('structure-value')</font>
<font color="red"> 339.         param_line = parent.get_section('CopySource')</font>
<font color="red"> 340.         value_portion = param_line.get_section('member-value')</font>
<font color="red"> 341.         value_portion.clear_text()</font>
<font color="red"> 342.         value_portion.write(&quot;'string' or {'Bucket': 'string', &quot;</font>
<font color="black"> 343.                             &quot;'Key': 'string', 'VersionId': 'string'}&quot;)</font>
<font color="red"> 344.     elif 'request-params' in event_name:</font>
<font color="red"> 345.         param_section = section.get_section('CopySource')</font>
<font color="red"> 346.         type_section = param_section.get_section('param-type')</font>
<font color="red"> 347.         type_section.clear_text()</font>
<font color="red"> 348.         type_section.write(':type CopySource: str or dict')</font>
<font color="red"> 349.         doc_section = param_section.get_section('param-documentation')</font>
<font color="red"> 350.         doc_section.clear_text()</font>
<font color="red"> 351.         doc_section.write(</font>
<font color="red"> 352.             &quot;The name of the source bucket, key name of the source object, &quot;</font>
<font color="black"> 353.             &quot;and optional version ID of the source object.  You can either &quot;</font>
<font color="black"> 354.             &quot;provide this value as a string or a dictionary.  The &quot;</font>
<font color="black"> 355.             &quot;string form is {bucket}/{key} or &quot;</font>
<font color="black"> 356.             &quot;{bucket}/{key}?versionId={versionId} if you want to copy a &quot;</font>
<font color="black"> 357.             &quot;specific version.  You can also provide this value as a &quot;</font>
<font color="black"> 358.             &quot;dictionary.  The dictionary format is recommended over &quot;</font>
<font color="black"> 359.             &quot;the string format because it is more explicit.  The dictionary &quot;</font>
<font color="black"> 360.             &quot;format is: {'Bucket': 'bucket', 'Key': 'key', 'VersionId': 'id'}.&quot;</font>
<font color="black"> 361.             &quot;  Note that the VersionId key is optional and may be omitted.&quot;</font>
<font color="black"> 362.         )</font>
<font color="black"> 363. </font>
<font color="black"> 364. </font>
<font color="green"> 365. def handle_copy_source_param(params, **kwargs):</font>
<font color="black"> 366.     &quot;&quot;&quot;Convert CopySource param for CopyObject/UploadPartCopy.</font>
<font color="black"> 367. </font>
<font color="black"> 368.     This handler will deal with two cases:</font>
<font color="black"> 369. </font>
<font color="black"> 370.         * CopySource provided as a string.  We'll make a best effort</font>
<font color="black"> 371.           to URL encode the key name as required.  This will require</font>
<font color="black"> 372.           parsing the bucket and version id from the CopySource value</font>
<font color="black"> 373.           and only encoding the key.</font>
<font color="black"> 374.         * CopySource provided as a dict.  In this case we're</font>
<font color="black"> 375.           explicitly given the Bucket, Key, and VersionId so we're</font>
<font color="black"> 376.           able to encode the key and ensure this value is serialized</font>
<font color="black"> 377.           and correctly sent to S3.</font>
<font color="black"> 378. </font>
<font color="black"> 379.     &quot;&quot;&quot;</font>
<font color="red"> 380.     source = params.get('CopySource')</font>
<font color="red"> 381.     if source is None:</font>
<font color="black"> 382.         # The call will eventually fail but we'll let the</font>
<font color="black"> 383.         # param validator take care of this.  It will</font>
<font color="black"> 384.         # give a better error message.</font>
<font color="red"> 385.         return</font>
<font color="red"> 386.     if isinstance(source, six.string_types):</font>
<font color="red"> 387.         params['CopySource'] = _quote_source_header(source)</font>
<font color="red"> 388.     elif isinstance(source, dict):</font>
<font color="red"> 389.         params['CopySource'] = _quote_source_header_from_dict(source)</font>
<font color="black"> 390. </font>
<font color="black"> 391. </font>
<font color="green"> 392. def _quote_source_header_from_dict(source_dict):</font>
<font color="red"> 393.     try:</font>
<font color="red"> 394.         bucket = source_dict['Bucket']</font>
<font color="red"> 395.         key = percent_encode(source_dict['Key'], safe=SAFE_CHARS + '/')</font>
<font color="red"> 396.         version_id = source_dict.get('VersionId')</font>
<font color="red"> 397.     except KeyError as e:</font>
<font color="red"> 398.         raise ParamValidationError(</font>
<font color="red"> 399.             report='Missing required parameter: %s' % str(e))</font>
<font color="red"> 400.     final = '%s/%s' % (bucket, key)</font>
<font color="red"> 401.     if version_id is not None:</font>
<font color="red"> 402.         final += '?versionId=%s' % version_id</font>
<font color="red"> 403.     return final</font>
<font color="black"> 404. </font>
<font color="black"> 405. </font>
<font color="green"> 406. def _quote_source_header(value):</font>
<font color="red"> 407.     result = VERSION_ID_SUFFIX.search(value)</font>
<font color="red"> 408.     if result is None:</font>
<font color="red"> 409.         return percent_encode(value, safe=SAFE_CHARS + '/')</font>
<font color="black"> 410.     else:</font>
<font color="red"> 411.         first, version_id = value[:result.start()], value[result.start():]</font>
<font color="red"> 412.         return percent_encode(first, safe=SAFE_CHARS + '/') + version_id</font>
<font color="black"> 413. </font>
<font color="black"> 414. </font>
<font color="green"> 415. def _get_cross_region_presigned_url(request_signer, request_dict, model,</font>
<font color="black"> 416.                                     source_region, destination_region):</font>
<font color="black"> 417.     # The better way to do this is to actually get the</font>
<font color="black"> 418.     # endpoint_resolver and get the endpoint_url given the</font>
<font color="black"> 419.     # source region.  In this specific case, we know that</font>
<font color="black"> 420.     # we can safely replace the dest region with the source</font>
<font color="black"> 421.     # region because of the supported EC2 regions, but in</font>
<font color="black"> 422.     # general this is not a safe assumption to make.</font>
<font color="black"> 423.     # I think eventually we should try to plumb through something</font>
<font color="black"> 424.     # that allows us to resolve endpoints from regions.</font>
<font color="red"> 425.     request_dict_copy = copy.deepcopy(request_dict)</font>
<font color="red"> 426.     request_dict_copy['body']['DestinationRegion'] = destination_region</font>
<font color="red"> 427.     request_dict_copy['url'] = request_dict['url'].replace(</font>
<font color="red"> 428.         destination_region, source_region)</font>
<font color="red"> 429.     request_dict_copy['method'] = 'GET'</font>
<font color="red"> 430.     request_dict_copy['headers'] = {}</font>
<font color="red"> 431.     return request_signer.generate_presigned_url(</font>
<font color="red"> 432.         request_dict_copy, region_name=source_region,</font>
<font color="red"> 433.         operation_name=model.name)</font>
<font color="black"> 434. </font>
<font color="black"> 435. </font>
<font color="green"> 436. def _get_presigned_url_source_and_destination_regions(request_signer, params):</font>
<font color="black"> 437.     # Gets the source and destination regions to be used</font>
<font color="red"> 438.     destination_region = request_signer._region_name</font>
<font color="red"> 439.     source_region = params.get('SourceRegion')</font>
<font color="red"> 440.     return source_region, destination_region</font>
<font color="black"> 441. </font>
<font color="black"> 442. </font>
<font color="green"> 443. def inject_presigned_url_ec2(params, request_signer, model, **kwargs):</font>
<font color="black"> 444.     # The customer can still provide this, so we should pass if they do.</font>
<font color="red"> 445.     if 'PresignedUrl' in params['body']:</font>
<font color="red"> 446.         return</font>
<font color="red"> 447.     src, dest = _get_presigned_url_source_and_destination_regions(</font>
<font color="red"> 448.         request_signer, params['body'])</font>
<font color="red"> 449.     url = _get_cross_region_presigned_url(</font>
<font color="red"> 450.         request_signer, params, model, src, dest)</font>
<font color="red"> 451.     params['body']['PresignedUrl'] = url</font>
<font color="black"> 452.     # EC2 Requires that the destination region be sent over the wire in</font>
<font color="black"> 453.     # addition to the source region.</font>
<font color="red"> 454.     params['body']['DestinationRegion'] = dest</font>
<font color="black"> 455. </font>
<font color="black"> 456. </font>
<font color="green"> 457. def inject_presigned_url_rds(params, request_signer, model, **kwargs):</font>
<font color="black"> 458.     # SourceRegion is not required for RDS operations, so it's possible that</font>
<font color="black"> 459.     # it isn't set. In that case it's probably a local copy so we don't need</font>
<font color="black"> 460.     # to do anything else.</font>
<font color="red"> 461.     if 'SourceRegion' not in params['body']:</font>
<font color="red"> 462.         return</font>
<font color="black"> 463. </font>
<font color="red"> 464.     src, dest = _get_presigned_url_source_and_destination_regions(</font>
<font color="red"> 465.         request_signer, params['body'])</font>
<font color="black"> 466. </font>
<font color="black"> 467.     # Since SourceRegion isn't actually modeled for RDS, it needs to be</font>
<font color="black"> 468.     # removed from the request params before we send the actual request.</font>
<font color="red"> 469.     del params['body']['SourceRegion']</font>
<font color="black"> 470. </font>
<font color="red"> 471.     if 'PreSignedUrl' in params['body']:</font>
<font color="red"> 472.         return</font>
<font color="black"> 473. </font>
<font color="red"> 474.     url = _get_cross_region_presigned_url(</font>
<font color="red"> 475.         request_signer, params, model, src, dest)</font>
<font color="red"> 476.     params['body']['PreSignedUrl'] = url</font>
<font color="black"> 477. </font>
<font color="black"> 478. </font>
<font color="green"> 479. def json_decode_policies(parsed, model, **kwargs):</font>
<font color="black"> 480.     # Any time an IAM operation returns a policy document</font>
<font color="black"> 481.     # it is a string that is json that has been urlencoded,</font>
<font color="black"> 482.     # i.e urlencode(json.dumps(policy_document)).</font>
<font color="black"> 483.     # To give users something more useful, we will urldecode</font>
<font color="black"> 484.     # this value and json.loads() the result so that they have</font>
<font color="black"> 485.     # the policy document as a dictionary.</font>
<font color="red"> 486.     output_shape = model.output_shape</font>
<font color="red"> 487.     if output_shape is not None:</font>
<font color="red"> 488.         _decode_policy_types(parsed, model.output_shape)</font>
<font color="black"> 489. </font>
<font color="black"> 490. </font>
<font color="green"> 491. def _decode_policy_types(parsed, shape):</font>
<font color="black"> 492.     # IAM consistently uses the policyDocumentType shape to indicate</font>
<font color="black"> 493.     # strings that have policy documents.</font>
<font color="red"> 494.     shape_name = 'policyDocumentType'</font>
<font color="red"> 495.     if shape.type_name == 'structure':</font>
<font color="red"> 496.         for member_name, member_shape in shape.members.items():</font>
<font color="red"> 497.             if member_shape.type_name == 'string' and \</font>
<font color="red"> 498.                     member_shape.name == shape_name and \</font>
<font color="red"> 499.                     member_name in parsed:</font>
<font color="red"> 500.                 parsed[member_name] = decode_quoted_jsondoc(</font>
<font color="red"> 501.                     parsed[member_name])</font>
<font color="red"> 502.             elif member_name in parsed:</font>
<font color="red"> 503.                 _decode_policy_types(parsed[member_name], member_shape)</font>
<font color="red"> 504.     if shape.type_name == 'list':</font>
<font color="red"> 505.         shape_member = shape.member</font>
<font color="red"> 506.         for item in parsed:</font>
<font color="red"> 507.             _decode_policy_types(item, shape_member)</font>
<font color="black"> 508. </font>
<font color="black"> 509. </font>
<font color="green"> 510. def parse_get_bucket_location(parsed, http_response, **kwargs):</font>
<font color="black"> 511.     # s3.GetBucketLocation cannot be modeled properly.  To</font>
<font color="black"> 512.     # account for this we just manually parse the XML document.</font>
<font color="black"> 513.     # The &quot;parsed&quot; passed in only has the ResponseMetadata</font>
<font color="black"> 514.     # filled out.  This handler will fill in the LocationConstraint</font>
<font color="black"> 515.     # value.</font>
<font color="red"> 516.     if 'LocationConstraint' in parsed:</font>
<font color="black"> 517.         # Response already set - a stub?</font>
<font color="red"> 518.         return</font>
<font color="red"> 519.     response_body = http_response.content</font>
<font color="red"> 520.     parser = xml.etree.cElementTree.XMLParser(</font>
<font color="red"> 521.         target=xml.etree.cElementTree.TreeBuilder(),</font>
<font color="red"> 522.         encoding='utf-8')</font>
<font color="red"> 523.     parser.feed(response_body)</font>
<font color="red"> 524.     root = parser.close()</font>
<font color="red"> 525.     region = root.text</font>
<font color="red"> 526.     parsed['LocationConstraint'] = region</font>
<font color="black"> 527. </font>
<font color="black"> 528. </font>
<font color="green"> 529. def base64_encode_user_data(params, **kwargs):</font>
<font color="red"> 530.     if 'UserData' in params:</font>
<font color="red"> 531.         if isinstance(params['UserData'], six.text_type):</font>
<font color="black"> 532.             # Encode it to bytes if it is text.</font>
<font color="red"> 533.             params['UserData'] = params['UserData'].encode('utf-8')</font>
<font color="red"> 534.         params['UserData'] = base64.b64encode(</font>
<font color="red"> 535.             params['UserData']).decode('utf-8')</font>
<font color="black"> 536. </font>
<font color="black"> 537. </font>
<font color="green"> 538. def document_base64_encoding(param):</font>
<font color="green"> 539.     description = ('**This value will be base64 encoded automatically. Do '</font>
<font color="black"> 540.                    'not base64 encode this value prior to performing the '</font>
<font color="black"> 541.                    'operation.**')</font>
<font color="green"> 542.     append = AppendParamDocumentation(param, description)</font>
<font color="green"> 543.     return append.append_documentation</font>
<font color="black"> 544. </font>
<font color="black"> 545. </font>
<font color="green"> 546. def validate_ascii_metadata(params, **kwargs):</font>
<font color="black"> 547.     &quot;&quot;&quot;Verify S3 Metadata only contains ascii characters.</font>
<font color="black"> 548. </font>
<font color="black"> 549.     From: http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html</font>
<font color="black"> 550. </font>
<font color="black"> 551.     &quot;Amazon S3 stores user-defined metadata in lowercase. Each name, value pair</font>
<font color="black"> 552.     must conform to US-ASCII when using REST and UTF-8 when using SOAP or</font>
<font color="black"> 553.     browser-based uploads via POST.&quot;</font>
<font color="black"> 554. </font>
<font color="black"> 555.     &quot;&quot;&quot;</font>
<font color="red"> 556.     metadata = params.get('Metadata')</font>
<font color="red"> 557.     if not metadata or not isinstance(metadata, dict):</font>
<font color="black"> 558.         # We have to at least type check the metadata as a dict type</font>
<font color="black"> 559.         # because this handler is called before param validation.</font>
<font color="black"> 560.         # We'll go ahead and return because the param validator will</font>
<font color="black"> 561.         # give a descriptive error message for us.</font>
<font color="black"> 562.         # We might need a post-param validation event.</font>
<font color="red"> 563.         return</font>
<font color="red"> 564.     for key, value in metadata.items():</font>
<font color="red"> 565.         try:</font>
<font color="red"> 566.             key.encode('ascii')</font>
<font color="red"> 567.             value.encode('ascii')</font>
<font color="red"> 568.         except UnicodeEncodeError as e:</font>
<font color="black"> 569.             error_msg = (</font>
<font color="red"> 570.                 'Non ascii characters found in S3 metadata '</font>
<font color="black"> 571.                 'for key &quot;%s&quot;, value: &quot;%s&quot;.  \nS3 metadata can only '</font>
<font color="red"> 572.                 'contain ASCII characters. ' % (key, value)</font>
<font color="black"> 573.             )</font>
<font color="red"> 574.             raise ParamValidationError(</font>
<font color="red"> 575.                 report=error_msg)</font>
<font color="black"> 576. </font>
<font color="black"> 577. </font>
<font color="green"> 578. def fix_route53_ids(params, model, **kwargs):</font>
<font color="black"> 579.     &quot;&quot;&quot;</font>
<font color="black"> 580.     Check for and split apart Route53 resource IDs, setting</font>
<font color="black"> 581.     only the last piece. This allows the output of one operation</font>
<font color="black"> 582.     (e.g. ``'foo/1234'``) to be used as input in another</font>
<font color="black"> 583.     operation (e.g. it expects just ``'1234'``).</font>
<font color="black"> 584.     &quot;&quot;&quot;</font>
<font color="red"> 585.     input_shape = model.input_shape</font>
<font color="red"> 586.     if not input_shape or not hasattr(input_shape, 'members'):</font>
<font color="red"> 587.         return</font>
<font color="black"> 588. </font>
<font color="red"> 589.     members = [name for (name, shape) in input_shape.members.items()</font>
<font color="red"> 590.                if shape.name in ['ResourceId', 'DelegationSetId']]</font>
<font color="black"> 591. </font>
<font color="red"> 592.     for name in members:</font>
<font color="red"> 593.         if name in params:</font>
<font color="red"> 594.             orig_value = params[name]</font>
<font color="red"> 595.             params[name] = orig_value.split('/')[-1]</font>
<font color="red"> 596.             logger.debug('%s %s -&gt; %s', name, orig_value, params[name])</font>
<font color="black"> 597. </font>
<font color="black"> 598. </font>
<font color="green"> 599. def inject_account_id(params, **kwargs):</font>
<font color="red"> 600.     if params.get('accountId') is None:</font>
<font color="black"> 601.         # Glacier requires accountId, but allows you</font>
<font color="black"> 602.         # to specify '-' for the current owners account.</font>
<font color="black"> 603.         # We add this default value if the user does not</font>
<font color="black"> 604.         # provide the accountId as a convenience.</font>
<font color="red"> 605.         params['accountId'] = '-'</font>
<font color="black"> 606. </font>
<font color="black"> 607. </font>
<font color="green"> 608. def add_glacier_version(model, params, **kwargs):</font>
<font color="red"> 609.     request_dict = params</font>
<font color="red"> 610.     request_dict['headers']['x-amz-glacier-version'] = model.metadata[</font>
<font color="red"> 611.         'apiVersion']</font>
<font color="black"> 612. </font>
<font color="black"> 613. </font>
<font color="green"> 614. def add_accept_header(model, params, **kwargs):</font>
<font color="red"> 615.     if params['headers'].get('Accept', None) is None:</font>
<font color="red"> 616.         request_dict = params</font>
<font color="red"> 617.         request_dict['headers']['Accept'] = 'application/json'</font>
<font color="black"> 618. </font>
<font color="black"> 619. </font>
<font color="green"> 620. def add_glacier_checksums(params, **kwargs):</font>
<font color="black"> 621.     &quot;&quot;&quot;Add glacier checksums to the http request.</font>
<font color="black"> 622. </font>
<font color="black"> 623.     This will add two headers to the http request:</font>
<font color="black"> 624. </font>
<font color="black"> 625.         * x-amz-content-sha256</font>
<font color="black"> 626.         * x-amz-sha256-tree-hash</font>
<font color="black"> 627. </font>
<font color="black"> 628.     These values will only be added if they are not present</font>
<font color="black"> 629.     in the HTTP request.</font>
<font color="black"> 630. </font>
<font color="black"> 631.     &quot;&quot;&quot;</font>
<font color="red"> 632.     request_dict = params</font>
<font color="red"> 633.     headers = request_dict['headers']</font>
<font color="red"> 634.     body = request_dict['body']</font>
<font color="red"> 635.     if isinstance(body, six.binary_type):</font>
<font color="black"> 636.         # If the user provided a bytes type instead of a file</font>
<font color="black"> 637.         # like object, we're temporarily create a BytesIO object</font>
<font color="black"> 638.         # so we can use the util functions to calculate the</font>
<font color="black"> 639.         # checksums which assume file like objects.  Note that</font>
<font color="black"> 640.         # we're not actually changing the body in the request_dict.</font>
<font color="red"> 641.         body = six.BytesIO(body)</font>
<font color="red"> 642.     starting_position = body.tell()</font>
<font color="red"> 643.     if 'x-amz-content-sha256' not in headers:</font>
<font color="red"> 644.         headers['x-amz-content-sha256'] = utils.calculate_sha256(</font>
<font color="red"> 645.             body, as_hex=True)</font>
<font color="red"> 646.     body.seek(starting_position)</font>
<font color="red"> 647.     if 'x-amz-sha256-tree-hash' not in headers:</font>
<font color="red"> 648.         headers['x-amz-sha256-tree-hash'] = utils.calculate_tree_hash(body)</font>
<font color="red"> 649.     body.seek(starting_position)</font>
<font color="black"> 650. </font>
<font color="black"> 651. </font>
<font color="green"> 652. def document_glacier_tree_hash_checksum():</font>
<font color="black"> 653.     doc = '''</font>
<font color="black"> 654.         This is a required field.</font>
<font color="black"> 655. </font>
<font color="black"> 656.         Ideally you will want to compute this value with checksums from</font>
<font color="black"> 657.         previous uploaded parts, using the algorithm described in</font>
<font color="black"> 658.         `Glacier documentation &lt;http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html&gt;`_.</font>
<font color="black"> 659. </font>
<font color="black"> 660.         But if you prefer, you can also use botocore.utils.calculate_tree_hash()</font>
<font color="black"> 661.         to compute it from raw file by::</font>
<font color="black"> 662. </font>
<font color="black"> 663.             checksum = calculate_tree_hash(open('your_file.txt', 'rb'))</font>
<font color="black"> 664. </font>
<font color="green"> 665.         '''</font>
<font color="green"> 666.     return AppendParamDocumentation('checksum', doc).append_documentation</font>
<font color="black"> 667. </font>
<font color="black"> 668. </font>
<font color="green"> 669. def document_cloudformation_get_template_return_type(section, event_name, **kwargs):</font>
<font color="red"> 670.     if 'response-params' in event_name:</font>
<font color="red"> 671.         template_body_section = section.get_section('TemplateBody')</font>
<font color="red"> 672.         type_section = template_body_section.get_section('param-type')</font>
<font color="red"> 673.         type_section.clear_text()</font>
<font color="red"> 674.         type_section.write('(*dict*) --')</font>
<font color="red"> 675.     elif 'response-example' in event_name:</font>
<font color="red"> 676.         parent = section.get_section('structure-value')</font>
<font color="red"> 677.         param_line = parent.get_section('TemplateBody')</font>
<font color="red"> 678.         value_portion = param_line.get_section('member-value')</font>
<font color="red"> 679.         value_portion.clear_text()</font>
<font color="red"> 680.         value_portion.write('{}')</font>
<font color="black"> 681. </font>
<font color="black"> 682. </font>
<font color="green"> 683. def switch_host_machinelearning(request, **kwargs):</font>
<font color="red"> 684.     switch_host_with_param(request, 'PredictEndpoint')</font>
<font color="black"> 685. </font>
<font color="black"> 686. </font>
<font color="green"> 687. def check_openssl_supports_tls_version_1_2(**kwargs):</font>
<font color="red"> 688.     import ssl</font>
<font color="red"> 689.     try:</font>
<font color="red"> 690.         openssl_version_tuple = ssl.OPENSSL_VERSION_INFO</font>
<font color="red"> 691.         if openssl_version_tuple &lt; (1, 0, 1):</font>
<font color="red"> 692.             warnings.warn(</font>
<font color="red"> 693.                 'Currently installed openssl version: %s does not '</font>
<font color="black"> 694.                 'support TLS 1.2, which is required for use of iot-data. '</font>
<font color="black"> 695.                 'Please use python installed with openssl version 1.0.1 or '</font>
<font color="red"> 696.                 'higher.' % (ssl.OPENSSL_VERSION),</font>
<font color="red"> 697.                 UnsupportedTLSVersionWarning</font>
<font color="black"> 698.             )</font>
<font color="black"> 699.     # We cannot check the openssl version on python2.6, so we should just</font>
<font color="black"> 700.     # pass on this conveniency check.</font>
<font color="red"> 701.     except AttributeError:</font>
<font color="red"> 702.         pass</font>
<font color="black"> 703. </font>
<font color="black"> 704. </font>
<font color="green"> 705. def change_get_to_post(request, **kwargs):</font>
<font color="black"> 706.     # This is useful when we need to change a potentially large GET request</font>
<font color="black"> 707.     # into a POST with x-www-form-urlencoded encoding.</font>
<font color="red"> 708.     if request.method == 'GET' and '?' in request.url:</font>
<font color="red"> 709.         request.headers['Content-Type'] = 'application/x-www-form-urlencoded'</font>
<font color="red"> 710.         request.method = 'POST'</font>
<font color="red"> 711.         request.url, request.data = request.url.split('?', 1)</font>
<font color="black"> 712. </font>
<font color="black"> 713. </font>
<font color="green"> 714. def set_list_objects_encoding_type_url(params, context, **kwargs):</font>
<font color="red"> 715.     if 'EncodingType' not in params:</font>
<font color="black"> 716.         # We set this context so that we know it wasn't the customer that</font>
<font color="black"> 717.         # requested the encoding.</font>
<font color="red"> 718.         context['encoding_type_auto_set'] = True</font>
<font color="red"> 719.         params['EncodingType'] = 'url'</font>
<font color="black"> 720. </font>
<font color="black"> 721. </font>
<font color="green"> 722. def decode_list_object(parsed, context, **kwargs):</font>
<font color="black"> 723.     # This is needed because we are passing url as the encoding type. Since the</font>
<font color="black"> 724.     # paginator is based on the key, we need to handle it before it can be</font>
<font color="black"> 725.     # round tripped.</font>
<font color="black"> 726.     #</font>
<font color="black"> 727.     # From the documentation: If you specify encoding-type request parameter,</font>
<font color="black"> 728.     # Amazon S3 includes this element in the response, and returns encoded key</font>
<font color="black"> 729.     # name values in the following response elements:</font>
<font color="black"> 730.     # Delimiter, Marker, Prefix, NextMarker, Key.</font>
<font color="red"> 731.     if parsed.get('EncodingType') == 'url' and \</font>
<font color="red"> 732.                     context.get('encoding_type_auto_set'):</font>
<font color="black"> 733.         # URL decode top-level keys in the response if present.</font>
<font color="red"> 734.         top_level_keys = ['Delimiter', 'Marker', 'NextMarker']</font>
<font color="red"> 735.         for key in top_level_keys:</font>
<font color="red"> 736.             if key in parsed:</font>
<font color="red"> 737.                 parsed[key] = unquote_str(parsed[key])</font>
<font color="black"> 738.         # URL decode nested keys from the response if present.</font>
<font color="red"> 739.         nested_keys = [('Contents', 'Key'), ('CommonPrefixes', 'Prefix')]</font>
<font color="red"> 740.         for (top_key, child_key) in nested_keys:</font>
<font color="red"> 741.             if top_key in parsed:</font>
<font color="red"> 742.                 for member in parsed[top_key]:</font>
<font color="red"> 743.                     member[child_key] = unquote_str(member[child_key])</font>
<font color="black"> 744. </font>
<font color="black"> 745. </font>
<font color="green"> 746. def convert_body_to_file_like_object(params, **kwargs):</font>
<font color="red"> 747.     if 'Body' in params:</font>
<font color="red"> 748.         if isinstance(params['Body'], six.string_types):</font>
<font color="red"> 749.             params['Body'] = six.BytesIO(ensure_bytes(params['Body']))</font>
<font color="red"> 750.         elif isinstance(params['Body'], six.binary_type):</font>
<font color="red"> 751.             params['Body'] = six.BytesIO(params['Body'])</font>
<font color="black"> 752. </font>
<font color="black"> 753. </font>
<font color="green"> 754. def _add_parameter_aliases(handler_list):</font>
<font color="black"> 755.     # Mapping of original parameter to parameter alias.</font>
<font color="black"> 756.     # The key is &lt;service&gt;.&lt;operation&gt;.parameter</font>
<font color="black"> 757.     # The first part of the key is used for event registration.</font>
<font color="black"> 758.     # The last part is the original parameter name and the value is the</font>
<font color="black"> 759.     # alias to expose in documentation.</font>
<font color="green"> 760.     aliases = {</font>
<font color="green"> 761.         'ec2.*.Filter': 'Filters',</font>
<font color="green"> 762.         'logs.CreateExportTask.from': 'fromTime',</font>
<font color="green"> 763.         'cloudsearchdomain.Search.return': 'returnFields'</font>
<font color="black"> 764.     }</font>
<font color="black"> 765. </font>
<font color="green"> 766.     for original, new_name in aliases.items():</font>
<font color="green"> 767.         event_portion, original_name = original.rsplit('.', 1)</font>
<font color="green"> 768.         parameter_alias = ParameterAlias(original_name, new_name)</font>
<font color="black"> 769. </font>
<font color="black"> 770.         # Add the handlers to the list of handlers.</font>
<font color="black"> 771.         # One handler is to handle when users provide the alias.</font>
<font color="black"> 772.         # The other handler is to update the documentation to show only</font>
<font color="black"> 773.         # the alias.</font>
<font color="black"> 774.         parameter_build_event_handler_tuple = (</font>
<font color="green"> 775.             'before-parameter-build.' + event_portion,</font>
<font color="green"> 776.             parameter_alias.alias_parameter_in_call,</font>
<font color="green"> 777.             REGISTER_FIRST</font>
<font color="black"> 778.         )</font>
<font color="black"> 779.         docs_event_handler_tuple = (</font>
<font color="green"> 780.             'docs.*.' + event_portion + '.complete-section',</font>
<font color="green"> 781.             parameter_alias.alias_parameter_in_documentation)</font>
<font color="green"> 782.         handler_list.append(parameter_build_event_handler_tuple)</font>
<font color="green"> 783.         handler_list.append(docs_event_handler_tuple)</font>
<font color="black"> 784. </font>
<font color="black"> 785. </font>
<font color="green"> 786. class ParameterAlias(object):</font>
<font color="green"> 787.     def __init__(self, original_name, alias_name):</font>
<font color="green"> 788.         self._original_name = original_name</font>
<font color="green"> 789.         self._alias_name = alias_name</font>
<font color="black"> 790. </font>
<font color="green"> 791.     def alias_parameter_in_call(self, params, model, **kwargs):</font>
<font color="red"> 792.         if model.input_shape:</font>
<font color="black"> 793.             # Only consider accepting the alias if it is modeled in the</font>
<font color="black"> 794.             # input shape.</font>
<font color="red"> 795.             if self._original_name in model.input_shape.members:</font>
<font color="red"> 796.                 if self._alias_name in params:</font>
<font color="red"> 797.                     if self._original_name in params:</font>
<font color="red"> 798.                         raise AliasConflictParameterError(</font>
<font color="red"> 799.                             original=self._original_name,</font>
<font color="red"> 800.                             alias=self._alias_name,</font>
<font color="red"> 801.                             operation=model.name</font>
<font color="black"> 802.                         )</font>
<font color="black"> 803.                     # Remove the alias parameter value and use the old name</font>
<font color="black"> 804.                     # instead.</font>
<font color="red"> 805.                     params[self._original_name] = params.pop(self._alias_name)</font>
<font color="black"> 806. </font>
<font color="green"> 807.     def alias_parameter_in_documentation(self, event_name, section, **kwargs):</font>
<font color="red"> 808.         if event_name.startswith('docs.request-params'):</font>
<font color="red"> 809.             if self._original_name not in section.available_sections:</font>
<font color="red"> 810.                 return</font>
<font color="black"> 811.             # Replace the name for parameter type</font>
<font color="red"> 812.             param_section = section.get_section(self._original_name)</font>
<font color="red"> 813.             param_type_section = param_section.get_section('param-type')</font>
<font color="red"> 814.             self._replace_content(param_type_section)</font>
<font color="black"> 815. </font>
<font color="black"> 816.             # Replace the name for the parameter description</font>
<font color="red"> 817.             param_name_section = param_section.get_section('param-name')</font>
<font color="red"> 818.             self._replace_content(param_name_section)</font>
<font color="red"> 819.         elif event_name.startswith('docs.request-example'):</font>
<font color="red"> 820.             section = section.get_section('structure-value')</font>
<font color="red"> 821.             if self._original_name not in section.available_sections:</font>
<font color="red"> 822.                 return</font>
<font color="black"> 823.             # Replace the name for the example</font>
<font color="red"> 824.             param_section = section.get_section(self._original_name)</font>
<font color="red"> 825.             self._replace_content(param_section)</font>
<font color="black"> 826. </font>
<font color="green"> 827.     def _replace_content(self, section):</font>
<font color="red"> 828.         content = section.getvalue().decode('utf-8')</font>
<font color="red"> 829.         updated_content = content.replace(</font>
<font color="red"> 830.             self._original_name, self._alias_name)</font>
<font color="red"> 831.         section.clear_text()</font>
<font color="red"> 832.         section.write(updated_content)</font>
<font color="black"> 833. </font>
<font color="black"> 834. </font>
<font color="green"> 835. class ClientMethodAlias(object):</font>
<font color="green"> 836.     def __init__(self, actual_name):</font>
<font color="black"> 837.         &quot;&quot;&quot; Aliases a non-extant method to an existing method.</font>
<font color="black"> 838. </font>
<font color="black"> 839.         :param actual_name: The name of the method that actually exists on</font>
<font color="black"> 840.             the client.</font>
<font color="black"> 841.         &quot;&quot;&quot;</font>
<font color="green"> 842.         self._actual = actual_name</font>
<font color="black"> 843. </font>
<font color="green"> 844.     def __call__(self, client, **kwargs):</font>
<font color="red"> 845.         return getattr(client, self._actual)</font>
<font color="black"> 846. </font>
<font color="black"> 847. # This is a list of (event_name, handler).</font>
<font color="black"> 848. # When a Session is created, everything in this list will be</font>
<font color="black"> 849. # automatically registered with that Session.</font>
<font color="black"> 850. </font>
<font color="black"> 851. BUILTIN_HANDLERS = [</font>
<font color="green"> 852.     ('choose-service-name', handle_service_name_alias),</font>
<font color="green"> 853.     ('getattr.mturk.list_hi_ts_for_qualification_type',</font>
<font color="green"> 854.      ClientMethodAlias('list_hits_for_qualification_type')),</font>
<font color="green"> 855.     ('before-parameter-build.s3.UploadPart',</font>
<font color="green"> 856.      convert_body_to_file_like_object, REGISTER_LAST),</font>
<font color="green"> 857.     ('before-parameter-build.s3.PutObject',</font>
<font color="green"> 858.      convert_body_to_file_like_object, REGISTER_LAST),</font>
<font color="green"> 859.     ('creating-client-class', add_generate_presigned_url),</font>
<font color="green"> 860.     ('creating-client-class.s3', add_generate_presigned_post),</font>
<font color="green"> 861.     ('creating-client-class.rds', add_generate_db_auth_token),</font>
<font color="green"> 862.     ('creating-client-class.iot-data', check_openssl_supports_tls_version_1_2),</font>
<font color="green"> 863.     ('after-call.iam', json_decode_policies),</font>
<font color="black"> 864. </font>
<font color="green"> 865.     ('after-call.ec2.GetConsoleOutput', decode_console_output),</font>
<font color="green"> 866.     ('after-call.cloudformation.GetTemplate', json_decode_template_body),</font>
<font color="green"> 867.     ('after-call.s3.GetBucketLocation', parse_get_bucket_location),</font>
<font color="black"> 868. </font>
<font color="green"> 869.     ('before-parameter-build', generate_idempotent_uuid),</font>
<font color="black"> 870. </font>
<font color="green"> 871.     ('before-parameter-build.s3', validate_bucket_name),</font>
<font color="black"> 872. </font>
<font color="green"> 873.     ('before-parameter-build.s3.ListObjects',</font>
<font color="green"> 874.      set_list_objects_encoding_type_url),</font>
<font color="green"> 875.     ('before-call.s3.PutBucketTagging', calculate_md5),</font>
<font color="green"> 876.     ('before-call.s3.PutBucketLifecycle', calculate_md5),</font>
<font color="green"> 877.     ('before-call.s3.PutBucketLifecycleConfiguration', calculate_md5),</font>
<font color="green"> 878.     ('before-call.s3.PutBucketCors', calculate_md5),</font>
<font color="green"> 879.     ('before-call.s3.DeleteObjects', calculate_md5),</font>
<font color="green"> 880.     ('before-call.s3.PutBucketReplication', calculate_md5),</font>
<font color="green"> 881.     ('before-call.s3.PutObject', conditionally_calculate_md5),</font>
<font color="green"> 882.     ('before-call.s3.UploadPart', conditionally_calculate_md5),</font>
<font color="green"> 883.     ('before-call.s3.PutBucketAcl', conditionally_calculate_md5),</font>
<font color="green"> 884.     ('before-call.s3.PutBucketLogging', conditionally_calculate_md5),</font>
<font color="green"> 885.     ('before-call.s3.PutBucketNotification', conditionally_calculate_md5),</font>
<font color="green"> 886.     ('before-call.s3.PutBucketPolicy', conditionally_calculate_md5),</font>
<font color="green"> 887.     ('before-call.s3.PutBucketRequestPayment', conditionally_calculate_md5),</font>
<font color="green"> 888.     ('before-call.s3.PutBucketVersioning', conditionally_calculate_md5),</font>
<font color="green"> 889.     ('before-call.s3.PutBucketWebsite', conditionally_calculate_md5),</font>
<font color="green"> 890.     ('before-call.s3.PutObjectAcl', conditionally_calculate_md5),</font>
<font color="black"> 891. </font>
<font color="green"> 892.     ('before-parameter-build.s3.CopyObject',</font>
<font color="green"> 893.      handle_copy_source_param),</font>
<font color="green"> 894.     ('before-parameter-build.s3.UploadPartCopy',</font>
<font color="green"> 895.      handle_copy_source_param),</font>
<font color="green"> 896.     ('before-parameter-build.s3.CopyObject', validate_ascii_metadata),</font>
<font color="green"> 897.     ('before-parameter-build.s3.PutObject', validate_ascii_metadata),</font>
<font color="green"> 898.     ('before-parameter-build.s3.CreateMultipartUpload',</font>
<font color="green"> 899.      validate_ascii_metadata),</font>
<font color="green"> 900.     ('docs.*.s3.CopyObject.complete-section', document_copy_source_form),</font>
<font color="green"> 901.     ('docs.*.s3.UploadPartCopy.complete-section', document_copy_source_form),</font>
<font color="black"> 902. </font>
<font color="green"> 903.     ('before-call.s3', add_expect_header),</font>
<font color="green"> 904.     ('before-call.glacier', add_glacier_version),</font>
<font color="green"> 905.     ('before-call.apigateway', add_accept_header),</font>
<font color="green"> 906.     ('before-call.glacier.UploadArchive', add_glacier_checksums),</font>
<font color="green"> 907.     ('before-call.glacier.UploadMultipartPart', add_glacier_checksums),</font>
<font color="green"> 908.     ('before-call.ec2.CopySnapshot', inject_presigned_url_ec2),</font>
<font color="green"> 909.     ('before-call.rds.CopyDBClusterSnapshot',</font>
<font color="green"> 910.      inject_presigned_url_rds),</font>
<font color="green"> 911.     ('before-call.rds.CreateDBCluster',</font>
<font color="green"> 912.      inject_presigned_url_rds),</font>
<font color="green"> 913.     ('before-call.rds.CopyDBSnapshot',</font>
<font color="green"> 914.      inject_presigned_url_rds),</font>
<font color="green"> 915.     ('before-call.rds.CreateDBInstanceReadReplica',</font>
<font color="green"> 916.      inject_presigned_url_rds),</font>
<font color="green"> 917.     ('request-created.machinelearning.Predict', switch_host_machinelearning),</font>
<font color="green"> 918.     ('needs-retry.s3.UploadPartCopy', check_for_200_error, REGISTER_FIRST),</font>
<font color="green"> 919.     ('needs-retry.s3.CopyObject', check_for_200_error, REGISTER_FIRST),</font>
<font color="green"> 920.     ('needs-retry.s3.CompleteMultipartUpload', check_for_200_error,</font>
<font color="green"> 921.      REGISTER_FIRST),</font>
<font color="green"> 922.     ('service-data-loaded', register_retries_for_service),</font>
<font color="green"> 923.     ('choose-signer.cognito-identity.GetId', disable_signing),</font>
<font color="green"> 924.     ('choose-signer.cognito-identity.GetOpenIdToken', disable_signing),</font>
<font color="green"> 925.     ('choose-signer.cognito-identity.UnlinkIdentity', disable_signing),</font>
<font color="green"> 926.     ('choose-signer.cognito-identity.GetCredentialsForIdentity',</font>
<font color="green"> 927.         disable_signing),</font>
<font color="green"> 928.     ('choose-signer.sts.AssumeRoleWithSAML', disable_signing),</font>
<font color="green"> 929.     ('choose-signer.sts.AssumeRoleWithWebIdentity', disable_signing),</font>
<font color="green"> 930.     ('choose-signer', set_operation_specific_signer),</font>
<font color="green"> 931.     ('before-parameter-build.s3.HeadObject', sse_md5),</font>
<font color="green"> 932.     ('before-parameter-build.s3.GetObject', sse_md5),</font>
<font color="green"> 933.     ('before-parameter-build.s3.PutObject', sse_md5),</font>
<font color="green"> 934.     ('before-parameter-build.s3.CopyObject', sse_md5),</font>
<font color="green"> 935.     ('before-parameter-build.s3.CopyObject', copy_source_sse_md5),</font>
<font color="green"> 936.     ('before-parameter-build.s3.CreateMultipartUpload', sse_md5),</font>
<font color="green"> 937.     ('before-parameter-build.s3.UploadPart', sse_md5),</font>
<font color="green"> 938.     ('before-parameter-build.s3.UploadPartCopy', sse_md5),</font>
<font color="green"> 939.     ('before-parameter-build.s3.UploadPartCopy', copy_source_sse_md5),</font>
<font color="green"> 940.     ('before-parameter-build.ec2.RunInstances', base64_encode_user_data),</font>
<font color="green"> 941.     ('before-parameter-build.autoscaling.CreateLaunchConfiguration',</font>
<font color="green"> 942.      base64_encode_user_data),</font>
<font color="green"> 943.     ('before-parameter-build.route53', fix_route53_ids),</font>
<font color="green"> 944.     ('before-parameter-build.glacier', inject_account_id),</font>
<font color="green"> 945.     ('after-call.s3.ListObjects', decode_list_object),</font>
<font color="black"> 946. </font>
<font color="black"> 947.     # Cloudsearchdomain search operation will be sent by HTTP POST</font>
<font color="green"> 948.     ('request-created.cloudsearchdomain.Search',</font>
<font color="green"> 949.      change_get_to_post),</font>
<font color="black"> 950.     # Glacier documentation customizations</font>
<font color="green"> 951.     ('docs.*.glacier.*.complete-section',</font>
<font color="green"> 952.      AutoPopulatedParam('accountId', 'Note: this parameter is set to &quot;-&quot; by'</font>
<font color="black"> 953.                         'default if no value is not specified.')</font>
<font color="black"> 954.      .document_auto_populated_param),</font>
<font color="green"> 955.     ('docs.*.glacier.UploadArchive.complete-section',</font>
<font color="green"> 956.      AutoPopulatedParam('checksum').document_auto_populated_param),</font>
<font color="green"> 957.     ('docs.*.glacier.UploadMultipartPart.complete-section',</font>
<font color="green"> 958.      AutoPopulatedParam('checksum').document_auto_populated_param),</font>
<font color="green"> 959.     ('docs.request-params.glacier.CompleteMultipartUpload.complete-section',</font>
<font color="green"> 960.      document_glacier_tree_hash_checksum()),</font>
<font color="black"> 961.     # Cloudformation documentation customizations</font>
<font color="green"> 962.     ('docs.*.cloudformation.GetTemplate.complete-section',</font>
<font color="green"> 963.      document_cloudformation_get_template_return_type),</font>
<font color="black"> 964. </font>
<font color="black"> 965.     # UserData base64 encoding documentation customizations</font>
<font color="green"> 966.     ('docs.*.ec2.RunInstances.complete-section',</font>
<font color="green"> 967.      document_base64_encoding('UserData')),</font>
<font color="green"> 968.     ('docs.*.autoscaling.CreateLaunchConfiguration.complete-section',</font>
<font color="green"> 969.      document_base64_encoding('UserData')),</font>
<font color="black"> 970. </font>
<font color="black"> 971.     # RDS PresignedUrl documentation customizations</font>
<font color="green"> 972.     ('docs.*.rds.CopyDBClusterSnapshot.complete-section',</font>
<font color="green"> 973.      AutoPopulatedParam('PreSignedUrl').document_auto_populated_param),</font>
<font color="green"> 974.     ('docs.*.rds.CreateDBCluster.complete-section',</font>
<font color="green"> 975.      AutoPopulatedParam('PreSignedUrl').document_auto_populated_param),</font>
<font color="green"> 976.     ('docs.*.rds.CopyDBSnapshot.complete-section',</font>
<font color="green"> 977.      AutoPopulatedParam('PreSignedUrl').document_auto_populated_param),</font>
<font color="green"> 978.     ('docs.*.rds.CreateDBInstanceReadReplica.complete-section',</font>
<font color="green"> 979.      AutoPopulatedParam('PreSignedUrl').document_auto_populated_param),</font>
<font color="black"> 980. </font>
<font color="black"> 981.     # EC2 CopySnapshot documentation customizations</font>
<font color="green"> 982.     ('docs.*.ec2.CopySnapshot.complete-section',</font>
<font color="green"> 983.      AutoPopulatedParam('PresignedUrl').document_auto_populated_param),</font>
<font color="green"> 984.     ('docs.*.ec2.CopySnapshot.complete-section',</font>
<font color="green"> 985.      AutoPopulatedParam('DestinationRegion').document_auto_populated_param),</font>
<font color="black"> 986.     # S3 SSE documentation modifications</font>
<font color="green"> 987.     ('docs.*.s3.*.complete-section',</font>
<font color="green"> 988.      AutoPopulatedParam('SSECustomerKeyMD5').document_auto_populated_param),</font>
<font color="black"> 989.     # S3 SSE Copy Source documentation modifications</font>
<font color="green"> 990.     ('docs.*.s3.*.complete-section',</font>
<font color="green"> 991.      AutoPopulatedParam(</font>
<font color="green"> 992.         'CopySourceSSECustomerKeyMD5').document_auto_populated_param),</font>
<font color="black"> 993.     # Add base64 information to Lambda</font>
<font color="green"> 994.     ('docs.*.lambda.UpdateFunctionCode.complete-section',</font>
<font color="green"> 995.      document_base64_encoding('ZipFile')),</font>
<font color="black"> 996.     # The following S3 operations cannot actually accept a ContentMD5</font>
<font color="green"> 997.     ('docs.*.s3.*.complete-section',</font>
<font color="green"> 998.      HideParamFromOperations(</font>
<font color="green"> 999.          's3', 'ContentMD5',</font>
<font color="green">1000.          ['DeleteObjects', 'PutBucketAcl', 'PutBucketCors',</font>
<font color="green">1001.           'PutBucketLifecycle', 'PutBucketLogging', 'PutBucketNotification',</font>
<font color="green">1002.           'PutBucketPolicy', 'PutBucketReplication', 'PutBucketRequestPayment',</font>
<font color="green">1003.           'PutBucketTagging', 'PutBucketVersioning', 'PutBucketWebsite',</font>
<font color="green">1004.           'PutObjectAcl']).hide_param)</font>
<font color="black">1005. ]</font>
<font color="green">1006. _add_parameter_aliases(BUILTIN_HANDLERS)</font>
</pre>

