source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/utils.py</b><br>


file stats: <b>345 lines, 114 executed: 33.0% covered</b>
<pre>
<font color="black">   1. # -*- coding: utf-8 -*-</font>
<font color="black">   2. </font>
<font color="black">   3. &quot;&quot;&quot;</font>
<font color="black">   4. requests.utils</font>
<font color="black">   5. ~~~~~~~~~~~~~~</font>
<font color="black">   6. </font>
<font color="black">   7. This module provides utility functions that are used within Requests</font>
<font color="black">   8. that are also useful for external consumption.</font>
<font color="black">   9. </font>
<font color="green">  10. &quot;&quot;&quot;</font>
<font color="black">  11. </font>
<font color="green">  12. import cgi</font>
<font color="green">  13. import codecs</font>
<font color="green">  14. import collections</font>
<font color="green">  15. import io</font>
<font color="green">  16. import os</font>
<font color="green">  17. import platform</font>
<font color="green">  18. import re</font>
<font color="green">  19. import sys</font>
<font color="green">  20. import socket</font>
<font color="green">  21. import struct</font>
<font color="green">  22. import warnings</font>
<font color="black">  23. </font>
<font color="green">  24. from . import __version__</font>
<font color="green">  25. from . import certs</font>
<font color="green">  26. from .compat import parse_http_list as _parse_list_header</font>
<font color="green">  27. from .compat import (quote, urlparse, bytes, str, OrderedDict, unquote, is_py2,</font>
<font color="black">  28.                      builtin_str, getproxies, proxy_bypass, urlunparse,</font>
<font color="black">  29.                      basestring)</font>
<font color="green">  30. from .cookies import RequestsCookieJar, cookiejar_from_dict</font>
<font color="green">  31. from .structures import CaseInsensitiveDict</font>
<font color="green">  32. from .exceptions import InvalidURL</font>
<font color="black">  33. </font>
<font color="green">  34. _hush_pyflakes = (RequestsCookieJar,)</font>
<font color="black">  35. </font>
<font color="green">  36. NETRC_FILES = ('.netrc', '_netrc')</font>
<font color="black">  37. </font>
<font color="green">  38. DEFAULT_CA_BUNDLE_PATH = certs.where()</font>
<font color="black">  39. </font>
<font color="black">  40. </font>
<font color="green">  41. def dict_to_sequence(d):</font>
<font color="black">  42.     &quot;&quot;&quot;Returns an internal sequence dictionary update.&quot;&quot;&quot;</font>
<font color="black">  43. </font>
<font color="red">  44.     if hasattr(d, 'items'):</font>
<font color="red">  45.         d = d.items()</font>
<font color="black">  46. </font>
<font color="red">  47.     return d</font>
<font color="black">  48. </font>
<font color="black">  49. </font>
<font color="green">  50. def super_len(o):</font>
<font color="green">  51.     if hasattr(o, '__len__'):</font>
<font color="green">  52.         return len(o)</font>
<font color="black">  53. </font>
<font color="red">  54.     if hasattr(o, 'len'):</font>
<font color="red">  55.         return o.len</font>
<font color="black">  56. </font>
<font color="red">  57.     if hasattr(o, 'fileno'):</font>
<font color="red">  58.         try:</font>
<font color="red">  59.             fileno = o.fileno()</font>
<font color="red">  60.         except io.UnsupportedOperation:</font>
<font color="red">  61.             pass</font>
<font color="black">  62.         else:</font>
<font color="red">  63.             return os.fstat(fileno).st_size</font>
<font color="black">  64. </font>
<font color="red">  65.     if hasattr(o, 'getvalue'):</font>
<font color="black">  66.         # e.g. BytesIO, cStringIO.StringIO</font>
<font color="red">  67.         return len(o.getvalue())</font>
<font color="black">  68. </font>
<font color="black">  69. </font>
<font color="green">  70. def get_netrc_auth(url):</font>
<font color="black">  71.     &quot;&quot;&quot;Returns the Requests tuple auth for a given url from netrc.&quot;&quot;&quot;</font>
<font color="black">  72. </font>
<font color="red">  73.     try:</font>
<font color="red">  74.         from netrc import netrc, NetrcParseError</font>
<font color="black">  75. </font>
<font color="red">  76.         netrc_path = None</font>
<font color="black">  77. </font>
<font color="red">  78.         for f in NETRC_FILES:</font>
<font color="red">  79.             try:</font>
<font color="red">  80.                 loc = os.path.expanduser('~/{0}'.format(f))</font>
<font color="red">  81.             except KeyError:</font>
<font color="black">  82.                 # os.path.expanduser can fail when $HOME is undefined and</font>
<font color="black">  83.                 # getpwuid fails. See http://bugs.python.org/issue20164 &amp;</font>
<font color="black">  84.                 # https://github.com/kennethreitz/requests/issues/1846</font>
<font color="red">  85.                 return</font>
<font color="black">  86. </font>
<font color="red">  87.             if os.path.exists(loc):</font>
<font color="red">  88.                 netrc_path = loc</font>
<font color="red">  89.                 break</font>
<font color="black">  90. </font>
<font color="black">  91.         # Abort early if there isn't one.</font>
<font color="red">  92.         if netrc_path is None:</font>
<font color="red">  93.             return</font>
<font color="black">  94. </font>
<font color="red">  95.         ri = urlparse(url)</font>
<font color="black">  96. </font>
<font color="black">  97.         # Strip port numbers from netloc</font>
<font color="red">  98.         host = ri.netloc.split(':')[0]</font>
<font color="black">  99. </font>
<font color="red"> 100.         try:</font>
<font color="red"> 101.             _netrc = netrc(netrc_path).authenticators(host)</font>
<font color="red"> 102.             if _netrc:</font>
<font color="black"> 103.                 # Return with login / password</font>
<font color="red"> 104.                 login_i = (0 if _netrc[0] else 1)</font>
<font color="red"> 105.                 return (_netrc[login_i], _netrc[2])</font>
<font color="red"> 106.         except (NetrcParseError, IOError):</font>
<font color="black"> 107.             # If there was a parsing error or a permissions issue reading the file,</font>
<font color="black"> 108.             # we'll just skip netrc auth</font>
<font color="red"> 109.             pass</font>
<font color="black"> 110. </font>
<font color="black"> 111.     # AppEngine hackiness.</font>
<font color="red"> 112.     except (ImportError, AttributeError):</font>
<font color="red"> 113.         pass</font>
<font color="black"> 114. </font>
<font color="black"> 115. </font>
<font color="green"> 116. def guess_filename(obj):</font>
<font color="black"> 117.     &quot;&quot;&quot;Tries to guess the filename of the given object.&quot;&quot;&quot;</font>
<font color="red"> 118.     name = getattr(obj, 'name', None)</font>
<font color="red"> 119.     if (name and isinstance(name, basestring) and name[0] != '&lt;' and</font>
<font color="red"> 120.             name[-1] != '&gt;'):</font>
<font color="red"> 121.         return os.path.basename(name)</font>
<font color="black"> 122. </font>
<font color="black"> 123. </font>
<font color="green"> 124. def from_key_val_list(value):</font>
<font color="black"> 125.     &quot;&quot;&quot;Take an object and test to see if it can be represented as a</font>
<font color="black"> 126.     dictionary. Unless it can not be represented as such, return an</font>
<font color="black"> 127.     OrderedDict, e.g.,</font>
<font color="black"> 128. </font>
<font color="black"> 129.     ::</font>
<font color="black"> 130. </font>
<font color="black"> 131.         &gt;&gt;&gt; from_key_val_list([('key', 'val')])</font>
<font color="black"> 132.         OrderedDict([('key', 'val')])</font>
<font color="black"> 133.         &gt;&gt;&gt; from_key_val_list('string')</font>
<font color="black"> 134.         ValueError: need more than 1 value to unpack</font>
<font color="black"> 135.         &gt;&gt;&gt; from_key_val_list({'key': 'val'})</font>
<font color="black"> 136.         OrderedDict([('key', 'val')])</font>
<font color="black"> 137.     &quot;&quot;&quot;</font>
<font color="red"> 138.     if value is None:</font>
<font color="red"> 139.         return None</font>
<font color="black"> 140. </font>
<font color="red"> 141.     if isinstance(value, (str, bytes, bool, int)):</font>
<font color="red"> 142.         raise ValueError('cannot encode objects that are not 2-tuples')</font>
<font color="black"> 143. </font>
<font color="red"> 144.     return OrderedDict(value)</font>
<font color="black"> 145. </font>
<font color="black"> 146. </font>
<font color="green"> 147. def to_key_val_list(value):</font>
<font color="black"> 148.     &quot;&quot;&quot;Take an object and test to see if it can be represented as a</font>
<font color="black"> 149.     dictionary. If it can be, return a list of tuples, e.g.,</font>
<font color="black"> 150. </font>
<font color="black"> 151.     ::</font>
<font color="black"> 152. </font>
<font color="black"> 153.         &gt;&gt;&gt; to_key_val_list([('key', 'val')])</font>
<font color="black"> 154.         [('key', 'val')]</font>
<font color="black"> 155.         &gt;&gt;&gt; to_key_val_list({'key': 'val'})</font>
<font color="black"> 156.         [('key', 'val')]</font>
<font color="black"> 157.         &gt;&gt;&gt; to_key_val_list('string')</font>
<font color="black"> 158.         ValueError: cannot encode objects that are not 2-tuples.</font>
<font color="black"> 159.     &quot;&quot;&quot;</font>
<font color="green"> 160.     if value is None:</font>
<font color="red"> 161.         return None</font>
<font color="black"> 162. </font>
<font color="green"> 163.     if isinstance(value, (str, bytes, bool, int)):</font>
<font color="red"> 164.         raise ValueError('cannot encode objects that are not 2-tuples')</font>
<font color="black"> 165. </font>
<font color="green"> 166.     if isinstance(value, collections.Mapping):</font>
<font color="green"> 167.         value = value.items()</font>
<font color="black"> 168. </font>
<font color="green"> 169.     return list(value)</font>
<font color="black"> 170. </font>
<font color="black"> 171. </font>
<font color="black"> 172. # From mitsuhiko/werkzeug (used with permission).</font>
<font color="green"> 173. def parse_list_header(value):</font>
<font color="black"> 174.     &quot;&quot;&quot;Parse lists as described by RFC 2068 Section 2.</font>
<font color="black"> 175. </font>
<font color="black"> 176.     In particular, parse comma-separated lists where the elements of</font>
<font color="black"> 177.     the list may include quoted-strings.  A quoted-string could</font>
<font color="black"> 178.     contain a comma.  A non-quoted string could have quotes in the</font>
<font color="black"> 179.     middle.  Quotes are removed automatically after parsing.</font>
<font color="black"> 180. </font>
<font color="black"> 181.     It basically works like :func:`parse_set_header` just that items</font>
<font color="black"> 182.     may appear multiple times and case sensitivity is preserved.</font>
<font color="black"> 183. </font>
<font color="black"> 184.     The return value is a standard :class:`list`:</font>
<font color="black"> 185. </font>
<font color="black"> 186.     &gt;&gt;&gt; parse_list_header('token, &quot;quoted value&quot;')</font>
<font color="black"> 187.     ['token', 'quoted value']</font>
<font color="black"> 188. </font>
<font color="black"> 189.     To create a header from the :class:`list` again, use the</font>
<font color="black"> 190.     :func:`dump_header` function.</font>
<font color="black"> 191. </font>
<font color="black"> 192.     :param value: a string with a list header.</font>
<font color="black"> 193.     :return: :class:`list`</font>
<font color="black"> 194.     &quot;&quot;&quot;</font>
<font color="red"> 195.     result = []</font>
<font color="red"> 196.     for item in _parse_list_header(value):</font>
<font color="red"> 197.         if item[:1] == item[-1:] == '&quot;':</font>
<font color="red"> 198.             item = unquote_header_value(item[1:-1])</font>
<font color="red"> 199.         result.append(item)</font>
<font color="red"> 200.     return result</font>
<font color="black"> 201. </font>
<font color="black"> 202. </font>
<font color="black"> 203. # From mitsuhiko/werkzeug (used with permission).</font>
<font color="green"> 204. def parse_dict_header(value):</font>
<font color="black"> 205.     &quot;&quot;&quot;Parse lists of key, value pairs as described by RFC 2068 Section 2 and</font>
<font color="black"> 206.     convert them into a python dict:</font>
<font color="black"> 207. </font>
<font color="black"> 208.     &gt;&gt;&gt; d = parse_dict_header('foo=&quot;is a fish&quot;, bar=&quot;as well&quot;')</font>
<font color="black"> 209.     &gt;&gt;&gt; type(d) is dict</font>
<font color="black"> 210.     True</font>
<font color="black"> 211.     &gt;&gt;&gt; sorted(d.items())</font>
<font color="black"> 212.     [('bar', 'as well'), ('foo', 'is a fish')]</font>
<font color="black"> 213. </font>
<font color="black"> 214.     If there is no value for a key it will be `None`:</font>
<font color="black"> 215. </font>
<font color="black"> 216.     &gt;&gt;&gt; parse_dict_header('key_without_value')</font>
<font color="black"> 217.     {'key_without_value': None}</font>
<font color="black"> 218. </font>
<font color="black"> 219.     To create a header from the :class:`dict` again, use the</font>
<font color="black"> 220.     :func:`dump_header` function.</font>
<font color="black"> 221. </font>
<font color="black"> 222.     :param value: a string with a dict header.</font>
<font color="black"> 223.     :return: :class:`dict`</font>
<font color="black"> 224.     &quot;&quot;&quot;</font>
<font color="red"> 225.     result = {}</font>
<font color="red"> 226.     for item in _parse_list_header(value):</font>
<font color="red"> 227.         if '=' not in item:</font>
<font color="red"> 228.             result[item] = None</font>
<font color="red"> 229.             continue</font>
<font color="red"> 230.         name, value = item.split('=', 1)</font>
<font color="red"> 231.         if value[:1] == value[-1:] == '&quot;':</font>
<font color="red"> 232.             value = unquote_header_value(value[1:-1])</font>
<font color="red"> 233.         result[name] = value</font>
<font color="red"> 234.     return result</font>
<font color="black"> 235. </font>
<font color="black"> 236. </font>
<font color="black"> 237. # From mitsuhiko/werkzeug (used with permission).</font>
<font color="green"> 238. def unquote_header_value(value, is_filename=False):</font>
<font color="black"> 239.     r&quot;&quot;&quot;Unquotes a header value.  (Reversal of :func:`quote_header_value`).</font>
<font color="black"> 240.     This does not use the real unquoting but what browsers are actually</font>
<font color="black"> 241.     using for quoting.</font>
<font color="black"> 242. </font>
<font color="black"> 243.     :param value: the header value to unquote.</font>
<font color="black"> 244.     &quot;&quot;&quot;</font>
<font color="red"> 245.     if value and value[0] == value[-1] == '&quot;':</font>
<font color="black"> 246.         # this is not the real unquoting, but fixing this so that the</font>
<font color="black"> 247.         # RFC is met will result in bugs with internet explorer and</font>
<font color="black"> 248.         # probably some other browsers as well.  IE for example is</font>
<font color="black"> 249.         # uploading files with &quot;C:\foo\bar.txt&quot; as filename</font>
<font color="red"> 250.         value = value[1:-1]</font>
<font color="black"> 251. </font>
<font color="black"> 252.         # if this is a filename and the starting characters look like</font>
<font color="black"> 253.         # a UNC path, then just return the value without quotes.  Using the</font>
<font color="black"> 254.         # replace sequence below on a UNC path has the effect of turning</font>
<font color="black"> 255.         # the leading double slash into a single slash and then</font>
<font color="black"> 256.         # _fix_ie_filename() doesn't work correctly.  See #458.</font>
<font color="red"> 257.         if not is_filename or value[:2] != '\\\\':</font>
<font color="red"> 258.             return value.replace('\\\\', '\\').replace('\\&quot;', '&quot;')</font>
<font color="red"> 259.     return value</font>
<font color="black"> 260. </font>
<font color="black"> 261. </font>
<font color="green"> 262. def dict_from_cookiejar(cj):</font>
<font color="black"> 263.     &quot;&quot;&quot;Returns a key/value dictionary from a CookieJar.</font>
<font color="black"> 264. </font>
<font color="black"> 265.     :param cj: CookieJar object to extract cookies from.</font>
<font color="black"> 266.     &quot;&quot;&quot;</font>
<font color="black"> 267. </font>
<font color="red"> 268.     cookie_dict = {}</font>
<font color="black"> 269. </font>
<font color="red"> 270.     for cookie in cj:</font>
<font color="red"> 271.         cookie_dict[cookie.name] = cookie.value</font>
<font color="black"> 272. </font>
<font color="red"> 273.     return cookie_dict</font>
<font color="black"> 274. </font>
<font color="black"> 275. </font>
<font color="green"> 276. def add_dict_to_cookiejar(cj, cookie_dict):</font>
<font color="black"> 277.     &quot;&quot;&quot;Returns a CookieJar from a key/value dictionary.</font>
<font color="black"> 278. </font>
<font color="black"> 279.     :param cj: CookieJar to insert cookies into.</font>
<font color="black"> 280.     :param cookie_dict: Dict of key/values to insert into CookieJar.</font>
<font color="black"> 281.     &quot;&quot;&quot;</font>
<font color="black"> 282. </font>
<font color="red"> 283.     cj2 = cookiejar_from_dict(cookie_dict)</font>
<font color="red"> 284.     cj.update(cj2)</font>
<font color="red"> 285.     return cj</font>
<font color="black"> 286. </font>
<font color="black"> 287. </font>
<font color="green"> 288. def get_encodings_from_content(content):</font>
<font color="black"> 289.     &quot;&quot;&quot;Returns encodings from given content string.</font>
<font color="black"> 290. </font>
<font color="black"> 291.     :param content: bytestring to extract encodings from.</font>
<font color="black"> 292.     &quot;&quot;&quot;</font>
<font color="red"> 293.     warnings.warn((</font>
<font color="red"> 294.         'In requests 3.0, get_encodings_from_content will be removed. For '</font>
<font color="black"> 295.         'more information, please see the discussion on issue #2266. (This'</font>
<font color="black"> 296.         ' warning should only appear once.)'),</font>
<font color="red"> 297.         DeprecationWarning)</font>
<font color="black"> 298. </font>
<font color="red"> 299.     charset_re = re.compile(r'&lt;meta.*?charset=[&quot;\']*(.+?)[&quot;\'&gt;]', flags=re.I)</font>
<font color="red"> 300.     pragma_re = re.compile(r'&lt;meta.*?content=[&quot;\']*;?charset=(.+?)[&quot;\'&gt;]', flags=re.I)</font>
<font color="red"> 301.     xml_re = re.compile(r'^&lt;\?xml.*?encoding=[&quot;\']*(.+?)[&quot;\'&gt;]')</font>
<font color="black"> 302. </font>
<font color="black"> 303.     return (charset_re.findall(content) +</font>
<font color="red"> 304.             pragma_re.findall(content) +</font>
<font color="red"> 305.             xml_re.findall(content))</font>
<font color="black"> 306. </font>
<font color="black"> 307. </font>
<font color="green"> 308. def get_encoding_from_headers(headers):</font>
<font color="black"> 309.     &quot;&quot;&quot;Returns encodings from given HTTP Header Dict.</font>
<font color="black"> 310. </font>
<font color="black"> 311.     :param headers: dictionary to extract encoding from.</font>
<font color="black"> 312.     &quot;&quot;&quot;</font>
<font color="black"> 313. </font>
<font color="green"> 314.     content_type = headers.get('content-type')</font>
<font color="black"> 315. </font>
<font color="green"> 316.     if not content_type:</font>
<font color="green"> 317.         return None</font>
<font color="black"> 318. </font>
<font color="green"> 319.     content_type, params = cgi.parse_header(content_type)</font>
<font color="black"> 320. </font>
<font color="green"> 321.     if 'charset' in params:</font>
<font color="red"> 322.         return params['charset'].strip(&quot;'\&quot;&quot;)</font>
<font color="black"> 323. </font>
<font color="green"> 324.     if 'text' in content_type:</font>
<font color="red"> 325.         return 'ISO-8859-1'</font>
<font color="black"> 326. </font>
<font color="black"> 327. </font>
<font color="green"> 328. def stream_decode_response_unicode(iterator, r):</font>
<font color="black"> 329.     &quot;&quot;&quot;Stream decodes a iterator.&quot;&quot;&quot;</font>
<font color="black"> 330. </font>
<font color="red"> 331.     if r.encoding is None:</font>
<font color="red"> 332.         for item in iterator:</font>
<font color="red"> 333.             yield item</font>
<font color="red"> 334.         return</font>
<font color="black"> 335. </font>
<font color="red"> 336.     decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')</font>
<font color="red"> 337.     for chunk in iterator:</font>
<font color="red"> 338.         rv = decoder.decode(chunk)</font>
<font color="red"> 339.         if rv:</font>
<font color="red"> 340.             yield rv</font>
<font color="red"> 341.     rv = decoder.decode(b'', final=True)</font>
<font color="red"> 342.     if rv:</font>
<font color="red"> 343.         yield rv</font>
<font color="black"> 344. </font>
<font color="black"> 345. </font>
<font color="green"> 346. def iter_slices(string, slice_length):</font>
<font color="black"> 347.     &quot;&quot;&quot;Iterate over slices of a string.&quot;&quot;&quot;</font>
<font color="red"> 348.     pos = 0</font>
<font color="red"> 349.     while pos &lt; len(string):</font>
<font color="red"> 350.         yield string[pos:pos + slice_length]</font>
<font color="red"> 351.         pos += slice_length</font>
<font color="black"> 352. </font>
<font color="black"> 353. </font>
<font color="green"> 354. def get_unicode_from_response(r):</font>
<font color="black"> 355.     &quot;&quot;&quot;Returns the requested content back in unicode.</font>
<font color="black"> 356. </font>
<font color="black"> 357.     :param r: Response object to get unicode content from.</font>
<font color="black"> 358. </font>
<font color="black"> 359.     Tried:</font>
<font color="black"> 360. </font>
<font color="black"> 361.     1. charset from content-type</font>
<font color="black"> 362.     2. fall back and replace all unicode characters</font>
<font color="black"> 363. </font>
<font color="black"> 364.     &quot;&quot;&quot;</font>
<font color="red"> 365.     warnings.warn((</font>
<font color="red"> 366.         'In requests 3.0, get_unicode_from_response will be removed. For '</font>
<font color="black"> 367.         'more information, please see the discussion on issue #2266. (This'</font>
<font color="black"> 368.         ' warning should only appear once.)'),</font>
<font color="red"> 369.         DeprecationWarning)</font>
<font color="black"> 370. </font>
<font color="red"> 371.     tried_encodings = []</font>
<font color="black"> 372. </font>
<font color="black"> 373.     # Try charset from content-type</font>
<font color="red"> 374.     encoding = get_encoding_from_headers(r.headers)</font>
<font color="black"> 375. </font>
<font color="red"> 376.     if encoding:</font>
<font color="red"> 377.         try:</font>
<font color="red"> 378.             return str(r.content, encoding)</font>
<font color="red"> 379.         except UnicodeError:</font>
<font color="red"> 380.             tried_encodings.append(encoding)</font>
<font color="black"> 381. </font>
<font color="black"> 382.     # Fall back:</font>
<font color="red"> 383.     try:</font>
<font color="red"> 384.         return str(r.content, encoding, errors='replace')</font>
<font color="red"> 385.     except TypeError:</font>
<font color="red"> 386.         return r.content</font>
<font color="black"> 387. </font>
<font color="black"> 388. </font>
<font color="black"> 389. # The unreserved URI characters (RFC 3986)</font>
<font color="green"> 390. UNRESERVED_SET = frozenset(</font>
<font color="green"> 391.     &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</font>
<font color="green"> 392.     + &quot;0123456789-._~&quot;)</font>
<font color="black"> 393. </font>
<font color="black"> 394. </font>
<font color="green"> 395. def unquote_unreserved(uri):</font>
<font color="black"> 396.     &quot;&quot;&quot;Un-escape any percent-escape sequences in a URI that are unreserved</font>
<font color="black"> 397.     characters. This leaves all reserved, illegal and non-ASCII bytes encoded.</font>
<font color="black"> 398.     &quot;&quot;&quot;</font>
<font color="green"> 399.     parts = uri.split('%')</font>
<font color="green"> 400.     for i in range(1, len(parts)):</font>
<font color="red"> 401.         h = parts[i][0:2]</font>
<font color="red"> 402.         if len(h) == 2 and h.isalnum():</font>
<font color="red"> 403.             try:</font>
<font color="red"> 404.                 c = chr(int(h, 16))</font>
<font color="red"> 405.             except ValueError:</font>
<font color="red"> 406.                 raise InvalidURL(&quot;Invalid percent-escape sequence: '%s'&quot; % h)</font>
<font color="black"> 407. </font>
<font color="red"> 408.             if c in UNRESERVED_SET:</font>
<font color="red"> 409.                 parts[i] = c + parts[i][2:]</font>
<font color="black"> 410.             else:</font>
<font color="red"> 411.                 parts[i] = '%' + parts[i]</font>
<font color="black"> 412.         else:</font>
<font color="red"> 413.             parts[i] = '%' + parts[i]</font>
<font color="green"> 414.     return ''.join(parts)</font>
<font color="black"> 415. </font>
<font color="black"> 416. </font>
<font color="green"> 417. def requote_uri(uri):</font>
<font color="black"> 418.     &quot;&quot;&quot;Re-quote the given URI.</font>
<font color="black"> 419. </font>
<font color="black"> 420.     This function passes the given URI through an unquote/quote cycle to</font>
<font color="black"> 421.     ensure that it is fully and consistently quoted.</font>
<font color="black"> 422.     &quot;&quot;&quot;</font>
<font color="green"> 423.     safe_with_percent = &quot;!#$%&amp;'()*+,/:;=?@[]~&quot;</font>
<font color="green"> 424.     safe_without_percent = &quot;!#$&amp;'()*+,/:;=?@[]~&quot;</font>
<font color="green"> 425.     try:</font>
<font color="black"> 426.         # Unquote only the unreserved characters</font>
<font color="black"> 427.         # Then quote only illegal characters (do not quote reserved,</font>
<font color="black"> 428.         # unreserved, or '%')</font>
<font color="green"> 429.         return quote(unquote_unreserved(uri), safe=safe_with_percent)</font>
<font color="red"> 430.     except InvalidURL:</font>
<font color="black"> 431.         # We couldn't unquote the given URI, so let's try quoting it, but</font>
<font color="black"> 432.         # there may be unquoted '%'s in the URI. We need to make sure they're</font>
<font color="black"> 433.         # properly quoted so they do not cause issues elsewhere.</font>
<font color="red"> 434.         return quote(uri, safe=safe_without_percent)</font>
<font color="black"> 435. </font>
<font color="black"> 436. </font>
<font color="green"> 437. def address_in_network(ip, net):</font>
<font color="black"> 438.     &quot;&quot;&quot;</font>
<font color="black"> 439.     This function allows you to check if on IP belongs to a network subnet</font>
<font color="black"> 440.     Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24</font>
<font color="black"> 441.              returns False if ip = 192.168.1.1 and net = 192.168.100.0/24</font>
<font color="black"> 442.     &quot;&quot;&quot;</font>
<font color="red"> 443.     ipaddr = struct.unpack('=L', socket.inet_aton(ip))[0]</font>
<font color="red"> 444.     netaddr, bits = net.split('/')</font>
<font color="red"> 445.     netmask = struct.unpack('=L', socket.inet_aton(dotted_netmask(int(bits))))[0]</font>
<font color="red"> 446.     network = struct.unpack('=L', socket.inet_aton(netaddr))[0] &amp; netmask</font>
<font color="red"> 447.     return (ipaddr &amp; netmask) == (network &amp; netmask)</font>
<font color="black"> 448. </font>
<font color="black"> 449. </font>
<font color="green"> 450. def dotted_netmask(mask):</font>
<font color="black"> 451.     &quot;&quot;&quot;</font>
<font color="black"> 452.     Converts mask from /xx format to xxx.xxx.xxx.xxx</font>
<font color="black"> 453.     Example: if mask is 24 function returns 255.255.255.0</font>
<font color="black"> 454.     &quot;&quot;&quot;</font>
<font color="red"> 455.     bits = 0xffffffff ^ (1 &lt;&lt; 32 - mask) - 1</font>
<font color="red"> 456.     return socket.inet_ntoa(struct.pack('&gt;I', bits))</font>
<font color="black"> 457. </font>
<font color="black"> 458. </font>
<font color="green"> 459. def is_ipv4_address(string_ip):</font>
<font color="red"> 460.     try:</font>
<font color="red"> 461.         socket.inet_aton(string_ip)</font>
<font color="red"> 462.     except socket.error:</font>
<font color="red"> 463.         return False</font>
<font color="red"> 464.     return True</font>
<font color="black"> 465. </font>
<font color="black"> 466. </font>
<font color="green"> 467. def is_valid_cidr(string_network):</font>
<font color="black"> 468.     &quot;&quot;&quot;Very simple check of the cidr format in no_proxy variable&quot;&quot;&quot;</font>
<font color="red"> 469.     if string_network.count('/') == 1:</font>
<font color="red"> 470.         try:</font>
<font color="red"> 471.             mask = int(string_network.split('/')[1])</font>
<font color="red"> 472.         except ValueError:</font>
<font color="red"> 473.             return False</font>
<font color="black"> 474. </font>
<font color="red"> 475.         if mask &lt; 1 or mask &gt; 32:</font>
<font color="red"> 476.             return False</font>
<font color="black"> 477. </font>
<font color="red"> 478.         try:</font>
<font color="red"> 479.             socket.inet_aton(string_network.split('/')[0])</font>
<font color="red"> 480.         except socket.error:</font>
<font color="red"> 481.             return False</font>
<font color="black"> 482.     else:</font>
<font color="red"> 483.         return False</font>
<font color="red"> 484.     return True</font>
<font color="black"> 485. </font>
<font color="black"> 486. </font>
<font color="green"> 487. def should_bypass_proxies(url):</font>
<font color="black"> 488.     &quot;&quot;&quot;</font>
<font color="black"> 489.     Returns whether we should bypass proxies or not.</font>
<font color="black"> 490.     &quot;&quot;&quot;</font>
<font color="green"> 491.     get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())</font>
<font color="black"> 492. </font>
<font color="black"> 493.     # First check whether no_proxy is defined. If it is, check that the URL</font>
<font color="black"> 494.     # we're getting isn't in the no_proxy list.</font>
<font color="green"> 495.     no_proxy = get_proxy('no_proxy')</font>
<font color="green"> 496.     netloc = urlparse(url).netloc</font>
<font color="black"> 497. </font>
<font color="green"> 498.     if no_proxy:</font>
<font color="black"> 499.         # We need to check whether we match here. We need to see if we match</font>
<font color="black"> 500.         # the end of the netloc, both with and without the port.</font>
<font color="red"> 501.         no_proxy = no_proxy.replace(' ', '').split(',')</font>
<font color="black"> 502. </font>
<font color="red"> 503.         ip = netloc.split(':')[0]</font>
<font color="red"> 504.         if is_ipv4_address(ip):</font>
<font color="red"> 505.             for proxy_ip in no_proxy:</font>
<font color="red"> 506.                 if is_valid_cidr(proxy_ip):</font>
<font color="red"> 507.                     if address_in_network(ip, proxy_ip):</font>
<font color="red"> 508.                         return True</font>
<font color="black"> 509.         else:</font>
<font color="red"> 510.             for host in no_proxy:</font>
<font color="red"> 511.                 if netloc.endswith(host) or netloc.split(':')[0].endswith(host):</font>
<font color="black"> 512.                     # The URL does match something in no_proxy, so we don't want</font>
<font color="black"> 513.                     # to apply the proxies on this URL.</font>
<font color="red"> 514.                     return True</font>
<font color="black"> 515. </font>
<font color="black"> 516.     # If the system proxy settings indicate that this URL should be bypassed,</font>
<font color="black"> 517.     # don't proxy.</font>
<font color="black"> 518.     # The proxy_bypass function is incredibly buggy on OS X in early versions</font>
<font color="black"> 519.     # of Python 2.6, so allow this call to fail. Only catch the specific</font>
<font color="black"> 520.     # exceptions we've seen, though: this call failing in other ways can reveal</font>
<font color="black"> 521.     # legitimate problems.</font>
<font color="green"> 522.     try:</font>
<font color="green"> 523.         bypass = proxy_bypass(netloc)</font>
<font color="red"> 524.     except (TypeError, socket.gaierror):</font>
<font color="red"> 525.         bypass = False</font>
<font color="black"> 526. </font>
<font color="green"> 527.     if bypass:</font>
<font color="red"> 528.         return True</font>
<font color="black"> 529. </font>
<font color="green"> 530.     return False</font>
<font color="black"> 531. </font>
<font color="green"> 532. def get_environ_proxies(url):</font>
<font color="black"> 533.     &quot;&quot;&quot;Return a dict of environment proxies.&quot;&quot;&quot;</font>
<font color="green"> 534.     if should_bypass_proxies(url):</font>
<font color="red"> 535.         return {}</font>
<font color="black"> 536.     else:</font>
<font color="green"> 537.         return getproxies()</font>
<font color="black"> 538. </font>
<font color="black"> 539. </font>
<font color="green"> 540. def default_user_agent(name=&quot;python-requests&quot;):</font>
<font color="black"> 541.     &quot;&quot;&quot;Return a string representing the default user agent.&quot;&quot;&quot;</font>
<font color="green"> 542.     _implementation = platform.python_implementation()</font>
<font color="black"> 543. </font>
<font color="green"> 544.     if _implementation == 'CPython':</font>
<font color="green"> 545.         _implementation_version = platform.python_version()</font>
<font color="red"> 546.     elif _implementation == 'PyPy':</font>
<font color="red"> 547.         _implementation_version = '%s.%s.%s' % (sys.pypy_version_info.major,</font>
<font color="red"> 548.                                                 sys.pypy_version_info.minor,</font>
<font color="red"> 549.                                                 sys.pypy_version_info.micro)</font>
<font color="red"> 550.         if sys.pypy_version_info.releaselevel != 'final':</font>
<font color="red"> 551.             _implementation_version = ''.join([_implementation_version, sys.pypy_version_info.releaselevel])</font>
<font color="red"> 552.     elif _implementation == 'Jython':</font>
<font color="red"> 553.         _implementation_version = platform.python_version()  # Complete Guess</font>
<font color="red"> 554.     elif _implementation == 'IronPython':</font>
<font color="red"> 555.         _implementation_version = platform.python_version()  # Complete Guess</font>
<font color="black"> 556.     else:</font>
<font color="red"> 557.         _implementation_version = 'Unknown'</font>
<font color="black"> 558. </font>
<font color="green"> 559.     try:</font>
<font color="green"> 560.         p_system = platform.system()</font>
<font color="green"> 561.         p_release = platform.release()</font>
<font color="red"> 562.     except IOError:</font>
<font color="red"> 563.         p_system = 'Unknown'</font>
<font color="red"> 564.         p_release = 'Unknown'</font>
<font color="black"> 565. </font>
<font color="green"> 566.     return &quot; &quot;.join(['%s/%s' % (name, __version__),</font>
<font color="green"> 567.                      '%s/%s' % (_implementation, _implementation_version),</font>
<font color="green"> 568.                      '%s/%s' % (p_system, p_release)])</font>
<font color="black"> 569. </font>
<font color="black"> 570. </font>
<font color="green"> 571. def default_headers():</font>
<font color="green"> 572.     return CaseInsensitiveDict({</font>
<font color="green"> 573.         'User-Agent': default_user_agent(),</font>
<font color="green"> 574.         'Accept-Encoding': ', '.join(('gzip', 'deflate')),</font>
<font color="green"> 575.         'Accept': '*/*',</font>
<font color="green"> 576.         'Connection': 'keep-alive',</font>
<font color="black"> 577.     })</font>
<font color="black"> 578. </font>
<font color="black"> 579. </font>
<font color="green"> 580. def parse_header_links(value):</font>
<font color="black"> 581.     &quot;&quot;&quot;Return a dict of parsed link headers proxies.</font>
<font color="black"> 582. </font>
<font color="black"> 583.     i.e. Link: &lt;http:/.../front.jpeg&gt;; rel=front; type=&quot;image/jpeg&quot;,&lt;http://.../back.jpeg&gt;; rel=back;type=&quot;image/jpeg&quot;</font>
<font color="black"> 584. </font>
<font color="black"> 585.     &quot;&quot;&quot;</font>
<font color="black"> 586. </font>
<font color="red"> 587.     links = []</font>
<font color="black"> 588. </font>
<font color="red"> 589.     replace_chars = &quot; '\&quot;&quot;</font>
<font color="black"> 590. </font>
<font color="red"> 591.     for val in re.split(&quot;, *&lt;&quot;, value):</font>
<font color="red"> 592.         try:</font>
<font color="red"> 593.             url, params = val.split(&quot;;&quot;, 1)</font>
<font color="red"> 594.         except ValueError:</font>
<font color="red"> 595.             url, params = val, ''</font>
<font color="black"> 596. </font>
<font color="red"> 597.         link = {}</font>
<font color="black"> 598. </font>
<font color="red"> 599.         link[&quot;url&quot;] = url.strip(&quot;&lt;&gt; '\&quot;&quot;)</font>
<font color="black"> 600. </font>
<font color="red"> 601.         for param in params.split(&quot;;&quot;):</font>
<font color="red"> 602.             try:</font>
<font color="red"> 603.                 key, value = param.split(&quot;=&quot;)</font>
<font color="red"> 604.             except ValueError:</font>
<font color="red"> 605.                 break</font>
<font color="black"> 606. </font>
<font color="red"> 607.             link[key.strip(replace_chars)] = value.strip(replace_chars)</font>
<font color="black"> 608. </font>
<font color="red"> 609.         links.append(link)</font>
<font color="black"> 610. </font>
<font color="red"> 611.     return links</font>
<font color="black"> 612. </font>
<font color="black"> 613. </font>
<font color="black"> 614. # Null bytes; no need to recreate these on each call to guess_json_utf</font>
<font color="green"> 615. _null = '\x00'.encode('ascii')  # encoding to ASCII for Python 3</font>
<font color="green"> 616. _null2 = _null * 2</font>
<font color="green"> 617. _null3 = _null * 3</font>
<font color="black"> 618. </font>
<font color="black"> 619. </font>
<font color="green"> 620. def guess_json_utf(data):</font>
<font color="black"> 621.     # JSON always starts with two ASCII characters, so detection is as</font>
<font color="black"> 622.     # easy as counting the nulls and from their location and count</font>
<font color="black"> 623.     # determine the encoding. Also detect a BOM, if present.</font>
<font color="red"> 624.     sample = data[:4]</font>
<font color="red"> 625.     if sample in (codecs.BOM_UTF32_LE, codecs.BOM32_BE):</font>
<font color="red"> 626.         return 'utf-32'     # BOM included</font>
<font color="red"> 627.     if sample[:3] == codecs.BOM_UTF8:</font>
<font color="red"> 628.         return 'utf-8-sig'  # BOM included, MS style (discouraged)</font>
<font color="red"> 629.     if sample[:2] in (codecs.BOM_UTF16_LE, codecs.BOM_UTF16_BE):</font>
<font color="red"> 630.         return 'utf-16'     # BOM included</font>
<font color="red"> 631.     nullcount = sample.count(_null)</font>
<font color="red"> 632.     if nullcount == 0:</font>
<font color="red"> 633.         return 'utf-8'</font>
<font color="red"> 634.     if nullcount == 2:</font>
<font color="red"> 635.         if sample[::2] == _null2:   # 1st and 3rd are null</font>
<font color="red"> 636.             return 'utf-16-be'</font>
<font color="red"> 637.         if sample[1::2] == _null2:  # 2nd and 4th are null</font>
<font color="red"> 638.             return 'utf-16-le'</font>
<font color="black"> 639.         # Did not detect 2 valid UTF-16 ascii-range characters</font>
<font color="red"> 640.     if nullcount == 3:</font>
<font color="red"> 641.         if sample[:3] == _null3:</font>
<font color="red"> 642.             return 'utf-32-be'</font>
<font color="red"> 643.         if sample[1:] == _null3:</font>
<font color="red"> 644.             return 'utf-32-le'</font>
<font color="black"> 645.         # Did not detect a valid UTF-32 ascii-range character</font>
<font color="red"> 646.     return None</font>
<font color="black"> 647. </font>
<font color="black"> 648. </font>
<font color="green"> 649. def prepend_scheme_if_needed(url, new_scheme):</font>
<font color="black"> 650.     '''Given a URL that may or may not have a scheme, prepend the given scheme.</font>
<font color="black"> 651.     Does not replace a present scheme with the one provided as an argument.'''</font>
<font color="red"> 652.     scheme, netloc, path, params, query, fragment = urlparse(url, new_scheme)</font>
<font color="black"> 653. </font>
<font color="black"> 654.     # urlparse is a finicky beast, and sometimes decides that there isn't a</font>
<font color="black"> 655.     # netloc present. Assume that it's being over-cautious, and switch netloc</font>
<font color="black"> 656.     # and path if urlparse decided there was no netloc.</font>
<font color="red"> 657.     if not netloc:</font>
<font color="red"> 658.         netloc, path = path, netloc</font>
<font color="black"> 659. </font>
<font color="red"> 660.     return urlunparse((scheme, netloc, path, params, query, fragment))</font>
<font color="black"> 661. </font>
<font color="black"> 662. </font>
<font color="green"> 663. def get_auth_from_url(url):</font>
<font color="black"> 664.     &quot;&quot;&quot;Given a url with authentication components, extract them into a tuple of</font>
<font color="black"> 665.     username,password.&quot;&quot;&quot;</font>
<font color="green"> 666.     parsed = urlparse(url)</font>
<font color="black"> 667. </font>
<font color="green"> 668.     try:</font>
<font color="green"> 669.         auth = (unquote(parsed.username), unquote(parsed.password))</font>
<font color="green"> 670.     except (AttributeError, TypeError):</font>
<font color="green"> 671.         auth = ('', '')</font>
<font color="black"> 672. </font>
<font color="green"> 673.     return auth</font>
<font color="black"> 674. </font>
<font color="black"> 675. </font>
<font color="green"> 676. def to_native_string(string, encoding='ascii'):</font>
<font color="black"> 677.     &quot;&quot;&quot;</font>
<font color="black"> 678.     Given a string object, regardless of type, returns a representation of that</font>
<font color="black"> 679.     string in the native string type, encoding and decoding where necessary.</font>
<font color="black"> 680.     This assumes ASCII unless told otherwise.</font>
<font color="black"> 681.     &quot;&quot;&quot;</font>
<font color="green"> 682.     out = None</font>
<font color="black"> 683. </font>
<font color="green"> 684.     if isinstance(string, builtin_str):</font>
<font color="green"> 685.         out = string</font>
<font color="black"> 686.     else:</font>
<font color="red"> 687.         if is_py2:</font>
<font color="red"> 688.             out = string.encode(encoding)</font>
<font color="black"> 689.         else:</font>
<font color="red"> 690.             out = string.decode(encoding)</font>
<font color="black"> 691. </font>
<font color="green"> 692.     return out</font>
<font color="black"> 693. </font>
<font color="black"> 694. </font>
<font color="green"> 695. def urldefragauth(url):</font>
<font color="black"> 696.     &quot;&quot;&quot;</font>
<font color="black"> 697.     Given a url remove the fragment and the authentication part</font>
<font color="black"> 698.     &quot;&quot;&quot;</font>
<font color="red"> 699.     scheme, netloc, path, params, query, fragment = urlparse(url)</font>
<font color="black"> 700. </font>
<font color="black"> 701.     # see func:`prepend_scheme_if_needed`</font>
<font color="red"> 702.     if not netloc:</font>
<font color="red"> 703.         netloc, path = path, netloc</font>
<font color="black"> 704. </font>
<font color="red"> 705.     netloc = netloc.rsplit('@', 1)[-1]</font>
<font color="black"> 706. </font>
<font color="red"> 707.     return urlunparse((scheme, netloc, path, params, query, ''))</font>
</pre>

