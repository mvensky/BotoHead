source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/auth.py</b><br>


file stats: <b>550 lines, 267 executed: 48.5% covered</b>
<pre>
<font color="black">   1. # Copyright (c) 2012-2013 Mitch Garnaat http://garnaat.org/</font>
<font color="black">   2. # Copyright 2012-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   3. #</font>
<font color="black">   4. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   5. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   6. # the License is located at</font>
<font color="black">   7. #</font>
<font color="black">   8. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   9. #</font>
<font color="black">  10. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  11. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  12. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  13. # language governing permissions and limitations under the License.</font>
<font color="green">  14. import base64</font>
<font color="green">  15. import datetime</font>
<font color="green">  16. from hashlib import sha256</font>
<font color="green">  17. from hashlib import sha1</font>
<font color="green">  18. import hmac</font>
<font color="green">  19. import logging</font>
<font color="green">  20. from email.utils import formatdate</font>
<font color="green">  21. from operator import itemgetter</font>
<font color="green">  22. import functools</font>
<font color="green">  23. import time</font>
<font color="green">  24. import calendar</font>
<font color="green">  25. import json</font>
<font color="black">  26. </font>
<font color="green">  27. from botocore.exceptions import NoCredentialsError</font>
<font color="green">  28. from botocore.utils import normalize_url_path, percent_encode_sequence</font>
<font color="green">  29. from botocore.compat import HTTPHeaders</font>
<font color="green">  30. from botocore.compat import quote, unquote, urlsplit, parse_qs</font>
<font color="green">  31. from botocore.compat import urlunsplit</font>
<font color="green">  32. from botocore.compat import encodebytes</font>
<font color="green">  33. from botocore.compat import six</font>
<font color="green">  34. from botocore.compat import json</font>
<font color="green">  35. from botocore.compat import MD5_AVAILABLE</font>
<font color="green">  36. from botocore.compat import ensure_unicode</font>
<font color="black">  37. </font>
<font color="green">  38. logger = logging.getLogger(__name__)</font>
<font color="black">  39. </font>
<font color="black">  40. </font>
<font color="black">  41. EMPTY_SHA256_HASH = (</font>
<font color="green">  42.     'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855')</font>
<font color="black">  43. # This is the buffer size used when calculating sha256 checksums.</font>
<font color="black">  44. # Experimenting with various buffer sizes showed that this value generally</font>
<font color="black">  45. # gave the best result (in terms of performance).</font>
<font color="green">  46. PAYLOAD_BUFFER = 1024 * 1024</font>
<font color="green">  47. ISO8601 = '%Y-%m-%dT%H:%M:%SZ'</font>
<font color="green">  48. SIGV4_TIMESTAMP = '%Y%m%dT%H%M%SZ'</font>
<font color="black">  49. SIGNED_HEADERS_BLACKLIST = [</font>
<font color="green">  50.     'expect',</font>
<font color="green">  51.     'user-agent',</font>
<font color="green">  52.     'x-amzn-trace-id',</font>
<font color="black">  53. ]</font>
<font color="green">  54. UNSIGNED_PAYLOAD = 'UNSIGNED-PAYLOAD'</font>
<font color="black">  55. </font>
<font color="black">  56. </font>
<font color="green">  57. class BaseSigner(object):</font>
<font color="green">  58.     REQUIRES_REGION = False</font>
<font color="black">  59. </font>
<font color="green">  60.     def add_auth(self, request):</font>
<font color="red">  61.         raise NotImplementedError(&quot;add_auth&quot;)</font>
<font color="black">  62. </font>
<font color="black">  63. </font>
<font color="green">  64. class SigV2Auth(BaseSigner):</font>
<font color="black">  65.     &quot;&quot;&quot;</font>
<font color="black">  66.     Sign a request with Signature V2.</font>
<font color="green">  67.     &quot;&quot;&quot;</font>
<font color="black">  68. </font>
<font color="green">  69.     def __init__(self, credentials):</font>
<font color="red">  70.         self.credentials = credentials</font>
<font color="black">  71. </font>
<font color="green">  72.     def calc_signature(self, request, params):</font>
<font color="red">  73.         logger.debug(&quot;Calculating signature using v2 auth.&quot;)</font>
<font color="red">  74.         split = urlsplit(request.url)</font>
<font color="red">  75.         path = split.path</font>
<font color="red">  76.         if len(path) == 0:</font>
<font color="red">  77.             path = '/'</font>
<font color="red">  78.         string_to_sign = '%s\n%s\n%s\n' % (request.method,</font>
<font color="red">  79.                                            split.netloc,</font>
<font color="red">  80.                                            path)</font>
<font color="red">  81.         lhmac = hmac.new(self.credentials.secret_key.encode('utf-8'),</font>
<font color="red">  82.                          digestmod=sha256)</font>
<font color="red">  83.         pairs = []</font>
<font color="red">  84.         for key in sorted(params):</font>
<font color="black">  85.             # Any previous signature should not be a part of this</font>
<font color="black">  86.             # one, so we skip that particular key. This prevents</font>
<font color="black">  87.             # issues during retries.</font>
<font color="red">  88.             if key == 'Signature':</font>
<font color="red">  89.                 continue</font>
<font color="red">  90.             value = six.text_type(params[key])</font>
<font color="red">  91.             pairs.append(quote(key.encode('utf-8'), safe='') + '=' +</font>
<font color="red">  92.                          quote(value.encode('utf-8'), safe='-_~'))</font>
<font color="red">  93.         qs = '&amp;'.join(pairs)</font>
<font color="red">  94.         string_to_sign += qs</font>
<font color="red">  95.         logger.debug('String to sign: %s', string_to_sign)</font>
<font color="red">  96.         lhmac.update(string_to_sign.encode('utf-8'))</font>
<font color="red">  97.         b64 = base64.b64encode(lhmac.digest()).strip().decode('utf-8')</font>
<font color="red">  98.         return (qs, b64)</font>
<font color="black">  99. </font>
<font color="green"> 100.     def add_auth(self, request):</font>
<font color="black"> 101.         # The auth handler is the last thing called in the</font>
<font color="black"> 102.         # preparation phase of a prepared request.</font>
<font color="black"> 103.         # Because of this we have to parse the query params</font>
<font color="black"> 104.         # from the request body so we can update them with</font>
<font color="black"> 105.         # the sigv2 auth params.</font>
<font color="red"> 106.         if self.credentials is None:</font>
<font color="red"> 107.             raise NoCredentialsError</font>
<font color="red"> 108.         if request.data:</font>
<font color="black"> 109.             # POST</font>
<font color="red"> 110.             params = request.data</font>
<font color="black"> 111.         else:</font>
<font color="black"> 112.             # GET</font>
<font color="red"> 113.             params = request.params</font>
<font color="red"> 114.         params['AWSAccessKeyId'] = self.credentials.access_key</font>
<font color="red"> 115.         params['SignatureVersion'] = '2'</font>
<font color="red"> 116.         params['SignatureMethod'] = 'HmacSHA256'</font>
<font color="red"> 117.         params['Timestamp'] = time.strftime(ISO8601, time.gmtime())</font>
<font color="red"> 118.         if self.credentials.token:</font>
<font color="red"> 119.             params['SecurityToken'] = self.credentials.token</font>
<font color="red"> 120.         qs, signature = self.calc_signature(request, params)</font>
<font color="red"> 121.         params['Signature'] = signature</font>
<font color="red"> 122.         return request</font>
<font color="black"> 123. </font>
<font color="black"> 124. </font>
<font color="green"> 125. class SigV3Auth(BaseSigner):</font>
<font color="green"> 126.     def __init__(self, credentials):</font>
<font color="red"> 127.         self.credentials = credentials</font>
<font color="black"> 128. </font>
<font color="green"> 129.     def add_auth(self, request):</font>
<font color="red"> 130.         if self.credentials is None:</font>
<font color="red"> 131.             raise NoCredentialsError</font>
<font color="red"> 132.         if 'Date' in request.headers:</font>
<font color="red"> 133.             del request.headers['Date']</font>
<font color="red"> 134.         request.headers['Date'] = formatdate(usegmt=True)</font>
<font color="red"> 135.         if self.credentials.token:</font>
<font color="red"> 136.             if 'X-Amz-Security-Token' in request.headers:</font>
<font color="red"> 137.                 del request.headers['X-Amz-Security-Token']</font>
<font color="red"> 138.             request.headers['X-Amz-Security-Token'] = self.credentials.token</font>
<font color="red"> 139.         new_hmac = hmac.new(self.credentials.secret_key.encode('utf-8'),</font>
<font color="red"> 140.                             digestmod=sha256)</font>
<font color="red"> 141.         new_hmac.update(request.headers['Date'].encode('utf-8'))</font>
<font color="red"> 142.         encoded_signature = encodebytes(new_hmac.digest()).strip()</font>
<font color="red"> 143.         signature = ('AWS3-HTTPS AWSAccessKeyId=%s,Algorithm=%s,Signature=%s' %</font>
<font color="red"> 144.                      (self.credentials.access_key, 'HmacSHA256',</font>
<font color="red"> 145.                       encoded_signature.decode('utf-8')))</font>
<font color="red"> 146.         if 'X-Amzn-Authorization' in request.headers:</font>
<font color="red"> 147.             del request.headers['X-Amzn-Authorization']</font>
<font color="red"> 148.         request.headers['X-Amzn-Authorization'] = signature</font>
<font color="black"> 149. </font>
<font color="black"> 150. </font>
<font color="green"> 151. class SigV4Auth(BaseSigner):</font>
<font color="black"> 152.     &quot;&quot;&quot;</font>
<font color="black"> 153.     Sign a request with Signature V4.</font>
<font color="green"> 154.     &quot;&quot;&quot;</font>
<font color="green"> 155.     REQUIRES_REGION = True</font>
<font color="black"> 156. </font>
<font color="green"> 157.     def __init__(self, credentials, service_name, region_name):</font>
<font color="green"> 158.         self.credentials = credentials</font>
<font color="black"> 159.         # We initialize these value here so the unit tests can have</font>
<font color="black"> 160.         # valid values.  But these will get overriden in ``add_auth``</font>
<font color="black"> 161.         # later for real requests.</font>
<font color="green"> 162.         self._region_name = region_name</font>
<font color="green"> 163.         self._service_name = service_name</font>
<font color="black"> 164. </font>
<font color="green"> 165.     def _sign(self, key, msg, hex=False):</font>
<font color="green"> 166.         if hex:</font>
<font color="green"> 167.             sig = hmac.new(key, msg.encode('utf-8'), sha256).hexdigest()</font>
<font color="black"> 168.         else:</font>
<font color="green"> 169.             sig = hmac.new(key, msg.encode('utf-8'), sha256).digest()</font>
<font color="green"> 170.         return sig</font>
<font color="black"> 171. </font>
<font color="green"> 172.     def headers_to_sign(self, request):</font>
<font color="black"> 173.         &quot;&quot;&quot;</font>
<font color="black"> 174.         Select the headers from the request that need to be included</font>
<font color="black"> 175.         in the StringToSign.</font>
<font color="black"> 176.         &quot;&quot;&quot;</font>
<font color="green"> 177.         header_map = HTTPHeaders()</font>
<font color="green"> 178.         for name, value in request.headers.items():</font>
<font color="green"> 179.             lname = name.lower()</font>
<font color="green"> 180.             if lname not in SIGNED_HEADERS_BLACKLIST:</font>
<font color="green"> 181.                 header_map[lname] = value</font>
<font color="green"> 182.         if 'host' not in header_map:</font>
<font color="green"> 183.             header_map['host'] = self._canonical_host(request.url)</font>
<font color="green"> 184.         return header_map</font>
<font color="black"> 185. </font>
<font color="green"> 186.     def _canonical_host(self, url):</font>
<font color="green"> 187.         url_parts = urlsplit(url)</font>
<font color="green"> 188.         default_ports = {</font>
<font color="green"> 189.             'http': 80,</font>
<font color="green"> 190.             'https': 443</font>
<font color="black"> 191.         }</font>
<font color="green"> 192.         if any(url_parts.scheme == scheme and url_parts.port == port</font>
<font color="green"> 193.                for scheme, port in default_ports.items()):</font>
<font color="black"> 194.             # No need to include the port if it's the default port.</font>
<font color="red"> 195.             return url_parts.hostname</font>
<font color="black"> 196.         # Strip out auth if it's present in the netloc.</font>
<font color="green"> 197.         return url_parts.netloc.rsplit('@', 1)[-1]</font>
<font color="black"> 198. </font>
<font color="green"> 199.     def canonical_query_string(self, request):</font>
<font color="black"> 200.         # The query string can come from two parts.  One is the</font>
<font color="black"> 201.         # params attribute of the request.  The other is from the request</font>
<font color="black"> 202.         # url (in which case we have to re-split the url into its components</font>
<font color="black"> 203.         # and parse out the query string component).</font>
<font color="green"> 204.         if request.params:</font>
<font color="red"> 205.             return self._canonical_query_string_params(request.params)</font>
<font color="black"> 206.         else:</font>
<font color="green"> 207.             return self._canonical_query_string_url(urlsplit(request.url))</font>
<font color="black"> 208. </font>
<font color="green"> 209.     def _canonical_query_string_params(self, params):</font>
<font color="red"> 210.         l = []</font>
<font color="red"> 211.         for param in sorted(params):</font>
<font color="red"> 212.             value = str(params[param])</font>
<font color="red"> 213.             l.append('%s=%s' % (quote(param, safe='-_.~'),</font>
<font color="red"> 214.                                 quote(value, safe='-_.~')))</font>
<font color="red"> 215.         cqs = '&amp;'.join(l)</font>
<font color="red"> 216.         return cqs</font>
<font color="black"> 217. </font>
<font color="green"> 218.     def _canonical_query_string_url(self, parts):</font>
<font color="green"> 219.         canonical_query_string = ''</font>
<font color="green"> 220.         if parts.query:</font>
<font color="black"> 221.             # [(key, value), (key2, value2)]</font>
<font color="green"> 222.             key_val_pairs = []</font>
<font color="green"> 223.             for pair in parts.query.split('&amp;'):</font>
<font color="green"> 224.                 key, _, value = pair.partition('=')</font>
<font color="green"> 225.                 key_val_pairs.append((key, value))</font>
<font color="green"> 226.             sorted_key_vals = []</font>
<font color="black"> 227.             # Sort by the key names, and in the case of</font>
<font color="black"> 228.             # repeated keys, then sort by the value.</font>
<font color="green"> 229.             for key, value in sorted(key_val_pairs):</font>
<font color="green"> 230.                 sorted_key_vals.append('%s=%s' % (key, value))</font>
<font color="green"> 231.             canonical_query_string = '&amp;'.join(sorted_key_vals)</font>
<font color="green"> 232.         return canonical_query_string</font>
<font color="black"> 233. </font>
<font color="green"> 234.     def canonical_headers(self, headers_to_sign):</font>
<font color="black"> 235.         &quot;&quot;&quot;</font>
<font color="black"> 236.         Return the headers that need to be included in the StringToSign</font>
<font color="black"> 237.         in their canonical form by converting all header keys to lower</font>
<font color="black"> 238.         case, sorting them in alphabetical order and then joining</font>
<font color="black"> 239.         them into a string, separated by newlines.</font>
<font color="black"> 240.         &quot;&quot;&quot;</font>
<font color="green"> 241.         headers = []</font>
<font color="green"> 242.         sorted_header_names = sorted(set(headers_to_sign))</font>
<font color="green"> 243.         for key in sorted_header_names:</font>
<font color="green"> 244.             value = ','.join(self._header_value(v) for v in</font>
<font color="green"> 245.                              sorted(headers_to_sign.get_all(key)))</font>
<font color="green"> 246.             headers.append('%s:%s' % (key, ensure_unicode(value)))</font>
<font color="green"> 247.         return '\n'.join(headers)</font>
<font color="black"> 248. </font>
<font color="green"> 249.     def _header_value(self, value):</font>
<font color="black"> 250.         # From the sigv4 docs:</font>
<font color="black"> 251.         # Lowercase(HeaderName) + ':' + Trimall(HeaderValue)</font>
<font color="black"> 252.         #</font>
<font color="black"> 253.         # The Trimall function removes excess white space before and after</font>
<font color="black"> 254.         # values, and converts sequential spaces to a single space.</font>
<font color="green"> 255.         return ' '.join(value.split())</font>
<font color="black"> 256. </font>
<font color="green"> 257.     def signed_headers(self, headers_to_sign):</font>
<font color="green"> 258.         l = ['%s' % n.lower().strip() for n in set(headers_to_sign)]</font>
<font color="green"> 259.         l = sorted(l)</font>
<font color="green"> 260.         return ';'.join(l)</font>
<font color="black"> 261. </font>
<font color="green"> 262.     def payload(self, request):</font>
<font color="green"> 263.         if not self._should_sha256_sign_payload(request):</font>
<font color="black"> 264.             # When payload signing is disabled, we use this static string in</font>
<font color="black"> 265.             # place of the payload checksum.</font>
<font color="red"> 266.             return UNSIGNED_PAYLOAD</font>
<font color="green"> 267.         if request.body and hasattr(request.body, 'seek'):</font>
<font color="red"> 268.             position = request.body.tell()</font>
<font color="red"> 269.             read_chunksize = functools.partial(request.body.read,</font>
<font color="red"> 270.                                                PAYLOAD_BUFFER)</font>
<font color="red"> 271.             checksum = sha256()</font>
<font color="red"> 272.             for chunk in iter(read_chunksize, b''):</font>
<font color="red"> 273.                 checksum.update(chunk)</font>
<font color="red"> 274.             hex_checksum = checksum.hexdigest()</font>
<font color="red"> 275.             request.body.seek(position)</font>
<font color="red"> 276.             return hex_checksum</font>
<font color="green"> 277.         elif request.body:</font>
<font color="black"> 278.             # The request serialization has ensured that</font>
<font color="black"> 279.             # request.body is a bytes() type.</font>
<font color="green"> 280.             return sha256(request.body).hexdigest()</font>
<font color="black"> 281.         else:</font>
<font color="green"> 282.             return EMPTY_SHA256_HASH</font>
<font color="black"> 283. </font>
<font color="green"> 284.     def _should_sha256_sign_payload(self, request):</font>
<font color="black"> 285.         # Payloads will always be signed over insecure connections.</font>
<font color="green"> 286.         if not request.url.startswith('https'):</font>
<font color="red"> 287.             return True</font>
<font color="black"> 288. </font>
<font color="black"> 289.         # Certain operations may have payload signing disabled by default.</font>
<font color="black"> 290.         # Since we don't have access to the operation model, we pass in this</font>
<font color="black"> 291.         # bit of metadata through the request context.</font>
<font color="green"> 292.         return request.context.get('payload_signing_enabled', True)</font>
<font color="black"> 293. </font>
<font color="green"> 294.     def canonical_request(self, request):</font>
<font color="green"> 295.         cr = [request.method.upper()]</font>
<font color="green"> 296.         path = self._normalize_url_path(urlsplit(request.url).path)</font>
<font color="green"> 297.         cr.append(path)</font>
<font color="green"> 298.         cr.append(self.canonical_query_string(request))</font>
<font color="green"> 299.         headers_to_sign = self.headers_to_sign(request)</font>
<font color="green"> 300.         cr.append(self.canonical_headers(headers_to_sign) + '\n')</font>
<font color="green"> 301.         cr.append(self.signed_headers(headers_to_sign))</font>
<font color="green"> 302.         if 'X-Amz-Content-SHA256' in request.headers:</font>
<font color="green"> 303.             body_checksum = request.headers['X-Amz-Content-SHA256']</font>
<font color="black"> 304.         else:</font>
<font color="red"> 305.             body_checksum = self.payload(request)</font>
<font color="green"> 306.         cr.append(body_checksum)</font>
<font color="green"> 307.         return '\n'.join(cr)</font>
<font color="black"> 308. </font>
<font color="green"> 309.     def _normalize_url_path(self, path):</font>
<font color="red"> 310.         normalized_path = quote(normalize_url_path(path), safe='/~')</font>
<font color="red"> 311.         return normalized_path</font>
<font color="black"> 312. </font>
<font color="green"> 313.     def scope(self, request):</font>
<font color="green"> 314.         scope = [self.credentials.access_key]</font>
<font color="green"> 315.         scope.append(request.context['timestamp'][0:8])</font>
<font color="green"> 316.         scope.append(self._region_name)</font>
<font color="green"> 317.         scope.append(self._service_name)</font>
<font color="green"> 318.         scope.append('aws4_request')</font>
<font color="green"> 319.         return '/'.join(scope)</font>
<font color="black"> 320. </font>
<font color="green"> 321.     def credential_scope(self, request):</font>
<font color="green"> 322.         scope = []</font>
<font color="green"> 323.         scope.append(request.context['timestamp'][0:8])</font>
<font color="green"> 324.         scope.append(self._region_name)</font>
<font color="green"> 325.         scope.append(self._service_name)</font>
<font color="green"> 326.         scope.append('aws4_request')</font>
<font color="green"> 327.         return '/'.join(scope)</font>
<font color="black"> 328. </font>
<font color="green"> 329.     def string_to_sign(self, request, canonical_request):</font>
<font color="black"> 330.         &quot;&quot;&quot;</font>
<font color="black"> 331.         Return the canonical StringToSign as well as a dict</font>
<font color="black"> 332.         containing the original version of all headers that</font>
<font color="black"> 333.         were included in the StringToSign.</font>
<font color="black"> 334.         &quot;&quot;&quot;</font>
<font color="green"> 335.         sts = ['AWS4-HMAC-SHA256']</font>
<font color="green"> 336.         sts.append(request.context['timestamp'])</font>
<font color="green"> 337.         sts.append(self.credential_scope(request))</font>
<font color="green"> 338.         sts.append(sha256(canonical_request.encode('utf-8')).hexdigest())</font>
<font color="green"> 339.         return '\n'.join(sts)</font>
<font color="black"> 340. </font>
<font color="green"> 341.     def signature(self, string_to_sign, request):</font>
<font color="green"> 342.         key = self.credentials.secret_key</font>
<font color="green"> 343.         k_date = self._sign(('AWS4' + key).encode('utf-8'),</font>
<font color="green"> 344.                             request.context['timestamp'][0:8])</font>
<font color="green"> 345.         k_region = self._sign(k_date, self._region_name)</font>
<font color="green"> 346.         k_service = self._sign(k_region, self._service_name)</font>
<font color="green"> 347.         k_signing = self._sign(k_service, 'aws4_request')</font>
<font color="green"> 348.         return self._sign(k_signing, string_to_sign, hex=True)</font>
<font color="black"> 349. </font>
<font color="green"> 350.     def add_auth(self, request):</font>
<font color="green"> 351.         if self.credentials is None:</font>
<font color="red"> 352.             raise NoCredentialsError</font>
<font color="green"> 353.         datetime_now = datetime.datetime.utcnow()</font>
<font color="green"> 354.         request.context['timestamp'] = datetime_now.strftime(SIGV4_TIMESTAMP)</font>
<font color="black"> 355.         # This could be a retry.  Make sure the previous</font>
<font color="black"> 356.         # authorization header is removed first.</font>
<font color="green"> 357.         self._modify_request_before_signing(request)</font>
<font color="green"> 358.         canonical_request = self.canonical_request(request)</font>
<font color="green"> 359.         logger.debug(&quot;Calculating signature using v4 auth.&quot;)</font>
<font color="green"> 360.         logger.debug('CanonicalRequest:\n%s', canonical_request)</font>
<font color="green"> 361.         string_to_sign = self.string_to_sign(request, canonical_request)</font>
<font color="green"> 362.         logger.debug('StringToSign:\n%s', string_to_sign)</font>
<font color="green"> 363.         signature = self.signature(string_to_sign, request)</font>
<font color="green"> 364.         logger.debug('Signature:\n%s', signature)</font>
<font color="black"> 365. </font>
<font color="green"> 366.         self._inject_signature_to_request(request, signature)</font>
<font color="black"> 367. </font>
<font color="green"> 368.     def _inject_signature_to_request(self, request, signature):</font>
<font color="green"> 369.         l = ['AWS4-HMAC-SHA256 Credential=%s' % self.scope(request)]</font>
<font color="green"> 370.         headers_to_sign = self.headers_to_sign(request)</font>
<font color="green"> 371.         l.append('SignedHeaders=%s' % self.signed_headers(headers_to_sign))</font>
<font color="green"> 372.         l.append('Signature=%s' % signature)</font>
<font color="green"> 373.         request.headers['Authorization'] = ', '.join(l)</font>
<font color="green"> 374.         return request</font>
<font color="black"> 375. </font>
<font color="green"> 376.     def _modify_request_before_signing(self, request):</font>
<font color="green"> 377.         if 'Authorization' in request.headers:</font>
<font color="red"> 378.             del request.headers['Authorization']</font>
<font color="green"> 379.         self._set_necessary_date_headers(request)</font>
<font color="green"> 380.         if self.credentials.token:</font>
<font color="red"> 381.             if 'X-Amz-Security-Token' in request.headers:</font>
<font color="red"> 382.                 del request.headers['X-Amz-Security-Token']</font>
<font color="red"> 383.             request.headers['X-Amz-Security-Token'] = self.credentials.token</font>
<font color="black"> 384. </font>
<font color="green"> 385.         if not request.context.get('payload_signing_enabled', True):</font>
<font color="red"> 386.             if 'X-Amz-Content-SHA256' in request.headers:</font>
<font color="red"> 387.                 del request.headers['X-Amz-Content-SHA256']</font>
<font color="red"> 388.             request.headers['X-Amz-Content-SHA256'] = UNSIGNED_PAYLOAD</font>
<font color="black"> 389. </font>
<font color="green"> 390.     def _set_necessary_date_headers(self, request):</font>
<font color="black"> 391.         # The spec allows for either the Date _or_ the X-Amz-Date value to be</font>
<font color="black"> 392.         # used so we check both.  If there's a Date header, we use the date</font>
<font color="black"> 393.         # header.  Otherwise we use the X-Amz-Date header.</font>
<font color="green"> 394.         if 'Date' in request.headers:</font>
<font color="red"> 395.             del request.headers['Date']</font>
<font color="red"> 396.             datetime_timestamp = datetime.datetime.strptime(</font>
<font color="red"> 397.                 request.context['timestamp'], SIGV4_TIMESTAMP)</font>
<font color="red"> 398.             request.headers['Date'] = formatdate(</font>
<font color="red"> 399.                 int(calendar.timegm(datetime_timestamp.timetuple())))</font>
<font color="red"> 400.             if 'X-Amz-Date' in request.headers:</font>
<font color="red"> 401.                 del request.headers['X-Amz-Date']</font>
<font color="black"> 402.         else:</font>
<font color="green"> 403.             if 'X-Amz-Date' in request.headers:</font>
<font color="red"> 404.                 del request.headers['X-Amz-Date']</font>
<font color="green"> 405.             request.headers['X-Amz-Date'] = request.context['timestamp']</font>
<font color="black"> 406. </font>
<font color="black"> 407. </font>
<font color="green"> 408. class S3SigV4Auth(SigV4Auth):</font>
<font color="green"> 409.     def __init__(self, credentials, service_name, region_name):</font>
<font color="green"> 410.         super(S3SigV4Auth, self).__init__(</font>
<font color="green"> 411.             credentials, service_name, region_name)</font>
<font color="green"> 412.         self._default_region_name = region_name</font>
<font color="black"> 413. </font>
<font color="green"> 414.     def add_auth(self, request):</font>
<font color="black"> 415.         # If we ever decide to share auth sessions, this could potentially be</font>
<font color="black"> 416.         # a source of concurrency bugs.</font>
<font color="green"> 417.         signing_context = request.context.get('signing', {})</font>
<font color="green"> 418.         self._region_name = signing_context.get(</font>
<font color="green"> 419.             'region', self._default_region_name)</font>
<font color="green"> 420.         super(S3SigV4Auth, self).add_auth(request)</font>
<font color="black"> 421. </font>
<font color="green"> 422.     def _modify_request_before_signing(self, request):</font>
<font color="green"> 423.         super(S3SigV4Auth, self)._modify_request_before_signing(request)</font>
<font color="green"> 424.         if 'X-Amz-Content-SHA256' in request.headers:</font>
<font color="red"> 425.             del request.headers['X-Amz-Content-SHA256']</font>
<font color="black"> 426. </font>
<font color="green"> 427.         request.headers['X-Amz-Content-SHA256'] = self.payload(request)</font>
<font color="black"> 428. </font>
<font color="green"> 429.     def _should_sha256_sign_payload(self, request):</font>
<font color="black"> 430.         # S3 allows optional body signing, so to minimize the performance</font>
<font color="black"> 431.         # impact, we opt to not SHA256 sign the body on streaming uploads,</font>
<font color="black"> 432.         # provided that we're on https.</font>
<font color="green"> 433.         client_config = request.context.get('client_config')</font>
<font color="green"> 434.         s3_config = getattr(client_config, 's3', None)</font>
<font color="black"> 435. </font>
<font color="black"> 436.         # The config could be None if it isn't set, or if the customer sets it</font>
<font color="black"> 437.         # to None.</font>
<font color="green"> 438.         if s3_config is None:</font>
<font color="green"> 439.             s3_config = {}</font>
<font color="black"> 440. </font>
<font color="black"> 441.         # The explicit configuration takes precedence over any implicit</font>
<font color="black"> 442.         # configuration.</font>
<font color="green"> 443.         sign_payload = s3_config.get('payload_signing_enabled', None)</font>
<font color="green"> 444.         if sign_payload is not None:</font>
<font color="red"> 445.             return sign_payload</font>
<font color="black"> 446. </font>
<font color="black"> 447.         # We require that both content-md5 be present and https be enabled</font>
<font color="black"> 448.         # to implicitly disable body signing. The combination of TLS and</font>
<font color="black"> 449.         # content-md5 is sufficiently secure and durable for us to be</font>
<font color="black"> 450.         # confident in the request without body signing.</font>
<font color="green"> 451.         if not request.url.startswith('https') or \</font>
<font color="green"> 452.                 'Content-MD5' not in request.headers:</font>
<font color="green"> 453.             return True</font>
<font color="black"> 454. </font>
<font color="black"> 455.         # If the input is streaming we disable body signing by default.</font>
<font color="green"> 456.         if request.context.get('has_streaming_input', False):</font>
<font color="red"> 457.             return False</font>
<font color="black"> 458. </font>
<font color="black"> 459.         # If the S3-specific checks had no results, delegate to the generic</font>
<font color="black"> 460.         # checks.</font>
<font color="green"> 461.         return super(S3SigV4Auth, self)._should_sha256_sign_payload(request)</font>
<font color="black"> 462. </font>
<font color="green"> 463.     def _normalize_url_path(self, path):</font>
<font color="black"> 464.         # For S3, we do not normalize the path.</font>
<font color="green"> 465.         return path</font>
<font color="black"> 466. </font>
<font color="black"> 467. </font>
<font color="green"> 468. class SigV4QueryAuth(SigV4Auth):</font>
<font color="green"> 469.     DEFAULT_EXPIRES = 3600</font>
<font color="black"> 470. </font>
<font color="black"> 471.     def __init__(self, credentials, service_name, region_name,</font>
<font color="green"> 472.                  expires=DEFAULT_EXPIRES):</font>
<font color="red"> 473.         super(SigV4QueryAuth, self).__init__(credentials, service_name,</font>
<font color="red"> 474.                                              region_name)</font>
<font color="red"> 475.         self._expires = expires</font>
<font color="black"> 476. </font>
<font color="green"> 477.     def _modify_request_before_signing(self, request):</font>
<font color="black"> 478.         # We automatically set this header, so if it's the auto-set value we</font>
<font color="black"> 479.         # want to get rid of it since it doesn't make sense for presigned urls.</font>
<font color="red"> 480.         content_type = request.headers.get('content-type')</font>
<font color="black"> 481.         blacklisted_content_type = (</font>
<font color="red"> 482.             'application/x-www-form-urlencoded; charset=utf-8'</font>
<font color="black"> 483.         )</font>
<font color="red"> 484.         if content_type == blacklisted_content_type:</font>
<font color="red"> 485.             del request.headers['content-type']</font>
<font color="black"> 486. </font>
<font color="black"> 487.         # Note that we're not including X-Amz-Signature.</font>
<font color="black"> 488.         # From the docs: &quot;The Canonical Query String must include all the query</font>
<font color="black"> 489.         # parameters from the preceding table except for X-Amz-Signature.</font>
<font color="red"> 490.         signed_headers = self.signed_headers(self.headers_to_sign(request))</font>
<font color="black"> 491. </font>
<font color="red"> 492.         auth_params = {</font>
<font color="red"> 493.             'X-Amz-Algorithm': 'AWS4-HMAC-SHA256',</font>
<font color="red"> 494.             'X-Amz-Credential': self.scope(request),</font>
<font color="red"> 495.             'X-Amz-Date': request.context['timestamp'],</font>
<font color="red"> 496.             'X-Amz-Expires': self._expires,</font>
<font color="red"> 497.             'X-Amz-SignedHeaders': signed_headers,</font>
<font color="black"> 498.         }</font>
<font color="red"> 499.         if self.credentials.token is not None:</font>
<font color="red"> 500.             auth_params['X-Amz-Security-Token'] = self.credentials.token</font>
<font color="black"> 501.         # Now parse the original query string to a dict, inject our new query</font>
<font color="black"> 502.         # params, and serialize back to a query string.</font>
<font color="red"> 503.         url_parts = urlsplit(request.url)</font>
<font color="black"> 504.         # parse_qs makes each value a list, but in our case we know we won't</font>
<font color="black"> 505.         # have repeated keys so we know we have single element lists which we</font>
<font color="black"> 506.         # can convert back to scalar values.</font>
<font color="red"> 507.         query_dict = dict(</font>
<font color="red"> 508.             [(k, v[0]) for k, v in</font>
<font color="red"> 509.              parse_qs(url_parts.query, keep_blank_values=True).items()])</font>
<font color="black"> 510.         # The spec is particular about this.  It *has* to be:</font>
<font color="black"> 511.         # https://&lt;endpoint&gt;?&lt;operation params&gt;&amp;&lt;auth params&gt;</font>
<font color="black"> 512.         # You can't mix the two types of params together, i.e just keep doing</font>
<font color="black"> 513.         # new_query_params.update(op_params)</font>
<font color="black"> 514.         # new_query_params.update(auth_params)</font>
<font color="black"> 515.         # percent_encode_sequence(new_query_params)</font>
<font color="red"> 516.         operation_params = ''</font>
<font color="red"> 517.         if request.data:</font>
<font color="black"> 518.             # We also need to move the body params into the query string. To</font>
<font color="black"> 519.             # do this, we first have to convert it to a dict.</font>
<font color="red"> 520.             query_dict.update(self._get_body_as_dict(request))</font>
<font color="red"> 521.             request.data = ''</font>
<font color="red"> 522.         if query_dict:</font>
<font color="red"> 523.             operation_params = percent_encode_sequence(query_dict) + '&amp;'</font>
<font color="red"> 524.         new_query_string = (operation_params +</font>
<font color="red"> 525.                             percent_encode_sequence(auth_params))</font>
<font color="black"> 526.         # url_parts is a tuple (and therefore immutable) so we need to create</font>
<font color="black"> 527.         # a new url_parts with the new query string.</font>
<font color="black"> 528.         # &lt;part&gt;   - &lt;index&gt;</font>
<font color="black"> 529.         # scheme   - 0</font>
<font color="black"> 530.         # netloc   - 1</font>
<font color="black"> 531.         # path     - 2</font>
<font color="black"> 532.         # query    - 3  &lt;-- we're replacing this.</font>
<font color="black"> 533.         # fragment - 4</font>
<font color="red"> 534.         p = url_parts</font>
<font color="red"> 535.         new_url_parts = (p[0], p[1], p[2], new_query_string, p[4])</font>
<font color="red"> 536.         request.url = urlunsplit(new_url_parts)</font>
<font color="black"> 537. </font>
<font color="green"> 538.     def _get_body_as_dict(self, request):</font>
<font color="black"> 539.         # For query services, request.data is form-encoded and is already a</font>
<font color="black"> 540.         # dict, but for other services such as rest-json it could be a json</font>
<font color="black"> 541.         # string or bytes. In those cases we attempt to load the data as a</font>
<font color="black"> 542.         # dict.</font>
<font color="red"> 543.         data = request.data</font>
<font color="red"> 544.         if isinstance(data, six.binary_type):</font>
<font color="red"> 545.             data = json.loads(data.decode('utf-8'))</font>
<font color="red"> 546.         elif isinstance(data, six.string_types):</font>
<font color="red"> 547.             data = json.loads(data)</font>
<font color="red"> 548.         return data</font>
<font color="black"> 549. </font>
<font color="green"> 550.     def _inject_signature_to_request(self, request, signature):</font>
<font color="black"> 551.         # Rather than calculating an &quot;Authorization&quot; header, for the query</font>
<font color="black"> 552.         # param quth, we just append an 'X-Amz-Signature' param to the end</font>
<font color="black"> 553.         # of the query string.</font>
<font color="red"> 554.         request.url += '&amp;X-Amz-Signature=%s' % signature</font>
<font color="black"> 555. </font>
<font color="black"> 556. </font>
<font color="green"> 557. class S3SigV4QueryAuth(SigV4QueryAuth):</font>
<font color="black"> 558.     &quot;&quot;&quot;S3 SigV4 auth using query parameters.</font>
<font color="black"> 559. </font>
<font color="black"> 560.     This signer will sign a request using query parameters and signature</font>
<font color="black"> 561.     version 4, i.e a &quot;presigned url&quot; signer.</font>
<font color="black"> 562. </font>
<font color="black"> 563.     Based off of:</font>
<font color="black"> 564. </font>
<font color="black"> 565.     http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html</font>
<font color="black"> 566. </font>
<font color="green"> 567.     &quot;&quot;&quot;</font>
<font color="green"> 568.     def _normalize_url_path(self, path):</font>
<font color="black"> 569.         # For S3, we do not normalize the path.</font>
<font color="red"> 570.         return path</font>
<font color="black"> 571. </font>
<font color="green"> 572.     def payload(self, request):</font>
<font color="black"> 573.         # From the doc link above:</font>
<font color="black"> 574.         # &quot;You don't include a payload hash in the Canonical Request, because</font>
<font color="black"> 575.         # when you create a presigned URL, you don't know anything about the</font>
<font color="black"> 576.         # payload. Instead, you use a constant string &quot;UNSIGNED-PAYLOAD&quot;.</font>
<font color="red"> 577.         return UNSIGNED_PAYLOAD</font>
<font color="black"> 578. </font>
<font color="black"> 579. </font>
<font color="green"> 580. class S3SigV4PostAuth(SigV4Auth):</font>
<font color="black"> 581.     &quot;&quot;&quot;</font>
<font color="black"> 582.     Presigns a s3 post</font>
<font color="black"> 583. </font>
<font color="black"> 584.     Implementation doc here:</font>
<font color="black"> 585.     http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-UsingHTTPPOST.html</font>
<font color="green"> 586.     &quot;&quot;&quot;</font>
<font color="green"> 587.     def add_auth(self, request):</font>
<font color="red"> 588.         datetime_now = datetime.datetime.utcnow()</font>
<font color="red"> 589.         request.context['timestamp'] = datetime_now.strftime(SIGV4_TIMESTAMP)</font>
<font color="black"> 590. </font>
<font color="red"> 591.         fields = {}</font>
<font color="red"> 592.         if request.context.get('s3-presign-post-fields', None) is not None:</font>
<font color="red"> 593.             fields = request.context['s3-presign-post-fields']</font>
<font color="black"> 594. </font>
<font color="red"> 595.         policy = {}</font>
<font color="red"> 596.         conditions = []</font>
<font color="red"> 597.         if request.context.get('s3-presign-post-policy', None) is not None:</font>
<font color="red"> 598.             policy = request.context['s3-presign-post-policy']</font>
<font color="red"> 599.             if policy.get('conditions', None) is not None:</font>
<font color="red"> 600.                 conditions = policy['conditions']</font>
<font color="black"> 601. </font>
<font color="red"> 602.         policy['conditions'] = conditions</font>
<font color="black"> 603. </font>
<font color="red"> 604.         fields['x-amz-algorithm'] = 'AWS4-HMAC-SHA256'</font>
<font color="red"> 605.         fields['x-amz-credential'] = self.scope(request)</font>
<font color="red"> 606.         fields['x-amz-date'] = request.context['timestamp']</font>
<font color="black"> 607. </font>
<font color="red"> 608.         conditions.append({'x-amz-algorithm': 'AWS4-HMAC-SHA256'})</font>
<font color="red"> 609.         conditions.append({'x-amz-credential': self.scope(request)})</font>
<font color="red"> 610.         conditions.append({'x-amz-date': request.context['timestamp']})</font>
<font color="black"> 611. </font>
<font color="red"> 612.         if self.credentials.token is not None:</font>
<font color="red"> 613.             fields['x-amz-security-token'] = self.credentials.token</font>
<font color="red"> 614.             conditions.append({'x-amz-security-token': self.credentials.token})</font>
<font color="black"> 615. </font>
<font color="black"> 616.         # Dump the base64 encoded policy into the fields dictionary.</font>
<font color="red"> 617.         fields['policy'] = base64.b64encode(</font>
<font color="red"> 618.             json.dumps(policy).encode('utf-8')).decode('utf-8')</font>
<font color="black"> 619. </font>
<font color="red"> 620.         fields['x-amz-signature'] = self.signature(fields['policy'], request)</font>
<font color="black"> 621. </font>
<font color="red"> 622.         request.context['s3-presign-post-fields'] = fields</font>
<font color="red"> 623.         request.context['s3-presign-post-policy'] = policy</font>
<font color="black"> 624. </font>
<font color="black"> 625. </font>
<font color="green"> 626. class HmacV1Auth(BaseSigner):</font>
<font color="black"> 627. </font>
<font color="black"> 628.     # List of Query String Arguments of Interest</font>
<font color="green"> 629.     QSAOfInterest = ['accelerate', 'acl', 'cors', 'defaultObjectAcl',</font>
<font color="green"> 630.                      'location', 'logging', 'partNumber', 'policy',</font>
<font color="green"> 631.                      'requestPayment', 'torrent',</font>
<font color="green"> 632.                      'versioning', 'versionId', 'versions', 'website',</font>
<font color="green"> 633.                      'uploads', 'uploadId', 'response-content-type',</font>
<font color="green"> 634.                      'response-content-language', 'response-expires',</font>
<font color="green"> 635.                      'response-cache-control', 'response-content-disposition',</font>
<font color="green"> 636.                      'response-content-encoding', 'delete', 'lifecycle',</font>
<font color="green"> 637.                      'tagging', 'restore', 'storageClass', 'notification',</font>
<font color="green"> 638.                      'replication', 'requestPayment', 'analytics', 'metrics',</font>
<font color="green"> 639.                      'inventory', 'select', 'select-type']</font>
<font color="black"> 640. </font>
<font color="green"> 641.     def __init__(self, credentials, service_name=None, region_name=None):</font>
<font color="red"> 642.         self.credentials = credentials</font>
<font color="black"> 643. </font>
<font color="green"> 644.     def sign_string(self, string_to_sign):</font>
<font color="red"> 645.         new_hmac = hmac.new(self.credentials.secret_key.encode('utf-8'),</font>
<font color="red"> 646.                             digestmod=sha1)</font>
<font color="red"> 647.         new_hmac.update(string_to_sign.encode('utf-8'))</font>
<font color="red"> 648.         return encodebytes(new_hmac.digest()).strip().decode('utf-8')</font>
<font color="black"> 649. </font>
<font color="green"> 650.     def canonical_standard_headers(self, headers):</font>
<font color="red"> 651.         interesting_headers = ['content-md5', 'content-type', 'date']</font>
<font color="red"> 652.         hoi = []</font>
<font color="red"> 653.         if 'Date' in headers:</font>
<font color="red"> 654.             del headers['Date']</font>
<font color="red"> 655.         headers['Date'] = self._get_date()</font>
<font color="red"> 656.         for ih in interesting_headers:</font>
<font color="red"> 657.             found = False</font>
<font color="red"> 658.             for key in headers:</font>
<font color="red"> 659.                 lk = key.lower()</font>
<font color="red"> 660.                 if headers[key] is not None and lk == ih:</font>
<font color="red"> 661.                     hoi.append(headers[key].strip())</font>
<font color="red"> 662.                     found = True</font>
<font color="red"> 663.             if not found:</font>
<font color="red"> 664.                 hoi.append('')</font>
<font color="red"> 665.         return '\n'.join(hoi)</font>
<font color="black"> 666. </font>
<font color="green"> 667.     def canonical_custom_headers(self, headers):</font>
<font color="red"> 668.         hoi = []</font>
<font color="red"> 669.         custom_headers = {}</font>
<font color="red"> 670.         for key in headers:</font>
<font color="red"> 671.             lk = key.lower()</font>
<font color="red"> 672.             if headers[key] is not None:</font>
<font color="red"> 673.                 if lk.startswith('x-amz-'):</font>
<font color="red"> 674.                     custom_headers[lk] = ','.join(v.strip() for v in</font>
<font color="red"> 675.                                                   headers.get_all(key))</font>
<font color="red"> 676.         sorted_header_keys = sorted(custom_headers.keys())</font>
<font color="red"> 677.         for key in sorted_header_keys:</font>
<font color="red"> 678.             hoi.append(&quot;%s:%s&quot; % (key, custom_headers[key]))</font>
<font color="red"> 679.         return '\n'.join(hoi)</font>
<font color="black"> 680. </font>
<font color="green"> 681.     def unquote_v(self, nv):</font>
<font color="black"> 682.         &quot;&quot;&quot;</font>
<font color="black"> 683.         TODO: Do we need this?</font>
<font color="black"> 684.         &quot;&quot;&quot;</font>
<font color="red"> 685.         if len(nv) == 1:</font>
<font color="red"> 686.             return nv</font>
<font color="black"> 687.         else:</font>
<font color="red"> 688.             return (nv[0], unquote(nv[1]))</font>
<font color="black"> 689. </font>
<font color="green"> 690.     def canonical_resource(self, split, auth_path=None):</font>
<font color="black"> 691.         # don't include anything after the first ? in the resource...</font>
<font color="black"> 692.         # unless it is one of the QSA of interest, defined above</font>
<font color="black"> 693.         # NOTE:</font>
<font color="black"> 694.         # The path in the canonical resource should always be the</font>
<font color="black"> 695.         # full path including the bucket name, even for virtual-hosting</font>
<font color="black"> 696.         # style addressing.  The ``auth_path`` keeps track of the full</font>
<font color="black"> 697.         # path for the canonical resource and would be passed in if</font>
<font color="black"> 698.         # the client was using virtual-hosting style.</font>
<font color="red"> 699.         if auth_path is not None:</font>
<font color="red"> 700.             buf = auth_path</font>
<font color="black"> 701.         else:</font>
<font color="red"> 702.             buf = split.path</font>
<font color="red"> 703.         if split.query:</font>
<font color="red"> 704.             qsa = split.query.split('&amp;')</font>
<font color="red"> 705.             qsa = [a.split('=', 1) for a in qsa]</font>
<font color="red"> 706.             qsa = [self.unquote_v(a) for a in qsa</font>
<font color="red"> 707.                    if a[0] in self.QSAOfInterest]</font>
<font color="red"> 708.             if len(qsa) &gt; 0:</font>
<font color="red"> 709.                 qsa.sort(key=itemgetter(0))</font>
<font color="red"> 710.                 qsa = ['='.join(a) for a in qsa]</font>
<font color="red"> 711.                 buf += '?'</font>
<font color="red"> 712.                 buf += '&amp;'.join(qsa)</font>
<font color="red"> 713.         return buf</font>
<font color="black"> 714. </font>
<font color="green"> 715.     def canonical_string(self, method, split, headers, expires=None,</font>
<font color="green"> 716.                          auth_path=None):</font>
<font color="red"> 717.         cs = method.upper() + '\n'</font>
<font color="red"> 718.         cs += self.canonical_standard_headers(headers) + '\n'</font>
<font color="red"> 719.         custom_headers = self.canonical_custom_headers(headers)</font>
<font color="red"> 720.         if custom_headers:</font>
<font color="red"> 721.             cs += custom_headers + '\n'</font>
<font color="red"> 722.         cs += self.canonical_resource(split, auth_path=auth_path)</font>
<font color="red"> 723.         return cs</font>
<font color="black"> 724. </font>
<font color="green"> 725.     def get_signature(self, method, split, headers, expires=None,</font>
<font color="green"> 726.                       auth_path=None):</font>
<font color="red"> 727.         if self.credentials.token:</font>
<font color="red"> 728.             del headers['x-amz-security-token']</font>
<font color="red"> 729.             headers['x-amz-security-token'] = self.credentials.token</font>
<font color="red"> 730.         string_to_sign = self.canonical_string(method,</font>
<font color="red"> 731.                                                split,</font>
<font color="red"> 732.                                                headers,</font>
<font color="red"> 733.                                                auth_path=auth_path)</font>
<font color="red"> 734.         logger.debug('StringToSign:\n%s', string_to_sign)</font>
<font color="red"> 735.         return self.sign_string(string_to_sign)</font>
<font color="black"> 736. </font>
<font color="green"> 737.     def add_auth(self, request):</font>
<font color="red"> 738.         if self.credentials is None:</font>
<font color="red"> 739.             raise NoCredentialsError</font>
<font color="red"> 740.         logger.debug(&quot;Calculating signature using hmacv1 auth.&quot;)</font>
<font color="red"> 741.         split = urlsplit(request.url)</font>
<font color="red"> 742.         logger.debug('HTTP request method: %s', request.method)</font>
<font color="red"> 743.         signature = self.get_signature(request.method, split,</font>
<font color="red"> 744.                                        request.headers,</font>
<font color="red"> 745.                                        auth_path=request.auth_path)</font>
<font color="red"> 746.         self._inject_signature(request, signature)</font>
<font color="black"> 747. </font>
<font color="green"> 748.     def _get_date(self):</font>
<font color="red"> 749.         return formatdate(usegmt=True)</font>
<font color="black"> 750. </font>
<font color="green"> 751.     def _inject_signature(self, request, signature):</font>
<font color="red"> 752.         if 'Authorization' in request.headers:</font>
<font color="black"> 753.             # We have to do this because request.headers is not</font>
<font color="black"> 754.             # normal dictionary.  It has the (unintuitive) behavior</font>
<font color="black"> 755.             # of aggregating repeated setattr calls for the same</font>
<font color="black"> 756.             # key value.  For example:</font>
<font color="black"> 757.             # headers['foo'] = 'a'; headers['foo'] = 'b'</font>
<font color="black"> 758.             # list(headers) will print ['foo', 'foo'].</font>
<font color="red"> 759.             del request.headers['Authorization']</font>
<font color="black"> 760.         request.headers['Authorization'] = (</font>
<font color="red"> 761.             &quot;AWS %s:%s&quot; % (self.credentials.access_key, signature))</font>
<font color="black"> 762. </font>
<font color="black"> 763. </font>
<font color="green"> 764. class HmacV1QueryAuth(HmacV1Auth):</font>
<font color="black"> 765.     &quot;&quot;&quot;</font>
<font color="black"> 766.     Generates a presigned request for s3.</font>
<font color="black"> 767. </font>
<font color="black"> 768.     Spec from this document:</font>
<font color="black"> 769. </font>
<font color="black"> 770.     http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html</font>
<font color="black"> 771.     #RESTAuthenticationQueryStringAuth</font>
<font color="black"> 772. </font>
<font color="green"> 773.     &quot;&quot;&quot;</font>
<font color="green"> 774.     DEFAULT_EXPIRES = 3600</font>
<font color="black"> 775. </font>
<font color="green"> 776.     def __init__(self, credentials, expires=DEFAULT_EXPIRES):</font>
<font color="red"> 777.         self.credentials = credentials</font>
<font color="red"> 778.         self._expires = expires</font>
<font color="black"> 779. </font>
<font color="green"> 780.     def _get_date(self):</font>
<font color="red"> 781.         return str(int(time.time() + int(self._expires)))</font>
<font color="black"> 782. </font>
<font color="green"> 783.     def _inject_signature(self, request, signature):</font>
<font color="red"> 784.         query_dict = {}</font>
<font color="red"> 785.         query_dict['AWSAccessKeyId'] = self.credentials.access_key</font>
<font color="red"> 786.         query_dict['Signature'] = signature</font>
<font color="black"> 787. </font>
<font color="red"> 788.         for header_key in request.headers:</font>
<font color="red"> 789.             lk = header_key.lower()</font>
<font color="black"> 790.             # For query string requests, Expires is used instead of the</font>
<font color="black"> 791.             # Date header.</font>
<font color="red"> 792.             if header_key == 'Date':</font>
<font color="red"> 793.                 query_dict['Expires'] = request.headers['Date']</font>
<font color="black"> 794.             # We only want to include relevant headers in the query string.</font>
<font color="black"> 795.             # These can be anything that starts with x-amz, is Content-MD5,</font>
<font color="black"> 796.             # or is Content-Type.</font>
<font color="red"> 797.             elif lk.startswith('x-amz-') or lk in ['content-md5',</font>
<font color="red"> 798.                                                    'content-type']:</font>
<font color="red"> 799.                 query_dict[lk] = request.headers[lk]</font>
<font color="black"> 800.         # Combine all of the identified headers into an encoded</font>
<font color="black"> 801.         # query string</font>
<font color="red"> 802.         new_query_string = percent_encode_sequence(query_dict)</font>
<font color="black"> 803. </font>
<font color="black"> 804.         # Create a new url with the presigned url.</font>
<font color="red"> 805.         p = urlsplit(request.url)</font>
<font color="red"> 806.         if p[3]:</font>
<font color="black"> 807.             # If there was a pre-existing query string, we should</font>
<font color="black"> 808.             # add that back before injecting the new query string.</font>
<font color="red"> 809.             new_query_string = '%s&amp;%s' % (p[3], new_query_string)</font>
<font color="red"> 810.         new_url_parts = (p[0], p[1], p[2], new_query_string, p[4])</font>
<font color="red"> 811.         request.url = urlunsplit(new_url_parts)</font>
<font color="black"> 812. </font>
<font color="black"> 813. </font>
<font color="green"> 814. class HmacV1PostAuth(HmacV1Auth):</font>
<font color="black"> 815.     &quot;&quot;&quot;</font>
<font color="black"> 816.     Generates a presigned post for s3.</font>
<font color="black"> 817. </font>
<font color="black"> 818.     Spec from this document:</font>
<font color="black"> 819. </font>
<font color="black"> 820.     http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingHTTPPOST.html</font>
<font color="green"> 821.     &quot;&quot;&quot;</font>
<font color="green"> 822.     def add_auth(self, request):</font>
<font color="red"> 823.         fields = {}</font>
<font color="red"> 824.         if request.context.get('s3-presign-post-fields', None) is not None:</font>
<font color="red"> 825.             fields = request.context['s3-presign-post-fields']</font>
<font color="black"> 826. </font>
<font color="red"> 827.         policy = {}</font>
<font color="red"> 828.         conditions = []</font>
<font color="red"> 829.         if request.context.get('s3-presign-post-policy', None) is not None:</font>
<font color="red"> 830.             policy = request.context['s3-presign-post-policy']</font>
<font color="red"> 831.             if policy.get('conditions', None) is not None:</font>
<font color="red"> 832.                 conditions = policy['conditions']</font>
<font color="black"> 833. </font>
<font color="red"> 834.         policy['conditions'] = conditions</font>
<font color="black"> 835. </font>
<font color="red"> 836.         fields['AWSAccessKeyId'] = self.credentials.access_key</font>
<font color="black"> 837. </font>
<font color="red"> 838.         if self.credentials.token is not None:</font>
<font color="red"> 839.             fields['x-amz-security-token'] = self.credentials.token</font>
<font color="red"> 840.             conditions.append({'x-amz-security-token': self.credentials.token})</font>
<font color="black"> 841. </font>
<font color="black"> 842.         # Dump the base64 encoded policy into the fields dictionary.</font>
<font color="red"> 843.         fields['policy'] = base64.b64encode(</font>
<font color="red"> 844.             json.dumps(policy).encode('utf-8')).decode('utf-8')</font>
<font color="black"> 845. </font>
<font color="red"> 846.         fields['signature'] = self.sign_string(fields['policy'])</font>
<font color="black"> 847. </font>
<font color="red"> 848.         request.context['s3-presign-post-fields'] = fields</font>
<font color="red"> 849.         request.context['s3-presign-post-policy'] = policy</font>
<font color="black"> 850. </font>
<font color="black"> 851. </font>
<font color="black"> 852. # Defined at the bottom instead of the top of the module because the Auth</font>
<font color="black"> 853. # classes weren't defined yet.</font>
<font color="green"> 854. AUTH_TYPE_MAPS = {</font>
<font color="green"> 855.     'v2': SigV2Auth,</font>
<font color="green"> 856.     'v4': SigV4Auth,</font>
<font color="green"> 857.     'v4-query': SigV4QueryAuth,</font>
<font color="green"> 858.     'v3': SigV3Auth,</font>
<font color="green"> 859.     'v3https': SigV3Auth,</font>
<font color="green"> 860.     's3': HmacV1Auth,</font>
<font color="green"> 861.     's3-query': HmacV1QueryAuth,</font>
<font color="green"> 862.     's3-presign-post': HmacV1PostAuth,</font>
<font color="green"> 863.     's3v4': S3SigV4Auth,</font>
<font color="green"> 864.     's3v4-query': S3SigV4QueryAuth,</font>
<font color="green"> 865.     's3v4-presign-post': S3SigV4PostAuth,</font>
<font color="black"> 866. </font>
<font color="black"> 867. }</font>
</pre>

