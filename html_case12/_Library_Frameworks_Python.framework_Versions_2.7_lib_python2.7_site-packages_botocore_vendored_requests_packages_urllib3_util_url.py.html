source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/botocore/vendored/requests/packages/urllib3/util/url.py</b><br>


file stats: <b>97 lines, 53 executed: 54.6% covered</b>
<pre>
<font color="green">   1. from collections import namedtuple</font>
<font color="black">   2. </font>
<font color="green">   3. from ..exceptions import LocationParseError</font>
<font color="black">   4. </font>
<font color="black">   5. </font>
<font color="green">   6. url_attrs = ['scheme', 'auth', 'host', 'port', 'path', 'query', 'fragment']</font>
<font color="black">   7. </font>
<font color="black">   8. </font>
<font color="green">   9. class Url(namedtuple('Url', url_attrs)):</font>
<font color="black">  10.     &quot;&quot;&quot;</font>
<font color="black">  11.     Datastructure for representing an HTTP URL. Used as a return value for</font>
<font color="black">  12.     :func:`parse_url`.</font>
<font color="green">  13.     &quot;&quot;&quot;</font>
<font color="green">  14.     slots = ()</font>
<font color="black">  15. </font>
<font color="green">  16.     def __new__(cls, scheme=None, auth=None, host=None, port=None, path=None,</font>
<font color="green">  17.                 query=None, fragment=None):</font>
<font color="green">  18.         if path and not path.startswith('/'):</font>
<font color="red">  19.             path = '/' + path</font>
<font color="green">  20.         return super(Url, cls).__new__(cls, scheme, auth, host, port, path,</font>
<font color="green">  21.                                        query, fragment)</font>
<font color="black">  22. </font>
<font color="green">  23.     @property</font>
<font color="black">  24.     def hostname(self):</font>
<font color="black">  25.         &quot;&quot;&quot;For backwards-compatibility with urlparse. We're nice like that.&quot;&quot;&quot;</font>
<font color="red">  26.         return self.host</font>
<font color="black">  27. </font>
<font color="green">  28.     @property</font>
<font color="black">  29.     def request_uri(self):</font>
<font color="black">  30.         &quot;&quot;&quot;Absolute path including the query string.&quot;&quot;&quot;</font>
<font color="red">  31.         uri = self.path or '/'</font>
<font color="black">  32. </font>
<font color="red">  33.         if self.query is not None:</font>
<font color="red">  34.             uri += '?' + self.query</font>
<font color="black">  35. </font>
<font color="red">  36.         return uri</font>
<font color="black">  37. </font>
<font color="green">  38.     @property</font>
<font color="black">  39.     def netloc(self):</font>
<font color="black">  40.         &quot;&quot;&quot;Network location including host and port&quot;&quot;&quot;</font>
<font color="red">  41.         if self.port:</font>
<font color="red">  42.             return '%s:%d' % (self.host, self.port)</font>
<font color="red">  43.         return self.host</font>
<font color="black">  44. </font>
<font color="green">  45.     @property</font>
<font color="black">  46.     def url(self):</font>
<font color="black">  47.         &quot;&quot;&quot;</font>
<font color="black">  48.         Convert self into a url</font>
<font color="black">  49. </font>
<font color="black">  50.         This function should more or less round-trip with :func:`.parse_url`. The</font>
<font color="black">  51.         returned url may not be exactly the same as the url inputted to</font>
<font color="black">  52.         :func:`.parse_url`, but it should be equivalent by the RFC (e.g., urls</font>
<font color="black">  53.         with a blank port will have : removed).</font>
<font color="black">  54. </font>
<font color="black">  55.         Example: ::</font>
<font color="black">  56. </font>
<font color="black">  57.             &gt;&gt;&gt; U = parse_url('http://google.com/mail/')</font>
<font color="black">  58.             &gt;&gt;&gt; U.url</font>
<font color="black">  59.             'http://google.com/mail/'</font>
<font color="black">  60.             &gt;&gt;&gt; Url('http', 'username:password', 'host.com', 80,</font>
<font color="black">  61.             ... '/path', 'query', 'fragment').url</font>
<font color="black">  62.             'http://username:password@host.com:80/path?query#fragment'</font>
<font color="black">  63.         &quot;&quot;&quot;</font>
<font color="red">  64.         scheme, auth, host, port, path, query, fragment = self</font>
<font color="red">  65.         url = ''</font>
<font color="black">  66. </font>
<font color="black">  67.         # We use &quot;is not None&quot; we want things to happen with empty strings (or 0 port)</font>
<font color="red">  68.         if scheme is not None:</font>
<font color="red">  69.             url += scheme + '://'</font>
<font color="red">  70.         if auth is not None:</font>
<font color="red">  71.             url += auth + '@'</font>
<font color="red">  72.         if host is not None:</font>
<font color="red">  73.             url += host</font>
<font color="red">  74.         if port is not None:</font>
<font color="red">  75.             url += ':' + str(port)</font>
<font color="red">  76.         if path is not None:</font>
<font color="red">  77.             url += path</font>
<font color="red">  78.         if query is not None:</font>
<font color="red">  79.             url += '?' + query</font>
<font color="red">  80.         if fragment is not None:</font>
<font color="red">  81.             url += '#' + fragment</font>
<font color="black">  82. </font>
<font color="red">  83.         return url</font>
<font color="black">  84. </font>
<font color="green">  85.     def __str__(self):</font>
<font color="red">  86.         return self.url</font>
<font color="black">  87. </font>
<font color="green">  88. def split_first(s, delims):</font>
<font color="black">  89.     &quot;&quot;&quot;</font>
<font color="black">  90.     Given a string and an iterable of delimiters, split on the first found</font>
<font color="black">  91.     delimiter. Return two split parts and the matched delimiter.</font>
<font color="black">  92. </font>
<font color="black">  93.     If not found, then the first part is the full input string.</font>
<font color="black">  94. </font>
<font color="black">  95.     Example::</font>
<font color="black">  96. </font>
<font color="black">  97.         &gt;&gt;&gt; split_first('foo/bar?baz', '?/=')</font>
<font color="black">  98.         ('foo', 'bar?baz', '/')</font>
<font color="black">  99.         &gt;&gt;&gt; split_first('foo/bar?baz', '123')</font>
<font color="black"> 100.         ('foo/bar?baz', '', None)</font>
<font color="black"> 101. </font>
<font color="black"> 102.     Scales linearly with number of delims. Not ideal for large number of delims.</font>
<font color="black"> 103.     &quot;&quot;&quot;</font>
<font color="green"> 104.     min_idx = None</font>
<font color="green"> 105.     min_delim = None</font>
<font color="green"> 106.     for d in delims:</font>
<font color="green"> 107.         idx = s.find(d)</font>
<font color="green"> 108.         if idx &lt; 0:</font>
<font color="green"> 109.             continue</font>
<font color="black"> 110. </font>
<font color="green"> 111.         if min_idx is None or idx &lt; min_idx:</font>
<font color="green"> 112.             min_idx = idx</font>
<font color="green"> 113.             min_delim = d</font>
<font color="black"> 114. </font>
<font color="green"> 115.     if min_idx is None or min_idx &lt; 0:</font>
<font color="red"> 116.         return s, '', None</font>
<font color="black"> 117. </font>
<font color="green"> 118.     return s[:min_idx], s[min_idx+1:], min_delim</font>
<font color="black"> 119. </font>
<font color="black"> 120. </font>
<font color="green"> 121. def parse_url(url):</font>
<font color="black"> 122.     &quot;&quot;&quot;</font>
<font color="black"> 123.     Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is</font>
<font color="black"> 124.     performed to parse incomplete urls. Fields not provided will be None.</font>
<font color="black"> 125. </font>
<font color="black"> 126.     Partly backwards-compatible with :mod:`urlparse`.</font>
<font color="black"> 127. </font>
<font color="black"> 128.     Example::</font>
<font color="black"> 129. </font>
<font color="black"> 130.         &gt;&gt;&gt; parse_url('http://google.com/mail/')</font>
<font color="black"> 131.         Url(scheme='http', host='google.com', port=None, path='/mail/', ...)</font>
<font color="black"> 132.         &gt;&gt;&gt; parse_url('google.com:80')</font>
<font color="black"> 133.         Url(scheme=None, host='google.com', port=80, path=None, ...)</font>
<font color="black"> 134.         &gt;&gt;&gt; parse_url('/foo?bar')</font>
<font color="black"> 135.         Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)</font>
<font color="black"> 136.     &quot;&quot;&quot;</font>
<font color="black"> 137. </font>
<font color="black"> 138.     # While this code has overlap with stdlib's urlparse, it is much</font>
<font color="black"> 139.     # simplified for our needs and less annoying.</font>
<font color="black"> 140.     # Additionally, this implementations does silly things to be optimal</font>
<font color="black"> 141.     # on CPython.</font>
<font color="black"> 142. </font>
<font color="green"> 143.     if not url:</font>
<font color="black"> 144.         # Empty</font>
<font color="red"> 145.         return Url()</font>
<font color="black"> 146. </font>
<font color="green"> 147.     scheme = None</font>
<font color="green"> 148.     auth = None</font>
<font color="green"> 149.     host = None</font>
<font color="green"> 150.     port = None</font>
<font color="green"> 151.     path = None</font>
<font color="green"> 152.     fragment = None</font>
<font color="green"> 153.     query = None</font>
<font color="black"> 154. </font>
<font color="black"> 155.     # Scheme</font>
<font color="green"> 156.     if '://' in url:</font>
<font color="green"> 157.         scheme, url = url.split('://', 1)</font>
<font color="black"> 158. </font>
<font color="black"> 159.     # Find the earliest Authority Terminator</font>
<font color="black"> 160.     # (http://tools.ietf.org/html/rfc3986#section-3.2)</font>
<font color="green"> 161.     url, path_, delim = split_first(url, ['/', '?', '#'])</font>
<font color="black"> 162. </font>
<font color="green"> 163.     if delim:</font>
<font color="black"> 164.         # Reassemble the path</font>
<font color="green"> 165.         path = delim + path_</font>
<font color="black"> 166. </font>
<font color="black"> 167.     # Auth</font>
<font color="green"> 168.     if '@' in url:</font>
<font color="black"> 169.         # Last '@' denotes end of auth part</font>
<font color="red"> 170.         auth, url = url.rsplit('@', 1)</font>
<font color="black"> 171. </font>
<font color="black"> 172.     # IPv6</font>
<font color="green"> 173.     if url and url[0] == '[':</font>
<font color="red"> 174.         host, url = url.split(']', 1)</font>
<font color="red"> 175.         host += ']'</font>
<font color="black"> 176. </font>
<font color="black"> 177.     # Port</font>
<font color="green"> 178.     if ':' in url:</font>
<font color="red"> 179.         _host, port = url.split(':', 1)</font>
<font color="black"> 180. </font>
<font color="red"> 181.         if not host:</font>
<font color="red"> 182.             host = _host</font>
<font color="black"> 183. </font>
<font color="red"> 184.         if port:</font>
<font color="black"> 185.             # If given, ports must be integers.</font>
<font color="red"> 186.             if not port.isdigit():</font>
<font color="red"> 187.                 raise LocationParseError(url)</font>
<font color="red"> 188.             port = int(port)</font>
<font color="black"> 189.         else:</font>
<font color="black"> 190.             # Blank ports are cool, too. (rfc3986#section-3.2.3)</font>
<font color="red"> 191.             port = None</font>
<font color="black"> 192. </font>
<font color="green"> 193.     elif not host and url:</font>
<font color="green"> 194.         host = url</font>
<font color="black"> 195. </font>
<font color="green"> 196.     if not path:</font>
<font color="red"> 197.         return Url(scheme, auth, host, port, path, query, fragment)</font>
<font color="black"> 198. </font>
<font color="black"> 199.     # Fragment</font>
<font color="green"> 200.     if '#' in path:</font>
<font color="red"> 201.         path, fragment = path.split('#', 1)</font>
<font color="black"> 202. </font>
<font color="black"> 203.     # Query</font>
<font color="green"> 204.     if '?' in path:</font>
<font color="green"> 205.         path, query = path.split('?', 1)</font>
<font color="black"> 206. </font>
<font color="green"> 207.     return Url(scheme, auth, host, port, path, query, fragment)</font>
<font color="black"> 208. </font>
<font color="green"> 209. def get_host(url):</font>
<font color="black"> 210.     &quot;&quot;&quot;</font>
<font color="black"> 211.     Deprecated. Use :func:`.parse_url` instead.</font>
<font color="black"> 212.     &quot;&quot;&quot;</font>
<font color="red"> 213.     p = parse_url(url)</font>
<font color="red"> 214.     return p.scheme or 'http', p.hostname, p.port</font>
</pre>

