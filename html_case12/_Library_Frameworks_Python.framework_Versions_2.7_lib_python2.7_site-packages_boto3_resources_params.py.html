source file: <b>/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/boto3/resources/params.py</b><br>


file stats: <b>57 lines, 8 executed: 14.0% covered</b>
<pre>
<font color="black">   1. # Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.</font>
<font color="black">   2. #</font>
<font color="black">   3. # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You</font>
<font color="black">   4. # may not use this file except in compliance with the License. A copy of</font>
<font color="black">   5. # the License is located at</font>
<font color="black">   6. #</font>
<font color="black">   7. # http://aws.amazon.com/apache2.0/</font>
<font color="black">   8. #</font>
<font color="black">   9. # or in the &quot;license&quot; file accompanying this file. This file is</font>
<font color="black">  10. # distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF</font>
<font color="black">  11. # ANY KIND, either express or implied. See the License for the specific</font>
<font color="black">  12. # language governing permissions and limitations under the License.</font>
<font color="black">  13. </font>
<font color="green">  14. import re</font>
<font color="black">  15. </font>
<font color="green">  16. import jmespath</font>
<font color="green">  17. from botocore import xform_name</font>
<font color="black">  18. </font>
<font color="green">  19. from ..exceptions import ResourceLoadException</font>
<font color="black">  20. </font>
<font color="black">  21. </font>
<font color="green">  22. INDEX_RE = re.compile('\[(.*)\]$')</font>
<font color="black">  23. </font>
<font color="black">  24. </font>
<font color="green">  25. def get_data_member(parent, path):</font>
<font color="black">  26.     &quot;&quot;&quot;</font>
<font color="black">  27.     Get a data member from a parent using a JMESPath search query,</font>
<font color="black">  28.     loading the parent if required. If the parent cannot be loaded</font>
<font color="black">  29.     and no data is present then an exception is raised.</font>
<font color="black">  30. </font>
<font color="black">  31.     :type parent: ServiceResource</font>
<font color="black">  32.     :param parent: The resource instance to which contains data we</font>
<font color="black">  33.                    are interested in.</font>
<font color="black">  34.     :type path: string</font>
<font color="black">  35.     :param path: The JMESPath expression to query</font>
<font color="black">  36.     :raises ResourceLoadException: When no data is present and the</font>
<font color="black">  37.                                    resource cannot be loaded.</font>
<font color="black">  38.     :returns: The queried data or ``None``.</font>
<font color="black">  39.     &quot;&quot;&quot;</font>
<font color="black">  40.     # Ensure the parent has its data loaded, if possible.</font>
<font color="red">  41.     if parent.meta.data is None:</font>
<font color="red">  42.         if hasattr(parent, 'load'):</font>
<font color="red">  43.             parent.load()</font>
<font color="black">  44.         else:</font>
<font color="red">  45.             raise ResourceLoadException(</font>
<font color="red">  46.                 '{0} has no load method!'.format(parent.__class__.__name__))</font>
<font color="black">  47. </font>
<font color="red">  48.     return jmespath.search(path, parent.meta.data)</font>
<font color="black">  49. </font>
<font color="black">  50. </font>
<font color="green">  51. def create_request_parameters(parent, request_model, params=None, index=None):</font>
<font color="black">  52.     &quot;&quot;&quot;</font>
<font color="black">  53.     Handle request parameters that can be filled in from identifiers,</font>
<font color="black">  54.     resource data members or constants.</font>
<font color="black">  55. </font>
<font color="black">  56.     By passing ``params``, you can invoke this method multiple times and</font>
<font color="black">  57.     build up a parameter dict over time, which is particularly useful</font>
<font color="black">  58.     for reverse JMESPath expressions that append to lists.</font>
<font color="black">  59. </font>
<font color="black">  60.     :type parent: ServiceResource</font>
<font color="black">  61.     :param parent: The resource instance to which this action is attached.</font>
<font color="black">  62.     :type request_model: :py:class:`~boto3.resources.model.Request`</font>
<font color="black">  63.     :param request_model: The action request model.</font>
<font color="black">  64.     :type params: dict</font>
<font color="black">  65.     :param params: If set, then add to this existing dict. It is both</font>
<font color="black">  66.                    edited in-place and returned.</font>
<font color="black">  67.     :type index: int</font>
<font color="black">  68.     :param index: The position of an item within a list</font>
<font color="black">  69.     :rtype: dict</font>
<font color="black">  70.     :return: Pre-filled parameters to be sent to the request operation.</font>
<font color="black">  71.     &quot;&quot;&quot;</font>
<font color="red">  72.     if params is None:</font>
<font color="red">  73.         params = {}</font>
<font color="black">  74. </font>
<font color="red">  75.     for param in request_model.params:</font>
<font color="red">  76.         source = param.source</font>
<font color="red">  77.         target = param.target</font>
<font color="black">  78. </font>
<font color="red">  79.         if source == 'identifier':</font>
<font color="black">  80.             # Resource identifier, e.g. queue.url</font>
<font color="red">  81.             value = getattr(parent, xform_name(param.name))</font>
<font color="red">  82.         elif source == 'data':</font>
<font color="black">  83.             # If this is a data member then it may incur a load</font>
<font color="black">  84.             # action before returning the value.</font>
<font color="red">  85.             value = get_data_member(parent, param.path)</font>
<font color="red">  86.         elif source in ['string', 'integer', 'boolean']:</font>
<font color="black">  87.             # These are hard-coded values in the definition</font>
<font color="red">  88.             value = param.value</font>
<font color="red">  89.         elif source == 'input':</font>
<font color="black">  90.             # This is provided by the user, so ignore it here</font>
<font color="red">  91.             continue</font>
<font color="black">  92.         else:</font>
<font color="red">  93.             raise NotImplementedError(</font>
<font color="red">  94.                 'Unsupported source type: {0}'.format(source))</font>
<font color="black">  95. </font>
<font color="red">  96.         build_param_structure(params, target, value, index)</font>
<font color="black">  97. </font>
<font color="red">  98.     return params</font>
<font color="black">  99. </font>
<font color="black"> 100. </font>
<font color="green"> 101. def build_param_structure(params, target, value, index=None):</font>
<font color="black"> 102.     &quot;&quot;&quot;</font>
<font color="black"> 103.     This method provides a basic reverse JMESPath implementation that</font>
<font color="black"> 104.     lets you go from a JMESPath-like string to a possibly deeply nested</font>
<font color="black"> 105.     object. The ``params`` are mutated in-place, so subsequent calls</font>
<font color="black"> 106.     can modify the same element by its index.</font>
<font color="black"> 107. </font>
<font color="black"> 108.         &gt;&gt;&gt; build_param_structure(params, 'test[0]', 1)</font>
<font color="black"> 109.         &gt;&gt;&gt; print(params)</font>
<font color="black"> 110.         {'test': [1]}</font>
<font color="black"> 111. </font>
<font color="black"> 112.         &gt;&gt;&gt; build_param_structure(params, 'foo.bar[0].baz', 'hello world')</font>
<font color="black"> 113.         &gt;&gt;&gt; print(params)</font>
<font color="black"> 114.         {'test': [1], 'foo': {'bar': [{'baz': 'hello, world'}]}}</font>
<font color="black"> 115. </font>
<font color="black"> 116.     &quot;&quot;&quot;</font>
<font color="red"> 117.     pos = params</font>
<font color="red"> 118.     parts = target.split('.')</font>
<font color="black"> 119. </font>
<font color="black"> 120.     # First, split into parts like 'foo', 'bar[0]', 'baz' and process</font>
<font color="black"> 121.     # each piece. It can either be a list or a dict, depending on if</font>
<font color="black"> 122.     # an index like `[0]` is present. We detect this via a regular</font>
<font color="black"> 123.     # expression, and keep track of where we are in params via the</font>
<font color="black"> 124.     # pos variable, walking down to the last item. Once there, we</font>
<font color="black"> 125.     # set the value.</font>
<font color="red"> 126.     for i, part in enumerate(parts):</font>
<font color="black"> 127.         # Is it indexing an array?</font>
<font color="red"> 128.         result = INDEX_RE.search(part)</font>
<font color="red"> 129.         if result:</font>
<font color="red"> 130.             if result.group(1):</font>
<font color="red"> 131.                 if result.group(1) == '*':</font>
<font color="red"> 132.                     part = part[:-3]</font>
<font color="black"> 133.                 else:</font>
<font color="black"> 134.                     # We have an explicit index</font>
<font color="red"> 135.                     index = int(result.group(1))</font>
<font color="red"> 136.                     part = part[:-len(str(index) + '[]')]</font>
<font color="black"> 137.             else:</font>
<font color="black"> 138.                 # Index will be set after we know the proper part</font>
<font color="black"> 139.                 # name and that it's a list instance.</font>
<font color="red"> 140.                 index = None</font>
<font color="red"> 141.                 part = part[:-2]</font>
<font color="black"> 142. </font>
<font color="red"> 143.             if part not in pos or not isinstance(pos[part], list):</font>
<font color="red"> 144.                 pos[part] = []</font>
<font color="black"> 145. </font>
<font color="black"> 146.             # This means we should append, e.g. 'foo[]'</font>
<font color="red"> 147.             if index is None:</font>
<font color="red"> 148.                 index = len(pos[part])</font>
<font color="black"> 149. </font>
<font color="red"> 150.             while len(pos[part]) &lt;= index:</font>
<font color="black"> 151.                 # Assume it's a dict until we set the final value below</font>
<font color="red"> 152.                 pos[part].append({})</font>
<font color="black"> 153. </font>
<font color="black"> 154.             # Last item? Set the value, otherwise set the new position</font>
<font color="red"> 155.             if i == len(parts) - 1:</font>
<font color="red"> 156.                 pos[part][index] = value</font>
<font color="black"> 157.             else:</font>
<font color="black"> 158.                 # The new pos is the *item* in the array, not the array!</font>
<font color="red"> 159.                 pos = pos[part][index]</font>
<font color="black"> 160.         else:</font>
<font color="red"> 161.             if part not in pos:</font>
<font color="red"> 162.                 pos[part] = {}</font>
<font color="black"> 163. </font>
<font color="black"> 164.             # Last item? Set the value, otherwise set the new position</font>
<font color="red"> 165.             if i == len(parts) - 1:</font>
<font color="red"> 166.                 pos[part] = value</font>
<font color="black"> 167.             else:</font>
<font color="red"> 168.                 pos = pos[part]</font>
</pre>

